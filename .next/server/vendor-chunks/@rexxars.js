"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@rexxars";
exports.ids = ["vendor-chunks/@rexxars"];
exports.modules = {

/***/ "(ssr)/./node_modules/@rexxars/react-json-inspector/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@rexxars/react-json-inspector/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonInspector: () => (/* binding */ JsonInspector)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var debounce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debounce */ \"(ssr)/./node_modules/debounce/index.js\");\n/* harmony import */ var md5_o_matic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! md5-o-matic */ \"(ssr)/./node_modules/md5-o-matic/lib/md5omatic.js\");\n\n\n\n\nlet id = Math.ceil(Math.random() * 10);\nconst uid = () => ++id;\nfunction type(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\nfunction isPrimitive(value) {\n  const t = type(value);\n  return t !== \"Object\" && t !== \"Array\";\n}\nclass Highlighter extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  shouldComponentUpdate(p) {\n    return p.highlight !== this.props.highlight;\n  }\n  render() {\n    const str = this.props.string || \"\", highlight = this.props.highlight || \"\", highlightStart = str.search(highlight);\n    if (!highlight || highlightStart === -1)\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { children: str });\n    const highlightLength = highlight.source.length, highlightString = str.slice(\n      highlightStart,\n      highlightStart + highlightLength\n    );\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { children: str.split(highlight).map(function(part, index) {\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"span\", { children: [\n        index > 0 ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { className: \"json-inspector__hl\", children: highlightString }) : null,\n        part\n      ] }, index);\n    }) });\n  }\n}\nfunction isObject(value) {\n  return typeof value == \"object\" && value !== null && !Array.isArray(value);\n}\nconst PATH_PREFIX = \".root.\";\nclass Leaf extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  constructor(props) {\n    super(props), this.state = {\n      expanded: this._isInitiallyExpanded(this.props)\n    };\n  }\n  render() {\n    const { label, data, root, id: inputId } = this.props, id2 = \"id_\" + uid(), d = {\n      path: this.keypath(),\n      key: label.toString(),\n      value: data\n    }, onLabelClick = this._onClick.bind(this, d);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\n      \"div\",\n      {\n        \"data-testid\": root ? \"leaf-root\" : \"leaf-child\",\n        \"aria-expanded\": this.state.expanded,\n        \"data-root\": root || void 0,\n        className: this.getClassName(),\n        id: \"leaf-\" + this._rootPath(),\n        children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n            \"input\",\n            {\n              className: \"json-inspector__radio\",\n              type: \"radio\",\n              name: id2,\n              id: inputId,\n              tabIndex: -1\n            }\n          ),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\n            \"label\",\n            {\n              className: \"json-inspector__line\",\n              htmlFor: id2,\n              onClick: onLabelClick,\n              children: [\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"json-inspector__flatpath\", children: d.path }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"span\", { className: \"json-inspector__key\", children: [\n                  this.format(d.key),\n                  \":\",\n                  this.renderInteractiveLabel(d.key, !0)\n                ] }),\n                this.renderTitle(),\n                this.renderShowOriginalButton()\n              ]\n            }\n          ),\n          this.renderChildren()\n        ]\n      }\n    );\n  }\n  renderTitle() {\n    const data = this.data(), t = type(data);\n    if (Array.isArray(data)) {\n      const length = data.length;\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"span\", { className: \"json-inspector__value json-inspector__value_helper\", children: [\n        length > 0 ? \"[\\u2026] \" : \"[] \",\n        items(length)\n      ] });\n    }\n    if (typeof data == \"object\" && data !== null) {\n      const keys = Object.keys(data).length;\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"span\", { className: \"json-inspector__value json-inspector__value_helper\", children: [\n        keys > 0 ? \"{\\u2026} \" : \"{} \",\n        properties(keys)\n      ] });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\n      \"span\",\n      {\n        className: \"json-inspector__value json-inspector__value_\" + t.toLowerCase(),\n        children: [\n          this.format(String(data)),\n          this.renderInteractiveLabel(data, !1)\n        ]\n      }\n    );\n  }\n  renderChildren() {\n    const {\n      verboseShowOriginal,\n      query,\n      id: id2,\n      isExpanded,\n      interactiveLabel,\n      onClick,\n      getOriginal\n    } = this.props, childPrefix = this._rootPath(), data = this.data();\n    return this.state.expanded && (isObject(data) || Array.isArray(data)) ? Object.keys(data).map((key) => {\n      const value = data[key], shouldGetOriginal = !this.state.original || (verboseShowOriginal ? query : !1);\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n        Leaf,\n        {\n          data: value,\n          label: key,\n          prefix: childPrefix,\n          onClick,\n          id: id2,\n          query,\n          getOriginal: shouldGetOriginal ? getOriginal : void 0,\n          isExpanded,\n          interactiveLabel,\n          verboseShowOriginal\n        },\n        getLeafKey(key, value)\n      );\n    }) : null;\n  }\n  renderShowOriginalButton() {\n    const { data, getOriginal, query } = this.props;\n    return isPrimitive(data) || this.state.original || !getOriginal || !query || query.test(this.keypath()) ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      \"span\",\n      {\n        className: \"json-inspector__show-original\",\n        onClick: this._onShowOriginalClick\n      }\n    );\n  }\n  renderInteractiveLabel(originalValue, isKey) {\n    const InteractiveLabel = this.props.interactiveLabel;\n    return typeof InteractiveLabel == \"function\" ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      InteractiveLabel,\n      {\n        value: String(originalValue),\n        originalValue,\n        isKey,\n        keypath: this.keypath()\n      }\n    ) : null;\n  }\n  static getDerivedStateFromProps(props, state) {\n    return props.query ? {\n      expanded: !props.query.test(props.label)\n    } : null;\n  }\n  componentDidUpdate(prevProps) {\n    prevProps.query && !this.props.query && this.setState({\n      expanded: this._isInitiallyExpanded(this.props)\n    });\n  }\n  _rootPath() {\n    return (this.props.prefix || \"\") + \".\" + this.props.label;\n  }\n  keypath() {\n    return this._rootPath().slice(PATH_PREFIX.length);\n  }\n  data() {\n    return this.state.original || this.props.data;\n  }\n  format(str) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Highlighter, { string: str, highlight: this.props.query });\n  }\n  getClassName() {\n    let cn = \"json-inspector__leaf\";\n    return this.props.root && (cn += \" json-inspector__leaf_root\"), this.state.expanded && (cn += \" json-inspector__leaf_expanded\"), isPrimitive(this.props.data) || (cn += \" json-inspector__leaf_composite\"), cn;\n  }\n  toggle() {\n    this.setState({\n      expanded: !this.state.expanded\n    });\n  }\n  _onClick(data, e) {\n    this.toggle(), this.props.onClick && this.props.onClick(data), e.stopPropagation();\n  }\n  _onShowOriginalClick = (e) => {\n    this.setState({\n      original: this.props.getOriginal?.(this.keypath())\n    }), e.stopPropagation();\n  };\n  _isInitiallyExpanded(p) {\n    if (p.root)\n      return !0;\n    const keypath = this.keypath();\n    return p.query ? !p.query.test(keypath) && typeof p.getOriginal == \"function\" : p.isExpanded ? p.isExpanded(keypath, p.data) : !1;\n  }\n}\nfunction items(count) {\n  return count + (count === 1 ? \" item\" : \" items\");\n}\nfunction properties(count) {\n  return count + (count === 1 ? \" property\" : \" properties\");\n}\nfunction getLeafKey(key, value) {\n  if (isPrimitive(value)) {\n    const hash = md5_o_matic__WEBPACK_IMPORTED_MODULE_3__(String(value));\n    return key + \":\" + hash;\n  } else\n    return key + \"[\" + type(value) + \"]\";\n}\nconst noop = (...args) => {\n}, SearchBar = ({ onChange = noop }) => {\n  const onSearchChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (evt) => onChange(evt.target.value),\n    [onChange]\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    \"input\",\n    {\n      className: \"json-inspector__search\",\n      type: \"search\",\n      placeholder: \"Search\",\n      onChange: onSearchChange\n    }\n  );\n};\nfunction isEmpty(object) {\n  return isObject(object) ? Object.keys(object).length === 0 : Array.isArray(object) ? object.length === 0 : object === null || typeof object != \"string\" || typeof object != \"number\" ? !0 : Object.keys(object).length === 0;\n}\nconst getFilterer = memoize(\n  (data, opts) => {\n    const options = opts || { cacheResults: !0 }, cache = {};\n    return function(query) {\n      if (!options.cacheResults)\n        return find(data, query, options);\n      let subquery;\n      if (!cache[query]) {\n        for (var i = query.length - 1; i > 0; i -= 1)\n          if (subquery = query.slice(0, i), cache[subquery]) {\n            cache[query] = find(cache[subquery], query, options);\n            break;\n          }\n      }\n      return cache[query] || (cache[query] = find(data, query, options)), cache[query];\n    };\n  }\n);\nfunction find(data, query, options) {\n  return !isObject(data) && !Array.isArray(data) ? {} : Object.keys(data).reduce(function(acc, key) {\n    const value = data[key];\n    let matches;\n    return value ? typeof value != \"object\" ? ((contains(query, key, options) || contains(query, value, options)) && (acc[key] = value), acc) : contains(query, key, options) ? (acc[key] = value, acc) : (matches = find(value, query, options), isEmpty(matches) || Object.assign(acc, pair(key, matches)), acc) : acc;\n  }, {});\n}\nfunction contains(query, value, options) {\n  if (!value)\n    return !1;\n  var haystack = String(value), needle = query;\n  return options?.ignoreCase && (haystack = haystack.toLowerCase(), needle = needle.toLowerCase()), haystack.indexOf(needle) !== -1;\n}\nfunction pair(key, value) {\n  return { [key]: value };\n}\nfunction memoize(fn) {\n  let lastData, lastOptions, lastResult;\n  return (data, options) => ((!lastResult || data !== lastData || options !== lastOptions) && (lastData = data, lastOptions = options, lastResult = fn(data, options)), lastResult);\n}\nconst PATH_DELIMITER = \".\";\nfunction integer(str) {\n  return parseInt(str, 10);\n}\nfunction lens(data, path) {\n  var p = path.split(PATH_DELIMITER), segment = p.shift();\n  if (!segment)\n    return data;\n  if (Array.isArray(data) && data[integer(segment)])\n    return lens(data[integer(segment)], p.join(PATH_DELIMITER));\n  if (isObject(data) && segment in data)\n    return lens(data[segment], p.join(PATH_DELIMITER));\n}\nconst defaultValidateQuery = (query) => query.length >= 2, defaultFilterOptions = { cacheResults: !0, ignoreCase: !1 };\nclass JsonInspector extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  static defaultProps = {\n    data: null,\n    search: SearchBar,\n    searchOptions: {\n      debounceTime: 0\n    },\n    className: \"\",\n    id: \"json-\" + Date.now(),\n    onClick: noop,\n    filterOptions: {\n      cacheResults: !0,\n      ignoreCase: !1\n    },\n    validateQuery: function(query) {\n      return query.length >= 2;\n    },\n    /**\n     * Decide whether the leaf node at given `keypath` should be expanded initially.\n     *\n     * @param keypath - Path to the node\n     * @param value - Value of the node\n     * @returns True if node should be expanded, false otherwise\n     */\n    isExpanded: function(keypath, value) {\n      return !1;\n    },\n    verboseShowOriginal: !1\n  };\n  constructor(props) {\n    super(props), this.state = {\n      query: \"\",\n      filterer: getFilterer(props.data, props.filterOptions)\n    };\n  }\n  render() {\n    const {\n      data: rawData,\n      className,\n      onClick,\n      id: id2,\n      isExpanded,\n      interactiveLabel,\n      verboseShowOriginal,\n      filterOptions = defaultFilterOptions,\n      validateQuery = defaultValidateQuery\n    } = this.props, isQueryValid = this.state.query !== \"\" && validateQuery(this.state.query), data = isQueryValid ? this.state.filterer(this.state.query) : rawData, isNotFound = isQueryValid && isEmpty(data);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\n      \"div\",\n      {\n        \"data-testid\": \"json-inspector\",\n        className: \"json-inspector \" + className,\n        children: [\n          this.renderToolbar(),\n          isNotFound ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"json-inspector__not-found\", children: \"Nothing found\" }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n            Leaf,\n            {\n              data,\n              onClick,\n              id: id2,\n              getOriginal: this.getOriginal,\n              query: isQueryValid ? new RegExp(\n                this.state.query,\n                filterOptions.ignoreCase ? \"i\" : \"\"\n              ) : null,\n              label: \"root\",\n              root: !0,\n              isExpanded,\n              interactiveLabel,\n              verboseShowOriginal\n            }\n          )\n        ]\n      }\n    );\n  }\n  renderToolbar() {\n    const Search = this.props.search;\n    return Search ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"json-inspector__toolbar\", children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      Search,\n      {\n        onChange: debounce__WEBPACK_IMPORTED_MODULE_2__(\n          this.search,\n          this.props.searchOptions?.debounceTime\n        ),\n        data: this.props.data,\n        query: this.state.query\n      }\n    ) }) : null;\n  }\n  search = (query) => {\n    this.setState({ query });\n  };\n  static getDerivedStateFromProps(nextProps, prevState) {\n    const filterer = getFilterer(nextProps.data, nextProps.filterOptions);\n    return filterer === prevState.filterer ? null : { ...prevState, filterer };\n  }\n  shouldComponentUpdate(nextProps, prevState) {\n    return prevState.query !== this.state.query || nextProps.data !== this.props.data || nextProps.onClick !== this.props.onClick;\n  }\n  createFilterer = (data, options) => {\n    this.setState({\n      filterer: getFilterer(data, options)\n    });\n  };\n  getOriginal = (path) => lens(this.props.data, path);\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJleHhhcnMvcmVhY3QtanNvbi1pbnNwZWN0b3IvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE4QztBQUNDO0FBQ2Y7QUFDSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNENBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNEQUFHLFdBQVcsZUFBZTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzREFBRyxXQUFXO0FBQ3pDLDZCQUE2Qix1REFBSSxXQUFXO0FBQzVDLG9DQUFvQyxzREFBRyxXQUFXLDREQUE0RDtBQUM5RztBQUNBLFNBQVM7QUFDVCxLQUFLLEdBQUc7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNENBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJCQUEyQix1REFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNEQUFHO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1REFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0RBQUcsVUFBVSx5REFBeUQ7QUFDdEcsZ0NBQWdDLHVEQUFJLFdBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdURBQUksV0FBVztBQUM1QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1REFBSSxXQUFXO0FBQzVDLHFCQUFxQixRQUFRLFFBQVE7QUFDckM7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwyQkFBMkIsdURBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDZCQUE2QixzREFBRztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkMscUlBQXFJLHNEQUFHO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxzREFBRztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzREFBRyxnQkFBZ0IsMENBQTBDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQVM7QUFDMUI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQkFBaUIsaUJBQWlCO0FBQ25DLHlCQUF5QixrREFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQUc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGLDRCQUE0Qiw0Q0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwyQkFBMkIsdURBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNEQUFHLFVBQVUsbUVBQW1FLG9CQUFvQixzREFBRztBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNEQUFHLFVBQVUsZ0VBQWdFLHNEQUFHO0FBQ3BIO0FBQ0E7QUFDQSxrQkFBa0IscUNBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL21hY2Jvb2twcm8vRG93bmxvYWRzL2NvbmljYXBwcy9pZ2VuZS9ub2RlX21vZHVsZXMvQHJleHhhcnMvcmVhY3QtanNvbi1pbnNwZWN0b3IvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc3gsIGpzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IENvbXBvbmVudCwgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBkZWJvdW5jZSBmcm9tIFwiZGVib3VuY2VcIjtcbmltcG9ydCBtZDVPTWF0aWMgZnJvbSBcIm1kNS1vLW1hdGljXCI7XG5sZXQgaWQgPSBNYXRoLmNlaWwoTWF0aC5yYW5kb20oKSAqIDEwKTtcbmNvbnN0IHVpZCA9ICgpID0+ICsraWQ7XG5mdW5jdGlvbiB0eXBlKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKTtcbn1cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XG4gIGNvbnN0IHQgPSB0eXBlKHZhbHVlKTtcbiAgcmV0dXJuIHQgIT09IFwiT2JqZWN0XCIgJiYgdCAhPT0gXCJBcnJheVwiO1xufVxuY2xhc3MgSGlnaGxpZ2h0ZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBzaG91bGRDb21wb25lbnRVcGRhdGUocCkge1xuICAgIHJldHVybiBwLmhpZ2hsaWdodCAhPT0gdGhpcy5wcm9wcy5oaWdobGlnaHQ7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHN0ciA9IHRoaXMucHJvcHMuc3RyaW5nIHx8IFwiXCIsIGhpZ2hsaWdodCA9IHRoaXMucHJvcHMuaGlnaGxpZ2h0IHx8IFwiXCIsIGhpZ2hsaWdodFN0YXJ0ID0gc3RyLnNlYXJjaChoaWdobGlnaHQpO1xuICAgIGlmICghaGlnaGxpZ2h0IHx8IGhpZ2hsaWdodFN0YXJ0ID09PSAtMSlcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IGNoaWxkcmVuOiBzdHIgfSk7XG4gICAgY29uc3QgaGlnaGxpZ2h0TGVuZ3RoID0gaGlnaGxpZ2h0LnNvdXJjZS5sZW5ndGgsIGhpZ2hsaWdodFN0cmluZyA9IHN0ci5zbGljZShcbiAgICAgIGhpZ2hsaWdodFN0YXJ0LFxuICAgICAgaGlnaGxpZ2h0U3RhcnQgKyBoaWdobGlnaHRMZW5ndGhcbiAgICApO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IGNoaWxkcmVuOiBzdHIuc3BsaXQoaGlnaGxpZ2h0KS5tYXAoZnVuY3Rpb24ocGFydCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhcInNwYW5cIiwgeyBjaGlsZHJlbjogW1xuICAgICAgICBpbmRleCA+IDAgPyAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJqc29uLWluc3BlY3Rvcl9faGxcIiwgY2hpbGRyZW46IGhpZ2hsaWdodFN0cmluZyB9KSA6IG51bGwsXG4gICAgICAgIHBhcnRcbiAgICAgIF0gfSwgaW5kZXgpO1xuICAgIH0pIH0pO1xuICB9XG59XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuY29uc3QgUEFUSF9QUkVGSVggPSBcIi5yb290LlwiO1xuY2xhc3MgTGVhZiBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpLCB0aGlzLnN0YXRlID0ge1xuICAgICAgZXhwYW5kZWQ6IHRoaXMuX2lzSW5pdGlhbGx5RXhwYW5kZWQodGhpcy5wcm9wcylcbiAgICB9O1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGxhYmVsLCBkYXRhLCByb290LCBpZDogaW5wdXRJZCB9ID0gdGhpcy5wcm9wcywgaWQyID0gXCJpZF9cIiArIHVpZCgpLCBkID0ge1xuICAgICAgcGF0aDogdGhpcy5rZXlwYXRoKCksXG4gICAgICBrZXk6IGxhYmVsLnRvU3RyaW5nKCksXG4gICAgICB2YWx1ZTogZGF0YVxuICAgIH0sIG9uTGFiZWxDbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzLCBkKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBcImRhdGEtdGVzdGlkXCI6IHJvb3QgPyBcImxlYWYtcm9vdFwiIDogXCJsZWFmLWNoaWxkXCIsXG4gICAgICAgIFwiYXJpYS1leHBhbmRlZFwiOiB0aGlzLnN0YXRlLmV4cGFuZGVkLFxuICAgICAgICBcImRhdGEtcm9vdFwiOiByb290IHx8IHZvaWQgMCxcbiAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmdldENsYXNzTmFtZSgpLFxuICAgICAgICBpZDogXCJsZWFmLVwiICsgdGhpcy5fcm9vdFBhdGgoKSxcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgICAgXCJpbnB1dFwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwianNvbi1pbnNwZWN0b3JfX3JhZGlvXCIsXG4gICAgICAgICAgICAgIHR5cGU6IFwicmFkaW9cIixcbiAgICAgICAgICAgICAgbmFtZTogaWQyLFxuICAgICAgICAgICAgICBpZDogaW5wdXRJZCxcbiAgICAgICAgICAgICAgdGFiSW5kZXg6IC0xXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4cyhcbiAgICAgICAgICAgIFwibGFiZWxcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImpzb24taW5zcGVjdG9yX19saW5lXCIsXG4gICAgICAgICAgICAgIGh0bWxGb3I6IGlkMixcbiAgICAgICAgICAgICAgb25DbGljazogb25MYWJlbENsaWNrLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwianNvbi1pbnNwZWN0b3JfX2ZsYXRwYXRoXCIsIGNoaWxkcmVuOiBkLnBhdGggfSksXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeHMoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImpzb24taW5zcGVjdG9yX19rZXlcIiwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0KGQua2V5KSxcbiAgICAgICAgICAgICAgICAgIFwiOlwiLFxuICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJJbnRlcmFjdGl2ZUxhYmVsKGQua2V5LCAhMClcbiAgICAgICAgICAgICAgICBdIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGl0bGUoKSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclNob3dPcmlnaW5hbEJ1dHRvbigpXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApLFxuICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4oKVxuICAgICAgICBdXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICByZW5kZXJUaXRsZSgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhKCksIHQgPSB0eXBlKGRhdGEpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwianNvbi1pbnNwZWN0b3JfX3ZhbHVlIGpzb24taW5zcGVjdG9yX192YWx1ZV9oZWxwZXJcIiwgY2hpbGRyZW46IFtcbiAgICAgICAgbGVuZ3RoID4gMCA/IFwiW1xcdTIwMjZdIFwiIDogXCJbXSBcIixcbiAgICAgICAgaXRlbXMobGVuZ3RoKVxuICAgICAgXSB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09IFwib2JqZWN0XCIgJiYgZGF0YSAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aDtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwianNvbi1pbnNwZWN0b3JfX3ZhbHVlIGpzb24taW5zcGVjdG9yX192YWx1ZV9oZWxwZXJcIiwgY2hpbGRyZW46IFtcbiAgICAgICAga2V5cyA+IDAgPyBcIntcXHUyMDI2fSBcIiA6IFwie30gXCIsXG4gICAgICAgIHByb3BlcnRpZXMoa2V5cylcbiAgICAgIF0gfSk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhcbiAgICAgIFwic3BhblwiLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IFwianNvbi1pbnNwZWN0b3JfX3ZhbHVlIGpzb24taW5zcGVjdG9yX192YWx1ZV9cIiArIHQudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICB0aGlzLmZvcm1hdChTdHJpbmcoZGF0YSkpLFxuICAgICAgICAgIHRoaXMucmVuZGVySW50ZXJhY3RpdmVMYWJlbChkYXRhLCAhMSlcbiAgICAgICAgXVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgcmVuZGVyQ2hpbGRyZW4oKSB7XG4gICAgY29uc3Qge1xuICAgICAgdmVyYm9zZVNob3dPcmlnaW5hbCxcbiAgICAgIHF1ZXJ5LFxuICAgICAgaWQ6IGlkMixcbiAgICAgIGlzRXhwYW5kZWQsXG4gICAgICBpbnRlcmFjdGl2ZUxhYmVsLFxuICAgICAgb25DbGljayxcbiAgICAgIGdldE9yaWdpbmFsXG4gICAgfSA9IHRoaXMucHJvcHMsIGNoaWxkUHJlZml4ID0gdGhpcy5fcm9vdFBhdGgoKSwgZGF0YSA9IHRoaXMuZGF0YSgpO1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmV4cGFuZGVkICYmIChpc09iamVjdChkYXRhKSB8fCBBcnJheS5pc0FycmF5KGRhdGEpKSA/IE9iamVjdC5rZXlzKGRhdGEpLm1hcCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGRhdGFba2V5XSwgc2hvdWxkR2V0T3JpZ2luYWwgPSAhdGhpcy5zdGF0ZS5vcmlnaW5hbCB8fCAodmVyYm9zZVNob3dPcmlnaW5hbCA/IHF1ZXJ5IDogITEpO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgIExlYWYsXG4gICAgICAgIHtcbiAgICAgICAgICBkYXRhOiB2YWx1ZSxcbiAgICAgICAgICBsYWJlbDoga2V5LFxuICAgICAgICAgIHByZWZpeDogY2hpbGRQcmVmaXgsXG4gICAgICAgICAgb25DbGljayxcbiAgICAgICAgICBpZDogaWQyLFxuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIGdldE9yaWdpbmFsOiBzaG91bGRHZXRPcmlnaW5hbCA/IGdldE9yaWdpbmFsIDogdm9pZCAwLFxuICAgICAgICAgIGlzRXhwYW5kZWQsXG4gICAgICAgICAgaW50ZXJhY3RpdmVMYWJlbCxcbiAgICAgICAgICB2ZXJib3NlU2hvd09yaWdpbmFsXG4gICAgICAgIH0sXG4gICAgICAgIGdldExlYWZLZXkoa2V5LCB2YWx1ZSlcbiAgICAgICk7XG4gICAgfSkgOiBudWxsO1xuICB9XG4gIHJlbmRlclNob3dPcmlnaW5hbEJ1dHRvbigpIHtcbiAgICBjb25zdCB7IGRhdGEsIGdldE9yaWdpbmFsLCBxdWVyeSB9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gaXNQcmltaXRpdmUoZGF0YSkgfHwgdGhpcy5zdGF0ZS5vcmlnaW5hbCB8fCAhZ2V0T3JpZ2luYWwgfHwgIXF1ZXJ5IHx8IHF1ZXJ5LnRlc3QodGhpcy5rZXlwYXRoKCkpID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBcInNwYW5cIixcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImpzb24taW5zcGVjdG9yX19zaG93LW9yaWdpbmFsXCIsXG4gICAgICAgIG9uQ2xpY2s6IHRoaXMuX29uU2hvd09yaWdpbmFsQ2xpY2tcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHJlbmRlckludGVyYWN0aXZlTGFiZWwob3JpZ2luYWxWYWx1ZSwgaXNLZXkpIHtcbiAgICBjb25zdCBJbnRlcmFjdGl2ZUxhYmVsID0gdGhpcy5wcm9wcy5pbnRlcmFjdGl2ZUxhYmVsO1xuICAgIHJldHVybiB0eXBlb2YgSW50ZXJhY3RpdmVMYWJlbCA9PSBcImZ1bmN0aW9uXCIgPyAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgSW50ZXJhY3RpdmVMYWJlbCxcbiAgICAgIHtcbiAgICAgICAgdmFsdWU6IFN0cmluZyhvcmlnaW5hbFZhbHVlKSxcbiAgICAgICAgb3JpZ2luYWxWYWx1ZSxcbiAgICAgICAgaXNLZXksXG4gICAgICAgIGtleXBhdGg6IHRoaXMua2V5cGF0aCgpXG4gICAgICB9XG4gICAgKSA6IG51bGw7XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICByZXR1cm4gcHJvcHMucXVlcnkgPyB7XG4gICAgICBleHBhbmRlZDogIXByb3BzLnF1ZXJ5LnRlc3QocHJvcHMubGFiZWwpXG4gICAgfSA6IG51bGw7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIHByZXZQcm9wcy5xdWVyeSAmJiAhdGhpcy5wcm9wcy5xdWVyeSAmJiB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGV4cGFuZGVkOiB0aGlzLl9pc0luaXRpYWxseUV4cGFuZGVkKHRoaXMucHJvcHMpXG4gICAgfSk7XG4gIH1cbiAgX3Jvb3RQYXRoKCkge1xuICAgIHJldHVybiAodGhpcy5wcm9wcy5wcmVmaXggfHwgXCJcIikgKyBcIi5cIiArIHRoaXMucHJvcHMubGFiZWw7XG4gIH1cbiAga2V5cGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdFBhdGgoKS5zbGljZShQQVRIX1BSRUZJWC5sZW5ndGgpO1xuICB9XG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUub3JpZ2luYWwgfHwgdGhpcy5wcm9wcy5kYXRhO1xuICB9XG4gIGZvcm1hdChzdHIpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChIaWdobGlnaHRlciwgeyBzdHJpbmc6IHN0ciwgaGlnaGxpZ2h0OiB0aGlzLnByb3BzLnF1ZXJ5IH0pO1xuICB9XG4gIGdldENsYXNzTmFtZSgpIHtcbiAgICBsZXQgY24gPSBcImpzb24taW5zcGVjdG9yX19sZWFmXCI7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMucm9vdCAmJiAoY24gKz0gXCIganNvbi1pbnNwZWN0b3JfX2xlYWZfcm9vdFwiKSwgdGhpcy5zdGF0ZS5leHBhbmRlZCAmJiAoY24gKz0gXCIganNvbi1pbnNwZWN0b3JfX2xlYWZfZXhwYW5kZWRcIiksIGlzUHJpbWl0aXZlKHRoaXMucHJvcHMuZGF0YSkgfHwgKGNuICs9IFwiIGpzb24taW5zcGVjdG9yX19sZWFmX2NvbXBvc2l0ZVwiKSwgY247XG4gIH1cbiAgdG9nZ2xlKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZXhwYW5kZWQ6ICF0aGlzLnN0YXRlLmV4cGFuZGVkXG4gICAgfSk7XG4gIH1cbiAgX29uQ2xpY2soZGF0YSwgZSkge1xuICAgIHRoaXMudG9nZ2xlKCksIHRoaXMucHJvcHMub25DbGljayAmJiB0aGlzLnByb3BzLm9uQ2xpY2soZGF0YSksIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgX29uU2hvd09yaWdpbmFsQ2xpY2sgPSAoZSkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgb3JpZ2luYWw6IHRoaXMucHJvcHMuZ2V0T3JpZ2luYWw/Lih0aGlzLmtleXBhdGgoKSlcbiAgICB9KSwgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfTtcbiAgX2lzSW5pdGlhbGx5RXhwYW5kZWQocCkge1xuICAgIGlmIChwLnJvb3QpXG4gICAgICByZXR1cm4gITA7XG4gICAgY29uc3Qga2V5cGF0aCA9IHRoaXMua2V5cGF0aCgpO1xuICAgIHJldHVybiBwLnF1ZXJ5ID8gIXAucXVlcnkudGVzdChrZXlwYXRoKSAmJiB0eXBlb2YgcC5nZXRPcmlnaW5hbCA9PSBcImZ1bmN0aW9uXCIgOiBwLmlzRXhwYW5kZWQgPyBwLmlzRXhwYW5kZWQoa2V5cGF0aCwgcC5kYXRhKSA6ICExO1xuICB9XG59XG5mdW5jdGlvbiBpdGVtcyhjb3VudCkge1xuICByZXR1cm4gY291bnQgKyAoY291bnQgPT09IDEgPyBcIiBpdGVtXCIgOiBcIiBpdGVtc1wiKTtcbn1cbmZ1bmN0aW9uIHByb3BlcnRpZXMoY291bnQpIHtcbiAgcmV0dXJuIGNvdW50ICsgKGNvdW50ID09PSAxID8gXCIgcHJvcGVydHlcIiA6IFwiIHByb3BlcnRpZXNcIik7XG59XG5mdW5jdGlvbiBnZXRMZWFmS2V5KGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzUHJpbWl0aXZlKHZhbHVlKSkge1xuICAgIGNvbnN0IGhhc2ggPSBtZDVPTWF0aWMoU3RyaW5nKHZhbHVlKSk7XG4gICAgcmV0dXJuIGtleSArIFwiOlwiICsgaGFzaDtcbiAgfSBlbHNlXG4gICAgcmV0dXJuIGtleSArIFwiW1wiICsgdHlwZSh2YWx1ZSkgKyBcIl1cIjtcbn1cbmNvbnN0IG5vb3AgPSAoLi4uYXJncykgPT4ge1xufSwgU2VhcmNoQmFyID0gKHsgb25DaGFuZ2UgPSBub29wIH0pID0+IHtcbiAgY29uc3Qgb25TZWFyY2hDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAgICAoZXZ0KSA9PiBvbkNoYW5nZShldnQudGFyZ2V0LnZhbHVlKSxcbiAgICBbb25DaGFuZ2VdXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgIFwiaW5wdXRcIixcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IFwianNvbi1pbnNwZWN0b3JfX3NlYXJjaFwiLFxuICAgICAgdHlwZTogXCJzZWFyY2hcIixcbiAgICAgIHBsYWNlaG9sZGVyOiBcIlNlYXJjaFwiLFxuICAgICAgb25DaGFuZ2U6IG9uU2VhcmNoQ2hhbmdlXG4gICAgfVxuICApO1xufTtcbmZ1bmN0aW9uIGlzRW1wdHkob2JqZWN0KSB7XG4gIHJldHVybiBpc09iamVjdChvYmplY3QpID8gT2JqZWN0LmtleXMob2JqZWN0KS5sZW5ndGggPT09IDAgOiBBcnJheS5pc0FycmF5KG9iamVjdCkgPyBvYmplY3QubGVuZ3RoID09PSAwIDogb2JqZWN0ID09PSBudWxsIHx8IHR5cGVvZiBvYmplY3QgIT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Ygb2JqZWN0ICE9IFwibnVtYmVyXCIgPyAhMCA6IE9iamVjdC5rZXlzKG9iamVjdCkubGVuZ3RoID09PSAwO1xufVxuY29uc3QgZ2V0RmlsdGVyZXIgPSBtZW1vaXplKFxuICAoZGF0YSwgb3B0cykgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRzIHx8IHsgY2FjaGVSZXN1bHRzOiAhMCB9LCBjYWNoZSA9IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbihxdWVyeSkge1xuICAgICAgaWYgKCFvcHRpb25zLmNhY2hlUmVzdWx0cylcbiAgICAgICAgcmV0dXJuIGZpbmQoZGF0YSwgcXVlcnksIG9wdGlvbnMpO1xuICAgICAgbGV0IHN1YnF1ZXJ5O1xuICAgICAgaWYgKCFjYWNoZVtxdWVyeV0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHF1ZXJ5Lmxlbmd0aCAtIDE7IGkgPiAwOyBpIC09IDEpXG4gICAgICAgICAgaWYgKHN1YnF1ZXJ5ID0gcXVlcnkuc2xpY2UoMCwgaSksIGNhY2hlW3N1YnF1ZXJ5XSkge1xuICAgICAgICAgICAgY2FjaGVbcXVlcnldID0gZmluZChjYWNoZVtzdWJxdWVyeV0sIHF1ZXJ5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWNoZVtxdWVyeV0gfHwgKGNhY2hlW3F1ZXJ5XSA9IGZpbmQoZGF0YSwgcXVlcnksIG9wdGlvbnMpKSwgY2FjaGVbcXVlcnldO1xuICAgIH07XG4gIH1cbik7XG5mdW5jdGlvbiBmaW5kKGRhdGEsIHF1ZXJ5LCBvcHRpb25zKSB7XG4gIHJldHVybiAhaXNPYmplY3QoZGF0YSkgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSkgPyB7fSA6IE9iamVjdC5rZXlzKGRhdGEpLnJlZHVjZShmdW5jdGlvbihhY2MsIGtleSkge1xuICAgIGNvbnN0IHZhbHVlID0gZGF0YVtrZXldO1xuICAgIGxldCBtYXRjaGVzO1xuICAgIHJldHVybiB2YWx1ZSA/IHR5cGVvZiB2YWx1ZSAhPSBcIm9iamVjdFwiID8gKChjb250YWlucyhxdWVyeSwga2V5LCBvcHRpb25zKSB8fCBjb250YWlucyhxdWVyeSwgdmFsdWUsIG9wdGlvbnMpKSAmJiAoYWNjW2tleV0gPSB2YWx1ZSksIGFjYykgOiBjb250YWlucyhxdWVyeSwga2V5LCBvcHRpb25zKSA/IChhY2Nba2V5XSA9IHZhbHVlLCBhY2MpIDogKG1hdGNoZXMgPSBmaW5kKHZhbHVlLCBxdWVyeSwgb3B0aW9ucyksIGlzRW1wdHkobWF0Y2hlcykgfHwgT2JqZWN0LmFzc2lnbihhY2MsIHBhaXIoa2V5LCBtYXRjaGVzKSksIGFjYykgOiBhY2M7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zKHF1ZXJ5LCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIXZhbHVlKVxuICAgIHJldHVybiAhMTtcbiAgdmFyIGhheXN0YWNrID0gU3RyaW5nKHZhbHVlKSwgbmVlZGxlID0gcXVlcnk7XG4gIHJldHVybiBvcHRpb25zPy5pZ25vcmVDYXNlICYmIChoYXlzdGFjayA9IGhheXN0YWNrLnRvTG93ZXJDYXNlKCksIG5lZWRsZSA9IG5lZWRsZS50b0xvd2VyQ2FzZSgpKSwgaGF5c3RhY2suaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcbn1cbmZ1bmN0aW9uIHBhaXIoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4geyBba2V5XTogdmFsdWUgfTtcbn1cbmZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgbGV0IGxhc3REYXRhLCBsYXN0T3B0aW9ucywgbGFzdFJlc3VsdDtcbiAgcmV0dXJuIChkYXRhLCBvcHRpb25zKSA9PiAoKCFsYXN0UmVzdWx0IHx8IGRhdGEgIT09IGxhc3REYXRhIHx8IG9wdGlvbnMgIT09IGxhc3RPcHRpb25zKSAmJiAobGFzdERhdGEgPSBkYXRhLCBsYXN0T3B0aW9ucyA9IG9wdGlvbnMsIGxhc3RSZXN1bHQgPSBmbihkYXRhLCBvcHRpb25zKSksIGxhc3RSZXN1bHQpO1xufVxuY29uc3QgUEFUSF9ERUxJTUlURVIgPSBcIi5cIjtcbmZ1bmN0aW9uIGludGVnZXIoc3RyKSB7XG4gIHJldHVybiBwYXJzZUludChzdHIsIDEwKTtcbn1cbmZ1bmN0aW9uIGxlbnMoZGF0YSwgcGF0aCkge1xuICB2YXIgcCA9IHBhdGguc3BsaXQoUEFUSF9ERUxJTUlURVIpLCBzZWdtZW50ID0gcC5zaGlmdCgpO1xuICBpZiAoIXNlZ21lbnQpXG4gICAgcmV0dXJuIGRhdGE7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpICYmIGRhdGFbaW50ZWdlcihzZWdtZW50KV0pXG4gICAgcmV0dXJuIGxlbnMoZGF0YVtpbnRlZ2VyKHNlZ21lbnQpXSwgcC5qb2luKFBBVEhfREVMSU1JVEVSKSk7XG4gIGlmIChpc09iamVjdChkYXRhKSAmJiBzZWdtZW50IGluIGRhdGEpXG4gICAgcmV0dXJuIGxlbnMoZGF0YVtzZWdtZW50XSwgcC5qb2luKFBBVEhfREVMSU1JVEVSKSk7XG59XG5jb25zdCBkZWZhdWx0VmFsaWRhdGVRdWVyeSA9IChxdWVyeSkgPT4gcXVlcnkubGVuZ3RoID49IDIsIGRlZmF1bHRGaWx0ZXJPcHRpb25zID0geyBjYWNoZVJlc3VsdHM6ICEwLCBpZ25vcmVDYXNlOiAhMSB9O1xuY2xhc3MgSnNvbkluc3BlY3RvciBleHRlbmRzIENvbXBvbmVudCB7XG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgZGF0YTogbnVsbCxcbiAgICBzZWFyY2g6IFNlYXJjaEJhcixcbiAgICBzZWFyY2hPcHRpb25zOiB7XG4gICAgICBkZWJvdW5jZVRpbWU6IDBcbiAgICB9LFxuICAgIGNsYXNzTmFtZTogXCJcIixcbiAgICBpZDogXCJqc29uLVwiICsgRGF0ZS5ub3coKSxcbiAgICBvbkNsaWNrOiBub29wLFxuICAgIGZpbHRlck9wdGlvbnM6IHtcbiAgICAgIGNhY2hlUmVzdWx0czogITAsXG4gICAgICBpZ25vcmVDYXNlOiAhMVxuICAgIH0sXG4gICAgdmFsaWRhdGVRdWVyeTogZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgIHJldHVybiBxdWVyeS5sZW5ndGggPj0gMjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERlY2lkZSB3aGV0aGVyIHRoZSBsZWFmIG5vZGUgYXQgZ2l2ZW4gYGtleXBhdGhgIHNob3VsZCBiZSBleHBhbmRlZCBpbml0aWFsbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5cGF0aCAtIFBhdGggdG8gdGhlIG5vZGVcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSBvZiB0aGUgbm9kZVxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgbm9kZSBzaG91bGQgYmUgZXhwYW5kZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGlzRXhwYW5kZWQ6IGZ1bmN0aW9uKGtleXBhdGgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfSxcbiAgICB2ZXJib3NlU2hvd09yaWdpbmFsOiAhMVxuICB9O1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKSwgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHF1ZXJ5OiBcIlwiLFxuICAgICAgZmlsdGVyZXI6IGdldEZpbHRlcmVyKHByb3BzLmRhdGEsIHByb3BzLmZpbHRlck9wdGlvbnMpXG4gICAgfTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YTogcmF3RGF0YSxcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIG9uQ2xpY2ssXG4gICAgICBpZDogaWQyLFxuICAgICAgaXNFeHBhbmRlZCxcbiAgICAgIGludGVyYWN0aXZlTGFiZWwsXG4gICAgICB2ZXJib3NlU2hvd09yaWdpbmFsLFxuICAgICAgZmlsdGVyT3B0aW9ucyA9IGRlZmF1bHRGaWx0ZXJPcHRpb25zLFxuICAgICAgdmFsaWRhdGVRdWVyeSA9IGRlZmF1bHRWYWxpZGF0ZVF1ZXJ5XG4gICAgfSA9IHRoaXMucHJvcHMsIGlzUXVlcnlWYWxpZCA9IHRoaXMuc3RhdGUucXVlcnkgIT09IFwiXCIgJiYgdmFsaWRhdGVRdWVyeSh0aGlzLnN0YXRlLnF1ZXJ5KSwgZGF0YSA9IGlzUXVlcnlWYWxpZCA/IHRoaXMuc3RhdGUuZmlsdGVyZXIodGhpcy5zdGF0ZS5xdWVyeSkgOiByYXdEYXRhLCBpc05vdEZvdW5kID0gaXNRdWVyeVZhbGlkICYmIGlzRW1wdHkoZGF0YSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFxuICAgICAgXCJkaXZcIixcbiAgICAgIHtcbiAgICAgICAgXCJkYXRhLXRlc3RpZFwiOiBcImpzb24taW5zcGVjdG9yXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJqc29uLWluc3BlY3RvciBcIiArIGNsYXNzTmFtZSxcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICB0aGlzLnJlbmRlclRvb2xiYXIoKSxcbiAgICAgICAgICBpc05vdEZvdW5kID8gLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJqc29uLWluc3BlY3Rvcl9fbm90LWZvdW5kXCIsIGNoaWxkcmVuOiBcIk5vdGhpbmcgZm91bmRcIiB9KSA6IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgICBMZWFmLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICBvbkNsaWNrLFxuICAgICAgICAgICAgICBpZDogaWQyLFxuICAgICAgICAgICAgICBnZXRPcmlnaW5hbDogdGhpcy5nZXRPcmlnaW5hbCxcbiAgICAgICAgICAgICAgcXVlcnk6IGlzUXVlcnlWYWxpZCA/IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5xdWVyeSxcbiAgICAgICAgICAgICAgICBmaWx0ZXJPcHRpb25zLmlnbm9yZUNhc2UgPyBcImlcIiA6IFwiXCJcbiAgICAgICAgICAgICAgKSA6IG51bGwsXG4gICAgICAgICAgICAgIGxhYmVsOiBcInJvb3RcIixcbiAgICAgICAgICAgICAgcm9vdDogITAsXG4gICAgICAgICAgICAgIGlzRXhwYW5kZWQsXG4gICAgICAgICAgICAgIGludGVyYWN0aXZlTGFiZWwsXG4gICAgICAgICAgICAgIHZlcmJvc2VTaG93T3JpZ2luYWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHJlbmRlclRvb2xiYXIoKSB7XG4gICAgY29uc3QgU2VhcmNoID0gdGhpcy5wcm9wcy5zZWFyY2g7XG4gICAgcmV0dXJuIFNlYXJjaCA/IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwianNvbi1pbnNwZWN0b3JfX3Rvb2xiYXJcIiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBTZWFyY2gsXG4gICAgICB7XG4gICAgICAgIG9uQ2hhbmdlOiBkZWJvdW5jZShcbiAgICAgICAgICB0aGlzLnNlYXJjaCxcbiAgICAgICAgICB0aGlzLnByb3BzLnNlYXJjaE9wdGlvbnM/LmRlYm91bmNlVGltZVxuICAgICAgICApLFxuICAgICAgICBkYXRhOiB0aGlzLnByb3BzLmRhdGEsXG4gICAgICAgIHF1ZXJ5OiB0aGlzLnN0YXRlLnF1ZXJ5XG4gICAgICB9XG4gICAgKSB9KSA6IG51bGw7XG4gIH1cbiAgc2VhcmNoID0gKHF1ZXJ5KSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHF1ZXJ5IH0pO1xuICB9O1xuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgY29uc3QgZmlsdGVyZXIgPSBnZXRGaWx0ZXJlcihuZXh0UHJvcHMuZGF0YSwgbmV4dFByb3BzLmZpbHRlck9wdGlvbnMpO1xuICAgIHJldHVybiBmaWx0ZXJlciA9PT0gcHJldlN0YXRlLmZpbHRlcmVyID8gbnVsbCA6IHsgLi4ucHJldlN0YXRlLCBmaWx0ZXJlciB9O1xuICB9XG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgIHJldHVybiBwcmV2U3RhdGUucXVlcnkgIT09IHRoaXMuc3RhdGUucXVlcnkgfHwgbmV4dFByb3BzLmRhdGEgIT09IHRoaXMucHJvcHMuZGF0YSB8fCBuZXh0UHJvcHMub25DbGljayAhPT0gdGhpcy5wcm9wcy5vbkNsaWNrO1xuICB9XG4gIGNyZWF0ZUZpbHRlcmVyID0gKGRhdGEsIG9wdGlvbnMpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGZpbHRlcmVyOiBnZXRGaWx0ZXJlcihkYXRhLCBvcHRpb25zKVxuICAgIH0pO1xuICB9O1xuICBnZXRPcmlnaW5hbCA9IChwYXRoKSA9PiBsZW5zKHRoaXMucHJvcHMuZGF0YSwgcGF0aCk7XG59XG5leHBvcnQge1xuICBKc29uSW5zcGVjdG9yXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@rexxars/react-json-inspector/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@rexxars/react-split-pane/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@rexxars/react-split-pane/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Pane: () => (/* binding */ Pane),\n/* harmony export */   SplitPane: () => (/* binding */ SplitPane)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n\n\nvar __defProp$1 = Object.defineProperty, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b))\n      __propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  return a;\n};\nconst Pane = function(props) {\n  const { children, className, split, style: styleProps, size, eleRef } = props;\n  let style = {\n    flex: 1,\n    position: \"relative\",\n    outline: \"none\"\n  };\n  size !== void 0 && (split === \"vertical\" ? style.width = size : (style.height = size, style.display = \"flex\"), style.flex = \"none\"), style = __spreadValues$1(__spreadValues$1({}, style), styleProps);\n  const classes = [\"Pane\", split, className].filter(Boolean).join(\" \");\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { role: \"region\", ref: eleRef, className: classes, style, children });\n}, RESIZER_DEFAULT_CLASSNAME = \"Resizer\", Resizer = function(props) {\n  const {\n    className = RESIZER_DEFAULT_CLASSNAME,\n    onClick,\n    onDoubleClick,\n    onMouseDown,\n    onTouchEnd,\n    onTouchStart,\n    resizerClassName,\n    split,\n    style\n  } = props, classes = [resizerClassName, split, className].filter(Boolean).join(\" \");\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    \"span\",\n    {\n      role: \"separator\",\n      className: classes,\n      style,\n      onMouseDown: (event) => onMouseDown(event.nativeEvent),\n      onTouchStart: (event) => {\n        event.preventDefault(), onTouchStart(event.nativeEvent);\n      },\n      onTouchEnd: (event) => {\n        event.preventDefault(), onTouchEnd(event.nativeEvent);\n      },\n      onClick: (event) => {\n        onClick && (event.preventDefault(), onClick(event.nativeEvent));\n      },\n      onDoubleClick: (event) => {\n        onDoubleClick && (event.preventDefault(), onDoubleClick(event.nativeEvent));\n      }\n    }\n  );\n};\nvar __defProp = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b))\n      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);\n  return a;\n}, __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b)), __publicField = (obj, key, value) => __defNormalProp(obj, typeof key != \"symbol\" ? key + \"\" : key, value);\nconst BASE_STYLES = {\n  display: \"flex\",\n  flex: 1,\n  height: \"100%\",\n  position: \"absolute\",\n  outline: \"none\",\n  overflow: \"hidden\",\n  MozUserSelect: \"text\",\n  WebkitUserSelect: \"text\",\n  msUserSelect: \"text\",\n  userSelect: \"text\"\n}, VERTICAL_STYLES = __spreadProps(__spreadValues({}, BASE_STYLES), {\n  flexDirection: \"row\",\n  left: 0,\n  right: 0\n}), HORIZONTAL_STYLES = __spreadProps(__spreadValues({}, BASE_STYLES), {\n  bottom: 0,\n  flexDirection: \"column\",\n  minHeight: \"100%\",\n  top: 0,\n  width: \"100%\"\n}), EMPTY_STYLES = {}, _SplitPane = class _SplitPane2 extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  constructor(props) {\n    super(props), __publicField(this, \"pane1\", null), __publicField(this, \"pane2\", null), __publicField(this, \"splitPane\", null), this.onMouseDown = this.onMouseDown.bind(this), this.onTouchStart = this.onTouchStart.bind(this), this.onMouseMove = this.onMouseMove.bind(this), this.onTouchMove = this.onTouchMove.bind(this), this.onMouseUp = this.onMouseUp.bind(this);\n    const { size, defaultSize, minSize, maxSize, primary } = props, initialSize = size !== void 0 ? size : getDefaultSize(defaultSize, minSize, maxSize, void 0);\n    this.state = {\n      active: !1,\n      resized: !1,\n      pane1Size: primary === \"first\" ? initialSize : void 0,\n      pane2Size: primary === \"second\" ? initialSize : void 0,\n      // these are props that are needed in static functions. ie: gDSFP\n      instanceProps: {\n        size\n      }\n    };\n  }\n  componentDidMount() {\n    document.addEventListener(\"mouseup\", this.onMouseUp), document.addEventListener(\"mousemove\", this.onMouseMove), document.addEventListener(\"touchmove\", this.onTouchMove), this.setState(_SplitPane2.getSizeUpdate(this.props, this.state));\n  }\n  static getDerivedStateFromProps(nextProps, prevState) {\n    return _SplitPane2.getSizeUpdate(nextProps, prevState);\n  }\n  componentWillUnmount() {\n    document.removeEventListener(\"mouseup\", this.onMouseUp), document.removeEventListener(\"mousemove\", this.onMouseMove), document.removeEventListener(\"touchmove\", this.onTouchMove);\n  }\n  onMouseDown(event) {\n    this.onTouchStart(__spreadProps(__spreadValues({}, event), {\n      touches: [{ clientX: event.clientX, clientY: event.clientY }]\n    }));\n  }\n  onTouchStart(event) {\n    const { allowResize, onDragStarted, split } = this.props;\n    if (allowResize) {\n      unFocus(document, window);\n      const position = split === \"vertical\" ? event.touches[0].clientX : event.touches[0].clientY;\n      typeof onDragStarted == \"function\" && onDragStarted(), this.setState({\n        active: !0,\n        position\n      });\n    }\n  }\n  onMouseMove(event) {\n    const eventWithTouches = Object.assign({}, event, {\n      touches: [{ clientX: event.clientX, clientY: event.clientY }]\n    });\n    this.onTouchMove(eventWithTouches);\n  }\n  onTouchMove(event) {\n    if (!this.state.active || !this.props.allowResize)\n      return;\n    const { position = 0 } = this.state, {\n      maxSize,\n      minSize = _SplitPane2.defaultProps.minSize,\n      onChange,\n      split = _SplitPane2.defaultProps.split,\n      step\n    } = this.props;\n    unFocus(document, window);\n    const isPrimaryFirst = this.props.primary === \"first\", ref = isPrimaryFirst ? this.pane1 : this.pane2, ref2 = isPrimaryFirst ? this.pane2 : this.pane1;\n    if (!ref || !ref2 || !ref.getBoundingClientRect)\n      return;\n    const node = ref, node2 = ref2, width = node.getBoundingClientRect().width, height = node.getBoundingClientRect().height, current = split === \"vertical\" ? event.touches[0].clientX : event.touches[0].clientY, size = split === \"vertical\" ? width : height;\n    let positionDelta = position - current;\n    if (step) {\n      if (Math.abs(positionDelta) < step)\n        return;\n      positionDelta = ~~(positionDelta / step) * step;\n    }\n    let sizeDelta = isPrimaryFirst ? positionDelta : -positionDelta;\n    const pane1Order = parseInt(window.getComputedStyle(node).order), pane2Order = parseInt(window.getComputedStyle(node2).order);\n    pane1Order > pane2Order && (sizeDelta = -sizeDelta);\n    let newMaxSize = maxSize;\n    this.splitPane && maxSize !== void 0 && maxSize <= 0 && (split === \"vertical\" ? newMaxSize = this.splitPane.getBoundingClientRect().width + maxSize : newMaxSize = this.splitPane.getBoundingClientRect().height + maxSize);\n    let newSize = size - sizeDelta;\n    const newPosition = position - positionDelta;\n    minSize && newSize < minSize ? newSize = minSize : newMaxSize !== void 0 && newSize > newMaxSize ? newSize = newMaxSize : this.setState({\n      position: newPosition,\n      resized: !0\n    }), onChange && onChange(newSize);\n    const sizeState = isPrimaryFirst ? { pane1Size: newSize, pane2Size: void 0 } : { pane2Size: newSize, pane1Size: void 0 };\n    this.setState(__spreadValues({ draggedSize: newSize }, sizeState));\n  }\n  onMouseUp() {\n    if (!this.state.active || !this.props.allowResize)\n      return;\n    const { onDragFinished } = this.props, { draggedSize } = this.state;\n    typeof draggedSize < \"u\" && typeof onDragFinished == \"function\" && onDragFinished(draggedSize), this.setState({ active: !1 });\n  }\n  // we have to check values since gDSFP is called on every render and more in StrictMode\n  static getSizeUpdate(props, state) {\n    const { instanceProps } = state;\n    if (instanceProps.size === props.size && props.size !== void 0)\n      return {};\n    const newSize = props.size !== void 0 ? props.size : getDefaultSize(\n      props.defaultSize,\n      props.minSize,\n      props.maxSize,\n      state.draggedSize\n    ), sizeState = props.primary === \"first\" ? { pane1Size: newSize, pane2Size: void 0 } : { pane2Size: newSize, pane1Size: void 0 };\n    return __spreadProps(__spreadValues(__spreadValues({}, sizeState), typeof props.size > \"u\" ? {} : { draggedSize: newSize }), {\n      instanceProps: { size: props.size }\n    });\n  }\n  render() {\n    const {\n      allowResize,\n      children,\n      className,\n      onResizerClick,\n      onResizerDoubleClick,\n      paneClassName,\n      pane1ClassName,\n      pane2ClassName,\n      paneStyle,\n      pane1Style: pane1StyleProps,\n      pane2Style: pane2StyleProps,\n      resizerClassName = RESIZER_DEFAULT_CLASSNAME,\n      resizerStyle,\n      split,\n      style: styleProps\n    } = this.props, { pane1Size, pane2Size } = this.state, disabledClass = allowResize ? \"\" : \"disabled\", resizerClassNamesIncludingDefault = resizerClassName && `${resizerClassName} ${RESIZER_DEFAULT_CLASSNAME}`, notNullChildren = removeNullChildren(children), baseStyles = split === \"vertical\" ? VERTICAL_STYLES : HORIZONTAL_STYLES, style = styleProps ? __spreadValues(__spreadValues({}, baseStyles), styleProps) : baseStyles, classes = [\"SplitPane\", className, split, disabledClass].filter(Boolean).join(\" \"), pane1Style = coalesceOnEmpty(\n      __spreadValues(__spreadValues({}, paneStyle), pane1StyleProps),\n      EMPTY_STYLES\n    ), pane2Style = coalesceOnEmpty(\n      __spreadValues(__spreadValues({}, paneStyle), pane2StyleProps),\n      EMPTY_STYLES\n    ), pane1Classes = [\"Pane1\", paneClassName, pane1ClassName].join(\" \"), pane2Classes = [\"Pane2\", paneClassName, pane2ClassName].join(\" \");\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\n      \"div\",\n      {\n        \"data-testid\": \"split-pane\",\n        className: classes,\n        style,\n        ref: (node) => {\n          this.splitPane = node;\n        },\n        children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n            Pane,\n            {\n              className: pane1Classes,\n              eleRef: (node) => {\n                this.pane1 = node;\n              },\n              size: pane1Size,\n              split,\n              style: pane1Style,\n              children: notNullChildren[0]\n            },\n            \"pane1\"\n          ),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n            Resizer,\n            {\n              className: disabledClass,\n              onClick: onResizerClick,\n              onDoubleClick: onResizerDoubleClick,\n              onMouseDown: this.onMouseDown,\n              onTouchStart: this.onTouchStart,\n              onTouchEnd: this.onMouseUp,\n              resizerClassName: resizerClassNamesIncludingDefault,\n              split: split || \"vertical\",\n              style: resizerStyle || EMPTY_STYLES\n            },\n            \"resizer\"\n          ),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n            Pane,\n            {\n              className: pane2Classes,\n              eleRef: (node) => {\n                this.pane2 = node;\n              },\n              size: pane2Size,\n              split,\n              style: pane2Style,\n              children: notNullChildren[1]\n            },\n            \"pane2\"\n          )\n        ]\n      }\n    );\n  }\n};\n__publicField(_SplitPane, \"defaultProps\", {\n  allowResize: !0,\n  minSize: 50,\n  primary: \"first\",\n  split: \"vertical\",\n  paneClassName: \"\",\n  pane1ClassName: \"\",\n  pane2ClassName: \"\"\n});\nlet SplitPane = _SplitPane;\nfunction unFocus(document2, window2) {\n  var _a;\n  if (\"selection\" in document2 && typeof document2.selection == \"object\" && document2.selection && \"empty\" in document2.selection && typeof document2.selection.empty == \"function\")\n    try {\n      document2.selection.empty();\n    } catch (e) {\n    }\n  else if (typeof window2 < \"u\" && typeof window2.getSelection == \"function\")\n    try {\n      (_a = window2.getSelection()) == null || _a.removeAllRanges();\n    } catch (e) {\n    }\n}\nfunction getDefaultSize(defaultSize, minSize, maxSize, draggedSize) {\n  if (typeof draggedSize == \"number\") {\n    const min = typeof minSize == \"number\" ? minSize : 0, max = typeof maxSize == \"number\" && maxSize >= 0 ? maxSize : 1 / 0;\n    return Math.max(min, Math.min(max, draggedSize));\n  }\n  return defaultSize !== void 0 ? defaultSize : minSize;\n}\nfunction removeNullChildren(children) {\n  return react__WEBPACK_IMPORTED_MODULE_1__.Children.toArray(children).filter((c) => c);\n}\nfunction isEmptyish(obj) {\n  return obj === null || typeof obj > \"u\" || Object.keys(obj).length === 0;\n}\nfunction coalesceOnEmpty(obj, useOnEmpty) {\n  return isEmptyish(obj) ? useOnEmpty : obj;\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJleHhhcnMvcmVhY3Qtc3BsaXQtcGFuZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBOEM7QUFDRjtBQUM1Qyx1UkFBdVIsdURBQXVEO0FBQzlVLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOERBQThEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtTEFBbUw7QUFDbkw7QUFDQSx5QkFBeUIsc0RBQUcsVUFBVSxrRUFBa0U7QUFDeEcsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHlCQUF5QixzREFBRztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1V0FBdVcsdURBQXVEO0FBQzlaLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1EQUFtRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0IseUNBQXlDLDRDQUFTO0FBQ3ZFO0FBQ0E7QUFDQSxZQUFZLCtDQUErQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsa0JBQWtCLGdEQUFnRDtBQUNsRSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0Msa0JBQWtCLGdEQUFnRDtBQUNsRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx5Q0FBeUMsd0NBQXdDLElBQUk7QUFDckYsbUNBQW1DLHNCQUFzQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCLGdCQUFnQixjQUFjO0FBQzNELG9IQUFvSCxZQUFZO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHdDQUF3QyxJQUFJO0FBQzdGLHlEQUF5RCwyQ0FBMkMsSUFBSSxzQkFBc0I7QUFDOUgsdUJBQXVCO0FBQ3ZCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdCQUFnQix1QkFBdUIsd0hBQXdILGtCQUFrQixFQUFFLDBCQUEwQixpTEFBaUw7QUFDcFksc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLDJCQUEyQix1REFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDBCQUEwQixzREFBRztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwQkFBMEIsc0RBQUc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMEJBQTBCLHNEQUFHO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMkNBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbWFjYm9va3Byby9Eb3dubG9hZHMvY29uaWNhcHBzL2lnZW5lL25vZGVfbW9kdWxlcy9AcmV4eGFycy9yZWFjdC1zcGxpdC1wYW5lL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4LCBqc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyBDb21wb25lbnQsIENoaWxkcmVuIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIF9fZ2V0T3duUHJvcFN5bWJvbHMkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIF9faGFzT3duUHJvcCQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgX19wcm9wSXNFbnVtJDEgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBfX2RlZk5vcm1hbFByb3AkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMShvYmosIGtleSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWUsIF9fc3ByZWFkVmFsdWVzJDEgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgX19oYXNPd25Qcm9wJDEuY2FsbChiLCBwcm9wKSAmJiBfX2RlZk5vcm1hbFByb3AkMShhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMkMSlcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMkMShiKSlcbiAgICAgIF9fcHJvcElzRW51bSQxLmNhbGwoYiwgcHJvcCkgJiYgX19kZWZOb3JtYWxQcm9wJDEoYSwgcHJvcCwgYltwcm9wXSk7XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IFBhbmUgPSBmdW5jdGlvbihwcm9wcykge1xuICBjb25zdCB7IGNoaWxkcmVuLCBjbGFzc05hbWUsIHNwbGl0LCBzdHlsZTogc3R5bGVQcm9wcywgc2l6ZSwgZWxlUmVmIH0gPSBwcm9wcztcbiAgbGV0IHN0eWxlID0ge1xuICAgIGZsZXg6IDEsXG4gICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICBvdXRsaW5lOiBcIm5vbmVcIlxuICB9O1xuICBzaXplICE9PSB2b2lkIDAgJiYgKHNwbGl0ID09PSBcInZlcnRpY2FsXCIgPyBzdHlsZS53aWR0aCA9IHNpemUgOiAoc3R5bGUuaGVpZ2h0ID0gc2l6ZSwgc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiKSwgc3R5bGUuZmxleCA9IFwibm9uZVwiKSwgc3R5bGUgPSBfX3NwcmVhZFZhbHVlcyQxKF9fc3ByZWFkVmFsdWVzJDEoe30sIHN0eWxlKSwgc3R5bGVQcm9wcyk7XG4gIGNvbnN0IGNsYXNzZXMgPSBbXCJQYW5lXCIsIHNwbGl0LCBjbGFzc05hbWVdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyByb2xlOiBcInJlZ2lvblwiLCByZWY6IGVsZVJlZiwgY2xhc3NOYW1lOiBjbGFzc2VzLCBzdHlsZSwgY2hpbGRyZW4gfSk7XG59LCBSRVNJWkVSX0RFRkFVTFRfQ0xBU1NOQU1FID0gXCJSZXNpemVyXCIsIFJlc2l6ZXIgPSBmdW5jdGlvbihwcm9wcykge1xuICBjb25zdCB7XG4gICAgY2xhc3NOYW1lID0gUkVTSVpFUl9ERUZBVUxUX0NMQVNTTkFNRSxcbiAgICBvbkNsaWNrLFxuICAgIG9uRG91YmxlQ2xpY2ssXG4gICAgb25Nb3VzZURvd24sXG4gICAgb25Ub3VjaEVuZCxcbiAgICBvblRvdWNoU3RhcnQsXG4gICAgcmVzaXplckNsYXNzTmFtZSxcbiAgICBzcGxpdCxcbiAgICBzdHlsZVxuICB9ID0gcHJvcHMsIGNsYXNzZXMgPSBbcmVzaXplckNsYXNzTmFtZSwgc3BsaXQsIGNsYXNzTmFtZV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBcInNwYW5cIixcbiAgICB7XG4gICAgICByb2xlOiBcInNlcGFyYXRvclwiLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc2VzLFxuICAgICAgc3R5bGUsXG4gICAgICBvbk1vdXNlRG93bjogKGV2ZW50KSA9PiBvbk1vdXNlRG93bihldmVudC5uYXRpdmVFdmVudCksXG4gICAgICBvblRvdWNoU3RhcnQ6IChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpLCBvblRvdWNoU3RhcnQoZXZlbnQubmF0aXZlRXZlbnQpO1xuICAgICAgfSxcbiAgICAgIG9uVG91Y2hFbmQ6IChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpLCBvblRvdWNoRW5kKGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBvbkNsaWNrOiAoZXZlbnQpID0+IHtcbiAgICAgICAgb25DbGljayAmJiAoZXZlbnQucHJldmVudERlZmF1bHQoKSwgb25DbGljayhldmVudC5uYXRpdmVFdmVudCkpO1xuICAgICAgfSxcbiAgICAgIG9uRG91YmxlQ2xpY2s6IChldmVudCkgPT4ge1xuICAgICAgICBvbkRvdWJsZUNsaWNrICYmIChldmVudC5wcmV2ZW50RGVmYXVsdCgpLCBvbkRvdWJsZUNsaWNrKGV2ZW50Lm5hdGl2ZUV2ZW50KSk7XG4gICAgICB9XG4gICAgfVxuICApO1xufTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcywgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycywgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlLCBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSAmJiBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSlcbiAgICAgIF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApICYmIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgcmV0dXJuIGE7XG59LCBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpLCBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuY29uc3QgQkFTRV9TVFlMRVMgPSB7XG4gIGRpc3BsYXk6IFwiZmxleFwiLFxuICBmbGV4OiAxLFxuICBoZWlnaHQ6IFwiMTAwJVwiLFxuICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gIE1velVzZXJTZWxlY3Q6IFwidGV4dFwiLFxuICBXZWJraXRVc2VyU2VsZWN0OiBcInRleHRcIixcbiAgbXNVc2VyU2VsZWN0OiBcInRleHRcIixcbiAgdXNlclNlbGVjdDogXCJ0ZXh0XCJcbn0sIFZFUlRJQ0FMX1NUWUxFUyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIEJBU0VfU1RZTEVTKSwge1xuICBmbGV4RGlyZWN0aW9uOiBcInJvd1wiLFxuICBsZWZ0OiAwLFxuICByaWdodDogMFxufSksIEhPUklaT05UQUxfU1RZTEVTID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgQkFTRV9TVFlMRVMpLCB7XG4gIGJvdHRvbTogMCxcbiAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgbWluSGVpZ2h0OiBcIjEwMCVcIixcbiAgdG9wOiAwLFxuICB3aWR0aDogXCIxMDAlXCJcbn0pLCBFTVBUWV9TVFlMRVMgPSB7fSwgX1NwbGl0UGFuZSA9IGNsYXNzIF9TcGxpdFBhbmUyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyksIF9fcHVibGljRmllbGQodGhpcywgXCJwYW5lMVwiLCBudWxsKSwgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBhbmUyXCIsIG51bGwpLCBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3BsaXRQYW5lXCIsIG51bGwpLCB0aGlzLm9uTW91c2VEb3duID0gdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpLCB0aGlzLm9uVG91Y2hTdGFydCA9IHRoaXMub25Ub3VjaFN0YXJ0LmJpbmQodGhpcyksIHRoaXMub25Nb3VzZU1vdmUgPSB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcyksIHRoaXMub25Ub3VjaE1vdmUgPSB0aGlzLm9uVG91Y2hNb3ZlLmJpbmQodGhpcyksIHRoaXMub25Nb3VzZVVwID0gdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICBjb25zdCB7IHNpemUsIGRlZmF1bHRTaXplLCBtaW5TaXplLCBtYXhTaXplLCBwcmltYXJ5IH0gPSBwcm9wcywgaW5pdGlhbFNpemUgPSBzaXplICE9PSB2b2lkIDAgPyBzaXplIDogZ2V0RGVmYXVsdFNpemUoZGVmYXVsdFNpemUsIG1pblNpemUsIG1heFNpemUsIHZvaWQgMCk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGFjdGl2ZTogITEsXG4gICAgICByZXNpemVkOiAhMSxcbiAgICAgIHBhbmUxU2l6ZTogcHJpbWFyeSA9PT0gXCJmaXJzdFwiID8gaW5pdGlhbFNpemUgOiB2b2lkIDAsXG4gICAgICBwYW5lMlNpemU6IHByaW1hcnkgPT09IFwic2Vjb25kXCIgPyBpbml0aWFsU2l6ZSA6IHZvaWQgMCxcbiAgICAgIC8vIHRoZXNlIGFyZSBwcm9wcyB0aGF0IGFyZSBuZWVkZWQgaW4gc3RhdGljIGZ1bmN0aW9ucy4gaWU6IGdEU0ZQXG4gICAgICBpbnN0YW5jZVByb3BzOiB7XG4gICAgICAgIHNpemVcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMub25Nb3VzZVVwKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm9uTW91c2VNb3ZlKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLm9uVG91Y2hNb3ZlKSwgdGhpcy5zZXRTdGF0ZShfU3BsaXRQYW5lMi5nZXRTaXplVXBkYXRlKHRoaXMucHJvcHMsIHRoaXMuc3RhdGUpKTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgcmV0dXJuIF9TcGxpdFBhbmUyLmdldFNpemVVcGRhdGUobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMub25Nb3VzZVVwKSwgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm9uTW91c2VNb3ZlKSwgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLm9uVG91Y2hNb3ZlKTtcbiAgfVxuICBvbk1vdXNlRG93bihldmVudCkge1xuICAgIHRoaXMub25Ub3VjaFN0YXJ0KF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGV2ZW50KSwge1xuICAgICAgdG91Y2hlczogW3sgY2xpZW50WDogZXZlbnQuY2xpZW50WCwgY2xpZW50WTogZXZlbnQuY2xpZW50WSB9XVxuICAgIH0pKTtcbiAgfVxuICBvblRvdWNoU3RhcnQoZXZlbnQpIHtcbiAgICBjb25zdCB7IGFsbG93UmVzaXplLCBvbkRyYWdTdGFydGVkLCBzcGxpdCB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoYWxsb3dSZXNpemUpIHtcbiAgICAgIHVuRm9jdXMoZG9jdW1lbnQsIHdpbmRvdyk7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHNwbGl0ID09PSBcInZlcnRpY2FsXCIgPyBldmVudC50b3VjaGVzWzBdLmNsaWVudFggOiBldmVudC50b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICB0eXBlb2Ygb25EcmFnU3RhcnRlZCA9PSBcImZ1bmN0aW9uXCIgJiYgb25EcmFnU3RhcnRlZCgpLCB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgYWN0aXZlOiAhMCxcbiAgICAgICAgcG9zaXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgIGNvbnN0IGV2ZW50V2l0aFRvdWNoZXMgPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCwge1xuICAgICAgdG91Y2hlczogW3sgY2xpZW50WDogZXZlbnQuY2xpZW50WCwgY2xpZW50WTogZXZlbnQuY2xpZW50WSB9XVxuICAgIH0pO1xuICAgIHRoaXMub25Ub3VjaE1vdmUoZXZlbnRXaXRoVG91Y2hlcyk7XG4gIH1cbiAgb25Ub3VjaE1vdmUoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuYWN0aXZlIHx8ICF0aGlzLnByb3BzLmFsbG93UmVzaXplKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgcG9zaXRpb24gPSAwIH0gPSB0aGlzLnN0YXRlLCB7XG4gICAgICBtYXhTaXplLFxuICAgICAgbWluU2l6ZSA9IF9TcGxpdFBhbmUyLmRlZmF1bHRQcm9wcy5taW5TaXplLFxuICAgICAgb25DaGFuZ2UsXG4gICAgICBzcGxpdCA9IF9TcGxpdFBhbmUyLmRlZmF1bHRQcm9wcy5zcGxpdCxcbiAgICAgIHN0ZXBcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICB1bkZvY3VzKGRvY3VtZW50LCB3aW5kb3cpO1xuICAgIGNvbnN0IGlzUHJpbWFyeUZpcnN0ID0gdGhpcy5wcm9wcy5wcmltYXJ5ID09PSBcImZpcnN0XCIsIHJlZiA9IGlzUHJpbWFyeUZpcnN0ID8gdGhpcy5wYW5lMSA6IHRoaXMucGFuZTIsIHJlZjIgPSBpc1ByaW1hcnlGaXJzdCA/IHRoaXMucGFuZTIgOiB0aGlzLnBhbmUxO1xuICAgIGlmICghcmVmIHx8ICFyZWYyIHx8ICFyZWYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG5vZGUgPSByZWYsIG5vZGUyID0gcmVmMiwgd2lkdGggPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoLCBoZWlnaHQgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCwgY3VycmVudCA9IHNwbGl0ID09PSBcInZlcnRpY2FsXCIgPyBldmVudC50b3VjaGVzWzBdLmNsaWVudFggOiBldmVudC50b3VjaGVzWzBdLmNsaWVudFksIHNpemUgPSBzcGxpdCA9PT0gXCJ2ZXJ0aWNhbFwiID8gd2lkdGggOiBoZWlnaHQ7XG4gICAgbGV0IHBvc2l0aW9uRGVsdGEgPSBwb3NpdGlvbiAtIGN1cnJlbnQ7XG4gICAgaWYgKHN0ZXApIHtcbiAgICAgIGlmIChNYXRoLmFicyhwb3NpdGlvbkRlbHRhKSA8IHN0ZXApXG4gICAgICAgIHJldHVybjtcbiAgICAgIHBvc2l0aW9uRGVsdGEgPSB+fihwb3NpdGlvbkRlbHRhIC8gc3RlcCkgKiBzdGVwO1xuICAgIH1cbiAgICBsZXQgc2l6ZURlbHRhID0gaXNQcmltYXJ5Rmlyc3QgPyBwb3NpdGlvbkRlbHRhIDogLXBvc2l0aW9uRGVsdGE7XG4gICAgY29uc3QgcGFuZTFPcmRlciA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpLm9yZGVyKSwgcGFuZTJPcmRlciA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUyKS5vcmRlcik7XG4gICAgcGFuZTFPcmRlciA+IHBhbmUyT3JkZXIgJiYgKHNpemVEZWx0YSA9IC1zaXplRGVsdGEpO1xuICAgIGxldCBuZXdNYXhTaXplID0gbWF4U2l6ZTtcbiAgICB0aGlzLnNwbGl0UGFuZSAmJiBtYXhTaXplICE9PSB2b2lkIDAgJiYgbWF4U2l6ZSA8PSAwICYmIChzcGxpdCA9PT0gXCJ2ZXJ0aWNhbFwiID8gbmV3TWF4U2l6ZSA9IHRoaXMuc3BsaXRQYW5lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICsgbWF4U2l6ZSA6IG5ld01heFNpemUgPSB0aGlzLnNwbGl0UGFuZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgKyBtYXhTaXplKTtcbiAgICBsZXQgbmV3U2l6ZSA9IHNpemUgLSBzaXplRGVsdGE7XG4gICAgY29uc3QgbmV3UG9zaXRpb24gPSBwb3NpdGlvbiAtIHBvc2l0aW9uRGVsdGE7XG4gICAgbWluU2l6ZSAmJiBuZXdTaXplIDwgbWluU2l6ZSA/IG5ld1NpemUgPSBtaW5TaXplIDogbmV3TWF4U2l6ZSAhPT0gdm9pZCAwICYmIG5ld1NpemUgPiBuZXdNYXhTaXplID8gbmV3U2l6ZSA9IG5ld01heFNpemUgOiB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHBvc2l0aW9uOiBuZXdQb3NpdGlvbixcbiAgICAgIHJlc2l6ZWQ6ICEwXG4gICAgfSksIG9uQ2hhbmdlICYmIG9uQ2hhbmdlKG5ld1NpemUpO1xuICAgIGNvbnN0IHNpemVTdGF0ZSA9IGlzUHJpbWFyeUZpcnN0ID8geyBwYW5lMVNpemU6IG5ld1NpemUsIHBhbmUyU2l6ZTogdm9pZCAwIH0gOiB7IHBhbmUyU2l6ZTogbmV3U2l6ZSwgcGFuZTFTaXplOiB2b2lkIDAgfTtcbiAgICB0aGlzLnNldFN0YXRlKF9fc3ByZWFkVmFsdWVzKHsgZHJhZ2dlZFNpemU6IG5ld1NpemUgfSwgc2l6ZVN0YXRlKSk7XG4gIH1cbiAgb25Nb3VzZVVwKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5hY3RpdmUgfHwgIXRoaXMucHJvcHMuYWxsb3dSZXNpemUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBvbkRyYWdGaW5pc2hlZCB9ID0gdGhpcy5wcm9wcywgeyBkcmFnZ2VkU2l6ZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICB0eXBlb2YgZHJhZ2dlZFNpemUgPCBcInVcIiAmJiB0eXBlb2Ygb25EcmFnRmluaXNoZWQgPT0gXCJmdW5jdGlvblwiICYmIG9uRHJhZ0ZpbmlzaGVkKGRyYWdnZWRTaXplKSwgdGhpcy5zZXRTdGF0ZSh7IGFjdGl2ZTogITEgfSk7XG4gIH1cbiAgLy8gd2UgaGF2ZSB0byBjaGVjayB2YWx1ZXMgc2luY2UgZ0RTRlAgaXMgY2FsbGVkIG9uIGV2ZXJ5IHJlbmRlciBhbmQgbW9yZSBpbiBTdHJpY3RNb2RlXG4gIHN0YXRpYyBnZXRTaXplVXBkYXRlKHByb3BzLCBzdGF0ZSkge1xuICAgIGNvbnN0IHsgaW5zdGFuY2VQcm9wcyB9ID0gc3RhdGU7XG4gICAgaWYgKGluc3RhbmNlUHJvcHMuc2l6ZSA9PT0gcHJvcHMuc2l6ZSAmJiBwcm9wcy5zaXplICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4ge307XG4gICAgY29uc3QgbmV3U2l6ZSA9IHByb3BzLnNpemUgIT09IHZvaWQgMCA/IHByb3BzLnNpemUgOiBnZXREZWZhdWx0U2l6ZShcbiAgICAgIHByb3BzLmRlZmF1bHRTaXplLFxuICAgICAgcHJvcHMubWluU2l6ZSxcbiAgICAgIHByb3BzLm1heFNpemUsXG4gICAgICBzdGF0ZS5kcmFnZ2VkU2l6ZVxuICAgICksIHNpemVTdGF0ZSA9IHByb3BzLnByaW1hcnkgPT09IFwiZmlyc3RcIiA/IHsgcGFuZTFTaXplOiBuZXdTaXplLCBwYW5lMlNpemU6IHZvaWQgMCB9IDogeyBwYW5lMlNpemU6IG5ld1NpemUsIHBhbmUxU2l6ZTogdm9pZCAwIH07XG4gICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHNpemVTdGF0ZSksIHR5cGVvZiBwcm9wcy5zaXplID4gXCJ1XCIgPyB7fSA6IHsgZHJhZ2dlZFNpemU6IG5ld1NpemUgfSksIHtcbiAgICAgIGluc3RhbmNlUHJvcHM6IHsgc2l6ZTogcHJvcHMuc2l6ZSB9XG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFsbG93UmVzaXplLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUsXG4gICAgICBvblJlc2l6ZXJDbGljayxcbiAgICAgIG9uUmVzaXplckRvdWJsZUNsaWNrLFxuICAgICAgcGFuZUNsYXNzTmFtZSxcbiAgICAgIHBhbmUxQ2xhc3NOYW1lLFxuICAgICAgcGFuZTJDbGFzc05hbWUsXG4gICAgICBwYW5lU3R5bGUsXG4gICAgICBwYW5lMVN0eWxlOiBwYW5lMVN0eWxlUHJvcHMsXG4gICAgICBwYW5lMlN0eWxlOiBwYW5lMlN0eWxlUHJvcHMsXG4gICAgICByZXNpemVyQ2xhc3NOYW1lID0gUkVTSVpFUl9ERUZBVUxUX0NMQVNTTkFNRSxcbiAgICAgIHJlc2l6ZXJTdHlsZSxcbiAgICAgIHNwbGl0LFxuICAgICAgc3R5bGU6IHN0eWxlUHJvcHNcbiAgICB9ID0gdGhpcy5wcm9wcywgeyBwYW5lMVNpemUsIHBhbmUyU2l6ZSB9ID0gdGhpcy5zdGF0ZSwgZGlzYWJsZWRDbGFzcyA9IGFsbG93UmVzaXplID8gXCJcIiA6IFwiZGlzYWJsZWRcIiwgcmVzaXplckNsYXNzTmFtZXNJbmNsdWRpbmdEZWZhdWx0ID0gcmVzaXplckNsYXNzTmFtZSAmJiBgJHtyZXNpemVyQ2xhc3NOYW1lfSAke1JFU0laRVJfREVGQVVMVF9DTEFTU05BTUV9YCwgbm90TnVsbENoaWxkcmVuID0gcmVtb3ZlTnVsbENoaWxkcmVuKGNoaWxkcmVuKSwgYmFzZVN0eWxlcyA9IHNwbGl0ID09PSBcInZlcnRpY2FsXCIgPyBWRVJUSUNBTF9TVFlMRVMgOiBIT1JJWk9OVEFMX1NUWUxFUywgc3R5bGUgPSBzdHlsZVByb3BzID8gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGJhc2VTdHlsZXMpLCBzdHlsZVByb3BzKSA6IGJhc2VTdHlsZXMsIGNsYXNzZXMgPSBbXCJTcGxpdFBhbmVcIiwgY2xhc3NOYW1lLCBzcGxpdCwgZGlzYWJsZWRDbGFzc10uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpLCBwYW5lMVN0eWxlID0gY29hbGVzY2VPbkVtcHR5KFxuICAgICAgX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHBhbmVTdHlsZSksIHBhbmUxU3R5bGVQcm9wcyksXG4gICAgICBFTVBUWV9TVFlMRVNcbiAgICApLCBwYW5lMlN0eWxlID0gY29hbGVzY2VPbkVtcHR5KFxuICAgICAgX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHBhbmVTdHlsZSksIHBhbmUyU3R5bGVQcm9wcyksXG4gICAgICBFTVBUWV9TVFlMRVNcbiAgICApLCBwYW5lMUNsYXNzZXMgPSBbXCJQYW5lMVwiLCBwYW5lQ2xhc3NOYW1lLCBwYW5lMUNsYXNzTmFtZV0uam9pbihcIiBcIiksIHBhbmUyQ2xhc3NlcyA9IFtcIlBhbmUyXCIsIHBhbmVDbGFzc05hbWUsIHBhbmUyQ2xhc3NOYW1lXS5qb2luKFwiIFwiKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBcImRhdGEtdGVzdGlkXCI6IFwic3BsaXQtcGFuZVwiLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzZXMsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICByZWY6IChub2RlKSA9PiB7XG4gICAgICAgICAgdGhpcy5zcGxpdFBhbmUgPSBub2RlO1xuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgICBQYW5lLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IHBhbmUxQ2xhc3NlcyxcbiAgICAgICAgICAgICAgZWxlUmVmOiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGFuZTEgPSBub2RlO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzaXplOiBwYW5lMVNpemUsXG4gICAgICAgICAgICAgIHNwbGl0LFxuICAgICAgICAgICAgICBzdHlsZTogcGFuZTFTdHlsZSxcbiAgICAgICAgICAgICAgY2hpbGRyZW46IG5vdE51bGxDaGlsZHJlblswXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicGFuZTFcIlxuICAgICAgICAgICksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICAgIFJlc2l6ZXIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogZGlzYWJsZWRDbGFzcyxcbiAgICAgICAgICAgICAgb25DbGljazogb25SZXNpemVyQ2xpY2ssXG4gICAgICAgICAgICAgIG9uRG91YmxlQ2xpY2s6IG9uUmVzaXplckRvdWJsZUNsaWNrLFxuICAgICAgICAgICAgICBvbk1vdXNlRG93bjogdGhpcy5vbk1vdXNlRG93bixcbiAgICAgICAgICAgICAgb25Ub3VjaFN0YXJ0OiB0aGlzLm9uVG91Y2hTdGFydCxcbiAgICAgICAgICAgICAgb25Ub3VjaEVuZDogdGhpcy5vbk1vdXNlVXAsXG4gICAgICAgICAgICAgIHJlc2l6ZXJDbGFzc05hbWU6IHJlc2l6ZXJDbGFzc05hbWVzSW5jbHVkaW5nRGVmYXVsdCxcbiAgICAgICAgICAgICAgc3BsaXQ6IHNwbGl0IHx8IFwidmVydGljYWxcIixcbiAgICAgICAgICAgICAgc3R5bGU6IHJlc2l6ZXJTdHlsZSB8fCBFTVBUWV9TVFlMRVNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInJlc2l6ZXJcIlxuICAgICAgICAgICksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICAgIFBhbmUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogcGFuZTJDbGFzc2VzLFxuICAgICAgICAgICAgICBlbGVSZWY6IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYW5lMiA9IG5vZGU7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNpemU6IHBhbmUyU2l6ZSxcbiAgICAgICAgICAgICAgc3BsaXQsXG4gICAgICAgICAgICAgIHN0eWxlOiBwYW5lMlN0eWxlLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogbm90TnVsbENoaWxkcmVuWzFdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwYW5lMlwiXG4gICAgICAgICAgKVxuICAgICAgICBdXG4gICAgICB9XG4gICAgKTtcbiAgfVxufTtcbl9fcHVibGljRmllbGQoX1NwbGl0UGFuZSwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBhbGxvd1Jlc2l6ZTogITAsXG4gIG1pblNpemU6IDUwLFxuICBwcmltYXJ5OiBcImZpcnN0XCIsXG4gIHNwbGl0OiBcInZlcnRpY2FsXCIsXG4gIHBhbmVDbGFzc05hbWU6IFwiXCIsXG4gIHBhbmUxQ2xhc3NOYW1lOiBcIlwiLFxuICBwYW5lMkNsYXNzTmFtZTogXCJcIlxufSk7XG5sZXQgU3BsaXRQYW5lID0gX1NwbGl0UGFuZTtcbmZ1bmN0aW9uIHVuRm9jdXMoZG9jdW1lbnQyLCB3aW5kb3cyKSB7XG4gIHZhciBfYTtcbiAgaWYgKFwic2VsZWN0aW9uXCIgaW4gZG9jdW1lbnQyICYmIHR5cGVvZiBkb2N1bWVudDIuc2VsZWN0aW9uID09IFwib2JqZWN0XCIgJiYgZG9jdW1lbnQyLnNlbGVjdGlvbiAmJiBcImVtcHR5XCIgaW4gZG9jdW1lbnQyLnNlbGVjdGlvbiAmJiB0eXBlb2YgZG9jdW1lbnQyLnNlbGVjdGlvbi5lbXB0eSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgdHJ5IHtcbiAgICAgIGRvY3VtZW50Mi5zZWxlY3Rpb24uZW1wdHkoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICBlbHNlIGlmICh0eXBlb2Ygd2luZG93MiA8IFwidVwiICYmIHR5cGVvZiB3aW5kb3cyLmdldFNlbGVjdGlvbiA9PSBcImZ1bmN0aW9uXCIpXG4gICAgdHJ5IHtcbiAgICAgIChfYSA9IHdpbmRvdzIuZ2V0U2VsZWN0aW9uKCkpID09IG51bGwgfHwgX2EucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRTaXplKGRlZmF1bHRTaXplLCBtaW5TaXplLCBtYXhTaXplLCBkcmFnZ2VkU2l6ZSkge1xuICBpZiAodHlwZW9mIGRyYWdnZWRTaXplID09IFwibnVtYmVyXCIpIHtcbiAgICBjb25zdCBtaW4gPSB0eXBlb2YgbWluU2l6ZSA9PSBcIm51bWJlclwiID8gbWluU2l6ZSA6IDAsIG1heCA9IHR5cGVvZiBtYXhTaXplID09IFwibnVtYmVyXCIgJiYgbWF4U2l6ZSA+PSAwID8gbWF4U2l6ZSA6IDEgLyAwO1xuICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgZHJhZ2dlZFNpemUpKTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFNpemUgIT09IHZvaWQgMCA/IGRlZmF1bHRTaXplIDogbWluU2l6ZTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU51bGxDaGlsZHJlbihjaGlsZHJlbikge1xuICByZXR1cm4gQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbikuZmlsdGVyKChjKSA9PiBjKTtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlpc2gob2JqKSB7XG4gIHJldHVybiBvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA+IFwidVwiIHx8IE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gY29hbGVzY2VPbkVtcHR5KG9iaiwgdXNlT25FbXB0eSkge1xuICByZXR1cm4gaXNFbXB0eWlzaChvYmopID8gdXNlT25FbXB0eSA6IG9iajtcbn1cbmV4cG9ydCB7XG4gIFBhbmUsXG4gIFNwbGl0UGFuZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@rexxars/react-split-pane/dist/index.js\n");

/***/ })

};
;
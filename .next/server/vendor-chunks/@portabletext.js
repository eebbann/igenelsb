"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@portabletext";
exports.ids = ["vendor-chunks/@portabletext"];
exports.modules = {

/***/ "(ssr)/./node_modules/@portabletext/block-tools/lib/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@portabletext/block-tools/lib/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBlockContentFeatures: () => (/* binding */ getBlockContentFeatures),\n/* harmony export */   htmlToBlocks: () => (/* binding */ htmlToBlocks),\n/* harmony export */   normalizeBlock: () => (/* binding */ normalizeBlock),\n/* harmony export */   randomKey: () => (/* binding */ randomKey)\n/* harmony export */ });\n/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/flatten.js */ \"(ssr)/./node_modules/lodash/flatten.js\");\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/./node_modules/lodash/isEqual.js\");\n/* harmony import */ var lodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/uniq.js */ \"(ssr)/./node_modules/lodash/uniq.js\");\n/* harmony import */ var get_random_values_esm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! get-random-values-esm */ \"(ssr)/./node_modules/get-random-values-esm/index.mjs\");\n\n\n\n\n\nfunction findBlockType(type) {\n  return type.type ? findBlockType(type.type) : type.name === \"block\";\n}\nconst objectToString = Object.prototype.toString;\nfunction resolveJsType(val) {\n  switch (objectToString.call(val)) {\n    case \"[object Function]\":\n      return \"function\";\n    case \"[object Date]\":\n      return \"date\";\n    case \"[object RegExp]\":\n      return \"regexp\";\n    case \"[object Arguments]\":\n      return \"arguments\";\n    case \"[object Array]\":\n      return \"array\";\n    case \"[object String]\":\n      return \"string\";\n  }\n  return val === null ? \"null\" : val === void 0 ? \"undefined\" : val && typeof val == \"object\" && \"nodeType\" in val && val.nodeType === 1 ? \"element\" : val === Object(val) ? \"object\" : typeof val;\n}\nvar s = { 0: 8203, 1: 8204, 2: 8205, 3: 8290, 4: 8291, 5: 8288, 6: 65279, 7: 8289, 8: 119155, 9: 119156, a: 119157, b: 119158, c: 119159, d: 119160, e: 119161, f: 119162 }, c = { 0: 8203, 1: 8204, 2: 8205, 3: 65279 };\nnew Array(4).fill(String.fromCodePoint(c[0])).join(\"\");\nObject.fromEntries(Object.entries(c).map((t) => t.reverse()));\nObject.fromEntries(Object.entries(s).map((t) => t.reverse()));\nvar S = `${Object.values(s).map((t) => `\\\\u{${t.toString(16)}}`).join(\"\")}`, f = new RegExp(`[${S}]{4,}`, \"gu\");\nfunction _(t) {\n  var e;\n  return { cleaned: t.replace(f, \"\"), encoded: ((e = t.match(f)) == null ? void 0 : e[0]) || \"\" };\n}\nfunction O(t) {\n  return t && JSON.parse(_(JSON.stringify(t)).cleaned);\n}\nconst PRESERVE_WHITESPACE_TAGS = [\"pre\", \"textarea\", \"code\"], BLOCK_DEFAULT_STYLE = \"normal\", DEFAULT_BLOCK = Object.freeze({\n  _type: \"block\",\n  markDefs: [],\n  style: BLOCK_DEFAULT_STYLE\n}), DEFAULT_SPAN = Object.freeze({\n  _type: \"span\",\n  marks: []\n}), HTML_BLOCK_TAGS = {\n  p: DEFAULT_BLOCK,\n  blockquote: { ...DEFAULT_BLOCK, style: \"blockquote\" }\n}, HTML_SPAN_TAGS = {\n  span: { object: \"text\" }\n}, HTML_LIST_CONTAINER_TAGS = {\n  ol: { object: null },\n  ul: { object: null }\n}, HTML_HEADER_TAGS = {\n  h1: { ...DEFAULT_BLOCK, style: \"h1\" },\n  h2: { ...DEFAULT_BLOCK, style: \"h2\" },\n  h3: { ...DEFAULT_BLOCK, style: \"h3\" },\n  h4: { ...DEFAULT_BLOCK, style: \"h4\" },\n  h5: { ...DEFAULT_BLOCK, style: \"h5\" },\n  h6: { ...DEFAULT_BLOCK, style: \"h6\" }\n}, HTML_MISC_TAGS = {\n  br: { ...DEFAULT_BLOCK, style: BLOCK_DEFAULT_STYLE }\n}, HTML_DECORATOR_TAGS = {\n  b: \"strong\",\n  strong: \"strong\",\n  i: \"em\",\n  em: \"em\",\n  u: \"underline\",\n  s: \"strike-through\",\n  strike: \"strike-through\",\n  del: \"strike-through\",\n  code: \"code\",\n  sup: \"sup\",\n  sub: \"sub\",\n  ins: \"ins\",\n  mark: \"mark\",\n  small: \"small\"\n}, HTML_LIST_ITEM_TAGS = {\n  li: {\n    ...DEFAULT_BLOCK,\n    style: BLOCK_DEFAULT_STYLE,\n    level: 1,\n    listItem: \"bullet\"\n  }\n}, ELEMENT_MAP = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_SPAN_TAGS,\n  ...HTML_LIST_CONTAINER_TAGS,\n  ...HTML_LIST_ITEM_TAGS,\n  ...HTML_HEADER_TAGS,\n  ...HTML_MISC_TAGS\n};\nlodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__(\n  Object.values(ELEMENT_MAP).filter((tag) => \"style\" in tag).map((tag) => tag.style)\n);\nlodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__(\n  Object.values(HTML_DECORATOR_TAGS)\n);\nfunction blockContentFeatures(blockContentType) {\n  if (!blockContentType)\n    throw new Error(\"Parameter 'blockContentType' required\");\n  const blockType = blockContentType.of.find(findBlockType);\n  if (!(0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isBlockSchemaType)(blockType))\n    throw new Error(\"'block' type is not defined in this schema (required).\");\n  const ofType = blockType.fields.find(_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isBlockChildrenObjectField)?.type?.of;\n  if (!ofType)\n    throw new Error(\"No `of` declaration found for blocks `children` field\");\n  const spanType = ofType.find(\n    (member) => member.name === \"span\"\n  );\n  if (!spanType)\n    throw new Error(\n      \"No `span` type found in `block` schema type `children` definition\"\n    );\n  const inlineObjectTypes = ofType.filter(\n    (inlineType) => inlineType.name !== \"span\" && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isObjectSchemaType)(inlineType)\n  ), blockObjectTypes = blockContentType.of.filter(\n    (memberType) => memberType.name !== blockType.name && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isObjectSchemaType)(memberType)\n  );\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    annotations: resolveEnabledAnnotationTypes(spanType),\n    lists: resolveEnabledListItems(blockType),\n    types: {\n      block: blockContentType,\n      span: spanType,\n      inlineObjects: inlineObjectTypes,\n      blockObjects: blockObjectTypes\n    }\n  };\n}\nfunction resolveEnabledStyles(blockType) {\n  const styleField = blockType.fields.find(_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isBlockStyleObjectField);\n  if (!styleField)\n    throw new Error(\n      \"A field with name 'style' is not defined in the block type (required).\"\n    );\n  const textStyles = getTitledListValuesFromEnumListOptions(\n    styleField.type.options\n  );\n  if (textStyles.length === 0)\n    throw new Error(\n      \"The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.\"\n    );\n  return textStyles;\n}\nfunction resolveEnabledAnnotationTypes(spanType) {\n  return spanType.annotations.map((annotation) => ({\n    title: annotation.title,\n    type: annotation,\n    value: annotation.name,\n    icon: annotation.icon\n  }));\n}\nfunction resolveEnabledDecorators(spanType) {\n  return spanType.decorators;\n}\nfunction resolveEnabledListItems(blockType) {\n  const listField = blockType.fields.find(_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isBlockListObjectField);\n  if (!listField)\n    throw new Error(\n      \"A field with name 'list' is not defined in the block type (required).\"\n    );\n  const listItems = getTitledListValuesFromEnumListOptions(\n    listField.type.options\n  );\n  if (!listItems)\n    throw new Error(\"The list field need at least to be an empty array\");\n  return listItems;\n}\nfunction getTitledListValuesFromEnumListOptions(options) {\n  const list = options ? options.list : void 0;\n  return Array.isArray(list) ? list.map(\n    (item) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isTitledListValue)(item) ? item : { title: item, value: item }\n  ) : [];\n}\nconst _XPathResult = {\n  ANY_TYPE: 0,\n  NUMBER_TYPE: 1,\n  STRING_TYPE: 2,\n  BOOLEAN_TYPE: 3,\n  UNORDERED_NODE_ITERATOR_TYPE: 4,\n  ORDERED_NODE_ITERATOR_TYPE: 5,\n  UNORDERED_NODE_SNAPSHOT_TYPE: 6,\n  ORDERED_NODE_SNAPSHOT_TYPE: 7,\n  ANY_UNORDERED_NODE_TYPE: 8,\n  FIRST_ORDERED_NODE_TYPE: 9\n};\nvar preprocessGDocs = (_html, doc, options) => {\n  const whitespaceOnPasteMode = options?.unstable_whitespaceOnPasteMode || \"preserve\";\n  let gDocsRootOrSiblingNode = doc.evaluate(\n    '//*[@id and contains(@id, \"docs-internal-guid\")]',\n    doc,\n    null,\n    _XPathResult.ORDERED_NODE_ITERATOR_TYPE,\n    null\n  ).iterateNext();\n  if (gDocsRootOrSiblingNode) {\n    const isWrappedRootTag = tagName(gDocsRootOrSiblingNode) === \"b\";\n    switch (isWrappedRootTag || (gDocsRootOrSiblingNode = doc.body), whitespaceOnPasteMode) {\n      case \"normalize\":\n        normalizeWhitespace(gDocsRootOrSiblingNode);\n        break;\n      case \"remove\":\n        removeAllWhitespace(gDocsRootOrSiblingNode);\n        break;\n    }\n    const childNodes = doc.evaluate(\n      \"//*\",\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null\n    );\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i);\n      elm?.setAttribute(\"data-is-google-docs\", \"true\"), (elm?.parentElement === gDocsRootOrSiblingNode || !isWrappedRootTag && elm.parentElement === doc.body) && (elm?.setAttribute(\"data-is-root-node\", \"true\"), tagName(elm)), tagName(elm) === \"li\" && elm.firstChild && tagName(elm?.firstChild) === \"img\" && elm.removeChild(elm.firstChild);\n    }\n    return isWrappedRootTag && doc.body.firstElementChild?.replaceWith(\n      ...Array.from(gDocsRootOrSiblingNode.childNodes)\n    ), doc;\n  }\n  return doc;\n};\nconst unwantedWordDocumentPaths = [\n  \"/html/text()\",\n  \"/html/head/text()\",\n  \"/html/body/text()\",\n  \"/html/body/ul/text()\",\n  \"/html/body/ol/text()\",\n  \"//comment()\",\n  \"//style\",\n  \"//xml\",\n  \"//script\",\n  \"//meta\",\n  \"//link\"\n];\nvar preprocessHTML = (_html, doc) => {\n  const bodyTextNodes = doc.evaluate(\n    \"/html/body/text()\",\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = bodyTextNodes.snapshotLength - 1; i >= 0; i--) {\n    const node = bodyTextNodes.snapshotItem(i), text = node.textContent || \"\";\n    if (text.replace(/[^\\S\\n]+$/g, \"\")) {\n      const newNode = doc.createElement(\"span\");\n      newNode.appendChild(doc.createTextNode(text)), node.parentNode?.replaceChild(newNode, node);\n    } else\n      node.parentNode?.removeChild(node);\n  }\n  const unwantedNodes = doc.evaluate(\n    unwantedWordDocumentPaths.join(\"|\"),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i);\n    unwanted && unwanted.parentNode?.removeChild(unwanted);\n  }\n  return doc;\n}, preprocessNotion = (html, doc) => {\n  const NOTION_REGEX = /<!-- notionvc:.*?-->/g;\n  if (html.match(NOTION_REGEX)) {\n    const childNodes = doc.evaluate(\n      \"//*\",\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null\n    );\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--)\n      childNodes.snapshotItem(i)?.setAttribute(\"data-is-notion\", \"true\");\n    return doc;\n  }\n  return doc;\n}, preprocessWhitespace = (_2, doc) => {\n  function processNode(node) {\n    if (node.nodeType === _XPathResult.BOOLEAN_TYPE && !PRESERVE_WHITESPACE_TAGS.includes(\n      node.parentElement?.tagName.toLowerCase() || \"\"\n    ))\n      node.textContent = node.textContent?.replace(/\\s\\s+/g, \" \").replace(/[\\r\\n]+/g, \" \") || \"\";\n    else\n      for (let i = 0; i < node.childNodes.length; i++)\n        processNode(node.childNodes[i]);\n  }\n  return processNode(doc.body), doc;\n};\nconst WORD_HTML_REGEX = /(class=\"?Mso|style=(?:\"|')[^\"]*?\\bmso-|w:WordDocument|<o:\\w+>|<\\/font>)/, unwantedPaths = [\n  \"//o:p\",\n  \"//span[@style='mso-list:Ignore']\",\n  \"//span[@style='mso-list: Ignore']\"\n], mappedPaths = [\n  \"//p[@class='MsoTocHeading']\",\n  \"//p[@class='MsoTitle']\",\n  \"//p[@class='MsoToaHeading']\",\n  \"//p[@class='MsoSubtitle']\",\n  \"//span[@class='MsoSubtleEmphasis']\",\n  \"//span[@class='MsoIntenseEmphasis']\"\n], elementMap = {\n  MsoTocHeading: [\"h3\"],\n  MsoTitle: [\"h1\"],\n  MsoToaHeading: [\"h2\"],\n  MsoSubtitle: [\"h5\"],\n  MsoSubtleEmphasis: [\"span\", \"em\"],\n  MsoIntenseEmphasis: [\"span\", \"em\", \"strong\"]\n  // Remove cruft\n};\nfunction isWordHtml(html) {\n  return WORD_HTML_REGEX.test(html);\n}\nvar preprocessWord = (html, doc) => {\n  if (!isWordHtml(html))\n    return doc;\n  const unwantedNodes = doc.evaluate(\n    unwantedPaths.join(\"|\"),\n    doc,\n    (prefix) => prefix === \"o\" ? \"urn:schemas-microsoft-com:office:office\" : null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i);\n    unwanted?.parentNode && unwanted.parentNode.removeChild(unwanted);\n  }\n  const mappedElements = doc.evaluate(\n    mappedPaths.join(\"|\"),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = mappedElements.snapshotLength - 1; i >= 0; i--) {\n    const mappedElm = mappedElements.snapshotItem(i), tags = elementMap[mappedElm.className], text = doc.createTextNode(mappedElm.textContent || \"\");\n    if (!tags)\n      continue;\n    const parentElement = doc.createElement(tags[0]);\n    let parent = parentElement, child = parentElement;\n    tags.slice(1).forEach((tag) => {\n      child = doc.createElement(tag), parent.appendChild(child), parent = child;\n    }), child.appendChild(text), mappedElm?.parentNode?.replaceChild(parentElement, mappedElm);\n  }\n  return doc;\n}, preprocessors = [\n  preprocessWhitespace,\n  preprocessNotion,\n  preprocessWord,\n  preprocessGDocs,\n  preprocessHTML\n];\nfunction createRuleOptions(blockContentType) {\n  const features = blockContentFeatures(blockContentType), enabledBlockStyles = features.styles.map(\n    (item) => item.value || item.title\n  ), enabledSpanDecorators = features.decorators.map(\n    (item) => item.value || item.title\n  ), enabledBlockAnnotations = features.annotations.map(\n    (item) => item.value || item.title || \"\"\n  ), enabledListTypes = features.lists.map(\n    (item) => item.value || item.title || \"\"\n  );\n  return {\n    enabledBlockStyles,\n    enabledSpanDecorators,\n    enabledBlockAnnotations,\n    enabledListTypes\n  };\n}\nfunction tagName(el) {\n  if (el && \"tagName\" in el)\n    return el.tagName.toLowerCase();\n}\nfunction preprocess(html, parseHtml, options) {\n  const cleanHTML = O(html), doc = parseHtml(normalizeHtmlBeforePreprocess(cleanHTML));\n  return preprocessors.forEach((processor) => {\n    processor(cleanHTML, doc, options);\n  }), doc;\n}\nfunction normalizeHtmlBeforePreprocess(html) {\n  return html.trim();\n}\nfunction defaultParseHtml() {\n  if (resolveJsType(DOMParser) === \"undefined\")\n    throw new Error(\n      \"The native `DOMParser` global which the `Html` deserializer uses by default is not present in this environment. You must supply the `options.parseHtml` function instead.\"\n    );\n  return (html) => new DOMParser().parseFromString(html, \"text/html\");\n}\nfunction flattenNestedBlocks(blocks2) {\n  let depth = 0;\n  const flattened = [], traverse = (nodes) => {\n    const toRemove = [];\n    nodes.forEach((node) => {\n      depth === 0 && flattened.push(node), (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextTextBlock)(node) && (depth > 0 && (toRemove.push(node), flattened.push(node)), depth++, traverse(node.children)), node._type === \"__block\" && (toRemove.push(node), flattened.push(node.block));\n    }), toRemove.forEach((node) => {\n      nodes.splice(nodes.indexOf(node), 1);\n    }), depth--;\n  };\n  return traverse(blocks2), flattened;\n}\nfunction nextSpan(block, index) {\n  const next = block.children[index + 1];\n  return next && next._type === \"span\" ? next : null;\n}\nfunction prevSpan(block, index) {\n  const prev = block.children[index - 1];\n  return prev && prev._type === \"span\" ? prev : null;\n}\nfunction isWhiteSpaceChar(text) {\n  return [\"\\xA0\", \" \"].includes(text);\n}\nfunction trimWhitespace(blocks2) {\n  return blocks2.forEach((block) => {\n    (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextTextBlock)(block) && block.children.forEach((child, index) => {\n      if (!isMinimalSpan(child))\n        return;\n      const nextChild = nextSpan(block, index), prevChild = prevSpan(block, index);\n      index === 0 && (child.text = child.text.replace(/^[^\\S\\n]+/g, \"\")), index === block.children.length - 1 && (child.text = child.text.replace(/[^\\S\\n]+$/g, \"\")), /\\s/.test(child.text.slice(Math.max(0, child.text.length - 1))) && nextChild && isMinimalSpan(nextChild) && /\\s/.test(nextChild.text.slice(0, 1)) && (child.text = child.text.replace(/[^\\S\\n]+$/g, \"\")), /\\s/.test(child.text.slice(0, 1)) && prevChild && isMinimalSpan(prevChild) && /\\s/.test(prevChild.text.slice(Math.max(0, prevChild.text.length - 1))) && (child.text = child.text.replace(/^[^\\S\\n]+/g, \"\")), child.text || block.children.splice(index, 1), prevChild && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(prevChild.marks, child.marks) && isWhiteSpaceChar(child.text) ? (prevChild.text += \" \", block.children.splice(index, 1)) : nextChild && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(nextChild.marks, child.marks) && isWhiteSpaceChar(child.text) && (nextChild.text = ` ${nextChild.text}`, block.children.splice(index, 1));\n    });\n  }), blocks2;\n}\nfunction ensureRootIsBlocks(blocks2) {\n  return blocks2.reduce((memo, node, i, original) => {\n    if (node._type === \"block\")\n      return memo.push(node), memo;\n    if (node._type === \"__block\")\n      return memo.push(node.block), memo;\n    const lastBlock = memo[memo.length - 1];\n    if (i > 0 && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextTextBlock)(original[i - 1]) && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextTextBlock)(lastBlock))\n      return lastBlock.children.push(node), memo;\n    const block = {\n      ...DEFAULT_BLOCK,\n      children: [node]\n    };\n    return memo.push(block), memo;\n  }, []);\n}\nfunction isNodeList(node) {\n  return Object.prototype.toString.call(node) === \"[object NodeList]\";\n}\nfunction isMinimalSpan(node) {\n  return node._type === \"span\";\n}\nfunction isMinimalBlock(node) {\n  return node._type === \"block\";\n}\nfunction isPlaceholderDecorator(node) {\n  return node._type === \"__decorator\";\n}\nfunction isPlaceholderAnnotation(node) {\n  return node._type === \"__annotation\";\n}\nfunction isElement(node) {\n  return node.nodeType === 1;\n}\nfunction normalizeWhitespace(rootNode) {\n  let emptyBlockCount = 0, lastParent = null;\n  const nodesToRemove = [];\n  for (let child = rootNode.firstChild; child; child = child.nextSibling) {\n    if (!isElement(child)) {\n      normalizeWhitespace(child), emptyBlockCount = 0;\n      continue;\n    }\n    const elm = child;\n    isWhitespaceBlock(elm) ? (lastParent && elm.parentElement === lastParent ? (emptyBlockCount++, emptyBlockCount > 1 && nodesToRemove.push(elm)) : emptyBlockCount = 1, lastParent = elm.parentElement) : (normalizeWhitespace(child), emptyBlockCount = 0);\n  }\n  nodesToRemove.forEach((node) => node.parentElement?.removeChild(node));\n}\nfunction removeAllWhitespace(rootNode) {\n  const nodesToRemove = [];\n  function collectNodesToRemove(currentNode) {\n    if (isElement(currentNode)) {\n      const elm = currentNode;\n      if (tagName(elm) === \"br\" && (tagName(elm.nextElementSibling) === \"p\" || tagName(elm.previousElementSibling) === \"p\")) {\n        nodesToRemove.push(elm);\n        return;\n      }\n      if ((tagName(elm) === \"p\" || tagName(elm) === \"br\") && elm?.firstChild?.textContent?.trim() === \"\") {\n        nodesToRemove.push(elm);\n        return;\n      }\n      for (let child = elm.firstChild; child; child = child.nextSibling)\n        collectNodesToRemove(child);\n    }\n  }\n  collectNodesToRemove(rootNode), nodesToRemove.forEach((node) => node.parentElement?.removeChild(node));\n}\nfunction isWhitespaceBlock(elm) {\n  return [\"p\", \"br\"].includes(tagName(elm) || \"\") && !elm.textContent?.trim();\n}\nconst LIST_CONTAINER_TAGS = Object.keys(HTML_LIST_CONTAINER_TAGS);\nfunction isEmphasis$1(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /font-style\\s*:\\s*italic/.test(style || \"\");\n}\nfunction isStrong$1(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /font-weight\\s*:\\s*700/.test(style || \"\");\n}\nfunction isUnderline$1(el) {\n  if (!isElement(el) || tagName(el.parentNode) === \"a\")\n    return !1;\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /text-decoration\\s*:\\s*underline/.test(style || \"\");\n}\nfunction isStrikethrough(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /text-decoration\\s*:\\s*(?:.*line-through.*;)/.test(style || \"\");\n}\nfunction isGoogleDocs(el) {\n  return isElement(el) && !!el.getAttribute(\"data-is-google-docs\");\n}\nfunction isRootNode(el) {\n  return isElement(el) && !!el.getAttribute(\"data-is-root-node\");\n}\nfunction getListItemStyle$1(el) {\n  const parentTag = tagName(el.parentNode);\n  if (!(parentTag && !LIST_CONTAINER_TAGS.includes(parentTag)))\n    return tagName(el.parentNode) === \"ul\" ? \"bullet\" : \"number\";\n}\nfunction getListItemLevel$1(el) {\n  let level = 0;\n  if (tagName(el) === \"li\") {\n    let parentNode = el.parentNode;\n    for (; parentNode; ) {\n      const parentTag = tagName(parentNode);\n      parentTag && LIST_CONTAINER_TAGS.includes(parentTag) && level++, parentNode = parentNode.parentNode;\n    }\n  } else\n    level = 1;\n  return level;\n}\nconst blocks = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_HEADER_TAGS\n};\nfunction getBlockStyle(el, enabledBlockStyles) {\n  const childTag = tagName(el.firstChild), block = childTag && blocks[childTag];\n  return block && enabledBlockStyles.includes(block.style) ? block.style : BLOCK_DEFAULT_STYLE;\n}\nfunction createGDocsRules(_blockContentType, options) {\n  return [\n    {\n      deserialize(el) {\n        if (isElement(el) && tagName(el) === \"span\" && isGoogleDocs(el)) {\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [],\n            text: el.textContent\n          };\n          return isStrong$1(el) && span.marks.push(\"strong\"), isUnderline$1(el) && span.marks.push(\"underline\"), isStrikethrough(el) && span.marks.push(\"strike-through\"), isEmphasis$1(el) && span.marks.push(\"em\"), span;\n        }\n      }\n    },\n    {\n      deserialize(el, next) {\n        if (tagName(el) === \"li\" && isGoogleDocs(el))\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle$1(el),\n            level: getListItemLevel$1(el),\n            style: getBlockStyle(el, options.enabledBlockStyles),\n            children: next(el.firstChild?.childNodes || [])\n          };\n      }\n    },\n    {\n      deserialize(el) {\n        if (tagName(el) === \"br\" && isGoogleDocs(el) && isElement(el) && el.classList.contains(\"apple-interchange-newline\"))\n          return {\n            ...DEFAULT_SPAN,\n            text: \"\"\n          };\n        if (tagName(el) === \"br\" && isGoogleDocs(el) && isElement(el) && el?.parentNode?.textContent === \"\")\n          return {\n            ...DEFAULT_SPAN,\n            text: \"\"\n          };\n        if (tagName(el) === \"br\" && isGoogleDocs(el) && isElement(el) && isRootNode(el))\n          return {\n            ...DEFAULT_SPAN,\n            text: \"\"\n          };\n      }\n    }\n  ];\n}\nfunction keyGenerator() {\n  return randomKey(12);\n}\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length);\n  return (0,get_random_values_esm__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(rnds8), rnds8;\n}\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i)\n  byteToHex[i] = (i + 256).toString(16).slice(1);\nfunction randomKey(length) {\n  return whatwgRNG(length).reduce((str, n) => str + byteToHex[n], \"\").slice(0, length);\n}\nconst whitespaceTextNodeRule = {\n  deserialize(node) {\n    return node.nodeName === \"#text\" && isWhitespaceTextNode(node) ? {\n      ...DEFAULT_SPAN,\n      marks: [],\n      text: (node.textContent ?? \"\").replace(/\\s\\s+/g, \" \")\n    } : void 0;\n  }\n};\nfunction isWhitespaceTextNode(node) {\n  return (node.nodeType === 3 && (node.textContent || \"\").replace(/[\\r\\n]/g, \" \").replace(/\\s\\s+/g, \" \") === \" \" && node.nextSibling && node.nextSibling.nodeType !== 3 && node.previousSibling && node.previousSibling.nodeType !== 3 || node.textContent !== \" \") && tagName(node.parentNode) !== \"body\";\n}\nfunction resolveListItem(listNodeTagName, enabledListTypes) {\n  if (listNodeTagName === \"ul\" && enabledListTypes.includes(\"bullet\"))\n    return \"bullet\";\n  if (listNodeTagName === \"ol\" && enabledListTypes.includes(\"number\"))\n    return \"number\";\n}\nfunction createHTMLRules(_blockContentType, options) {\n  return [\n    whitespaceTextNodeRule,\n    {\n      // Pre element\n      deserialize(el) {\n        if (tagName(el) !== \"pre\")\n          return;\n        const isCodeEnabled = options.enabledBlockStyles.includes(\"code\");\n        return {\n          _type: \"block\",\n          style: \"normal\",\n          markDefs: [],\n          children: [\n            {\n              ...DEFAULT_SPAN,\n              marks: isCodeEnabled ? [\"code\"] : [],\n              text: el.textContent || \"\"\n            }\n          ]\n        };\n      }\n    },\n    // Blockquote element\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== \"blockquote\")\n          return;\n        const blocks2 = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS\n        };\n        delete blocks2.blockquote;\n        const nonBlockquoteBlocks = Object.keys(blocks2), children = [];\n        return el.childNodes.forEach((node, index) => {\n          if (el.ownerDocument)\n            if (node.nodeType === 1 && nonBlockquoteBlocks.includes(\n              node.localName.toLowerCase()\n            )) {\n              const span = el.ownerDocument.createElement(\"span\"), previousChild = children[children.length - 1];\n              previousChild && previousChild.nodeType === 3 && previousChild.textContent?.trim() && span.appendChild(el.ownerDocument.createTextNode(\"\\r\")), node.childNodes.forEach((cn) => {\n                span.appendChild(cn.cloneNode(!0));\n              }), index !== el.childNodes.length && span.appendChild(el.ownerDocument.createTextNode(\"\\r\")), children.push(span);\n            } else\n              children.push(node);\n        }), {\n          _type: \"block\",\n          style: \"blockquote\",\n          markDefs: [],\n          children: next(children)\n        };\n      }\n    },\n    // Block elements\n    {\n      deserialize(el, next) {\n        const blocks2 = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS\n        }, tag = tagName(el);\n        let block = tag ? blocks2[tag] : void 0;\n        if (block)\n          return el.parentNode && tagName(el.parentNode) === \"li\" ? next(el.childNodes) : (options.enabledBlockStyles.includes(block.style) || (block = DEFAULT_BLOCK), {\n            ...block,\n            children: next(el.childNodes)\n          });\n      }\n    },\n    // Ignore span tags\n    {\n      deserialize(el, next) {\n        const tag = tagName(el);\n        if (!(!tag || !(tag in HTML_SPAN_TAGS)))\n          return next(el.childNodes);\n      }\n    },\n    // Ignore div tags\n    {\n      deserialize(el, next) {\n        if (tagName(el) === \"div\")\n          return next(el.childNodes);\n      }\n    },\n    // Ignore list containers\n    {\n      deserialize(el, next) {\n        const tag = tagName(el);\n        if (!(!tag || !(tag in HTML_LIST_CONTAINER_TAGS)))\n          return next(el.childNodes);\n      }\n    },\n    // Deal with br's\n    {\n      deserialize(el) {\n        if (tagName(el) === \"br\")\n          return {\n            ...DEFAULT_SPAN,\n            text: `\n`\n          };\n      }\n    },\n    // Deal with list items\n    {\n      deserialize(el, next, block) {\n        const tag = tagName(el), listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : void 0, parentTag = tagName(el.parentNode) || \"\";\n        if (!listItem || !el.parentNode || !HTML_LIST_CONTAINER_TAGS[parentTag])\n          return;\n        const enabledListItem = resolveListItem(\n          parentTag,\n          options.enabledListTypes\n        );\n        return enabledListItem ? (listItem.listItem = enabledListItem, {\n          ...listItem,\n          children: next(el.childNodes)\n        }) : block({ _type: \"block\", children: next(el.childNodes) });\n      }\n    },\n    // Deal with decorators - this is a limited set of known html elements that we know how to deserialize\n    {\n      deserialize(el, next) {\n        const decorator = HTML_DECORATOR_TAGS[tagName(el) || \"\"];\n        if (!(!decorator || !options.enabledSpanDecorators.includes(decorator)))\n          return {\n            _type: \"__decorator\",\n            name: decorator,\n            children: next(el.childNodes)\n          };\n      }\n    },\n    // Special case for hyperlinks, add annotation (if allowed by schema),\n    // If not supported just write out the link text and href in plain text.\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== \"a\")\n          return;\n        const linkEnabled = options.enabledBlockAnnotations.includes(\"link\"), href = isElement(el) && el.getAttribute(\"href\");\n        if (!href)\n          return next(el.childNodes);\n        let markDef;\n        return linkEnabled ? (markDef = {\n          _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n          _type: \"link\",\n          href\n        }, {\n          _type: \"__annotation\",\n          markDef,\n          children: next(el.childNodes)\n        }) : el.appendChild(el.ownerDocument.createTextNode(` (${href})`)) && next(el.childNodes);\n      }\n    }\n  ];\n}\nfunction isEmphasis(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /font-style:italic/.test(style || \"\");\n}\nfunction isStrong(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /font-weight:700/.test(style || \"\") || /font-weight:600/.test(style || \"\");\n}\nfunction isUnderline(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /text-decoration:underline/.test(style || \"\");\n}\nfunction isNotion(el) {\n  return isElement(el) && !!el.getAttribute(\"data-is-notion\");\n}\nfunction createNotionRules(_blockContentType) {\n  return [\n    {\n      deserialize(el) {\n        if (isElement(el) && tagName(el) === \"span\" && isNotion(el)) {\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [],\n            text: el.textContent\n          };\n          return isStrong(el) && span.marks.push(\"strong\"), isUnderline(el) && span.marks.push(\"underline\"), isEmphasis(el) && span.marks.push(\"em\"), span;\n        }\n      }\n    }\n  ];\n}\nfunction getListItemStyle(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  if (style && style.match(/lfo\\d+/))\n    return style.match(\"lfo1\") ? \"bullet\" : \"number\";\n}\nfunction getListItemLevel(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  if (!style)\n    return;\n  const levelMatch = style.match(/level\\d+/);\n  if (!levelMatch)\n    return;\n  const [level] = levelMatch[0].match(/\\d/) || [];\n  return (level ? Number.parseInt(level, 10) : 1) || 1;\n}\nfunction isWordListElement(el) {\n  return isElement(el) && el.className ? el.className === \"MsoListParagraphCxSpFirst\" || el.className === \"MsoListParagraphCxSpMiddle\" || el.className === \"MsoListParagraphCxSpLast\" : !1;\n}\nfunction createWordRules() {\n  return [\n    {\n      deserialize(el, next) {\n        if (tagName(el) === \"p\" && isWordListElement(el))\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: BLOCK_DEFAULT_STYLE,\n            children: next(el.childNodes)\n          };\n      }\n    }\n  ];\n}\nfunction createRules(blockContentType, options) {\n  return [\n    ...createWordRules(),\n    ...createNotionRules(),\n    ...createGDocsRules(blockContentType, options),\n    ...createHTMLRules(blockContentType, options)\n  ];\n}\nclass HtmlDeserializer {\n  blockContentType;\n  rules;\n  parseHtml;\n  _markDefs = [];\n  /**\n   * Create a new serializer respecting a Sanity block content type's schema\n   *\n   * @param blockContentType - Schema type for array containing _at least_ a block child type\n   * @param options - Options for the deserialization process\n   */\n  constructor(blockContentType, options = {}) {\n    const { rules = [], unstable_whitespaceOnPasteMode = \"preserve\" } = options;\n    if (!blockContentType)\n      throw new Error(\"Parameter 'blockContentType' is required\");\n    const standardRules = createRules(blockContentType, {\n      ...createRuleOptions(blockContentType),\n      keyGenerator: options.keyGenerator\n    });\n    this.rules = [...rules, ...standardRules];\n    const parseHtml = options.parseHtml || defaultParseHtml();\n    this.blockContentType = blockContentType, this.parseHtml = (html) => preprocess(html, parseHtml, { unstable_whitespaceOnPasteMode }).body;\n  }\n  /**\n   * Deserialize HTML.\n   *\n   * @param html - The HTML to deserialize, as a string\n   * @returns Array of blocks - either portable text blocks or other allowed blocks\n   */\n  deserialize = (html) => {\n    this._markDefs = [];\n    const { parseHtml } = this, fragment = parseHtml(html), children = Array.from(fragment.childNodes), blocks2 = trimWhitespace(\n      flattenNestedBlocks(\n        ensureRootIsBlocks(this.deserializeElements(children))\n      )\n    );\n    this._markDefs.length > 0 && blocks2.filter(\n      (block) => block._type === \"block\"\n    ).forEach((block) => {\n      block.markDefs = block.markDefs || [], block.markDefs = block.markDefs.concat(\n        this._markDefs.filter((def) => lodash_flatten_js__WEBPACK_IMPORTED_MODULE_0__(\n          block.children.map((child) => child.marks || [])\n        ).includes(def._key))\n      );\n    });\n    const type = this.blockContentType.of.find(findBlockType);\n    return type ? blocks2.map((block) => (block._type === \"block\" && (block._type = type.name), block)) : blocks2;\n  };\n  /**\n   * Deserialize an array of DOM elements.\n   *\n   * @param elements - Array of DOM elements to deserialize\n   * @returns\n   */\n  deserializeElements = (elements = []) => {\n    let nodes = [];\n    return elements.forEach((element) => {\n      nodes = nodes.concat(this.deserializeElement(element));\n    }), nodes;\n  };\n  /**\n   * Deserialize a DOM element\n   *\n   * @param element - Deserialize a DOM element\n   * @returns\n   */\n  deserializeElement = (element) => {\n    const next = (elements) => {\n      if (isNodeList(elements))\n        return this.deserializeElements(Array.from(elements));\n      if (Array.isArray(elements))\n        return this.deserializeElements(elements);\n      if (elements)\n        return this.deserializeElement(elements);\n    }, block = (props) => ({\n      _type: \"__block\",\n      block: props\n    });\n    let node;\n    for (let i = 0; i < this.rules.length; i++) {\n      const rule = this.rules[i];\n      if (!rule.deserialize)\n        continue;\n      const ret = rule.deserialize(element, next, block), type = resolveJsType(ret);\n      if (type !== \"array\" && type !== \"object\" && type !== \"null\" && type !== \"undefined\")\n        throw new Error(\n          `A rule returned an invalid deserialized representation: \"${node}\".`\n        );\n      if (ret !== void 0) {\n        {\n          if (ret === null)\n            throw new Error(\"Deserializer rule returned `null`\");\n          Array.isArray(ret) ? node = ret : isPlaceholderDecorator(ret) ? node = this.deserializeDecorator(ret) : isPlaceholderAnnotation(ret) ? node = this.deserializeAnnotation(ret) : node = ret;\n        }\n        if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && \"listItem\" in ret) {\n          let parent = element.parentNode?.parentNode;\n          for (; parent && tagName(parent) === \"li\"; )\n            parent = parent.parentNode?.parentNode, ret.level = ret.level ? ret.level + 1 : 1;\n        }\n        ret && !Array.isArray(ret) && isMinimalBlock(ret) && ret.style === \"blockquote\" && ret.children.forEach((child, index) => {\n          isMinimalSpan(child) && child.text === \"\\r\" && (child.text = `\n`, (index === 0 || index === ret.children.length - 1) && ret.children.splice(index, 1));\n        });\n        break;\n      }\n    }\n    return node || next(element.childNodes) || [];\n  };\n  /**\n   * Deserialize a `__decorator` type\n   * (an internal made up type to process decorators exclusively)\n   *\n   * @param decorator -\n   * @returns array of ...\n   */\n  deserializeDecorator = (decorator) => {\n    const { name } = decorator, applyDecorator = (node) => {\n      if (isPlaceholderDecorator(node))\n        return this.deserializeDecorator(node);\n      if (isMinimalSpan(node))\n        node.marks = node.marks || [], node.text.trim() && node.marks.unshift(name);\n      else if (\"children\" in node && Array.isArray(node.children)) {\n        const block = node;\n        block.children = block.children.map(applyDecorator);\n      }\n      return node;\n    };\n    return decorator.children.reduce((children, node) => {\n      const ret = applyDecorator(node);\n      return Array.isArray(ret) ? children.concat(ret) : (children.push(ret), children);\n    }, []);\n  };\n  /**\n   * Deserialize a `__annotation` object.\n   * (an internal made up type to process annotations exclusively)\n   *\n   * @param annotation -\n   * @returns Array of...\n   */\n  deserializeAnnotation = (annotation) => {\n    const { markDef } = annotation;\n    this._markDefs.push(markDef);\n    const applyAnnotation = (node) => {\n      if (isPlaceholderAnnotation(node))\n        return this.deserializeAnnotation(node);\n      if (isMinimalSpan(node))\n        node.marks = node.marks || [], node.text.trim() && node.marks.unshift(markDef._key);\n      else if (\"children\" in node && Array.isArray(node.children)) {\n        const block = node;\n        block.children = block.children.map(applyAnnotation);\n      }\n      return node;\n    };\n    return annotation.children.reduce((children, node) => {\n      const ret = applyAnnotation(node);\n      return Array.isArray(ret) ? children.concat(ret) : (children.push(ret), children);\n    }, []);\n  };\n}\nfunction normalizeBlock(node, options = {}) {\n  if (node._type !== (options.blockTypeName || \"block\"))\n    return \"_key\" in node ? node : {\n      ...node,\n      _key: options.keyGenerator ? options.keyGenerator() : keyGenerator()\n    };\n  const block = {\n    _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n    children: [],\n    markDefs: [],\n    ...node\n  }, lastChild = block.children[block.children.length - 1];\n  if (!lastChild)\n    return block.children = [\n      {\n        _type: \"span\",\n        _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n        text: \"\",\n        marks: []\n      }\n    ], block;\n  const usedMarkDefs = [], allowedDecorators = options.allowedDecorators && Array.isArray(options.allowedDecorators) ? options.allowedDecorators : !1;\n  return block.children = block.children.reduce(\n    (acc, child) => {\n      const previousChild = acc[acc.length - 1];\n      return previousChild && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextSpan)(child) && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextSpan)(previousChild) && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(previousChild.marks, child.marks) ? (lastChild && lastChild === child && child.text === \"\" && block.children.length > 1 || (previousChild.text += child.text), acc) : (acc.push(child), acc);\n    },\n    []\n  ).map((child) => {\n    if (!child)\n      throw new Error(\"missing child\");\n    return child._key = options.keyGenerator ? options.keyGenerator() : keyGenerator(), (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextSpan)(child) && (child.marks ? allowedDecorators && (child.marks = child.marks.filter((mark) => {\n      const isAllowed = allowedDecorators.includes(mark), isUsed = block.markDefs?.some((def) => def._key === mark);\n      return isAllowed || isUsed;\n    })) : child.marks = [], usedMarkDefs.push(...child.marks)), child;\n  }), block.markDefs = (block.markDefs || []).filter(\n    (markDef) => usedMarkDefs.includes(markDef._key)\n  ), block;\n}\nfunction htmlToBlocks(html, blockContentType, options = {}) {\n  return new HtmlDeserializer(blockContentType, options).deserialize(html).map((block) => normalizeBlock(block, { keyGenerator: options.keyGenerator }));\n}\nfunction getBlockContentFeatures(blockContentType) {\n  return blockContentFeatures(blockContentType);\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9ibG9jay10b29scy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQzJLO0FBQzNLO0FBQ047QUFDa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpS0FBaUssUUFBUTtBQUNuTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQyxFQUFFLGdCQUFnQixZQUFZLHNCQUFzQixFQUFFLEVBQUUsR0FBRztBQUN2RztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGdCQUFnQjtBQUNoQixDQUFDO0FBQ0QsVUFBVTtBQUNWLENBQUM7QUFDRCxRQUFRLGNBQWM7QUFDdEIsUUFBUTtBQUNSLENBQUM7QUFDRCxRQUFRLCtCQUErQjtBQUN2QyxRQUFRLCtCQUErQjtBQUN2QyxRQUFRLCtCQUErQjtBQUN2QyxRQUFRLCtCQUErQjtBQUN2QyxRQUFRLCtCQUErQjtBQUN2QyxRQUFRO0FBQ1IsQ0FBQztBQUNELFFBQVE7QUFDUixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBSTtBQUNKO0FBQ0E7QUFDQSwyQ0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0VBQWlCO0FBQ3hCO0FBQ0EsdUNBQXVDLHFFQUEwQjtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlFQUFlO0FBQ3hCO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFlBQVksK0NBQStDO0FBQ3BFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdEQUF3RCxLQUFLO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLFlBQVksMERBQTBEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVHQUF1RyxnQ0FBZ0M7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsOENBQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsS0FBSztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0NBQW9DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlFQUFrQixXQUFXLGlFQUFrQixtQkFBbUIsOENBQU87QUFDdkcsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLGlFQUFrQjtBQUMxRztBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsa0hBQWtILG9DQUFvQztBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQU1FO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNib29rcHJvL0Rvd25sb2Fkcy9jb25pY2FwcHMvaWdlbmUvbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvYmxvY2stdG9vbHMvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmbGF0dGVuIGZyb20gXCJsb2Rhc2gvZmxhdHRlbi5qc1wiO1xuaW1wb3J0IHsgaXNCbG9ja1NjaGVtYVR5cGUsIGlzQmxvY2tDaGlsZHJlbk9iamVjdEZpZWxkLCBpc09iamVjdFNjaGVtYVR5cGUsIGlzQmxvY2tTdHlsZU9iamVjdEZpZWxkLCBpc0Jsb2NrTGlzdE9iamVjdEZpZWxkLCBpc1RpdGxlZExpc3RWYWx1ZSwgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2ssIGlzUG9ydGFibGVUZXh0U3BhbiB9IGZyb20gXCJAc2FuaXR5L3R5cGVzXCI7XG5pbXBvcnQgaXNFcXVhbCBmcm9tIFwibG9kYXNoL2lzRXF1YWwuanNcIjtcbmltcG9ydCB1bmlxIGZyb20gXCJsb2Rhc2gvdW5pcS5qc1wiO1xuaW1wb3J0IGdldFJhbmRvbVZhbHVlcyBmcm9tIFwiZ2V0LXJhbmRvbS12YWx1ZXMtZXNtXCI7XG5mdW5jdGlvbiBmaW5kQmxvY2tUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUudHlwZSA/IGZpbmRCbG9ja1R5cGUodHlwZS50eXBlKSA6IHR5cGUubmFtZSA9PT0gXCJibG9ja1wiO1xufVxuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuZnVuY3Rpb24gcmVzb2x2ZUpzVHlwZSh2YWwpIHtcbiAgc3dpdGNoIChvYmplY3RUb1N0cmluZy5jYWxsKHZhbCkpIHtcbiAgICBjYXNlIFwiW29iamVjdCBGdW5jdGlvbl1cIjpcbiAgICAgIHJldHVybiBcImZ1bmN0aW9uXCI7XG4gICAgY2FzZSBcIltvYmplY3QgRGF0ZV1cIjpcbiAgICAgIHJldHVybiBcImRhdGVcIjtcbiAgICBjYXNlIFwiW29iamVjdCBSZWdFeHBdXCI6XG4gICAgICByZXR1cm4gXCJyZWdleHBcIjtcbiAgICBjYXNlIFwiW29iamVjdCBBcmd1bWVudHNdXCI6XG4gICAgICByZXR1cm4gXCJhcmd1bWVudHNcIjtcbiAgICBjYXNlIFwiW29iamVjdCBBcnJheV1cIjpcbiAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgY2FzZSBcIltvYmplY3QgU3RyaW5nXVwiOlxuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH1cbiAgcmV0dXJuIHZhbCA9PT0gbnVsbCA/IFwibnVsbFwiIDogdmFsID09PSB2b2lkIDAgPyBcInVuZGVmaW5lZFwiIDogdmFsICYmIHR5cGVvZiB2YWwgPT0gXCJvYmplY3RcIiAmJiBcIm5vZGVUeXBlXCIgaW4gdmFsICYmIHZhbC5ub2RlVHlwZSA9PT0gMSA/IFwiZWxlbWVudFwiIDogdmFsID09PSBPYmplY3QodmFsKSA/IFwib2JqZWN0XCIgOiB0eXBlb2YgdmFsO1xufVxudmFyIHMgPSB7IDA6IDgyMDMsIDE6IDgyMDQsIDI6IDgyMDUsIDM6IDgyOTAsIDQ6IDgyOTEsIDU6IDgyODgsIDY6IDY1Mjc5LCA3OiA4Mjg5LCA4OiAxMTkxNTUsIDk6IDExOTE1NiwgYTogMTE5MTU3LCBiOiAxMTkxNTgsIGM6IDExOTE1OSwgZDogMTE5MTYwLCBlOiAxMTkxNjEsIGY6IDExOTE2MiB9LCBjID0geyAwOiA4MjAzLCAxOiA4MjA0LCAyOiA4MjA1LCAzOiA2NTI3OSB9O1xubmV3IEFycmF5KDQpLmZpbGwoU3RyaW5nLmZyb21Db2RlUG9pbnQoY1swXSkpLmpvaW4oXCJcIik7XG5PYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoYykubWFwKCh0KSA9PiB0LnJldmVyc2UoKSkpO1xuT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHMpLm1hcCgodCkgPT4gdC5yZXZlcnNlKCkpKTtcbnZhciBTID0gYCR7T2JqZWN0LnZhbHVlcyhzKS5tYXAoKHQpID0+IGBcXFxcdXske3QudG9TdHJpbmcoMTYpfX1gKS5qb2luKFwiXCIpfWAsIGYgPSBuZXcgUmVnRXhwKGBbJHtTfV17NCx9YCwgXCJndVwiKTtcbmZ1bmN0aW9uIF8odCkge1xuICB2YXIgZTtcbiAgcmV0dXJuIHsgY2xlYW5lZDogdC5yZXBsYWNlKGYsIFwiXCIpLCBlbmNvZGVkOiAoKGUgPSB0Lm1hdGNoKGYpKSA9PSBudWxsID8gdm9pZCAwIDogZVswXSkgfHwgXCJcIiB9O1xufVxuZnVuY3Rpb24gTyh0KSB7XG4gIHJldHVybiB0ICYmIEpTT04ucGFyc2UoXyhKU09OLnN0cmluZ2lmeSh0KSkuY2xlYW5lZCk7XG59XG5jb25zdCBQUkVTRVJWRV9XSElURVNQQUNFX1RBR1MgPSBbXCJwcmVcIiwgXCJ0ZXh0YXJlYVwiLCBcImNvZGVcIl0sIEJMT0NLX0RFRkFVTFRfU1RZTEUgPSBcIm5vcm1hbFwiLCBERUZBVUxUX0JMT0NLID0gT2JqZWN0LmZyZWV6ZSh7XG4gIF90eXBlOiBcImJsb2NrXCIsXG4gIG1hcmtEZWZzOiBbXSxcbiAgc3R5bGU6IEJMT0NLX0RFRkFVTFRfU1RZTEVcbn0pLCBERUZBVUxUX1NQQU4gPSBPYmplY3QuZnJlZXplKHtcbiAgX3R5cGU6IFwic3BhblwiLFxuICBtYXJrczogW11cbn0pLCBIVE1MX0JMT0NLX1RBR1MgPSB7XG4gIHA6IERFRkFVTFRfQkxPQ0ssXG4gIGJsb2NrcXVvdGU6IHsgLi4uREVGQVVMVF9CTE9DSywgc3R5bGU6IFwiYmxvY2txdW90ZVwiIH1cbn0sIEhUTUxfU1BBTl9UQUdTID0ge1xuICBzcGFuOiB7IG9iamVjdDogXCJ0ZXh0XCIgfVxufSwgSFRNTF9MSVNUX0NPTlRBSU5FUl9UQUdTID0ge1xuICBvbDogeyBvYmplY3Q6IG51bGwgfSxcbiAgdWw6IHsgb2JqZWN0OiBudWxsIH1cbn0sIEhUTUxfSEVBREVSX1RBR1MgPSB7XG4gIGgxOiB7IC4uLkRFRkFVTFRfQkxPQ0ssIHN0eWxlOiBcImgxXCIgfSxcbiAgaDI6IHsgLi4uREVGQVVMVF9CTE9DSywgc3R5bGU6IFwiaDJcIiB9LFxuICBoMzogeyAuLi5ERUZBVUxUX0JMT0NLLCBzdHlsZTogXCJoM1wiIH0sXG4gIGg0OiB7IC4uLkRFRkFVTFRfQkxPQ0ssIHN0eWxlOiBcImg0XCIgfSxcbiAgaDU6IHsgLi4uREVGQVVMVF9CTE9DSywgc3R5bGU6IFwiaDVcIiB9LFxuICBoNjogeyAuLi5ERUZBVUxUX0JMT0NLLCBzdHlsZTogXCJoNlwiIH1cbn0sIEhUTUxfTUlTQ19UQUdTID0ge1xuICBicjogeyAuLi5ERUZBVUxUX0JMT0NLLCBzdHlsZTogQkxPQ0tfREVGQVVMVF9TVFlMRSB9XG59LCBIVE1MX0RFQ09SQVRPUl9UQUdTID0ge1xuICBiOiBcInN0cm9uZ1wiLFxuICBzdHJvbmc6IFwic3Ryb25nXCIsXG4gIGk6IFwiZW1cIixcbiAgZW06IFwiZW1cIixcbiAgdTogXCJ1bmRlcmxpbmVcIixcbiAgczogXCJzdHJpa2UtdGhyb3VnaFwiLFxuICBzdHJpa2U6IFwic3RyaWtlLXRocm91Z2hcIixcbiAgZGVsOiBcInN0cmlrZS10aHJvdWdoXCIsXG4gIGNvZGU6IFwiY29kZVwiLFxuICBzdXA6IFwic3VwXCIsXG4gIHN1YjogXCJzdWJcIixcbiAgaW5zOiBcImluc1wiLFxuICBtYXJrOiBcIm1hcmtcIixcbiAgc21hbGw6IFwic21hbGxcIlxufSwgSFRNTF9MSVNUX0lURU1fVEFHUyA9IHtcbiAgbGk6IHtcbiAgICAuLi5ERUZBVUxUX0JMT0NLLFxuICAgIHN0eWxlOiBCTE9DS19ERUZBVUxUX1NUWUxFLFxuICAgIGxldmVsOiAxLFxuICAgIGxpc3RJdGVtOiBcImJ1bGxldFwiXG4gIH1cbn0sIEVMRU1FTlRfTUFQID0ge1xuICAuLi5IVE1MX0JMT0NLX1RBR1MsXG4gIC4uLkhUTUxfU1BBTl9UQUdTLFxuICAuLi5IVE1MX0xJU1RfQ09OVEFJTkVSX1RBR1MsXG4gIC4uLkhUTUxfTElTVF9JVEVNX1RBR1MsXG4gIC4uLkhUTUxfSEVBREVSX1RBR1MsXG4gIC4uLkhUTUxfTUlTQ19UQUdTXG59O1xudW5pcShcbiAgT2JqZWN0LnZhbHVlcyhFTEVNRU5UX01BUCkuZmlsdGVyKCh0YWcpID0+IFwic3R5bGVcIiBpbiB0YWcpLm1hcCgodGFnKSA9PiB0YWcuc3R5bGUpXG4pO1xudW5pcShcbiAgT2JqZWN0LnZhbHVlcyhIVE1MX0RFQ09SQVRPUl9UQUdTKVxuKTtcbmZ1bmN0aW9uIGJsb2NrQ29udGVudEZlYXR1cmVzKGJsb2NrQ29udGVudFR5cGUpIHtcbiAgaWYgKCFibG9ja0NvbnRlbnRUeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciAnYmxvY2tDb250ZW50VHlwZScgcmVxdWlyZWRcIik7XG4gIGNvbnN0IGJsb2NrVHlwZSA9IGJsb2NrQ29udGVudFR5cGUub2YuZmluZChmaW5kQmxvY2tUeXBlKTtcbiAgaWYgKCFpc0Jsb2NrU2NoZW1hVHlwZShibG9ja1R5cGUpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIidibG9jaycgdHlwZSBpcyBub3QgZGVmaW5lZCBpbiB0aGlzIHNjaGVtYSAocmVxdWlyZWQpLlwiKTtcbiAgY29uc3Qgb2ZUeXBlID0gYmxvY2tUeXBlLmZpZWxkcy5maW5kKGlzQmxvY2tDaGlsZHJlbk9iamVjdEZpZWxkKT8udHlwZT8ub2Y7XG4gIGlmICghb2ZUeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGBvZmAgZGVjbGFyYXRpb24gZm91bmQgZm9yIGJsb2NrcyBgY2hpbGRyZW5gIGZpZWxkXCIpO1xuICBjb25zdCBzcGFuVHlwZSA9IG9mVHlwZS5maW5kKFxuICAgIChtZW1iZXIpID0+IG1lbWJlci5uYW1lID09PSBcInNwYW5cIlxuICApO1xuICBpZiAoIXNwYW5UeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiTm8gYHNwYW5gIHR5cGUgZm91bmQgaW4gYGJsb2NrYCBzY2hlbWEgdHlwZSBgY2hpbGRyZW5gIGRlZmluaXRpb25cIlxuICAgICk7XG4gIGNvbnN0IGlubGluZU9iamVjdFR5cGVzID0gb2ZUeXBlLmZpbHRlcihcbiAgICAoaW5saW5lVHlwZSkgPT4gaW5saW5lVHlwZS5uYW1lICE9PSBcInNwYW5cIiAmJiBpc09iamVjdFNjaGVtYVR5cGUoaW5saW5lVHlwZSlcbiAgKSwgYmxvY2tPYmplY3RUeXBlcyA9IGJsb2NrQ29udGVudFR5cGUub2YuZmlsdGVyKFxuICAgIChtZW1iZXJUeXBlKSA9PiBtZW1iZXJUeXBlLm5hbWUgIT09IGJsb2NrVHlwZS5uYW1lICYmIGlzT2JqZWN0U2NoZW1hVHlwZShtZW1iZXJUeXBlKVxuICApO1xuICByZXR1cm4ge1xuICAgIHN0eWxlczogcmVzb2x2ZUVuYWJsZWRTdHlsZXMoYmxvY2tUeXBlKSxcbiAgICBkZWNvcmF0b3JzOiByZXNvbHZlRW5hYmxlZERlY29yYXRvcnMoc3BhblR5cGUpLFxuICAgIGFubm90YXRpb25zOiByZXNvbHZlRW5hYmxlZEFubm90YXRpb25UeXBlcyhzcGFuVHlwZSksXG4gICAgbGlzdHM6IHJlc29sdmVFbmFibGVkTGlzdEl0ZW1zKGJsb2NrVHlwZSksXG4gICAgdHlwZXM6IHtcbiAgICAgIGJsb2NrOiBibG9ja0NvbnRlbnRUeXBlLFxuICAgICAgc3Bhbjogc3BhblR5cGUsXG4gICAgICBpbmxpbmVPYmplY3RzOiBpbmxpbmVPYmplY3RUeXBlcyxcbiAgICAgIGJsb2NrT2JqZWN0czogYmxvY2tPYmplY3RUeXBlc1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVFbmFibGVkU3R5bGVzKGJsb2NrVHlwZSkge1xuICBjb25zdCBzdHlsZUZpZWxkID0gYmxvY2tUeXBlLmZpZWxkcy5maW5kKGlzQmxvY2tTdHlsZU9iamVjdEZpZWxkKTtcbiAgaWYgKCFzdHlsZUZpZWxkKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiQSBmaWVsZCB3aXRoIG5hbWUgJ3N0eWxlJyBpcyBub3QgZGVmaW5lZCBpbiB0aGUgYmxvY2sgdHlwZSAocmVxdWlyZWQpLlwiXG4gICAgKTtcbiAgY29uc3QgdGV4dFN0eWxlcyA9IGdldFRpdGxlZExpc3RWYWx1ZXNGcm9tRW51bUxpc3RPcHRpb25zKFxuICAgIHN0eWxlRmllbGQudHlwZS5vcHRpb25zXG4gICk7XG4gIGlmICh0ZXh0U3R5bGVzLmxlbmd0aCA9PT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSBzdHlsZSBmaWVsZHMgbmVlZCBhdCBsZWFzdCBvbmUgc3R5bGUgZGVmaW5lZC4gSS5lOiB7dGl0bGU6ICdOb3JtYWwnLCB2YWx1ZTogJ25vcm1hbCd9LlwiXG4gICAgKTtcbiAgcmV0dXJuIHRleHRTdHlsZXM7XG59XG5mdW5jdGlvbiByZXNvbHZlRW5hYmxlZEFubm90YXRpb25UeXBlcyhzcGFuVHlwZSkge1xuICByZXR1cm4gc3BhblR5cGUuYW5ub3RhdGlvbnMubWFwKChhbm5vdGF0aW9uKSA9PiAoe1xuICAgIHRpdGxlOiBhbm5vdGF0aW9uLnRpdGxlLFxuICAgIHR5cGU6IGFubm90YXRpb24sXG4gICAgdmFsdWU6IGFubm90YXRpb24ubmFtZSxcbiAgICBpY29uOiBhbm5vdGF0aW9uLmljb25cbiAgfSkpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuYWJsZWREZWNvcmF0b3JzKHNwYW5UeXBlKSB7XG4gIHJldHVybiBzcGFuVHlwZS5kZWNvcmF0b3JzO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuYWJsZWRMaXN0SXRlbXMoYmxvY2tUeXBlKSB7XG4gIGNvbnN0IGxpc3RGaWVsZCA9IGJsb2NrVHlwZS5maWVsZHMuZmluZChpc0Jsb2NrTGlzdE9iamVjdEZpZWxkKTtcbiAgaWYgKCFsaXN0RmllbGQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJBIGZpZWxkIHdpdGggbmFtZSAnbGlzdCcgaXMgbm90IGRlZmluZWQgaW4gdGhlIGJsb2NrIHR5cGUgKHJlcXVpcmVkKS5cIlxuICAgICk7XG4gIGNvbnN0IGxpc3RJdGVtcyA9IGdldFRpdGxlZExpc3RWYWx1ZXNGcm9tRW51bUxpc3RPcHRpb25zKFxuICAgIGxpc3RGaWVsZC50eXBlLm9wdGlvbnNcbiAgKTtcbiAgaWYgKCFsaXN0SXRlbXMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxpc3QgZmllbGQgbmVlZCBhdCBsZWFzdCB0byBiZSBhbiBlbXB0eSBhcnJheVwiKTtcbiAgcmV0dXJuIGxpc3RJdGVtcztcbn1cbmZ1bmN0aW9uIGdldFRpdGxlZExpc3RWYWx1ZXNGcm9tRW51bUxpc3RPcHRpb25zKG9wdGlvbnMpIHtcbiAgY29uc3QgbGlzdCA9IG9wdGlvbnMgPyBvcHRpb25zLmxpc3QgOiB2b2lkIDA7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGxpc3QpID8gbGlzdC5tYXAoXG4gICAgKGl0ZW0pID0+IGlzVGl0bGVkTGlzdFZhbHVlKGl0ZW0pID8gaXRlbSA6IHsgdGl0bGU6IGl0ZW0sIHZhbHVlOiBpdGVtIH1cbiAgKSA6IFtdO1xufVxuY29uc3QgX1hQYXRoUmVzdWx0ID0ge1xuICBBTllfVFlQRTogMCxcbiAgTlVNQkVSX1RZUEU6IDEsXG4gIFNUUklOR19UWVBFOiAyLFxuICBCT09MRUFOX1RZUEU6IDMsXG4gIFVOT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEU6IDQsXG4gIE9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFOiA1LFxuICBVTk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFOiA2LFxuICBPUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRTogNyxcbiAgQU5ZX1VOT1JERVJFRF9OT0RFX1RZUEU6IDgsXG4gIEZJUlNUX09SREVSRURfTk9ERV9UWVBFOiA5XG59O1xudmFyIHByZXByb2Nlc3NHRG9jcyA9IChfaHRtbCwgZG9jLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHdoaXRlc3BhY2VPblBhc3RlTW9kZSA9IG9wdGlvbnM/LnVuc3RhYmxlX3doaXRlc3BhY2VPblBhc3RlTW9kZSB8fCBcInByZXNlcnZlXCI7XG4gIGxldCBnRG9jc1Jvb3RPclNpYmxpbmdOb2RlID0gZG9jLmV2YWx1YXRlKFxuICAgICcvLypbQGlkIGFuZCBjb250YWlucyhAaWQsIFwiZG9jcy1pbnRlcm5hbC1ndWlkXCIpXScsXG4gICAgZG9jLFxuICAgIG51bGwsXG4gICAgX1hQYXRoUmVzdWx0Lk9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFLFxuICAgIG51bGxcbiAgKS5pdGVyYXRlTmV4dCgpO1xuICBpZiAoZ0RvY3NSb290T3JTaWJsaW5nTm9kZSkge1xuICAgIGNvbnN0IGlzV3JhcHBlZFJvb3RUYWcgPSB0YWdOYW1lKGdEb2NzUm9vdE9yU2libGluZ05vZGUpID09PSBcImJcIjtcbiAgICBzd2l0Y2ggKGlzV3JhcHBlZFJvb3RUYWcgfHwgKGdEb2NzUm9vdE9yU2libGluZ05vZGUgPSBkb2MuYm9keSksIHdoaXRlc3BhY2VPblBhc3RlTW9kZSkge1xuICAgICAgY2FzZSBcIm5vcm1hbGl6ZVwiOlxuICAgICAgICBub3JtYWxpemVXaGl0ZXNwYWNlKGdEb2NzUm9vdE9yU2libGluZ05vZGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyZW1vdmVcIjpcbiAgICAgICAgcmVtb3ZlQWxsV2hpdGVzcGFjZShnRG9jc1Jvb3RPclNpYmxpbmdOb2RlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBkb2MuZXZhbHVhdGUoXG4gICAgICBcIi8vKlwiLFxuICAgICAgZG9jLFxuICAgICAgbnVsbCxcbiAgICAgIF9YUGF0aFJlc3VsdC5VTk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFLFxuICAgICAgbnVsbFxuICAgICk7XG4gICAgZm9yIChsZXQgaSA9IGNoaWxkTm9kZXMuc25hcHNob3RMZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgZWxtID0gY2hpbGROb2Rlcy5zbmFwc2hvdEl0ZW0oaSk7XG4gICAgICBlbG0/LnNldEF0dHJpYnV0ZShcImRhdGEtaXMtZ29vZ2xlLWRvY3NcIiwgXCJ0cnVlXCIpLCAoZWxtPy5wYXJlbnRFbGVtZW50ID09PSBnRG9jc1Jvb3RPclNpYmxpbmdOb2RlIHx8ICFpc1dyYXBwZWRSb290VGFnICYmIGVsbS5wYXJlbnRFbGVtZW50ID09PSBkb2MuYm9keSkgJiYgKGVsbT8uc2V0QXR0cmlidXRlKFwiZGF0YS1pcy1yb290LW5vZGVcIiwgXCJ0cnVlXCIpLCB0YWdOYW1lKGVsbSkpLCB0YWdOYW1lKGVsbSkgPT09IFwibGlcIiAmJiBlbG0uZmlyc3RDaGlsZCAmJiB0YWdOYW1lKGVsbT8uZmlyc3RDaGlsZCkgPT09IFwiaW1nXCIgJiYgZWxtLnJlbW92ZUNoaWxkKGVsbS5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzV3JhcHBlZFJvb3RUYWcgJiYgZG9jLmJvZHkuZmlyc3RFbGVtZW50Q2hpbGQ/LnJlcGxhY2VXaXRoKFxuICAgICAgLi4uQXJyYXkuZnJvbShnRG9jc1Jvb3RPclNpYmxpbmdOb2RlLmNoaWxkTm9kZXMpXG4gICAgKSwgZG9jO1xuICB9XG4gIHJldHVybiBkb2M7XG59O1xuY29uc3QgdW53YW50ZWRXb3JkRG9jdW1lbnRQYXRocyA9IFtcbiAgXCIvaHRtbC90ZXh0KClcIixcbiAgXCIvaHRtbC9oZWFkL3RleHQoKVwiLFxuICBcIi9odG1sL2JvZHkvdGV4dCgpXCIsXG4gIFwiL2h0bWwvYm9keS91bC90ZXh0KClcIixcbiAgXCIvaHRtbC9ib2R5L29sL3RleHQoKVwiLFxuICBcIi8vY29tbWVudCgpXCIsXG4gIFwiLy9zdHlsZVwiLFxuICBcIi8veG1sXCIsXG4gIFwiLy9zY3JpcHRcIixcbiAgXCIvL21ldGFcIixcbiAgXCIvL2xpbmtcIlxuXTtcbnZhciBwcmVwcm9jZXNzSFRNTCA9IChfaHRtbCwgZG9jKSA9PiB7XG4gIGNvbnN0IGJvZHlUZXh0Tm9kZXMgPSBkb2MuZXZhbHVhdGUoXG4gICAgXCIvaHRtbC9ib2R5L3RleHQoKVwiLFxuICAgIGRvYyxcbiAgICBudWxsLFxuICAgIF9YUGF0aFJlc3VsdC5VTk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFLFxuICAgIG51bGxcbiAgKTtcbiAgZm9yIChsZXQgaSA9IGJvZHlUZXh0Tm9kZXMuc25hcHNob3RMZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IG5vZGUgPSBib2R5VGV4dE5vZGVzLnNuYXBzaG90SXRlbShpKSwgdGV4dCA9IG5vZGUudGV4dENvbnRlbnQgfHwgXCJcIjtcbiAgICBpZiAodGV4dC5yZXBsYWNlKC9bXlxcU1xcbl0rJC9nLCBcIlwiKSkge1xuICAgICAgY29uc3QgbmV3Tm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIG5ld05vZGUuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpKSwgbm9kZS5wYXJlbnROb2RlPy5yZXBsYWNlQ2hpbGQobmV3Tm9kZSwgbm9kZSk7XG4gICAgfSBlbHNlXG4gICAgICBub2RlLnBhcmVudE5vZGU/LnJlbW92ZUNoaWxkKG5vZGUpO1xuICB9XG4gIGNvbnN0IHVud2FudGVkTm9kZXMgPSBkb2MuZXZhbHVhdGUoXG4gICAgdW53YW50ZWRXb3JkRG9jdW1lbnRQYXRocy5qb2luKFwifFwiKSxcbiAgICBkb2MsXG4gICAgbnVsbCxcbiAgICBfWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRSxcbiAgICBudWxsXG4gICk7XG4gIGZvciAobGV0IGkgPSB1bndhbnRlZE5vZGVzLnNuYXBzaG90TGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCB1bndhbnRlZCA9IHVud2FudGVkTm9kZXMuc25hcHNob3RJdGVtKGkpO1xuICAgIHVud2FudGVkICYmIHVud2FudGVkLnBhcmVudE5vZGU/LnJlbW92ZUNoaWxkKHVud2FudGVkKTtcbiAgfVxuICByZXR1cm4gZG9jO1xufSwgcHJlcHJvY2Vzc05vdGlvbiA9IChodG1sLCBkb2MpID0+IHtcbiAgY29uc3QgTk9USU9OX1JFR0VYID0gLzwhLS0gbm90aW9udmM6Lio/LS0+L2c7XG4gIGlmIChodG1sLm1hdGNoKE5PVElPTl9SRUdFWCkpIHtcbiAgICBjb25zdCBjaGlsZE5vZGVzID0gZG9jLmV2YWx1YXRlKFxuICAgICAgXCIvLypcIixcbiAgICAgIGRvYyxcbiAgICAgIG51bGwsXG4gICAgICBfWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRSxcbiAgICAgIG51bGxcbiAgICApO1xuICAgIGZvciAobGV0IGkgPSBjaGlsZE5vZGVzLnNuYXBzaG90TGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICBjaGlsZE5vZGVzLnNuYXBzaG90SXRlbShpKT8uc2V0QXR0cmlidXRlKFwiZGF0YS1pcy1ub3Rpb25cIiwgXCJ0cnVlXCIpO1xuICAgIHJldHVybiBkb2M7XG4gIH1cbiAgcmV0dXJuIGRvYztcbn0sIHByZXByb2Nlc3NXaGl0ZXNwYWNlID0gKF8yLCBkb2MpID0+IHtcbiAgZnVuY3Rpb24gcHJvY2Vzc05vZGUobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBfWFBhdGhSZXN1bHQuQk9PTEVBTl9UWVBFICYmICFQUkVTRVJWRV9XSElURVNQQUNFX1RBR1MuaW5jbHVkZXMoXG4gICAgICBub2RlLnBhcmVudEVsZW1lbnQ/LnRhZ05hbWUudG9Mb3dlckNhc2UoKSB8fCBcIlwiXG4gICAgKSlcbiAgICAgIG5vZGUudGV4dENvbnRlbnQgPSBub2RlLnRleHRDb250ZW50Py5yZXBsYWNlKC9cXHNcXHMrL2csIFwiIFwiKS5yZXBsYWNlKC9bXFxyXFxuXSsvZywgXCIgXCIpIHx8IFwiXCI7XG4gICAgZWxzZVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHByb2Nlc3NOb2RlKG5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHByb2Nlc3NOb2RlKGRvYy5ib2R5KSwgZG9jO1xufTtcbmNvbnN0IFdPUkRfSFRNTF9SRUdFWCA9IC8oY2xhc3M9XCI/TXNvfHN0eWxlPSg/OlwifCcpW15cIl0qP1xcYm1zby18dzpXb3JkRG9jdW1lbnR8PG86XFx3Kz58PFxcL2ZvbnQ+KS8sIHVud2FudGVkUGF0aHMgPSBbXG4gIFwiLy9vOnBcIixcbiAgXCIvL3NwYW5bQHN0eWxlPSdtc28tbGlzdDpJZ25vcmUnXVwiLFxuICBcIi8vc3BhbltAc3R5bGU9J21zby1saXN0OiBJZ25vcmUnXVwiXG5dLCBtYXBwZWRQYXRocyA9IFtcbiAgXCIvL3BbQGNsYXNzPSdNc29Ub2NIZWFkaW5nJ11cIixcbiAgXCIvL3BbQGNsYXNzPSdNc29UaXRsZSddXCIsXG4gIFwiLy9wW0BjbGFzcz0nTXNvVG9hSGVhZGluZyddXCIsXG4gIFwiLy9wW0BjbGFzcz0nTXNvU3VidGl0bGUnXVwiLFxuICBcIi8vc3BhbltAY2xhc3M9J01zb1N1YnRsZUVtcGhhc2lzJ11cIixcbiAgXCIvL3NwYW5bQGNsYXNzPSdNc29JbnRlbnNlRW1waGFzaXMnXVwiXG5dLCBlbGVtZW50TWFwID0ge1xuICBNc29Ub2NIZWFkaW5nOiBbXCJoM1wiXSxcbiAgTXNvVGl0bGU6IFtcImgxXCJdLFxuICBNc29Ub2FIZWFkaW5nOiBbXCJoMlwiXSxcbiAgTXNvU3VidGl0bGU6IFtcImg1XCJdLFxuICBNc29TdWJ0bGVFbXBoYXNpczogW1wic3BhblwiLCBcImVtXCJdLFxuICBNc29JbnRlbnNlRW1waGFzaXM6IFtcInNwYW5cIiwgXCJlbVwiLCBcInN0cm9uZ1wiXVxuICAvLyBSZW1vdmUgY3J1ZnRcbn07XG5mdW5jdGlvbiBpc1dvcmRIdG1sKGh0bWwpIHtcbiAgcmV0dXJuIFdPUkRfSFRNTF9SRUdFWC50ZXN0KGh0bWwpO1xufVxudmFyIHByZXByb2Nlc3NXb3JkID0gKGh0bWwsIGRvYykgPT4ge1xuICBpZiAoIWlzV29yZEh0bWwoaHRtbCkpXG4gICAgcmV0dXJuIGRvYztcbiAgY29uc3QgdW53YW50ZWROb2RlcyA9IGRvYy5ldmFsdWF0ZShcbiAgICB1bndhbnRlZFBhdGhzLmpvaW4oXCJ8XCIpLFxuICAgIGRvYyxcbiAgICAocHJlZml4KSA9PiBwcmVmaXggPT09IFwib1wiID8gXCJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOm9mZmljZTpvZmZpY2VcIiA6IG51bGwsXG4gICAgX1hQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUsXG4gICAgbnVsbFxuICApO1xuICBmb3IgKGxldCBpID0gdW53YW50ZWROb2Rlcy5zbmFwc2hvdExlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgdW53YW50ZWQgPSB1bndhbnRlZE5vZGVzLnNuYXBzaG90SXRlbShpKTtcbiAgICB1bndhbnRlZD8ucGFyZW50Tm9kZSAmJiB1bndhbnRlZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHVud2FudGVkKTtcbiAgfVxuICBjb25zdCBtYXBwZWRFbGVtZW50cyA9IGRvYy5ldmFsdWF0ZShcbiAgICBtYXBwZWRQYXRocy5qb2luKFwifFwiKSxcbiAgICBkb2MsXG4gICAgbnVsbCxcbiAgICBfWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRSxcbiAgICBudWxsXG4gICk7XG4gIGZvciAobGV0IGkgPSBtYXBwZWRFbGVtZW50cy5zbmFwc2hvdExlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgbWFwcGVkRWxtID0gbWFwcGVkRWxlbWVudHMuc25hcHNob3RJdGVtKGkpLCB0YWdzID0gZWxlbWVudE1hcFttYXBwZWRFbG0uY2xhc3NOYW1lXSwgdGV4dCA9IGRvYy5jcmVhdGVUZXh0Tm9kZShtYXBwZWRFbG0udGV4dENvbnRlbnQgfHwgXCJcIik7XG4gICAgaWYgKCF0YWdzKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgcGFyZW50RWxlbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZ3NbMF0pO1xuICAgIGxldCBwYXJlbnQgPSBwYXJlbnRFbGVtZW50LCBjaGlsZCA9IHBhcmVudEVsZW1lbnQ7XG4gICAgdGFncy5zbGljZSgxKS5mb3JFYWNoKCh0YWcpID0+IHtcbiAgICAgIGNoaWxkID0gZG9jLmNyZWF0ZUVsZW1lbnQodGFnKSwgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKSwgcGFyZW50ID0gY2hpbGQ7XG4gICAgfSksIGNoaWxkLmFwcGVuZENoaWxkKHRleHQpLCBtYXBwZWRFbG0/LnBhcmVudE5vZGU/LnJlcGxhY2VDaGlsZChwYXJlbnRFbGVtZW50LCBtYXBwZWRFbG0pO1xuICB9XG4gIHJldHVybiBkb2M7XG59LCBwcmVwcm9jZXNzb3JzID0gW1xuICBwcmVwcm9jZXNzV2hpdGVzcGFjZSxcbiAgcHJlcHJvY2Vzc05vdGlvbixcbiAgcHJlcHJvY2Vzc1dvcmQsXG4gIHByZXByb2Nlc3NHRG9jcyxcbiAgcHJlcHJvY2Vzc0hUTUxcbl07XG5mdW5jdGlvbiBjcmVhdGVSdWxlT3B0aW9ucyhibG9ja0NvbnRlbnRUeXBlKSB7XG4gIGNvbnN0IGZlYXR1cmVzID0gYmxvY2tDb250ZW50RmVhdHVyZXMoYmxvY2tDb250ZW50VHlwZSksIGVuYWJsZWRCbG9ja1N0eWxlcyA9IGZlYXR1cmVzLnN0eWxlcy5tYXAoXG4gICAgKGl0ZW0pID0+IGl0ZW0udmFsdWUgfHwgaXRlbS50aXRsZVxuICApLCBlbmFibGVkU3BhbkRlY29yYXRvcnMgPSBmZWF0dXJlcy5kZWNvcmF0b3JzLm1hcChcbiAgICAoaXRlbSkgPT4gaXRlbS52YWx1ZSB8fCBpdGVtLnRpdGxlXG4gICksIGVuYWJsZWRCbG9ja0Fubm90YXRpb25zID0gZmVhdHVyZXMuYW5ub3RhdGlvbnMubWFwKFxuICAgIChpdGVtKSA9PiBpdGVtLnZhbHVlIHx8IGl0ZW0udGl0bGUgfHwgXCJcIlxuICApLCBlbmFibGVkTGlzdFR5cGVzID0gZmVhdHVyZXMubGlzdHMubWFwKFxuICAgIChpdGVtKSA9PiBpdGVtLnZhbHVlIHx8IGl0ZW0udGl0bGUgfHwgXCJcIlxuICApO1xuICByZXR1cm4ge1xuICAgIGVuYWJsZWRCbG9ja1N0eWxlcyxcbiAgICBlbmFibGVkU3BhbkRlY29yYXRvcnMsXG4gICAgZW5hYmxlZEJsb2NrQW5ub3RhdGlvbnMsXG4gICAgZW5hYmxlZExpc3RUeXBlc1xuICB9O1xufVxuZnVuY3Rpb24gdGFnTmFtZShlbCkge1xuICBpZiAoZWwgJiYgXCJ0YWdOYW1lXCIgaW4gZWwpXG4gICAgcmV0dXJuIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHByZXByb2Nlc3MoaHRtbCwgcGFyc2VIdG1sLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNsZWFuSFRNTCA9IE8oaHRtbCksIGRvYyA9IHBhcnNlSHRtbChub3JtYWxpemVIdG1sQmVmb3JlUHJlcHJvY2VzcyhjbGVhbkhUTUwpKTtcbiAgcmV0dXJuIHByZXByb2Nlc3NvcnMuZm9yRWFjaCgocHJvY2Vzc29yKSA9PiB7XG4gICAgcHJvY2Vzc29yKGNsZWFuSFRNTCwgZG9jLCBvcHRpb25zKTtcbiAgfSksIGRvYztcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUh0bWxCZWZvcmVQcmVwcm9jZXNzKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWwudHJpbSgpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFBhcnNlSHRtbCgpIHtcbiAgaWYgKHJlc29sdmVKc1R5cGUoRE9NUGFyc2VyKSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSBuYXRpdmUgYERPTVBhcnNlcmAgZ2xvYmFsIHdoaWNoIHRoZSBgSHRtbGAgZGVzZXJpYWxpemVyIHVzZXMgYnkgZGVmYXVsdCBpcyBub3QgcHJlc2VudCBpbiB0aGlzIGVudmlyb25tZW50LiBZb3UgbXVzdCBzdXBwbHkgdGhlIGBvcHRpb25zLnBhcnNlSHRtbGAgZnVuY3Rpb24gaW5zdGVhZC5cIlxuICAgICk7XG4gIHJldHVybiAoaHRtbCkgPT4gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhodG1sLCBcInRleHQvaHRtbFwiKTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5OZXN0ZWRCbG9ja3MoYmxvY2tzMikge1xuICBsZXQgZGVwdGggPSAwO1xuICBjb25zdCBmbGF0dGVuZWQgPSBbXSwgdHJhdmVyc2UgPSAobm9kZXMpID0+IHtcbiAgICBjb25zdCB0b1JlbW92ZSA9IFtdO1xuICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIGRlcHRoID09PSAwICYmIGZsYXR0ZW5lZC5wdXNoKG5vZGUpLCBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhub2RlKSAmJiAoZGVwdGggPiAwICYmICh0b1JlbW92ZS5wdXNoKG5vZGUpLCBmbGF0dGVuZWQucHVzaChub2RlKSksIGRlcHRoKyssIHRyYXZlcnNlKG5vZGUuY2hpbGRyZW4pKSwgbm9kZS5fdHlwZSA9PT0gXCJfX2Jsb2NrXCIgJiYgKHRvUmVtb3ZlLnB1c2gobm9kZSksIGZsYXR0ZW5lZC5wdXNoKG5vZGUuYmxvY2spKTtcbiAgICB9KSwgdG9SZW1vdmUuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgbm9kZXMuc3BsaWNlKG5vZGVzLmluZGV4T2Yobm9kZSksIDEpO1xuICAgIH0pLCBkZXB0aC0tO1xuICB9O1xuICByZXR1cm4gdHJhdmVyc2UoYmxvY2tzMiksIGZsYXR0ZW5lZDtcbn1cbmZ1bmN0aW9uIG5leHRTcGFuKGJsb2NrLCBpbmRleCkge1xuICBjb25zdCBuZXh0ID0gYmxvY2suY2hpbGRyZW5baW5kZXggKyAxXTtcbiAgcmV0dXJuIG5leHQgJiYgbmV4dC5fdHlwZSA9PT0gXCJzcGFuXCIgPyBuZXh0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIHByZXZTcGFuKGJsb2NrLCBpbmRleCkge1xuICBjb25zdCBwcmV2ID0gYmxvY2suY2hpbGRyZW5baW5kZXggLSAxXTtcbiAgcmV0dXJuIHByZXYgJiYgcHJldi5fdHlwZSA9PT0gXCJzcGFuXCIgPyBwcmV2IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZUNoYXIodGV4dCkge1xuICByZXR1cm4gW1wiXFx4QTBcIiwgXCIgXCJdLmluY2x1ZGVzKHRleHQpO1xufVxuZnVuY3Rpb24gdHJpbVdoaXRlc3BhY2UoYmxvY2tzMikge1xuICByZXR1cm4gYmxvY2tzMi5mb3JFYWNoKChibG9jaykgPT4ge1xuICAgIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKGJsb2NrKSAmJiBibG9jay5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgIGlmICghaXNNaW5pbWFsU3BhbihjaGlsZCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG5leHRDaGlsZCA9IG5leHRTcGFuKGJsb2NrLCBpbmRleCksIHByZXZDaGlsZCA9IHByZXZTcGFuKGJsb2NrLCBpbmRleCk7XG4gICAgICBpbmRleCA9PT0gMCAmJiAoY2hpbGQudGV4dCA9IGNoaWxkLnRleHQucmVwbGFjZSgvXlteXFxTXFxuXSsvZywgXCJcIikpLCBpbmRleCA9PT0gYmxvY2suY2hpbGRyZW4ubGVuZ3RoIC0gMSAmJiAoY2hpbGQudGV4dCA9IGNoaWxkLnRleHQucmVwbGFjZSgvW15cXFNcXG5dKyQvZywgXCJcIikpLCAvXFxzLy50ZXN0KGNoaWxkLnRleHQuc2xpY2UoTWF0aC5tYXgoMCwgY2hpbGQudGV4dC5sZW5ndGggLSAxKSkpICYmIG5leHRDaGlsZCAmJiBpc01pbmltYWxTcGFuKG5leHRDaGlsZCkgJiYgL1xccy8udGVzdChuZXh0Q2hpbGQudGV4dC5zbGljZSgwLCAxKSkgJiYgKGNoaWxkLnRleHQgPSBjaGlsZC50ZXh0LnJlcGxhY2UoL1teXFxTXFxuXSskL2csIFwiXCIpKSwgL1xccy8udGVzdChjaGlsZC50ZXh0LnNsaWNlKDAsIDEpKSAmJiBwcmV2Q2hpbGQgJiYgaXNNaW5pbWFsU3BhbihwcmV2Q2hpbGQpICYmIC9cXHMvLnRlc3QocHJldkNoaWxkLnRleHQuc2xpY2UoTWF0aC5tYXgoMCwgcHJldkNoaWxkLnRleHQubGVuZ3RoIC0gMSkpKSAmJiAoY2hpbGQudGV4dCA9IGNoaWxkLnRleHQucmVwbGFjZSgvXlteXFxTXFxuXSsvZywgXCJcIikpLCBjaGlsZC50ZXh0IHx8IGJsb2NrLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSksIHByZXZDaGlsZCAmJiBpc0VxdWFsKHByZXZDaGlsZC5tYXJrcywgY2hpbGQubWFya3MpICYmIGlzV2hpdGVTcGFjZUNoYXIoY2hpbGQudGV4dCkgPyAocHJldkNoaWxkLnRleHQgKz0gXCIgXCIsIGJsb2NrLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSkpIDogbmV4dENoaWxkICYmIGlzRXF1YWwobmV4dENoaWxkLm1hcmtzLCBjaGlsZC5tYXJrcykgJiYgaXNXaGl0ZVNwYWNlQ2hhcihjaGlsZC50ZXh0KSAmJiAobmV4dENoaWxkLnRleHQgPSBgICR7bmV4dENoaWxkLnRleHR9YCwgYmxvY2suY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKSk7XG4gICAgfSk7XG4gIH0pLCBibG9ja3MyO1xufVxuZnVuY3Rpb24gZW5zdXJlUm9vdElzQmxvY2tzKGJsb2NrczIpIHtcbiAgcmV0dXJuIGJsb2NrczIucmVkdWNlKChtZW1vLCBub2RlLCBpLCBvcmlnaW5hbCkgPT4ge1xuICAgIGlmIChub2RlLl90eXBlID09PSBcImJsb2NrXCIpXG4gICAgICByZXR1cm4gbWVtby5wdXNoKG5vZGUpLCBtZW1vO1xuICAgIGlmIChub2RlLl90eXBlID09PSBcIl9fYmxvY2tcIilcbiAgICAgIHJldHVybiBtZW1vLnB1c2gobm9kZS5ibG9jayksIG1lbW87XG4gICAgY29uc3QgbGFzdEJsb2NrID0gbWVtb1ttZW1vLmxlbmd0aCAtIDFdO1xuICAgIGlmIChpID4gMCAmJiAhaXNQb3J0YWJsZVRleHRUZXh0QmxvY2sob3JpZ2luYWxbaSAtIDFdKSAmJiBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhsYXN0QmxvY2spKVxuICAgICAgcmV0dXJuIGxhc3RCbG9jay5jaGlsZHJlbi5wdXNoKG5vZGUpLCBtZW1vO1xuICAgIGNvbnN0IGJsb2NrID0ge1xuICAgICAgLi4uREVGQVVMVF9CTE9DSyxcbiAgICAgIGNoaWxkcmVuOiBbbm9kZV1cbiAgICB9O1xuICAgIHJldHVybiBtZW1vLnB1c2goYmxvY2spLCBtZW1vO1xuICB9LCBbXSk7XG59XG5mdW5jdGlvbiBpc05vZGVMaXN0KG5vZGUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChub2RlKSA9PT0gXCJbb2JqZWN0IE5vZGVMaXN0XVwiO1xufVxuZnVuY3Rpb24gaXNNaW5pbWFsU3Bhbihub2RlKSB7XG4gIHJldHVybiBub2RlLl90eXBlID09PSBcInNwYW5cIjtcbn1cbmZ1bmN0aW9uIGlzTWluaW1hbEJsb2NrKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3R5cGUgPT09IFwiYmxvY2tcIjtcbn1cbmZ1bmN0aW9uIGlzUGxhY2Vob2xkZXJEZWNvcmF0b3Iobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdHlwZSA9PT0gXCJfX2RlY29yYXRvclwiO1xufVxuZnVuY3Rpb24gaXNQbGFjZWhvbGRlckFubm90YXRpb24obm9kZSkge1xuICByZXR1cm4gbm9kZS5fdHlwZSA9PT0gXCJfX2Fubm90YXRpb25cIjtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAxO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplV2hpdGVzcGFjZShyb290Tm9kZSkge1xuICBsZXQgZW1wdHlCbG9ja0NvdW50ID0gMCwgbGFzdFBhcmVudCA9IG51bGw7XG4gIGNvbnN0IG5vZGVzVG9SZW1vdmUgPSBbXTtcbiAgZm9yIChsZXQgY2hpbGQgPSByb290Tm9kZS5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgIGlmICghaXNFbGVtZW50KGNoaWxkKSkge1xuICAgICAgbm9ybWFsaXplV2hpdGVzcGFjZShjaGlsZCksIGVtcHR5QmxvY2tDb3VudCA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZWxtID0gY2hpbGQ7XG4gICAgaXNXaGl0ZXNwYWNlQmxvY2soZWxtKSA/IChsYXN0UGFyZW50ICYmIGVsbS5wYXJlbnRFbGVtZW50ID09PSBsYXN0UGFyZW50ID8gKGVtcHR5QmxvY2tDb3VudCsrLCBlbXB0eUJsb2NrQ291bnQgPiAxICYmIG5vZGVzVG9SZW1vdmUucHVzaChlbG0pKSA6IGVtcHR5QmxvY2tDb3VudCA9IDEsIGxhc3RQYXJlbnQgPSBlbG0ucGFyZW50RWxlbWVudCkgOiAobm9ybWFsaXplV2hpdGVzcGFjZShjaGlsZCksIGVtcHR5QmxvY2tDb3VudCA9IDApO1xuICB9XG4gIG5vZGVzVG9SZW1vdmUuZm9yRWFjaCgobm9kZSkgPT4gbm9kZS5wYXJlbnRFbGVtZW50Py5yZW1vdmVDaGlsZChub2RlKSk7XG59XG5mdW5jdGlvbiByZW1vdmVBbGxXaGl0ZXNwYWNlKHJvb3ROb2RlKSB7XG4gIGNvbnN0IG5vZGVzVG9SZW1vdmUgPSBbXTtcbiAgZnVuY3Rpb24gY29sbGVjdE5vZGVzVG9SZW1vdmUoY3VycmVudE5vZGUpIHtcbiAgICBpZiAoaXNFbGVtZW50KGN1cnJlbnROb2RlKSkge1xuICAgICAgY29uc3QgZWxtID0gY3VycmVudE5vZGU7XG4gICAgICBpZiAodGFnTmFtZShlbG0pID09PSBcImJyXCIgJiYgKHRhZ05hbWUoZWxtLm5leHRFbGVtZW50U2libGluZykgPT09IFwicFwiIHx8IHRhZ05hbWUoZWxtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpID09PSBcInBcIikpIHtcbiAgICAgICAgbm9kZXNUb1JlbW92ZS5wdXNoKGVsbSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgodGFnTmFtZShlbG0pID09PSBcInBcIiB8fCB0YWdOYW1lKGVsbSkgPT09IFwiYnJcIikgJiYgZWxtPy5maXJzdENoaWxkPy50ZXh0Q29udGVudD8udHJpbSgpID09PSBcIlwiKSB7XG4gICAgICAgIG5vZGVzVG9SZW1vdmUucHVzaChlbG0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBjaGlsZCA9IGVsbS5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZylcbiAgICAgICAgY29sbGVjdE5vZGVzVG9SZW1vdmUoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBjb2xsZWN0Tm9kZXNUb1JlbW92ZShyb290Tm9kZSksIG5vZGVzVG9SZW1vdmUuZm9yRWFjaCgobm9kZSkgPT4gbm9kZS5wYXJlbnRFbGVtZW50Py5yZW1vdmVDaGlsZChub2RlKSk7XG59XG5mdW5jdGlvbiBpc1doaXRlc3BhY2VCbG9jayhlbG0pIHtcbiAgcmV0dXJuIFtcInBcIiwgXCJiclwiXS5pbmNsdWRlcyh0YWdOYW1lKGVsbSkgfHwgXCJcIikgJiYgIWVsbS50ZXh0Q29udGVudD8udHJpbSgpO1xufVxuY29uc3QgTElTVF9DT05UQUlORVJfVEFHUyA9IE9iamVjdC5rZXlzKEhUTUxfTElTVF9DT05UQUlORVJfVEFHUyk7XG5mdW5jdGlvbiBpc0VtcGhhc2lzJDEoZWwpIHtcbiAgY29uc3Qgc3R5bGUgPSBpc0VsZW1lbnQoZWwpICYmIGVsLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICByZXR1cm4gL2ZvbnQtc3R5bGVcXHMqOlxccyppdGFsaWMvLnRlc3Qoc3R5bGUgfHwgXCJcIik7XG59XG5mdW5jdGlvbiBpc1N0cm9uZyQxKGVsKSB7XG4gIGNvbnN0IHN0eWxlID0gaXNFbGVtZW50KGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgcmV0dXJuIC9mb250LXdlaWdodFxccyo6XFxzKjcwMC8udGVzdChzdHlsZSB8fCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzVW5kZXJsaW5lJDEoZWwpIHtcbiAgaWYgKCFpc0VsZW1lbnQoZWwpIHx8IHRhZ05hbWUoZWwucGFyZW50Tm9kZSkgPT09IFwiYVwiKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3Qgc3R5bGUgPSBpc0VsZW1lbnQoZWwpICYmIGVsLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICByZXR1cm4gL3RleHQtZGVjb3JhdGlvblxccyo6XFxzKnVuZGVybGluZS8udGVzdChzdHlsZSB8fCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWtldGhyb3VnaChlbCkge1xuICBjb25zdCBzdHlsZSA9IGlzRWxlbWVudChlbCkgJiYgZWwuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gIHJldHVybiAvdGV4dC1kZWNvcmF0aW9uXFxzKjpcXHMqKD86LipsaW5lLXRocm91Z2guKjspLy50ZXN0KHN0eWxlIHx8IFwiXCIpO1xufVxuZnVuY3Rpb24gaXNHb29nbGVEb2NzKGVsKSB7XG4gIHJldHVybiBpc0VsZW1lbnQoZWwpICYmICEhZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1pcy1nb29nbGUtZG9jc1wiKTtcbn1cbmZ1bmN0aW9uIGlzUm9vdE5vZGUoZWwpIHtcbiAgcmV0dXJuIGlzRWxlbWVudChlbCkgJiYgISFlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWlzLXJvb3Qtbm9kZVwiKTtcbn1cbmZ1bmN0aW9uIGdldExpc3RJdGVtU3R5bGUkMShlbCkge1xuICBjb25zdCBwYXJlbnRUYWcgPSB0YWdOYW1lKGVsLnBhcmVudE5vZGUpO1xuICBpZiAoIShwYXJlbnRUYWcgJiYgIUxJU1RfQ09OVEFJTkVSX1RBR1MuaW5jbHVkZXMocGFyZW50VGFnKSkpXG4gICAgcmV0dXJuIHRhZ05hbWUoZWwucGFyZW50Tm9kZSkgPT09IFwidWxcIiA/IFwiYnVsbGV0XCIgOiBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gZ2V0TGlzdEl0ZW1MZXZlbCQxKGVsKSB7XG4gIGxldCBsZXZlbCA9IDA7XG4gIGlmICh0YWdOYW1lKGVsKSA9PT0gXCJsaVwiKSB7XG4gICAgbGV0IHBhcmVudE5vZGUgPSBlbC5wYXJlbnROb2RlO1xuICAgIGZvciAoOyBwYXJlbnROb2RlOyApIHtcbiAgICAgIGNvbnN0IHBhcmVudFRhZyA9IHRhZ05hbWUocGFyZW50Tm9kZSk7XG4gICAgICBwYXJlbnRUYWcgJiYgTElTVF9DT05UQUlORVJfVEFHUy5pbmNsdWRlcyhwYXJlbnRUYWcpICYmIGxldmVsKyssIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9IGVsc2VcbiAgICBsZXZlbCA9IDE7XG4gIHJldHVybiBsZXZlbDtcbn1cbmNvbnN0IGJsb2NrcyA9IHtcbiAgLi4uSFRNTF9CTE9DS19UQUdTLFxuICAuLi5IVE1MX0hFQURFUl9UQUdTXG59O1xuZnVuY3Rpb24gZ2V0QmxvY2tTdHlsZShlbCwgZW5hYmxlZEJsb2NrU3R5bGVzKSB7XG4gIGNvbnN0IGNoaWxkVGFnID0gdGFnTmFtZShlbC5maXJzdENoaWxkKSwgYmxvY2sgPSBjaGlsZFRhZyAmJiBibG9ja3NbY2hpbGRUYWddO1xuICByZXR1cm4gYmxvY2sgJiYgZW5hYmxlZEJsb2NrU3R5bGVzLmluY2x1ZGVzKGJsb2NrLnN0eWxlKSA/IGJsb2NrLnN0eWxlIDogQkxPQ0tfREVGQVVMVF9TVFlMRTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdEb2NzUnVsZXMoX2Jsb2NrQ29udGVudFR5cGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCkge1xuICAgICAgICBpZiAoaXNFbGVtZW50KGVsKSAmJiB0YWdOYW1lKGVsKSA9PT0gXCJzcGFuXCIgJiYgaXNHb29nbGVEb2NzKGVsKSkge1xuICAgICAgICAgIGNvbnN0IHNwYW4gPSB7XG4gICAgICAgICAgICAuLi5ERUZBVUxUX1NQQU4sXG4gICAgICAgICAgICBtYXJrczogW10sXG4gICAgICAgICAgICB0ZXh0OiBlbC50ZXh0Q29udGVudFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGlzU3Ryb25nJDEoZWwpICYmIHNwYW4ubWFya3MucHVzaChcInN0cm9uZ1wiKSwgaXNVbmRlcmxpbmUkMShlbCkgJiYgc3Bhbi5tYXJrcy5wdXNoKFwidW5kZXJsaW5lXCIpLCBpc1N0cmlrZXRocm91Z2goZWwpICYmIHNwYW4ubWFya3MucHVzaChcInN0cmlrZS10aHJvdWdoXCIpLCBpc0VtcGhhc2lzJDEoZWwpICYmIHNwYW4ubWFya3MucHVzaChcImVtXCIpLCBzcGFuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCwgbmV4dCkge1xuICAgICAgICBpZiAodGFnTmFtZShlbCkgPT09IFwibGlcIiAmJiBpc0dvb2dsZURvY3MoZWwpKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5ERUZBVUxUX0JMT0NLLFxuICAgICAgICAgICAgbGlzdEl0ZW06IGdldExpc3RJdGVtU3R5bGUkMShlbCksXG4gICAgICAgICAgICBsZXZlbDogZ2V0TGlzdEl0ZW1MZXZlbCQxKGVsKSxcbiAgICAgICAgICAgIHN0eWxlOiBnZXRCbG9ja1N0eWxlKGVsLCBvcHRpb25zLmVuYWJsZWRCbG9ja1N0eWxlcyksXG4gICAgICAgICAgICBjaGlsZHJlbjogbmV4dChlbC5maXJzdENoaWxkPy5jaGlsZE5vZGVzIHx8IFtdKVxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCkge1xuICAgICAgICBpZiAodGFnTmFtZShlbCkgPT09IFwiYnJcIiAmJiBpc0dvb2dsZURvY3MoZWwpICYmIGlzRWxlbWVudChlbCkgJiYgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYXBwbGUtaW50ZXJjaGFuZ2UtbmV3bGluZVwiKSlcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uREVGQVVMVF9TUEFOLFxuICAgICAgICAgICAgdGV4dDogXCJcIlxuICAgICAgICAgIH07XG4gICAgICAgIGlmICh0YWdOYW1lKGVsKSA9PT0gXCJiclwiICYmIGlzR29vZ2xlRG9jcyhlbCkgJiYgaXNFbGVtZW50KGVsKSAmJiBlbD8ucGFyZW50Tm9kZT8udGV4dENvbnRlbnQgPT09IFwiXCIpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLkRFRkFVTFRfU1BBTixcbiAgICAgICAgICAgIHRleHQ6IFwiXCJcbiAgICAgICAgICB9O1xuICAgICAgICBpZiAodGFnTmFtZShlbCkgPT09IFwiYnJcIiAmJiBpc0dvb2dsZURvY3MoZWwpICYmIGlzRWxlbWVudChlbCkgJiYgaXNSb290Tm9kZShlbCkpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLkRFRkFVTFRfU1BBTixcbiAgICAgICAgICAgIHRleHQ6IFwiXCJcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgXTtcbn1cbmZ1bmN0aW9uIGtleUdlbmVyYXRvcigpIHtcbiAgcmV0dXJuIHJhbmRvbUtleSgxMik7XG59XG5mdW5jdGlvbiB3aGF0d2dSTkcobGVuZ3RoID0gMTYpIHtcbiAgY29uc3Qgcm5kczggPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KSwgcm5kczg7XG59XG5jb25zdCBieXRlVG9IZXggPSBbXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpXG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMjU2KS50b1N0cmluZygxNikuc2xpY2UoMSk7XG5mdW5jdGlvbiByYW5kb21LZXkobGVuZ3RoKSB7XG4gIHJldHVybiB3aGF0d2dSTkcobGVuZ3RoKS5yZWR1Y2UoKHN0ciwgbikgPT4gc3RyICsgYnl0ZVRvSGV4W25dLCBcIlwiKS5zbGljZSgwLCBsZW5ndGgpO1xufVxuY29uc3Qgd2hpdGVzcGFjZVRleHROb2RlUnVsZSA9IHtcbiAgZGVzZXJpYWxpemUobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVOYW1lID09PSBcIiN0ZXh0XCIgJiYgaXNXaGl0ZXNwYWNlVGV4dE5vZGUobm9kZSkgPyB7XG4gICAgICAuLi5ERUZBVUxUX1NQQU4sXG4gICAgICBtYXJrczogW10sXG4gICAgICB0ZXh0OiAobm9kZS50ZXh0Q29udGVudCA/PyBcIlwiKS5yZXBsYWNlKC9cXHNcXHMrL2csIFwiIFwiKVxuICAgIH0gOiB2b2lkIDA7XG4gIH1cbn07XG5mdW5jdGlvbiBpc1doaXRlc3BhY2VUZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiAobm9kZS5ub2RlVHlwZSA9PT0gMyAmJiAobm9kZS50ZXh0Q29udGVudCB8fCBcIlwiKS5yZXBsYWNlKC9bXFxyXFxuXS9nLCBcIiBcIikucmVwbGFjZSgvXFxzXFxzKy9nLCBcIiBcIikgPT09IFwiIFwiICYmIG5vZGUubmV4dFNpYmxpbmcgJiYgbm9kZS5uZXh0U2libGluZy5ub2RlVHlwZSAhPT0gMyAmJiBub2RlLnByZXZpb3VzU2libGluZyAmJiBub2RlLnByZXZpb3VzU2libGluZy5ub2RlVHlwZSAhPT0gMyB8fCBub2RlLnRleHRDb250ZW50ICE9PSBcIiBcIikgJiYgdGFnTmFtZShub2RlLnBhcmVudE5vZGUpICE9PSBcImJvZHlcIjtcbn1cbmZ1bmN0aW9uIHJlc29sdmVMaXN0SXRlbShsaXN0Tm9kZVRhZ05hbWUsIGVuYWJsZWRMaXN0VHlwZXMpIHtcbiAgaWYgKGxpc3ROb2RlVGFnTmFtZSA9PT0gXCJ1bFwiICYmIGVuYWJsZWRMaXN0VHlwZXMuaW5jbHVkZXMoXCJidWxsZXRcIikpXG4gICAgcmV0dXJuIFwiYnVsbGV0XCI7XG4gIGlmIChsaXN0Tm9kZVRhZ05hbWUgPT09IFwib2xcIiAmJiBlbmFibGVkTGlzdFR5cGVzLmluY2x1ZGVzKFwibnVtYmVyXCIpKVxuICAgIHJldHVybiBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gY3JlYXRlSFRNTFJ1bGVzKF9ibG9ja0NvbnRlbnRUeXBlLCBvcHRpb25zKSB7XG4gIHJldHVybiBbXG4gICAgd2hpdGVzcGFjZVRleHROb2RlUnVsZSxcbiAgICB7XG4gICAgICAvLyBQcmUgZWxlbWVudFxuICAgICAgZGVzZXJpYWxpemUoZWwpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpICE9PSBcInByZVwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaXNDb2RlRW5hYmxlZCA9IG9wdGlvbnMuZW5hYmxlZEJsb2NrU3R5bGVzLmluY2x1ZGVzKFwiY29kZVwiKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBfdHlwZTogXCJibG9ja1wiLFxuICAgICAgICAgIHN0eWxlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgIG1hcmtEZWZzOiBbXSxcbiAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAuLi5ERUZBVUxUX1NQQU4sXG4gICAgICAgICAgICAgIG1hcmtzOiBpc0NvZGVFbmFibGVkID8gW1wiY29kZVwiXSA6IFtdLFxuICAgICAgICAgICAgICB0ZXh0OiBlbC50ZXh0Q29udGVudCB8fCBcIlwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQmxvY2txdW90ZSBlbGVtZW50XG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpICE9PSBcImJsb2NrcXVvdGVcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGJsb2NrczIgPSB7XG4gICAgICAgICAgLi4uSFRNTF9CTE9DS19UQUdTLFxuICAgICAgICAgIC4uLkhUTUxfSEVBREVSX1RBR1NcbiAgICAgICAgfTtcbiAgICAgICAgZGVsZXRlIGJsb2NrczIuYmxvY2txdW90ZTtcbiAgICAgICAgY29uc3Qgbm9uQmxvY2txdW90ZUJsb2NrcyA9IE9iamVjdC5rZXlzKGJsb2NrczIpLCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICByZXR1cm4gZWwuY2hpbGROb2Rlcy5mb3JFYWNoKChub2RlLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChlbC5vd25lckRvY3VtZW50KVxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9uQmxvY2txdW90ZUJsb2Nrcy5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgbm9kZS5sb2NhbE5hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICBjb25zdCBzcGFuID0gZWwub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSwgcHJldmlvdXNDaGlsZCA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICBwcmV2aW91c0NoaWxkICYmIHByZXZpb3VzQ2hpbGQubm9kZVR5cGUgPT09IDMgJiYgcHJldmlvdXNDaGlsZC50ZXh0Q29udGVudD8udHJpbSgpICYmIHNwYW4uYXBwZW5kQ2hpbGQoZWwub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcclwiKSksIG5vZGUuY2hpbGROb2Rlcy5mb3JFYWNoKChjbikgPT4ge1xuICAgICAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoY24uY2xvbmVOb2RlKCEwKSk7XG4gICAgICAgICAgICAgIH0pLCBpbmRleCAhPT0gZWwuY2hpbGROb2Rlcy5sZW5ndGggJiYgc3Bhbi5hcHBlbmRDaGlsZChlbC5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxyXCIpKSwgY2hpbGRyZW4ucHVzaChzcGFuKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICB9KSwge1xuICAgICAgICAgIF90eXBlOiBcImJsb2NrXCIsXG4gICAgICAgICAgc3R5bGU6IFwiYmxvY2txdW90ZVwiLFxuICAgICAgICAgIG1hcmtEZWZzOiBbXSxcbiAgICAgICAgICBjaGlsZHJlbjogbmV4dChjaGlsZHJlbilcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEJsb2NrIGVsZW1lbnRzXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgY29uc3QgYmxvY2tzMiA9IHtcbiAgICAgICAgICAuLi5IVE1MX0JMT0NLX1RBR1MsXG4gICAgICAgICAgLi4uSFRNTF9IRUFERVJfVEFHU1xuICAgICAgICB9LCB0YWcgPSB0YWdOYW1lKGVsKTtcbiAgICAgICAgbGV0IGJsb2NrID0gdGFnID8gYmxvY2tzMlt0YWddIDogdm9pZCAwO1xuICAgICAgICBpZiAoYmxvY2spXG4gICAgICAgICAgcmV0dXJuIGVsLnBhcmVudE5vZGUgJiYgdGFnTmFtZShlbC5wYXJlbnROb2RlKSA9PT0gXCJsaVwiID8gbmV4dChlbC5jaGlsZE5vZGVzKSA6IChvcHRpb25zLmVuYWJsZWRCbG9ja1N0eWxlcy5pbmNsdWRlcyhibG9jay5zdHlsZSkgfHwgKGJsb2NrID0gREVGQVVMVF9CTE9DSyksIHtcbiAgICAgICAgICAgIC4uLmJsb2NrLFxuICAgICAgICAgICAgY2hpbGRyZW46IG5leHQoZWwuY2hpbGROb2RlcylcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIElnbm9yZSBzcGFuIHRhZ3NcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCwgbmV4dCkge1xuICAgICAgICBjb25zdCB0YWcgPSB0YWdOYW1lKGVsKTtcbiAgICAgICAgaWYgKCEoIXRhZyB8fCAhKHRhZyBpbiBIVE1MX1NQQU5fVEFHUykpKVxuICAgICAgICAgIHJldHVybiBuZXh0KGVsLmNoaWxkTm9kZXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gSWdub3JlIGRpdiB0YWdzXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpID09PSBcImRpdlwiKVxuICAgICAgICAgIHJldHVybiBuZXh0KGVsLmNoaWxkTm9kZXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gSWdub3JlIGxpc3QgY29udGFpbmVyc1xuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsLCBuZXh0KSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IHRhZ05hbWUoZWwpO1xuICAgICAgICBpZiAoISghdGFnIHx8ICEodGFnIGluIEhUTUxfTElTVF9DT05UQUlORVJfVEFHUykpKVxuICAgICAgICAgIHJldHVybiBuZXh0KGVsLmNoaWxkTm9kZXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gRGVhbCB3aXRoIGJyJ3NcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCkge1xuICAgICAgICBpZiAodGFnTmFtZShlbCkgPT09IFwiYnJcIilcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uREVGQVVMVF9TUEFOLFxuICAgICAgICAgICAgdGV4dDogYFxuYFxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBEZWFsIHdpdGggbGlzdCBpdGVtc1xuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsLCBuZXh0LCBibG9jaykge1xuICAgICAgICBjb25zdCB0YWcgPSB0YWdOYW1lKGVsKSwgbGlzdEl0ZW0gPSB0YWcgPyBIVE1MX0xJU1RfSVRFTV9UQUdTW3RhZ10gOiB2b2lkIDAsIHBhcmVudFRhZyA9IHRhZ05hbWUoZWwucGFyZW50Tm9kZSkgfHwgXCJcIjtcbiAgICAgICAgaWYgKCFsaXN0SXRlbSB8fCAhZWwucGFyZW50Tm9kZSB8fCAhSFRNTF9MSVNUX0NPTlRBSU5FUl9UQUdTW3BhcmVudFRhZ10pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBlbmFibGVkTGlzdEl0ZW0gPSByZXNvbHZlTGlzdEl0ZW0oXG4gICAgICAgICAgcGFyZW50VGFnLFxuICAgICAgICAgIG9wdGlvbnMuZW5hYmxlZExpc3RUeXBlc1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW5hYmxlZExpc3RJdGVtID8gKGxpc3RJdGVtLmxpc3RJdGVtID0gZW5hYmxlZExpc3RJdGVtLCB7XG4gICAgICAgICAgLi4ubGlzdEl0ZW0sXG4gICAgICAgICAgY2hpbGRyZW46IG5leHQoZWwuY2hpbGROb2RlcylcbiAgICAgICAgfSkgOiBibG9jayh7IF90eXBlOiBcImJsb2NrXCIsIGNoaWxkcmVuOiBuZXh0KGVsLmNoaWxkTm9kZXMpIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gRGVhbCB3aXRoIGRlY29yYXRvcnMgLSB0aGlzIGlzIGEgbGltaXRlZCBzZXQgb2Yga25vd24gaHRtbCBlbGVtZW50cyB0aGF0IHdlIGtub3cgaG93IHRvIGRlc2VyaWFsaXplXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgY29uc3QgZGVjb3JhdG9yID0gSFRNTF9ERUNPUkFUT1JfVEFHU1t0YWdOYW1lKGVsKSB8fCBcIlwiXTtcbiAgICAgICAgaWYgKCEoIWRlY29yYXRvciB8fCAhb3B0aW9ucy5lbmFibGVkU3BhbkRlY29yYXRvcnMuaW5jbHVkZXMoZGVjb3JhdG9yKSkpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcIl9fZGVjb3JhdG9yXCIsXG4gICAgICAgICAgICBuYW1lOiBkZWNvcmF0b3IsXG4gICAgICAgICAgICBjaGlsZHJlbjogbmV4dChlbC5jaGlsZE5vZGVzKVxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGh5cGVybGlua3MsIGFkZCBhbm5vdGF0aW9uIChpZiBhbGxvd2VkIGJ5IHNjaGVtYSksXG4gICAgLy8gSWYgbm90IHN1cHBvcnRlZCBqdXN0IHdyaXRlIG91dCB0aGUgbGluayB0ZXh0IGFuZCBocmVmIGluIHBsYWluIHRleHQuXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpICE9PSBcImFcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGxpbmtFbmFibGVkID0gb3B0aW9ucy5lbmFibGVkQmxvY2tBbm5vdGF0aW9ucy5pbmNsdWRlcyhcImxpbmtcIiksIGhyZWYgPSBpc0VsZW1lbnQoZWwpICYmIGVsLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICAgIGlmICghaHJlZilcbiAgICAgICAgICByZXR1cm4gbmV4dChlbC5jaGlsZE5vZGVzKTtcbiAgICAgICAgbGV0IG1hcmtEZWY7XG4gICAgICAgIHJldHVybiBsaW5rRW5hYmxlZCA/IChtYXJrRGVmID0ge1xuICAgICAgICAgIF9rZXk6IG9wdGlvbnMua2V5R2VuZXJhdG9yID8gb3B0aW9ucy5rZXlHZW5lcmF0b3IoKSA6IGtleUdlbmVyYXRvcigpLFxuICAgICAgICAgIF90eXBlOiBcImxpbmtcIixcbiAgICAgICAgICBocmVmXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBfdHlwZTogXCJfX2Fubm90YXRpb25cIixcbiAgICAgICAgICBtYXJrRGVmLFxuICAgICAgICAgIGNoaWxkcmVuOiBuZXh0KGVsLmNoaWxkTm9kZXMpXG4gICAgICAgIH0pIDogZWwuYXBwZW5kQ2hpbGQoZWwub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShgICgke2hyZWZ9KWApKSAmJiBuZXh0KGVsLmNoaWxkTm9kZXMpO1xuICAgICAgfVxuICAgIH1cbiAgXTtcbn1cbmZ1bmN0aW9uIGlzRW1waGFzaXMoZWwpIHtcbiAgY29uc3Qgc3R5bGUgPSBpc0VsZW1lbnQoZWwpICYmIGVsLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICByZXR1cm4gL2ZvbnQtc3R5bGU6aXRhbGljLy50ZXN0KHN0eWxlIHx8IFwiXCIpO1xufVxuZnVuY3Rpb24gaXNTdHJvbmcoZWwpIHtcbiAgY29uc3Qgc3R5bGUgPSBpc0VsZW1lbnQoZWwpICYmIGVsLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICByZXR1cm4gL2ZvbnQtd2VpZ2h0OjcwMC8udGVzdChzdHlsZSB8fCBcIlwiKSB8fCAvZm9udC13ZWlnaHQ6NjAwLy50ZXN0KHN0eWxlIHx8IFwiXCIpO1xufVxuZnVuY3Rpb24gaXNVbmRlcmxpbmUoZWwpIHtcbiAgY29uc3Qgc3R5bGUgPSBpc0VsZW1lbnQoZWwpICYmIGVsLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICByZXR1cm4gL3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmUvLnRlc3Qoc3R5bGUgfHwgXCJcIik7XG59XG5mdW5jdGlvbiBpc05vdGlvbihlbCkge1xuICByZXR1cm4gaXNFbGVtZW50KGVsKSAmJiAhIWVsLmdldEF0dHJpYnV0ZShcImRhdGEtaXMtbm90aW9uXCIpO1xufVxuZnVuY3Rpb24gY3JlYXRlTm90aW9uUnVsZXMoX2Jsb2NrQ29udGVudFR5cGUpIHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCkge1xuICAgICAgICBpZiAoaXNFbGVtZW50KGVsKSAmJiB0YWdOYW1lKGVsKSA9PT0gXCJzcGFuXCIgJiYgaXNOb3Rpb24oZWwpKSB7XG4gICAgICAgICAgY29uc3Qgc3BhbiA9IHtcbiAgICAgICAgICAgIC4uLkRFRkFVTFRfU1BBTixcbiAgICAgICAgICAgIG1hcmtzOiBbXSxcbiAgICAgICAgICAgIHRleHQ6IGVsLnRleHRDb250ZW50XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gaXNTdHJvbmcoZWwpICYmIHNwYW4ubWFya3MucHVzaChcInN0cm9uZ1wiKSwgaXNVbmRlcmxpbmUoZWwpICYmIHNwYW4ubWFya3MucHVzaChcInVuZGVybGluZVwiKSwgaXNFbXBoYXNpcyhlbCkgJiYgc3Bhbi5tYXJrcy5wdXNoKFwiZW1cIiksIHNwYW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBnZXRMaXN0SXRlbVN0eWxlKGVsKSB7XG4gIGNvbnN0IHN0eWxlID0gaXNFbGVtZW50KGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgaWYgKHN0eWxlICYmIHN0eWxlLm1hdGNoKC9sZm9cXGQrLykpXG4gICAgcmV0dXJuIHN0eWxlLm1hdGNoKFwibGZvMVwiKSA/IFwiYnVsbGV0XCIgOiBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gZ2V0TGlzdEl0ZW1MZXZlbChlbCkge1xuICBjb25zdCBzdHlsZSA9IGlzRWxlbWVudChlbCkgJiYgZWwuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gIGlmICghc3R5bGUpXG4gICAgcmV0dXJuO1xuICBjb25zdCBsZXZlbE1hdGNoID0gc3R5bGUubWF0Y2goL2xldmVsXFxkKy8pO1xuICBpZiAoIWxldmVsTWF0Y2gpXG4gICAgcmV0dXJuO1xuICBjb25zdCBbbGV2ZWxdID0gbGV2ZWxNYXRjaFswXS5tYXRjaCgvXFxkLykgfHwgW107XG4gIHJldHVybiAobGV2ZWwgPyBOdW1iZXIucGFyc2VJbnQobGV2ZWwsIDEwKSA6IDEpIHx8IDE7XG59XG5mdW5jdGlvbiBpc1dvcmRMaXN0RWxlbWVudChlbCkge1xuICByZXR1cm4gaXNFbGVtZW50KGVsKSAmJiBlbC5jbGFzc05hbWUgPyBlbC5jbGFzc05hbWUgPT09IFwiTXNvTGlzdFBhcmFncmFwaEN4U3BGaXJzdFwiIHx8IGVsLmNsYXNzTmFtZSA9PT0gXCJNc29MaXN0UGFyYWdyYXBoQ3hTcE1pZGRsZVwiIHx8IGVsLmNsYXNzTmFtZSA9PT0gXCJNc29MaXN0UGFyYWdyYXBoQ3hTcExhc3RcIiA6ICExO1xufVxuZnVuY3Rpb24gY3JlYXRlV29yZFJ1bGVzKCkge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsLCBuZXh0KSB7XG4gICAgICAgIGlmICh0YWdOYW1lKGVsKSA9PT0gXCJwXCIgJiYgaXNXb3JkTGlzdEVsZW1lbnQoZWwpKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5ERUZBVUxUX0JMT0NLLFxuICAgICAgICAgICAgbGlzdEl0ZW06IGdldExpc3RJdGVtU3R5bGUoZWwpLFxuICAgICAgICAgICAgbGV2ZWw6IGdldExpc3RJdGVtTGV2ZWwoZWwpLFxuICAgICAgICAgICAgc3R5bGU6IEJMT0NLX0RFRkFVTFRfU1RZTEUsXG4gICAgICAgICAgICBjaGlsZHJlbjogbmV4dChlbC5jaGlsZE5vZGVzKVxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICBdO1xufVxuZnVuY3Rpb24gY3JlYXRlUnVsZXMoYmxvY2tDb250ZW50VHlwZSwgb3B0aW9ucykge1xuICByZXR1cm4gW1xuICAgIC4uLmNyZWF0ZVdvcmRSdWxlcygpLFxuICAgIC4uLmNyZWF0ZU5vdGlvblJ1bGVzKCksXG4gICAgLi4uY3JlYXRlR0RvY3NSdWxlcyhibG9ja0NvbnRlbnRUeXBlLCBvcHRpb25zKSxcbiAgICAuLi5jcmVhdGVIVE1MUnVsZXMoYmxvY2tDb250ZW50VHlwZSwgb3B0aW9ucylcbiAgXTtcbn1cbmNsYXNzIEh0bWxEZXNlcmlhbGl6ZXIge1xuICBibG9ja0NvbnRlbnRUeXBlO1xuICBydWxlcztcbiAgcGFyc2VIdG1sO1xuICBfbWFya0RlZnMgPSBbXTtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzZXJpYWxpemVyIHJlc3BlY3RpbmcgYSBTYW5pdHkgYmxvY2sgY29udGVudCB0eXBlJ3Mgc2NoZW1hXG4gICAqXG4gICAqIEBwYXJhbSBibG9ja0NvbnRlbnRUeXBlIC0gU2NoZW1hIHR5cGUgZm9yIGFycmF5IGNvbnRhaW5pbmcgX2F0IGxlYXN0XyBhIGJsb2NrIGNoaWxkIHR5cGVcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgZGVzZXJpYWxpemF0aW9uIHByb2Nlc3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKGJsb2NrQ29udGVudFR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcnVsZXMgPSBbXSwgdW5zdGFibGVfd2hpdGVzcGFjZU9uUGFzdGVNb2RlID0gXCJwcmVzZXJ2ZVwiIH0gPSBvcHRpb25zO1xuICAgIGlmICghYmxvY2tDb250ZW50VHlwZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciAnYmxvY2tDb250ZW50VHlwZScgaXMgcmVxdWlyZWRcIik7XG4gICAgY29uc3Qgc3RhbmRhcmRSdWxlcyA9IGNyZWF0ZVJ1bGVzKGJsb2NrQ29udGVudFR5cGUsIHtcbiAgICAgIC4uLmNyZWF0ZVJ1bGVPcHRpb25zKGJsb2NrQ29udGVudFR5cGUpLFxuICAgICAga2V5R2VuZXJhdG9yOiBvcHRpb25zLmtleUdlbmVyYXRvclxuICAgIH0pO1xuICAgIHRoaXMucnVsZXMgPSBbLi4ucnVsZXMsIC4uLnN0YW5kYXJkUnVsZXNdO1xuICAgIGNvbnN0IHBhcnNlSHRtbCA9IG9wdGlvbnMucGFyc2VIdG1sIHx8IGRlZmF1bHRQYXJzZUh0bWwoKTtcbiAgICB0aGlzLmJsb2NrQ29udGVudFR5cGUgPSBibG9ja0NvbnRlbnRUeXBlLCB0aGlzLnBhcnNlSHRtbCA9IChodG1sKSA9PiBwcmVwcm9jZXNzKGh0bWwsIHBhcnNlSHRtbCwgeyB1bnN0YWJsZV93aGl0ZXNwYWNlT25QYXN0ZU1vZGUgfSkuYm9keTtcbiAgfVxuICAvKipcbiAgICogRGVzZXJpYWxpemUgSFRNTC5cbiAgICpcbiAgICogQHBhcmFtIGh0bWwgLSBUaGUgSFRNTCB0byBkZXNlcmlhbGl6ZSwgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybnMgQXJyYXkgb2YgYmxvY2tzIC0gZWl0aGVyIHBvcnRhYmxlIHRleHQgYmxvY2tzIG9yIG90aGVyIGFsbG93ZWQgYmxvY2tzXG4gICAqL1xuICBkZXNlcmlhbGl6ZSA9IChodG1sKSA9PiB7XG4gICAgdGhpcy5fbWFya0RlZnMgPSBbXTtcbiAgICBjb25zdCB7IHBhcnNlSHRtbCB9ID0gdGhpcywgZnJhZ21lbnQgPSBwYXJzZUh0bWwoaHRtbCksIGNoaWxkcmVuID0gQXJyYXkuZnJvbShmcmFnbWVudC5jaGlsZE5vZGVzKSwgYmxvY2tzMiA9IHRyaW1XaGl0ZXNwYWNlKFxuICAgICAgZmxhdHRlbk5lc3RlZEJsb2NrcyhcbiAgICAgICAgZW5zdXJlUm9vdElzQmxvY2tzKHRoaXMuZGVzZXJpYWxpemVFbGVtZW50cyhjaGlsZHJlbikpXG4gICAgICApXG4gICAgKTtcbiAgICB0aGlzLl9tYXJrRGVmcy5sZW5ndGggPiAwICYmIGJsb2NrczIuZmlsdGVyKFxuICAgICAgKGJsb2NrKSA9PiBibG9jay5fdHlwZSA9PT0gXCJibG9ja1wiXG4gICAgKS5mb3JFYWNoKChibG9jaykgPT4ge1xuICAgICAgYmxvY2subWFya0RlZnMgPSBibG9jay5tYXJrRGVmcyB8fCBbXSwgYmxvY2subWFya0RlZnMgPSBibG9jay5tYXJrRGVmcy5jb25jYXQoXG4gICAgICAgIHRoaXMuX21hcmtEZWZzLmZpbHRlcigoZGVmKSA9PiBmbGF0dGVuKFxuICAgICAgICAgIGJsb2NrLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNoaWxkLm1hcmtzIHx8IFtdKVxuICAgICAgICApLmluY2x1ZGVzKGRlZi5fa2V5KSlcbiAgICAgICk7XG4gICAgfSk7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuYmxvY2tDb250ZW50VHlwZS5vZi5maW5kKGZpbmRCbG9ja1R5cGUpO1xuICAgIHJldHVybiB0eXBlID8gYmxvY2tzMi5tYXAoKGJsb2NrKSA9PiAoYmxvY2suX3R5cGUgPT09IFwiYmxvY2tcIiAmJiAoYmxvY2suX3R5cGUgPSB0eXBlLm5hbWUpLCBibG9jaykpIDogYmxvY2tzMjtcbiAgfTtcbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGFuIGFycmF5IG9mIERPTSBlbGVtZW50cy5cbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnRzIC0gQXJyYXkgb2YgRE9NIGVsZW1lbnRzIHRvIGRlc2VyaWFsaXplXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBkZXNlcmlhbGl6ZUVsZW1lbnRzID0gKGVsZW1lbnRzID0gW10pID0+IHtcbiAgICBsZXQgbm9kZXMgPSBbXTtcbiAgICByZXR1cm4gZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgbm9kZXMgPSBub2Rlcy5jb25jYXQodGhpcy5kZXNlcmlhbGl6ZUVsZW1lbnQoZWxlbWVudCkpO1xuICAgIH0pLCBub2RlcztcbiAgfTtcbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGEgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnQgLSBEZXNlcmlhbGl6ZSBhIERPTSBlbGVtZW50XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBkZXNlcmlhbGl6ZUVsZW1lbnQgPSAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IG5leHQgPSAoZWxlbWVudHMpID0+IHtcbiAgICAgIGlmIChpc05vZGVMaXN0KGVsZW1lbnRzKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVFbGVtZW50cyhBcnJheS5mcm9tKGVsZW1lbnRzKSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50cykpXG4gICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplRWxlbWVudHMoZWxlbWVudHMpO1xuICAgICAgaWYgKGVsZW1lbnRzKVxuICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZUVsZW1lbnQoZWxlbWVudHMpO1xuICAgIH0sIGJsb2NrID0gKHByb3BzKSA9PiAoe1xuICAgICAgX3R5cGU6IFwiX19ibG9ja1wiLFxuICAgICAgYmxvY2s6IHByb3BzXG4gICAgfSk7XG4gICAgbGV0IG5vZGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBydWxlID0gdGhpcy5ydWxlc1tpXTtcbiAgICAgIGlmICghcnVsZS5kZXNlcmlhbGl6ZSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCByZXQgPSBydWxlLmRlc2VyaWFsaXplKGVsZW1lbnQsIG5leHQsIGJsb2NrKSwgdHlwZSA9IHJlc29sdmVKc1R5cGUocmV0KTtcbiAgICAgIGlmICh0eXBlICE9PSBcImFycmF5XCIgJiYgdHlwZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlICE9PSBcIm51bGxcIiAmJiB0eXBlICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEEgcnVsZSByZXR1cm5lZCBhbiBpbnZhbGlkIGRlc2VyaWFsaXplZCByZXByZXNlbnRhdGlvbjogXCIke25vZGV9XCIuYFxuICAgICAgICApO1xuICAgICAgaWYgKHJldCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAocmV0ID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVzZXJpYWxpemVyIHJ1bGUgcmV0dXJuZWQgYG51bGxgXCIpO1xuICAgICAgICAgIEFycmF5LmlzQXJyYXkocmV0KSA/IG5vZGUgPSByZXQgOiBpc1BsYWNlaG9sZGVyRGVjb3JhdG9yKHJldCkgPyBub2RlID0gdGhpcy5kZXNlcmlhbGl6ZURlY29yYXRvcihyZXQpIDogaXNQbGFjZWhvbGRlckFubm90YXRpb24ocmV0KSA/IG5vZGUgPSB0aGlzLmRlc2VyaWFsaXplQW5ub3RhdGlvbihyZXQpIDogbm9kZSA9IHJldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0ICYmICFBcnJheS5pc0FycmF5KHJldCkgJiYgaXNNaW5pbWFsQmxvY2socmV0KSAmJiBcImxpc3RJdGVtXCIgaW4gcmV0KSB7XG4gICAgICAgICAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZT8ucGFyZW50Tm9kZTtcbiAgICAgICAgICBmb3IgKDsgcGFyZW50ICYmIHRhZ05hbWUocGFyZW50KSA9PT0gXCJsaVwiOyApXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZT8ucGFyZW50Tm9kZSwgcmV0LmxldmVsID0gcmV0LmxldmVsID8gcmV0LmxldmVsICsgMSA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0ICYmICFBcnJheS5pc0FycmF5KHJldCkgJiYgaXNNaW5pbWFsQmxvY2socmV0KSAmJiByZXQuc3R5bGUgPT09IFwiYmxvY2txdW90ZVwiICYmIHJldC5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICBpc01pbmltYWxTcGFuKGNoaWxkKSAmJiBjaGlsZC50ZXh0ID09PSBcIlxcclwiICYmIChjaGlsZC50ZXh0ID0gYFxuYCwgKGluZGV4ID09PSAwIHx8IGluZGV4ID09PSByZXQuY2hpbGRyZW4ubGVuZ3RoIC0gMSkgJiYgcmV0LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlIHx8IG5leHQoZWxlbWVudC5jaGlsZE5vZGVzKSB8fCBbXTtcbiAgfTtcbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGEgYF9fZGVjb3JhdG9yYCB0eXBlXG4gICAqIChhbiBpbnRlcm5hbCBtYWRlIHVwIHR5cGUgdG8gcHJvY2VzcyBkZWNvcmF0b3JzIGV4Y2x1c2l2ZWx5KVxuICAgKlxuICAgKiBAcGFyYW0gZGVjb3JhdG9yIC1cbiAgICogQHJldHVybnMgYXJyYXkgb2YgLi4uXG4gICAqL1xuICBkZXNlcmlhbGl6ZURlY29yYXRvciA9IChkZWNvcmF0b3IpID0+IHtcbiAgICBjb25zdCB7IG5hbWUgfSA9IGRlY29yYXRvciwgYXBwbHlEZWNvcmF0b3IgPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKGlzUGxhY2Vob2xkZXJEZWNvcmF0b3Iobm9kZSkpXG4gICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplRGVjb3JhdG9yKG5vZGUpO1xuICAgICAgaWYgKGlzTWluaW1hbFNwYW4obm9kZSkpXG4gICAgICAgIG5vZGUubWFya3MgPSBub2RlLm1hcmtzIHx8IFtdLCBub2RlLnRleHQudHJpbSgpICYmIG5vZGUubWFya3MudW5zaGlmdChuYW1lKTtcbiAgICAgIGVsc2UgaWYgKFwiY2hpbGRyZW5cIiBpbiBub2RlICYmIEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBub2RlO1xuICAgICAgICBibG9jay5jaGlsZHJlbiA9IGJsb2NrLmNoaWxkcmVuLm1hcChhcHBseURlY29yYXRvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIHJldHVybiBkZWNvcmF0b3IuY2hpbGRyZW4ucmVkdWNlKChjaGlsZHJlbiwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgcmV0ID0gYXBwbHlEZWNvcmF0b3Iobm9kZSk7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShyZXQpID8gY2hpbGRyZW4uY29uY2F0KHJldCkgOiAoY2hpbGRyZW4ucHVzaChyZXQpLCBjaGlsZHJlbik7XG4gICAgfSwgW10pO1xuICB9O1xuICAvKipcbiAgICogRGVzZXJpYWxpemUgYSBgX19hbm5vdGF0aW9uYCBvYmplY3QuXG4gICAqIChhbiBpbnRlcm5hbCBtYWRlIHVwIHR5cGUgdG8gcHJvY2VzcyBhbm5vdGF0aW9ucyBleGNsdXNpdmVseSlcbiAgICpcbiAgICogQHBhcmFtIGFubm90YXRpb24gLVxuICAgKiBAcmV0dXJucyBBcnJheSBvZi4uLlxuICAgKi9cbiAgZGVzZXJpYWxpemVBbm5vdGF0aW9uID0gKGFubm90YXRpb24pID0+IHtcbiAgICBjb25zdCB7IG1hcmtEZWYgfSA9IGFubm90YXRpb247XG4gICAgdGhpcy5fbWFya0RlZnMucHVzaChtYXJrRGVmKTtcbiAgICBjb25zdCBhcHBseUFubm90YXRpb24gPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKGlzUGxhY2Vob2xkZXJBbm5vdGF0aW9uKG5vZGUpKVxuICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZUFubm90YXRpb24obm9kZSk7XG4gICAgICBpZiAoaXNNaW5pbWFsU3Bhbihub2RlKSlcbiAgICAgICAgbm9kZS5tYXJrcyA9IG5vZGUubWFya3MgfHwgW10sIG5vZGUudGV4dC50cmltKCkgJiYgbm9kZS5tYXJrcy51bnNoaWZ0KG1hcmtEZWYuX2tleSk7XG4gICAgICBlbHNlIGlmIChcImNoaWxkcmVuXCIgaW4gbm9kZSAmJiBBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gbm9kZTtcbiAgICAgICAgYmxvY2suY2hpbGRyZW4gPSBibG9jay5jaGlsZHJlbi5tYXAoYXBwbHlBbm5vdGF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgcmV0dXJuIGFubm90YXRpb24uY2hpbGRyZW4ucmVkdWNlKChjaGlsZHJlbiwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgcmV0ID0gYXBwbHlBbm5vdGF0aW9uKG5vZGUpO1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmV0KSA/IGNoaWxkcmVuLmNvbmNhdChyZXQpIDogKGNoaWxkcmVuLnB1c2gocmV0KSwgY2hpbGRyZW4pO1xuICAgIH0sIFtdKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJsb2NrKG5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAobm9kZS5fdHlwZSAhPT0gKG9wdGlvbnMuYmxvY2tUeXBlTmFtZSB8fCBcImJsb2NrXCIpKVxuICAgIHJldHVybiBcIl9rZXlcIiBpbiBub2RlID8gbm9kZSA6IHtcbiAgICAgIC4uLm5vZGUsXG4gICAgICBfa2V5OiBvcHRpb25zLmtleUdlbmVyYXRvciA/IG9wdGlvbnMua2V5R2VuZXJhdG9yKCkgOiBrZXlHZW5lcmF0b3IoKVxuICAgIH07XG4gIGNvbnN0IGJsb2NrID0ge1xuICAgIF9rZXk6IG9wdGlvbnMua2V5R2VuZXJhdG9yID8gb3B0aW9ucy5rZXlHZW5lcmF0b3IoKSA6IGtleUdlbmVyYXRvcigpLFxuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBtYXJrRGVmczogW10sXG4gICAgLi4ubm9kZVxuICB9LCBsYXN0Q2hpbGQgPSBibG9jay5jaGlsZHJlbltibG9jay5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgaWYgKCFsYXN0Q2hpbGQpXG4gICAgcmV0dXJuIGJsb2NrLmNoaWxkcmVuID0gW1xuICAgICAge1xuICAgICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICAgIF9rZXk6IG9wdGlvbnMua2V5R2VuZXJhdG9yID8gb3B0aW9ucy5rZXlHZW5lcmF0b3IoKSA6IGtleUdlbmVyYXRvcigpLFxuICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICBtYXJrczogW11cbiAgICAgIH1cbiAgICBdLCBibG9jaztcbiAgY29uc3QgdXNlZE1hcmtEZWZzID0gW10sIGFsbG93ZWREZWNvcmF0b3JzID0gb3B0aW9ucy5hbGxvd2VkRGVjb3JhdG9ycyAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMuYWxsb3dlZERlY29yYXRvcnMpID8gb3B0aW9ucy5hbGxvd2VkRGVjb3JhdG9ycyA6ICExO1xuICByZXR1cm4gYmxvY2suY2hpbGRyZW4gPSBibG9jay5jaGlsZHJlbi5yZWR1Y2UoXG4gICAgKGFjYywgY2hpbGQpID0+IHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQ2hpbGQgPSBhY2NbYWNjLmxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuIHByZXZpb3VzQ2hpbGQgJiYgaXNQb3J0YWJsZVRleHRTcGFuKGNoaWxkKSAmJiBpc1BvcnRhYmxlVGV4dFNwYW4ocHJldmlvdXNDaGlsZCkgJiYgaXNFcXVhbChwcmV2aW91c0NoaWxkLm1hcmtzLCBjaGlsZC5tYXJrcykgPyAobGFzdENoaWxkICYmIGxhc3RDaGlsZCA9PT0gY2hpbGQgJiYgY2hpbGQudGV4dCA9PT0gXCJcIiAmJiBibG9jay5jaGlsZHJlbi5sZW5ndGggPiAxIHx8IChwcmV2aW91c0NoaWxkLnRleHQgKz0gY2hpbGQudGV4dCksIGFjYykgOiAoYWNjLnB1c2goY2hpbGQpLCBhY2MpO1xuICAgIH0sXG4gICAgW11cbiAgKS5tYXAoKGNoaWxkKSA9PiB7XG4gICAgaWYgKCFjaGlsZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgY2hpbGRcIik7XG4gICAgcmV0dXJuIGNoaWxkLl9rZXkgPSBvcHRpb25zLmtleUdlbmVyYXRvciA/IG9wdGlvbnMua2V5R2VuZXJhdG9yKCkgOiBrZXlHZW5lcmF0b3IoKSwgaXNQb3J0YWJsZVRleHRTcGFuKGNoaWxkKSAmJiAoY2hpbGQubWFya3MgPyBhbGxvd2VkRGVjb3JhdG9ycyAmJiAoY2hpbGQubWFya3MgPSBjaGlsZC5tYXJrcy5maWx0ZXIoKG1hcmspID0+IHtcbiAgICAgIGNvbnN0IGlzQWxsb3dlZCA9IGFsbG93ZWREZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspLCBpc1VzZWQgPSBibG9jay5tYXJrRGVmcz8uc29tZSgoZGVmKSA9PiBkZWYuX2tleSA9PT0gbWFyayk7XG4gICAgICByZXR1cm4gaXNBbGxvd2VkIHx8IGlzVXNlZDtcbiAgICB9KSkgOiBjaGlsZC5tYXJrcyA9IFtdLCB1c2VkTWFya0RlZnMucHVzaCguLi5jaGlsZC5tYXJrcykpLCBjaGlsZDtcbiAgfSksIGJsb2NrLm1hcmtEZWZzID0gKGJsb2NrLm1hcmtEZWZzIHx8IFtdKS5maWx0ZXIoXG4gICAgKG1hcmtEZWYpID0+IHVzZWRNYXJrRGVmcy5pbmNsdWRlcyhtYXJrRGVmLl9rZXkpXG4gICksIGJsb2NrO1xufVxuZnVuY3Rpb24gaHRtbFRvQmxvY2tzKGh0bWwsIGJsb2NrQ29udGVudFR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gbmV3IEh0bWxEZXNlcmlhbGl6ZXIoYmxvY2tDb250ZW50VHlwZSwgb3B0aW9ucykuZGVzZXJpYWxpemUoaHRtbCkubWFwKChibG9jaykgPT4gbm9ybWFsaXplQmxvY2soYmxvY2ssIHsga2V5R2VuZXJhdG9yOiBvcHRpb25zLmtleUdlbmVyYXRvciB9KSk7XG59XG5mdW5jdGlvbiBnZXRCbG9ja0NvbnRlbnRGZWF0dXJlcyhibG9ja0NvbnRlbnRUeXBlKSB7XG4gIHJldHVybiBibG9ja0NvbnRlbnRGZWF0dXJlcyhibG9ja0NvbnRlbnRUeXBlKTtcbn1cbmV4cG9ydCB7XG4gIGdldEJsb2NrQ29udGVudEZlYXR1cmVzLFxuICBodG1sVG9CbG9ja3MsXG4gIG5vcm1hbGl6ZUJsb2NrLFxuICByYW5kb21LZXlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/block-tools/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/behavior.core.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/behavior.core.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   coreBehaviors: () => (/* binding */ coreBehaviors),\n/* harmony export */   defineBehavior: () => (/* binding */ defineBehavior),\n/* harmony export */   isCustomBehaviorEvent: () => (/* binding */ isCustomBehaviorEvent),\n/* harmony export */   isHotkey: () => (/* binding */ isHotkey),\n/* harmony export */   raise: () => (/* binding */ raise)\n/* harmony export */ });\n/* harmony import */ var _selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selector.is-at-the-start-of-block.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-at-the-start-of-block.js\");\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var _util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.slice-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\");\n\n\n\nfunction isCustomBehaviorEvent(event) {\n  return event.type.startsWith(\"custom.\");\n}\nfunction raise(event) {\n  return {\n    type: \"raise\",\n    event\n  };\n}\nfunction defineBehavior(behavior) {\n  return behavior;\n}\nconst addAnnotationOnCollapsedSelection = {\n  on: \"annotation.add\",\n  guard: ({\n    snapshot\n  }) => {\n    if (!(0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)(snapshot))\n      return !1;\n    const caretWordSelection = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getCaretWordSelection)(snapshot);\n    return !caretWordSelection || !(0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionExpanded)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: caretWordSelection\n      }\n    }) ? !1 : {\n      caretWordSelection\n    };\n  },\n  actions: [({\n    event\n  }, {\n    caretWordSelection\n  }) => [raise({\n    type: \"select\",\n    selection: caretWordSelection\n  }), raise({\n    type: \"annotation.add\",\n    annotation: event.annotation\n  })]]\n}, coreAnnotationBehaviors = {\n  addAnnotationOnCollapsedSelection\n}, IS_MAC = typeof window < \"u\" && /Mac|iPod|iPhone|iPad/.test(window.navigator.userAgent), modifiers = {\n  alt: \"altKey\",\n  control: \"ctrlKey\",\n  meta: \"metaKey\",\n  shift: \"shiftKey\"\n}, aliases = {\n  add: \"+\",\n  break: \"pause\",\n  cmd: \"meta\",\n  command: \"meta\",\n  ctl: \"control\",\n  ctrl: \"control\",\n  del: \"delete\",\n  down: \"arrowdown\",\n  esc: \"escape\",\n  ins: \"insert\",\n  left: \"arrowleft\",\n  mod: IS_MAC ? \"meta\" : \"control\",\n  opt: \"alt\",\n  option: \"alt\",\n  return: \"enter\",\n  right: \"arrowright\",\n  space: \" \",\n  spacebar: \" \",\n  up: \"arrowup\",\n  win: \"meta\",\n  windows: \"meta\"\n}, keyCodes = {\n  backspace: 8,\n  tab: 9,\n  enter: 13,\n  shift: 16,\n  control: 17,\n  alt: 18,\n  pause: 19,\n  capslock: 20,\n  escape: 27,\n  \" \": 32,\n  pageup: 33,\n  pagedown: 34,\n  end: 35,\n  home: 36,\n  arrowleft: 37,\n  arrowup: 38,\n  arrowright: 39,\n  arrowdown: 40,\n  insert: 45,\n  delete: 46,\n  meta: 91,\n  numlock: 144,\n  scrolllock: 145,\n  \";\": 186,\n  \"=\": 187,\n  \",\": 188,\n  \"-\": 189,\n  \".\": 190,\n  \"/\": 191,\n  \"`\": 192,\n  \"[\": 219,\n  \"\\\\\": 220,\n  \"]\": 221,\n  \"'\": 222,\n  f1: 112,\n  f2: 113,\n  f3: 114,\n  f4: 115,\n  f5: 116,\n  f6: 117,\n  f7: 118,\n  f8: 119,\n  f9: 120,\n  f10: 121,\n  f11: 122,\n  f12: 123,\n  f13: 124,\n  f14: 125,\n  f15: 126,\n  f16: 127,\n  f17: 128,\n  f18: 129,\n  f19: 130,\n  f20: 131\n};\nfunction isHotkey(hotkey, event) {\n  return compareHotkey(parseHotkey(hotkey), event);\n}\nfunction parseHotkey(hotkey) {\n  const parsedHotkey = {\n    altKey: !1,\n    ctrlKey: !1,\n    metaKey: !1,\n    shiftKey: !1\n  }, hotkeySegments = hotkey.replace(\"++\", \"+add\").split(\"+\");\n  for (const rawHotkeySegment of hotkeySegments) {\n    const optional = rawHotkeySegment.endsWith(\"?\") && rawHotkeySegment.length > 1, hotkeySegment = optional ? rawHotkeySegment.slice(0, -1) : rawHotkeySegment, keyName = toKeyName(hotkeySegment), modifier = modifiers[keyName], alias = aliases[hotkeySegment], code = keyCodes[keyName];\n    if (hotkeySegment.length > 1 && modifier === void 0 && alias === void 0 && code === void 0)\n      throw new TypeError(`Unknown modifier: \"${hotkeySegment}\"`);\n    (hotkeySegments.length === 1 || modifier === void 0) && (parsedHotkey.key = keyName, parsedHotkey.keyCode = toKeyCode(hotkeySegment)), modifier !== void 0 && (parsedHotkey[modifier] = optional ? null : !0);\n  }\n  return parsedHotkey;\n}\nfunction compareHotkey(parsedHotkey, event) {\n  return (parsedHotkey.altKey == null || parsedHotkey.altKey === event.altKey) && (parsedHotkey.ctrlKey == null || parsedHotkey.ctrlKey === event.ctrlKey) && (parsedHotkey.metaKey == null || parsedHotkey.metaKey === event.metaKey) && (parsedHotkey.shiftKey == null || parsedHotkey.shiftKey === event.shiftKey) ? parsedHotkey.keyCode !== void 0 && event.keyCode !== void 0 ? parsedHotkey.keyCode === 91 && event.keyCode === 93 ? !0 : parsedHotkey.keyCode === event.keyCode : parsedHotkey.keyCode === event.keyCode || parsedHotkey.key === event.key.toLowerCase() : !1;\n}\nfunction toKeyCode(name) {\n  const keyName = toKeyName(name);\n  return keyCodes[keyName] ?? keyName.toUpperCase().charCodeAt(0);\n}\nfunction toKeyName(name) {\n  const keyName = name.toLowerCase();\n  return aliases[keyName] ?? keyName;\n}\nconst arrowDownOnLonelyBlockObject = {\n  on: \"key.down\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const isArrowDown = isHotkey(\"ArrowDown\", event.keyboardEvent), focusBlockObject = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getFocusBlockObject)(snapshot), nextBlock = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getNextBlock)(snapshot);\n    return isArrowDown && focusBlockObject && !nextBlock;\n  },\n  actions: [() => [raise({\n    type: \"insert.text block\",\n    placement: \"after\"\n  })]]\n}, arrowUpOnLonelyBlockObject = {\n  on: \"key.down\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const isArrowUp = isHotkey(\"ArrowUp\", event.keyboardEvent), focusBlockObject = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getFocusBlockObject)(snapshot), previousBlock = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getPreviousBlock)(snapshot);\n    return isArrowUp && focusBlockObject && !previousBlock;\n  },\n  actions: [() => [raise({\n    type: \"insert.text block\",\n    placement: \"before\"\n  }), raise({\n    type: \"select.previous block\"\n  })]]\n}, breakingBlockObject = {\n  on: \"insert.break\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusBlockObject = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getFocusBlockObject)(snapshot);\n    return (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)(snapshot) && focusBlockObject !== void 0;\n  },\n  actions: [() => [raise({\n    type: \"insert.text block\",\n    placement: \"after\"\n  })]]\n}, deletingEmptyTextBlockAfterBlockObject = {\n  on: \"delete.backward\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusTextBlock = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getFocusTextBlock)(snapshot), selectionCollapsed = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)(snapshot), previousBlock = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getPreviousBlock)(snapshot);\n    return !focusTextBlock || !selectionCollapsed || !previousBlock ? !1 : (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__.isEmptyTextBlock)(focusTextBlock.node) && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_2__.isPortableTextTextBlock)(previousBlock.node) ? {\n      focusTextBlock,\n      previousBlock\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock,\n    previousBlock\n  }) => [raise({\n    type: \"delete.block\",\n    blockPath: focusTextBlock.path\n  }), raise({\n    type: \"select\",\n    selection: {\n      anchor: {\n        path: previousBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: previousBlock.path,\n        offset: 0\n      }\n    }\n  })]]\n}, deletingEmptyTextBlockBeforeBlockObject = {\n  on: \"delete.forward\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusTextBlock = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getFocusTextBlock)(snapshot), selectionCollapsed = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)(snapshot), nextBlock = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getNextBlock)(snapshot);\n    return !focusTextBlock || !selectionCollapsed || !nextBlock ? !1 : (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__.isEmptyTextBlock)(focusTextBlock.node) && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_2__.isPortableTextTextBlock)(nextBlock.node) ? {\n      focusTextBlock,\n      nextBlock\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock,\n    nextBlock\n  }) => [raise({\n    type: \"delete.block\",\n    blockPath: focusTextBlock.path\n  }), raise({\n    type: \"select\",\n    selection: {\n      anchor: {\n        path: nextBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: nextBlock.path,\n        offset: 0\n      }\n    }\n  })]]\n}, coreBlockObjectBehaviors = {\n  arrowDownOnLonelyBlockObject,\n  arrowUpOnLonelyBlockObject,\n  breakingBlockObject,\n  deletingEmptyTextBlockAfterBlockObject,\n  deletingEmptyTextBlockBeforeBlockObject\n}, coreDecoratorBehaviors = {\n  strongShortcut: {\n    on: \"key.down\",\n    guard: ({\n      snapshot,\n      event\n    }) => isHotkey(\"mod+b\", event.keyboardEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.value === \"strong\"),\n    actions: [() => [raise({\n      type: \"decorator.toggle\",\n      decorator: \"strong\"\n    })]]\n  },\n  emShortcut: {\n    on: \"key.down\",\n    guard: ({\n      snapshot,\n      event\n    }) => isHotkey(\"mod+i\", event.keyboardEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.value === \"em\"),\n    actions: [() => [raise({\n      type: \"decorator.toggle\",\n      decorator: \"em\"\n    })]]\n  },\n  underlineShortcut: {\n    on: \"key.down\",\n    guard: ({\n      snapshot,\n      event\n    }) => isHotkey(\"mod+u\", event.keyboardEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.value === \"underline\"),\n    actions: [() => [raise({\n      type: \"decorator.toggle\",\n      decorator: \"underline\"\n    })]]\n  },\n  codeShortcut: {\n    on: \"key.down\",\n    guard: ({\n      snapshot,\n      event\n    }) => isHotkey(\"mod+'\", event.keyboardEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.value === \"code\"),\n    actions: [() => [raise({\n      type: \"decorator.toggle\",\n      decorator: \"code\"\n    })]]\n  }\n}, breakingAtTheEndOfTextBlock = {\n  on: \"insert.break\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusTextBlock = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getFocusTextBlock)(snapshot), selectionCollapsed = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)(snapshot);\n    if (!snapshot.context.selection || !focusTextBlock || !selectionCollapsed)\n      return !1;\n    const atTheEndOfBlock = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.isAtTheEndOfBlock)(focusTextBlock)(snapshot), focusListItem = focusTextBlock.node.listItem, focusLevel = focusTextBlock.node.level;\n    return atTheEndOfBlock ? {\n      focusListItem,\n      focusLevel\n    } : !1;\n  },\n  actions: [({\n    snapshot\n  }, {\n    focusListItem,\n    focusLevel\n  }) => [raise({\n    type: \"insert.block\",\n    block: {\n      _type: snapshot.context.schema.block.name,\n      _key: snapshot.context.keyGenerator(),\n      children: [{\n        _key: snapshot.context.keyGenerator(),\n        _type: snapshot.context.schema.span.name,\n        text: \"\",\n        marks: []\n      }],\n      markDefs: [],\n      listItem: focusListItem,\n      level: focusLevel,\n      style: snapshot.context.schema.styles[0]?.value\n    },\n    placement: \"after\"\n  })]]\n}, breakingAtTheStartOfTextBlock = {\n  on: \"insert.break\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusTextBlock = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getFocusTextBlock)(snapshot), selectionCollapsed = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)(snapshot);\n    if (!snapshot.context.selection || !focusTextBlock || !selectionCollapsed)\n      return !1;\n    const focusSpan = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getFocusSpan)(snapshot), focusDecorators = focusSpan?.node.marks?.filter((mark) => snapshot.context.schema.decorators.some((decorator) => decorator.value === mark) ?? []), focusAnnotations = focusSpan?.node.marks?.filter((mark) => !snapshot.context.schema.decorators.some((decorator) => decorator.value === mark)) ?? [], focusListItem = focusTextBlock.node.listItem, focusLevel = focusTextBlock.node.level;\n    return (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.isAtTheStartOfBlock)(focusTextBlock)(snapshot) ? {\n      focusAnnotations,\n      focusDecorators,\n      focusListItem,\n      focusLevel\n    } : !1;\n  },\n  actions: [({\n    snapshot\n  }, {\n    focusAnnotations,\n    focusDecorators,\n    focusListItem,\n    focusLevel\n  }) => [raise({\n    type: \"insert.block\",\n    block: {\n      _key: snapshot.context.keyGenerator(),\n      _type: snapshot.context.schema.block.name,\n      children: [{\n        _key: snapshot.context.keyGenerator(),\n        _type: snapshot.context.schema.span.name,\n        marks: focusAnnotations.length === 0 ? focusDecorators : [],\n        text: \"\"\n      }],\n      listItem: focusListItem,\n      level: focusLevel,\n      style: snapshot.context.schema.styles[0]?.value\n    },\n    placement: \"before\"\n  })]]\n}, coreInsertBreakBehaviors = {\n  breakingAtTheEndOfTextBlock,\n  breakingAtTheStartOfTextBlock\n}, MAX_LIST_LEVEL = 10, clearListOnBackspace = {\n  on: \"delete.backward\",\n  guard: ({\n    snapshot\n  }) => {\n    const selectionCollapsed = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)(snapshot), focusTextBlock = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getFocusTextBlock)(snapshot), focusSpan = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getFocusSpan)(snapshot);\n    return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && snapshot.context.selection?.focus.offset === 0 && focusTextBlock.node.level === 1 ? {\n      focusTextBlock\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock\n  }) => [raise({\n    type: \"block.unset\",\n    props: [\"listItem\", \"level\"],\n    at: focusTextBlock.path\n  })]]\n}, unindentListOnBackspace = {\n  on: \"delete.backward\",\n  guard: ({\n    snapshot\n  }) => {\n    const selectionCollapsed = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)(snapshot), focusTextBlock = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getFocusTextBlock)(snapshot), focusSpan = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getFocusSpan)(snapshot);\n    return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && snapshot.context.selection?.focus.offset === 0 && focusTextBlock.node.level !== void 0 && focusTextBlock.node.level > 1 ? {\n      focusTextBlock,\n      level: focusTextBlock.node.level - 1\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock,\n    level\n  }) => [raise({\n    type: \"block.set\",\n    props: {\n      level\n    },\n    at: focusTextBlock.path\n  })]]\n}, clearListOnEnter = {\n  on: \"insert.break\",\n  guard: ({\n    snapshot\n  }) => {\n    const selectionCollapsed = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)(snapshot), focusListBlock = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getFocusListBlock)(snapshot);\n    return !selectionCollapsed || !focusListBlock || !(0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__.isEmptyTextBlock)(focusListBlock.node) ? !1 : {\n      focusListBlock\n    };\n  },\n  actions: [(_, {\n    focusListBlock\n  }) => [raise({\n    type: \"block.unset\",\n    props: [\"listItem\", \"level\"],\n    at: focusListBlock.path\n  })]]\n}, indentListOnTab = {\n  on: \"key.down\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (!isHotkey(\"Tab\", event.keyboardEvent))\n      return !1;\n    const selectedBlocks = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getSelectedBlocks)(snapshot), guards = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.createGuards)(snapshot.context), selectedListBlocks = selectedBlocks.flatMap((block) => guards.isListBlock(block.node) ? [{\n      node: block.node,\n      path: block.path\n    }] : []);\n    return selectedListBlocks.length === selectedBlocks.length ? {\n      selectedListBlocks\n    } : !1;\n  },\n  actions: [(_, {\n    selectedListBlocks\n  }) => selectedListBlocks.map((selectedListBlock) => raise({\n    type: \"block.set\",\n    props: {\n      level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level + 1))\n    },\n    at: selectedListBlock.path\n  }))]\n}, unindentListOnShiftTab = {\n  on: \"key.down\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (!isHotkey(\"Shift+Tab\", event.keyboardEvent))\n      return !1;\n    const selectedBlocks = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.getSelectedBlocks)(snapshot), guards = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_0__.createGuards)(snapshot.context), selectedListBlocks = selectedBlocks.flatMap((block) => guards.isListBlock(block.node) ? [{\n      node: block.node,\n      path: block.path\n    }] : []);\n    return selectedListBlocks.length === selectedBlocks.length ? {\n      selectedListBlocks\n    } : !1;\n  },\n  actions: [(_, {\n    selectedListBlocks\n  }) => selectedListBlocks.map((selectedListBlock) => raise({\n    type: \"block.set\",\n    props: {\n      level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level - 1))\n    },\n    at: selectedListBlock.path\n  }))]\n}, coreListBehaviors = {\n  clearListOnBackspace,\n  unindentListOnBackspace,\n  clearListOnEnter,\n  indentListOnTab,\n  unindentListOnShiftTab\n}, coreBehaviors = [coreAnnotationBehaviors.addAnnotationOnCollapsedSelection, coreDecoratorBehaviors.strongShortcut, coreDecoratorBehaviors.emShortcut, coreDecoratorBehaviors.underlineShortcut, coreDecoratorBehaviors.codeShortcut, coreBlockObjectBehaviors.arrowDownOnLonelyBlockObject, coreBlockObjectBehaviors.arrowUpOnLonelyBlockObject, coreBlockObjectBehaviors.breakingBlockObject, coreBlockObjectBehaviors.deletingEmptyTextBlockAfterBlockObject, coreBlockObjectBehaviors.deletingEmptyTextBlockBeforeBlockObject, coreListBehaviors.clearListOnBackspace, coreListBehaviors.unindentListOnBackspace, coreListBehaviors.clearListOnEnter, coreListBehaviors.indentListOnTab, coreListBehaviors.unindentListOnShiftTab, coreInsertBreakBehaviors.breakingAtTheEndOfTextBlock, coreInsertBreakBehaviors.breakingAtTheStartOfTextBlock];\n\n//# sourceMappingURL=behavior.core.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvYmVoYXZpb3IuY29yZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE0UztBQUNwUDtBQUNFO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsMkZBQW9CO0FBQzdCO0FBQ0EsK0JBQStCLDRGQUFxQjtBQUNwRCxtQ0FBbUMsMEZBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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S0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ04sR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQU9DO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNib29rcHJvL0Rvd25sb2Fkcy9jb25pY2FwcHMvaWdlbmUvbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL2JlaGF2aW9yLmNvcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNTZWxlY3Rpb25Db2xsYXBzZWQsIGdldENhcmV0V29yZFNlbGVjdGlvbiwgaXNTZWxlY3Rpb25FeHBhbmRlZCwgZ2V0Rm9jdXNCbG9ja09iamVjdCwgZ2V0TmV4dEJsb2NrLCBnZXRQcmV2aW91c0Jsb2NrLCBnZXRGb2N1c1RleHRCbG9jaywgaXNBdFRoZUVuZE9mQmxvY2ssIGdldEZvY3VzU3BhbiwgaXNBdFRoZVN0YXJ0T2ZCbG9jaywgZ2V0Rm9jdXNMaXN0QmxvY2ssIGdldFNlbGVjdGVkQmxvY2tzLCBjcmVhdGVHdWFyZHMgfSBmcm9tIFwiLi9zZWxlY3Rvci5pcy1hdC10aGUtc3RhcnQtb2YtYmxvY2suanNcIjtcbmltcG9ydCB7IGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrIH0gZnJvbSBcIkBzYW5pdHkvdHlwZXNcIjtcbmltcG9ydCB7IGlzRW1wdHlUZXh0QmxvY2sgfSBmcm9tIFwiLi91dGlsLnNsaWNlLWJsb2Nrcy5qc1wiO1xuZnVuY3Rpb24gaXNDdXN0b21CZWhhdmlvckV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlLnN0YXJ0c1dpdGgoXCJjdXN0b20uXCIpO1xufVxuZnVuY3Rpb24gcmFpc2UoZXZlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInJhaXNlXCIsXG4gICAgZXZlbnRcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmluZUJlaGF2aW9yKGJlaGF2aW9yKSB7XG4gIHJldHVybiBiZWhhdmlvcjtcbn1cbmNvbnN0IGFkZEFubm90YXRpb25PbkNvbGxhcHNlZFNlbGVjdGlvbiA9IHtcbiAgb246IFwiYW5ub3RhdGlvbi5hZGRcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4ge1xuICAgIGlmICghaXNTZWxlY3Rpb25Db2xsYXBzZWQoc25hcHNob3QpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGNhcmV0V29yZFNlbGVjdGlvbiA9IGdldENhcmV0V29yZFNlbGVjdGlvbihzbmFwc2hvdCk7XG4gICAgcmV0dXJuICFjYXJldFdvcmRTZWxlY3Rpb24gfHwgIWlzU2VsZWN0aW9uRXhwYW5kZWQoe1xuICAgICAgLi4uc25hcHNob3QsXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvbjogY2FyZXRXb3JkU2VsZWN0aW9uXG4gICAgICB9XG4gICAgfSkgPyAhMSA6IHtcbiAgICAgIGNhcmV0V29yZFNlbGVjdGlvblxuICAgIH07XG4gIH0sXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0sIHtcbiAgICBjYXJldFdvcmRTZWxlY3Rpb25cbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcInNlbGVjdFwiLFxuICAgIHNlbGVjdGlvbjogY2FyZXRXb3JkU2VsZWN0aW9uXG4gIH0pLCByYWlzZSh7XG4gICAgdHlwZTogXCJhbm5vdGF0aW9uLmFkZFwiLFxuICAgIGFubm90YXRpb246IGV2ZW50LmFubm90YXRpb25cbiAgfSldXVxufSwgY29yZUFubm90YXRpb25CZWhhdmlvcnMgPSB7XG4gIGFkZEFubm90YXRpb25PbkNvbGxhcHNlZFNlbGVjdGlvblxufSwgSVNfTUFDID0gdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIC9NYWN8aVBvZHxpUGhvbmV8aVBhZC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCksIG1vZGlmaWVycyA9IHtcbiAgYWx0OiBcImFsdEtleVwiLFxuICBjb250cm9sOiBcImN0cmxLZXlcIixcbiAgbWV0YTogXCJtZXRhS2V5XCIsXG4gIHNoaWZ0OiBcInNoaWZ0S2V5XCJcbn0sIGFsaWFzZXMgPSB7XG4gIGFkZDogXCIrXCIsXG4gIGJyZWFrOiBcInBhdXNlXCIsXG4gIGNtZDogXCJtZXRhXCIsXG4gIGNvbW1hbmQ6IFwibWV0YVwiLFxuICBjdGw6IFwiY29udHJvbFwiLFxuICBjdHJsOiBcImNvbnRyb2xcIixcbiAgZGVsOiBcImRlbGV0ZVwiLFxuICBkb3duOiBcImFycm93ZG93blwiLFxuICBlc2M6IFwiZXNjYXBlXCIsXG4gIGluczogXCJpbnNlcnRcIixcbiAgbGVmdDogXCJhcnJvd2xlZnRcIixcbiAgbW9kOiBJU19NQUMgPyBcIm1ldGFcIiA6IFwiY29udHJvbFwiLFxuICBvcHQ6IFwiYWx0XCIsXG4gIG9wdGlvbjogXCJhbHRcIixcbiAgcmV0dXJuOiBcImVudGVyXCIsXG4gIHJpZ2h0OiBcImFycm93cmlnaHRcIixcbiAgc3BhY2U6IFwiIFwiLFxuICBzcGFjZWJhcjogXCIgXCIsXG4gIHVwOiBcImFycm93dXBcIixcbiAgd2luOiBcIm1ldGFcIixcbiAgd2luZG93czogXCJtZXRhXCJcbn0sIGtleUNvZGVzID0ge1xuICBiYWNrc3BhY2U6IDgsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzaGlmdDogMTYsXG4gIGNvbnRyb2w6IDE3LFxuICBhbHQ6IDE4LFxuICBwYXVzZTogMTksXG4gIGNhcHNsb2NrOiAyMCxcbiAgZXNjYXBlOiAyNyxcbiAgXCIgXCI6IDMyLFxuICBwYWdldXA6IDMzLFxuICBwYWdlZG93bjogMzQsXG4gIGVuZDogMzUsXG4gIGhvbWU6IDM2LFxuICBhcnJvd2xlZnQ6IDM3LFxuICBhcnJvd3VwOiAzOCxcbiAgYXJyb3dyaWdodDogMzksXG4gIGFycm93ZG93bjogNDAsXG4gIGluc2VydDogNDUsXG4gIGRlbGV0ZTogNDYsXG4gIG1ldGE6IDkxLFxuICBudW1sb2NrOiAxNDQsXG4gIHNjcm9sbGxvY2s6IDE0NSxcbiAgXCI7XCI6IDE4NixcbiAgXCI9XCI6IDE4NyxcbiAgXCIsXCI6IDE4OCxcbiAgXCItXCI6IDE4OSxcbiAgXCIuXCI6IDE5MCxcbiAgXCIvXCI6IDE5MSxcbiAgXCJgXCI6IDE5MixcbiAgXCJbXCI6IDIxOSxcbiAgXCJcXFxcXCI6IDIyMCxcbiAgXCJdXCI6IDIyMSxcbiAgXCInXCI6IDIyMixcbiAgZjE6IDExMixcbiAgZjI6IDExMyxcbiAgZjM6IDExNCxcbiAgZjQ6IDExNSxcbiAgZjU6IDExNixcbiAgZjY6IDExNyxcbiAgZjc6IDExOCxcbiAgZjg6IDExOSxcbiAgZjk6IDEyMCxcbiAgZjEwOiAxMjEsXG4gIGYxMTogMTIyLFxuICBmMTI6IDEyMyxcbiAgZjEzOiAxMjQsXG4gIGYxNDogMTI1LFxuICBmMTU6IDEyNixcbiAgZjE2OiAxMjcsXG4gIGYxNzogMTI4LFxuICBmMTg6IDEyOSxcbiAgZjE5OiAxMzAsXG4gIGYyMDogMTMxXG59O1xuZnVuY3Rpb24gaXNIb3RrZXkoaG90a2V5LCBldmVudCkge1xuICByZXR1cm4gY29tcGFyZUhvdGtleShwYXJzZUhvdGtleShob3RrZXkpLCBldmVudCk7XG59XG5mdW5jdGlvbiBwYXJzZUhvdGtleShob3RrZXkpIHtcbiAgY29uc3QgcGFyc2VkSG90a2V5ID0ge1xuICAgIGFsdEtleTogITEsXG4gICAgY3RybEtleTogITEsXG4gICAgbWV0YUtleTogITEsXG4gICAgc2hpZnRLZXk6ICExXG4gIH0sIGhvdGtleVNlZ21lbnRzID0gaG90a2V5LnJlcGxhY2UoXCIrK1wiLCBcIithZGRcIikuc3BsaXQoXCIrXCIpO1xuICBmb3IgKGNvbnN0IHJhd0hvdGtleVNlZ21lbnQgb2YgaG90a2V5U2VnbWVudHMpIHtcbiAgICBjb25zdCBvcHRpb25hbCA9IHJhd0hvdGtleVNlZ21lbnQuZW5kc1dpdGgoXCI/XCIpICYmIHJhd0hvdGtleVNlZ21lbnQubGVuZ3RoID4gMSwgaG90a2V5U2VnbWVudCA9IG9wdGlvbmFsID8gcmF3SG90a2V5U2VnbWVudC5zbGljZSgwLCAtMSkgOiByYXdIb3RrZXlTZWdtZW50LCBrZXlOYW1lID0gdG9LZXlOYW1lKGhvdGtleVNlZ21lbnQpLCBtb2RpZmllciA9IG1vZGlmaWVyc1trZXlOYW1lXSwgYWxpYXMgPSBhbGlhc2VzW2hvdGtleVNlZ21lbnRdLCBjb2RlID0ga2V5Q29kZXNba2V5TmFtZV07XG4gICAgaWYgKGhvdGtleVNlZ21lbnQubGVuZ3RoID4gMSAmJiBtb2RpZmllciA9PT0gdm9pZCAwICYmIGFsaWFzID09PSB2b2lkIDAgJiYgY29kZSA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5rbm93biBtb2RpZmllcjogXCIke2hvdGtleVNlZ21lbnR9XCJgKTtcbiAgICAoaG90a2V5U2VnbWVudHMubGVuZ3RoID09PSAxIHx8IG1vZGlmaWVyID09PSB2b2lkIDApICYmIChwYXJzZWRIb3RrZXkua2V5ID0ga2V5TmFtZSwgcGFyc2VkSG90a2V5LmtleUNvZGUgPSB0b0tleUNvZGUoaG90a2V5U2VnbWVudCkpLCBtb2RpZmllciAhPT0gdm9pZCAwICYmIChwYXJzZWRIb3RrZXlbbW9kaWZpZXJdID0gb3B0aW9uYWwgPyBudWxsIDogITApO1xuICB9XG4gIHJldHVybiBwYXJzZWRIb3RrZXk7XG59XG5mdW5jdGlvbiBjb21wYXJlSG90a2V5KHBhcnNlZEhvdGtleSwgZXZlbnQpIHtcbiAgcmV0dXJuIChwYXJzZWRIb3RrZXkuYWx0S2V5ID09IG51bGwgfHwgcGFyc2VkSG90a2V5LmFsdEtleSA9PT0gZXZlbnQuYWx0S2V5KSAmJiAocGFyc2VkSG90a2V5LmN0cmxLZXkgPT0gbnVsbCB8fCBwYXJzZWRIb3RrZXkuY3RybEtleSA9PT0gZXZlbnQuY3RybEtleSkgJiYgKHBhcnNlZEhvdGtleS5tZXRhS2V5ID09IG51bGwgfHwgcGFyc2VkSG90a2V5Lm1ldGFLZXkgPT09IGV2ZW50Lm1ldGFLZXkpICYmIChwYXJzZWRIb3RrZXkuc2hpZnRLZXkgPT0gbnVsbCB8fCBwYXJzZWRIb3RrZXkuc2hpZnRLZXkgPT09IGV2ZW50LnNoaWZ0S2V5KSA/IHBhcnNlZEhvdGtleS5rZXlDb2RlICE9PSB2b2lkIDAgJiYgZXZlbnQua2V5Q29kZSAhPT0gdm9pZCAwID8gcGFyc2VkSG90a2V5LmtleUNvZGUgPT09IDkxICYmIGV2ZW50LmtleUNvZGUgPT09IDkzID8gITAgOiBwYXJzZWRIb3RrZXkua2V5Q29kZSA9PT0gZXZlbnQua2V5Q29kZSA6IHBhcnNlZEhvdGtleS5rZXlDb2RlID09PSBldmVudC5rZXlDb2RlIHx8IHBhcnNlZEhvdGtleS5rZXkgPT09IGV2ZW50LmtleS50b0xvd2VyQ2FzZSgpIDogITE7XG59XG5mdW5jdGlvbiB0b0tleUNvZGUobmFtZSkge1xuICBjb25zdCBrZXlOYW1lID0gdG9LZXlOYW1lKG5hbWUpO1xuICByZXR1cm4ga2V5Q29kZXNba2V5TmFtZV0gPz8ga2V5TmFtZS50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCk7XG59XG5mdW5jdGlvbiB0b0tleU5hbWUobmFtZSkge1xuICBjb25zdCBrZXlOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gYWxpYXNlc1trZXlOYW1lXSA/PyBrZXlOYW1lO1xufVxuY29uc3QgYXJyb3dEb3duT25Mb25lbHlCbG9ja09iamVjdCA9IHtcbiAgb246IFwia2V5LmRvd25cIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGlzQXJyb3dEb3duID0gaXNIb3RrZXkoXCJBcnJvd0Rvd25cIiwgZXZlbnQua2V5Ym9hcmRFdmVudCksIGZvY3VzQmxvY2tPYmplY3QgPSBnZXRGb2N1c0Jsb2NrT2JqZWN0KHNuYXBzaG90KSwgbmV4dEJsb2NrID0gZ2V0TmV4dEJsb2NrKHNuYXBzaG90KTtcbiAgICByZXR1cm4gaXNBcnJvd0Rvd24gJiYgZm9jdXNCbG9ja09iamVjdCAmJiAhbmV4dEJsb2NrO1xuICB9LFxuICBhY3Rpb25zOiBbKCkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImluc2VydC50ZXh0IGJsb2NrXCIsXG4gICAgcGxhY2VtZW50OiBcImFmdGVyXCJcbiAgfSldXVxufSwgYXJyb3dVcE9uTG9uZWx5QmxvY2tPYmplY3QgPSB7XG4gIG9uOiBcImtleS5kb3duXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBjb25zdCBpc0Fycm93VXAgPSBpc0hvdGtleShcIkFycm93VXBcIiwgZXZlbnQua2V5Ym9hcmRFdmVudCksIGZvY3VzQmxvY2tPYmplY3QgPSBnZXRGb2N1c0Jsb2NrT2JqZWN0KHNuYXBzaG90KSwgcHJldmlvdXNCbG9jayA9IGdldFByZXZpb3VzQmxvY2soc25hcHNob3QpO1xuICAgIHJldHVybiBpc0Fycm93VXAgJiYgZm9jdXNCbG9ja09iamVjdCAmJiAhcHJldmlvdXNCbG9jaztcbiAgfSxcbiAgYWN0aW9uczogWygpID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJpbnNlcnQudGV4dCBibG9ja1wiLFxuICAgIHBsYWNlbWVudDogXCJiZWZvcmVcIlxuICB9KSwgcmFpc2Uoe1xuICAgIHR5cGU6IFwic2VsZWN0LnByZXZpb3VzIGJsb2NrXCJcbiAgfSldXVxufSwgYnJlYWtpbmdCbG9ja09iamVjdCA9IHtcbiAgb246IFwiaW5zZXJ0LmJyZWFrXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90XG4gIH0pID0+IHtcbiAgICBjb25zdCBmb2N1c0Jsb2NrT2JqZWN0ID0gZ2V0Rm9jdXNCbG9ja09iamVjdChzbmFwc2hvdCk7XG4gICAgcmV0dXJuIGlzU2VsZWN0aW9uQ29sbGFwc2VkKHNuYXBzaG90KSAmJiBmb2N1c0Jsb2NrT2JqZWN0ICE9PSB2b2lkIDA7XG4gIH0sXG4gIGFjdGlvbnM6IFsoKSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiaW5zZXJ0LnRleHQgYmxvY2tcIixcbiAgICBwbGFjZW1lbnQ6IFwiYWZ0ZXJcIlxuICB9KV1dXG59LCBkZWxldGluZ0VtcHR5VGV4dEJsb2NrQWZ0ZXJCbG9ja09iamVjdCA9IHtcbiAgb246IFwiZGVsZXRlLmJhY2t3YXJkXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90XG4gIH0pID0+IHtcbiAgICBjb25zdCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSwgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQoc25hcHNob3QpLCBwcmV2aW91c0Jsb2NrID0gZ2V0UHJldmlvdXNCbG9jayhzbmFwc2hvdCk7XG4gICAgcmV0dXJuICFmb2N1c1RleHRCbG9jayB8fCAhc2VsZWN0aW9uQ29sbGFwc2VkIHx8ICFwcmV2aW91c0Jsb2NrID8gITEgOiBpc0VtcHR5VGV4dEJsb2NrKGZvY3VzVGV4dEJsb2NrLm5vZGUpICYmICFpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhwcmV2aW91c0Jsb2NrLm5vZGUpID8ge1xuICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICBwcmV2aW91c0Jsb2NrXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBmb2N1c1RleHRCbG9jayxcbiAgICBwcmV2aW91c0Jsb2NrXG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJkZWxldGUuYmxvY2tcIixcbiAgICBibG9ja1BhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGhcbiAgfSksIHJhaXNlKHtcbiAgICB0eXBlOiBcInNlbGVjdFwiLFxuICAgIHNlbGVjdGlvbjoge1xuICAgICAgYW5jaG9yOiB7XG4gICAgICAgIHBhdGg6IHByZXZpb3VzQmxvY2sucGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuICAgICAgZm9jdXM6IHtcbiAgICAgICAgcGF0aDogcHJldmlvdXNCbG9jay5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1cbiAgICB9XG4gIH0pXV1cbn0sIGRlbGV0aW5nRW1wdHlUZXh0QmxvY2tCZWZvcmVCbG9ja09iamVjdCA9IHtcbiAgb246IFwiZGVsZXRlLmZvcndhcmRcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soc25hcHNob3QpLCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBpc1NlbGVjdGlvbkNvbGxhcHNlZChzbmFwc2hvdCksIG5leHRCbG9jayA9IGdldE5leHRCbG9jayhzbmFwc2hvdCk7XG4gICAgcmV0dXJuICFmb2N1c1RleHRCbG9jayB8fCAhc2VsZWN0aW9uQ29sbGFwc2VkIHx8ICFuZXh0QmxvY2sgPyAhMSA6IGlzRW1wdHlUZXh0QmxvY2soZm9jdXNUZXh0QmxvY2subm9kZSkgJiYgIWlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKG5leHRCbG9jay5ub2RlKSA/IHtcbiAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgbmV4dEJsb2NrXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBmb2N1c1RleHRCbG9jayxcbiAgICBuZXh0QmxvY2tcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImRlbGV0ZS5ibG9ja1wiLFxuICAgIGJsb2NrUGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aFxuICB9KSwgcmFpc2Uoe1xuICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgc2VsZWN0aW9uOiB7XG4gICAgICBhbmNob3I6IHtcbiAgICAgICAgcGF0aDogbmV4dEJsb2NrLnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IG5leHRCbG9jay5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1cbiAgICB9XG4gIH0pXV1cbn0sIGNvcmVCbG9ja09iamVjdEJlaGF2aW9ycyA9IHtcbiAgYXJyb3dEb3duT25Mb25lbHlCbG9ja09iamVjdCxcbiAgYXJyb3dVcE9uTG9uZWx5QmxvY2tPYmplY3QsXG4gIGJyZWFraW5nQmxvY2tPYmplY3QsXG4gIGRlbGV0aW5nRW1wdHlUZXh0QmxvY2tBZnRlckJsb2NrT2JqZWN0LFxuICBkZWxldGluZ0VtcHR5VGV4dEJsb2NrQmVmb3JlQmxvY2tPYmplY3Rcbn0sIGNvcmVEZWNvcmF0b3JCZWhhdmlvcnMgPSB7XG4gIHN0cm9uZ1Nob3J0Y3V0OiB7XG4gICAgb246IFwia2V5LmRvd25cIixcbiAgICBndWFyZDogKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiBpc0hvdGtleShcIm1vZCtiXCIsIGV2ZW50LmtleWJvYXJkRXZlbnQpICYmIHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLmRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IudmFsdWUgPT09IFwic3Ryb25nXCIpLFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbcmFpc2Uoe1xuICAgICAgdHlwZTogXCJkZWNvcmF0b3IudG9nZ2xlXCIsXG4gICAgICBkZWNvcmF0b3I6IFwic3Ryb25nXCJcbiAgICB9KV1dXG4gIH0sXG4gIGVtU2hvcnRjdXQ6IHtcbiAgICBvbjogXCJrZXkuZG93blwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IGlzSG90a2V5KFwibW9kK2lcIiwgZXZlbnQua2V5Ym9hcmRFdmVudCkgJiYgc25hcHNob3QuY29udGV4dC5zY2hlbWEuZGVjb3JhdG9ycy5zb21lKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci52YWx1ZSA9PT0gXCJlbVwiKSxcbiAgICBhY3Rpb25zOiBbKCkgPT4gW3JhaXNlKHtcbiAgICAgIHR5cGU6IFwiZGVjb3JhdG9yLnRvZ2dsZVwiLFxuICAgICAgZGVjb3JhdG9yOiBcImVtXCJcbiAgICB9KV1dXG4gIH0sXG4gIHVuZGVybGluZVNob3J0Y3V0OiB7XG4gICAgb246IFwia2V5LmRvd25cIixcbiAgICBndWFyZDogKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiBpc0hvdGtleShcIm1vZCt1XCIsIGV2ZW50LmtleWJvYXJkRXZlbnQpICYmIHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLmRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IudmFsdWUgPT09IFwidW5kZXJsaW5lXCIpLFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbcmFpc2Uoe1xuICAgICAgdHlwZTogXCJkZWNvcmF0b3IudG9nZ2xlXCIsXG4gICAgICBkZWNvcmF0b3I6IFwidW5kZXJsaW5lXCJcbiAgICB9KV1dXG4gIH0sXG4gIGNvZGVTaG9ydGN1dDoge1xuICAgIG9uOiBcImtleS5kb3duXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gaXNIb3RrZXkoXCJtb2QrJ1wiLCBldmVudC5rZXlib2FyZEV2ZW50KSAmJiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5kZWNvcmF0b3JzLnNvbWUoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLnZhbHVlID09PSBcImNvZGVcIiksXG4gICAgYWN0aW9uczogWygpID0+IFtyYWlzZSh7XG4gICAgICB0eXBlOiBcImRlY29yYXRvci50b2dnbGVcIixcbiAgICAgIGRlY29yYXRvcjogXCJjb2RlXCJcbiAgICB9KV1dXG4gIH1cbn0sIGJyZWFraW5nQXRUaGVFbmRPZlRleHRCbG9jayA9IHtcbiAgb246IFwiaW5zZXJ0LmJyZWFrXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90XG4gIH0pID0+IHtcbiAgICBjb25zdCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSwgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQoc25hcHNob3QpO1xuICAgIGlmICghc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24gfHwgIWZvY3VzVGV4dEJsb2NrIHx8ICFzZWxlY3Rpb25Db2xsYXBzZWQpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgYXRUaGVFbmRPZkJsb2NrID0gaXNBdFRoZUVuZE9mQmxvY2soZm9jdXNUZXh0QmxvY2spKHNuYXBzaG90KSwgZm9jdXNMaXN0SXRlbSA9IGZvY3VzVGV4dEJsb2NrLm5vZGUubGlzdEl0ZW0sIGZvY3VzTGV2ZWwgPSBmb2N1c1RleHRCbG9jay5ub2RlLmxldmVsO1xuICAgIHJldHVybiBhdFRoZUVuZE9mQmxvY2sgPyB7XG4gICAgICBmb2N1c0xpc3RJdGVtLFxuICAgICAgZm9jdXNMZXZlbFxuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyh7XG4gICAgc25hcHNob3RcbiAgfSwge1xuICAgIGZvY3VzTGlzdEl0ZW0sXG4gICAgZm9jdXNMZXZlbFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgYmxvY2s6IHtcbiAgICAgIF90eXBlOiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lLFxuICAgICAgX2tleTogc25hcHNob3QuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICBfa2V5OiBzbmFwc2hvdC5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICBfdHlwZTogc25hcHNob3QuY29udGV4dC5zY2hlbWEuc3Bhbi5uYW1lLFxuICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICBtYXJrczogW11cbiAgICAgIH1dLFxuICAgICAgbWFya0RlZnM6IFtdLFxuICAgICAgbGlzdEl0ZW06IGZvY3VzTGlzdEl0ZW0sXG4gICAgICBsZXZlbDogZm9jdXNMZXZlbCxcbiAgICAgIHN0eWxlOiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5zdHlsZXNbMF0/LnZhbHVlXG4gICAgfSxcbiAgICBwbGFjZW1lbnQ6IFwiYWZ0ZXJcIlxuICB9KV1dXG59LCBicmVha2luZ0F0VGhlU3RhcnRPZlRleHRCbG9jayA9IHtcbiAgb246IFwiaW5zZXJ0LmJyZWFrXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90XG4gIH0pID0+IHtcbiAgICBjb25zdCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSwgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQoc25hcHNob3QpO1xuICAgIGlmICghc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24gfHwgIWZvY3VzVGV4dEJsb2NrIHx8ICFzZWxlY3Rpb25Db2xsYXBzZWQpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgZm9jdXNTcGFuID0gZ2V0Rm9jdXNTcGFuKHNuYXBzaG90KSwgZm9jdXNEZWNvcmF0b3JzID0gZm9jdXNTcGFuPy5ub2RlLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLmRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IudmFsdWUgPT09IG1hcmspID8/IFtdKSwgZm9jdXNBbm5vdGF0aW9ucyA9IGZvY3VzU3Bhbj8ubm9kZS5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiAhc25hcHNob3QuY29udGV4dC5zY2hlbWEuZGVjb3JhdG9ycy5zb21lKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci52YWx1ZSA9PT0gbWFyaykpID8/IFtdLCBmb2N1c0xpc3RJdGVtID0gZm9jdXNUZXh0QmxvY2subm9kZS5saXN0SXRlbSwgZm9jdXNMZXZlbCA9IGZvY3VzVGV4dEJsb2NrLm5vZGUubGV2ZWw7XG4gICAgcmV0dXJuIGlzQXRUaGVTdGFydE9mQmxvY2soZm9jdXNUZXh0QmxvY2spKHNuYXBzaG90KSA/IHtcbiAgICAgIGZvY3VzQW5ub3RhdGlvbnMsXG4gICAgICBmb2N1c0RlY29yYXRvcnMsXG4gICAgICBmb2N1c0xpc3RJdGVtLFxuICAgICAgZm9jdXNMZXZlbFxuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyh7XG4gICAgc25hcHNob3RcbiAgfSwge1xuICAgIGZvY3VzQW5ub3RhdGlvbnMsXG4gICAgZm9jdXNEZWNvcmF0b3JzLFxuICAgIGZvY3VzTGlzdEl0ZW0sXG4gICAgZm9jdXNMZXZlbFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgYmxvY2s6IHtcbiAgICAgIF9rZXk6IHNuYXBzaG90LmNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICBfdHlwZTogc25hcHNob3QuY29udGV4dC5zY2hlbWEuYmxvY2submFtZSxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICBfa2V5OiBzbmFwc2hvdC5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICBfdHlwZTogc25hcHNob3QuY29udGV4dC5zY2hlbWEuc3Bhbi5uYW1lLFxuICAgICAgICBtYXJrczogZm9jdXNBbm5vdGF0aW9ucy5sZW5ndGggPT09IDAgPyBmb2N1c0RlY29yYXRvcnMgOiBbXSxcbiAgICAgICAgdGV4dDogXCJcIlxuICAgICAgfV0sXG4gICAgICBsaXN0SXRlbTogZm9jdXNMaXN0SXRlbSxcbiAgICAgIGxldmVsOiBmb2N1c0xldmVsLFxuICAgICAgc3R5bGU6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLnN0eWxlc1swXT8udmFsdWVcbiAgICB9LFxuICAgIHBsYWNlbWVudDogXCJiZWZvcmVcIlxuICB9KV1dXG59LCBjb3JlSW5zZXJ0QnJlYWtCZWhhdmlvcnMgPSB7XG4gIGJyZWFraW5nQXRUaGVFbmRPZlRleHRCbG9jayxcbiAgYnJlYWtpbmdBdFRoZVN0YXJ0T2ZUZXh0QmxvY2tcbn0sIE1BWF9MSVNUX0xFVkVMID0gMTAsIGNsZWFyTGlzdE9uQmFja3NwYWNlID0ge1xuICBvbjogXCJkZWxldGUuYmFja3dhcmRcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkKHNuYXBzaG90KSwgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCksIGZvY3VzU3BhbiA9IGdldEZvY3VzU3BhbihzbmFwc2hvdCk7XG4gICAgcmV0dXJuICFzZWxlY3Rpb25Db2xsYXBzZWQgfHwgIWZvY3VzVGV4dEJsb2NrIHx8ICFmb2N1c1NwYW4gPyAhMSA6IGZvY3VzVGV4dEJsb2NrLm5vZGUuY2hpbGRyZW5bMF0uX2tleSA9PT0gZm9jdXNTcGFuLm5vZGUuX2tleSAmJiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbj8uZm9jdXMub2Zmc2V0ID09PSAwICYmIGZvY3VzVGV4dEJsb2NrLm5vZGUubGV2ZWwgPT09IDEgPyB7XG4gICAgICBmb2N1c1RleHRCbG9ja1xuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyhfLCB7XG4gICAgZm9jdXNUZXh0QmxvY2tcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImJsb2NrLnVuc2V0XCIsXG4gICAgcHJvcHM6IFtcImxpc3RJdGVtXCIsIFwibGV2ZWxcIl0sXG4gICAgYXQ6IGZvY3VzVGV4dEJsb2NrLnBhdGhcbiAgfSldXVxufSwgdW5pbmRlbnRMaXN0T25CYWNrc3BhY2UgPSB7XG4gIG9uOiBcImRlbGV0ZS5iYWNrd2FyZFwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQoc25hcHNob3QpLCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSwgZm9jdXNTcGFuID0gZ2V0Rm9jdXNTcGFuKHNuYXBzaG90KTtcbiAgICByZXR1cm4gIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIWZvY3VzU3BhbiA/ICExIDogZm9jdXNUZXh0QmxvY2subm9kZS5jaGlsZHJlblswXS5fa2V5ID09PSBmb2N1c1NwYW4ubm9kZS5fa2V5ICYmIHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uPy5mb2N1cy5vZmZzZXQgPT09IDAgJiYgZm9jdXNUZXh0QmxvY2subm9kZS5sZXZlbCAhPT0gdm9pZCAwICYmIGZvY3VzVGV4dEJsb2NrLm5vZGUubGV2ZWwgPiAxID8ge1xuICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICBsZXZlbDogZm9jdXNUZXh0QmxvY2subm9kZS5sZXZlbCAtIDFcbiAgICB9IDogITE7XG4gIH0sXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgIGxldmVsXG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJibG9jay5zZXRcIixcbiAgICBwcm9wczoge1xuICAgICAgbGV2ZWxcbiAgICB9LFxuICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gIH0pXV1cbn0sIGNsZWFyTGlzdE9uRW50ZXIgPSB7XG4gIG9uOiBcImluc2VydC5icmVha1wiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQoc25hcHNob3QpLCBmb2N1c0xpc3RCbG9jayA9IGdldEZvY3VzTGlzdEJsb2NrKHNuYXBzaG90KTtcbiAgICByZXR1cm4gIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNMaXN0QmxvY2sgfHwgIWlzRW1wdHlUZXh0QmxvY2soZm9jdXNMaXN0QmxvY2subm9kZSkgPyAhMSA6IHtcbiAgICAgIGZvY3VzTGlzdEJsb2NrXG4gICAgfTtcbiAgfSxcbiAgYWN0aW9uczogWyhfLCB7XG4gICAgZm9jdXNMaXN0QmxvY2tcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImJsb2NrLnVuc2V0XCIsXG4gICAgcHJvcHM6IFtcImxpc3RJdGVtXCIsIFwibGV2ZWxcIl0sXG4gICAgYXQ6IGZvY3VzTGlzdEJsb2NrLnBhdGhcbiAgfSldXVxufSwgaW5kZW50TGlzdE9uVGFiID0ge1xuICBvbjogXCJrZXkuZG93blwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgaWYgKCFpc0hvdGtleShcIlRhYlwiLCBldmVudC5rZXlib2FyZEV2ZW50KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IGdldFNlbGVjdGVkQmxvY2tzKHNuYXBzaG90KSwgZ3VhcmRzID0gY3JlYXRlR3VhcmRzKHNuYXBzaG90LmNvbnRleHQpLCBzZWxlY3RlZExpc3RCbG9ja3MgPSBzZWxlY3RlZEJsb2Nrcy5mbGF0TWFwKChibG9jaykgPT4gZ3VhcmRzLmlzTGlzdEJsb2NrKGJsb2NrLm5vZGUpID8gW3tcbiAgICAgIG5vZGU6IGJsb2NrLm5vZGUsXG4gICAgICBwYXRoOiBibG9jay5wYXRoXG4gICAgfV0gOiBbXSk7XG4gICAgcmV0dXJuIHNlbGVjdGVkTGlzdEJsb2Nrcy5sZW5ndGggPT09IHNlbGVjdGVkQmxvY2tzLmxlbmd0aCA/IHtcbiAgICAgIHNlbGVjdGVkTGlzdEJsb2Nrc1xuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyhfLCB7XG4gICAgc2VsZWN0ZWRMaXN0QmxvY2tzXG4gIH0pID0+IHNlbGVjdGVkTGlzdEJsb2Nrcy5tYXAoKHNlbGVjdGVkTGlzdEJsb2NrKSA9PiByYWlzZSh7XG4gICAgdHlwZTogXCJibG9jay5zZXRcIixcbiAgICBwcm9wczoge1xuICAgICAgbGV2ZWw6IE1hdGgubWluKE1BWF9MSVNUX0xFVkVMLCBNYXRoLm1heCgxLCBzZWxlY3RlZExpc3RCbG9jay5ub2RlLmxldmVsICsgMSkpXG4gICAgfSxcbiAgICBhdDogc2VsZWN0ZWRMaXN0QmxvY2sucGF0aFxuICB9KSldXG59LCB1bmluZGVudExpc3RPblNoaWZ0VGFiID0ge1xuICBvbjogXCJrZXkuZG93blwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgaWYgKCFpc0hvdGtleShcIlNoaWZ0K1RhYlwiLCBldmVudC5rZXlib2FyZEV2ZW50KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IGdldFNlbGVjdGVkQmxvY2tzKHNuYXBzaG90KSwgZ3VhcmRzID0gY3JlYXRlR3VhcmRzKHNuYXBzaG90LmNvbnRleHQpLCBzZWxlY3RlZExpc3RCbG9ja3MgPSBzZWxlY3RlZEJsb2Nrcy5mbGF0TWFwKChibG9jaykgPT4gZ3VhcmRzLmlzTGlzdEJsb2NrKGJsb2NrLm5vZGUpID8gW3tcbiAgICAgIG5vZGU6IGJsb2NrLm5vZGUsXG4gICAgICBwYXRoOiBibG9jay5wYXRoXG4gICAgfV0gOiBbXSk7XG4gICAgcmV0dXJuIHNlbGVjdGVkTGlzdEJsb2Nrcy5sZW5ndGggPT09IHNlbGVjdGVkQmxvY2tzLmxlbmd0aCA/IHtcbiAgICAgIHNlbGVjdGVkTGlzdEJsb2Nrc1xuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyhfLCB7XG4gICAgc2VsZWN0ZWRMaXN0QmxvY2tzXG4gIH0pID0+IHNlbGVjdGVkTGlzdEJsb2Nrcy5tYXAoKHNlbGVjdGVkTGlzdEJsb2NrKSA9PiByYWlzZSh7XG4gICAgdHlwZTogXCJibG9jay5zZXRcIixcbiAgICBwcm9wczoge1xuICAgICAgbGV2ZWw6IE1hdGgubWluKE1BWF9MSVNUX0xFVkVMLCBNYXRoLm1heCgxLCBzZWxlY3RlZExpc3RCbG9jay5ub2RlLmxldmVsIC0gMSkpXG4gICAgfSxcbiAgICBhdDogc2VsZWN0ZWRMaXN0QmxvY2sucGF0aFxuICB9KSldXG59LCBjb3JlTGlzdEJlaGF2aW9ycyA9IHtcbiAgY2xlYXJMaXN0T25CYWNrc3BhY2UsXG4gIHVuaW5kZW50TGlzdE9uQmFja3NwYWNlLFxuICBjbGVhckxpc3RPbkVudGVyLFxuICBpbmRlbnRMaXN0T25UYWIsXG4gIHVuaW5kZW50TGlzdE9uU2hpZnRUYWJcbn0sIGNvcmVCZWhhdmlvcnMgPSBbY29yZUFubm90YXRpb25CZWhhdmlvcnMuYWRkQW5ub3RhdGlvbk9uQ29sbGFwc2VkU2VsZWN0aW9uLCBjb3JlRGVjb3JhdG9yQmVoYXZpb3JzLnN0cm9uZ1Nob3J0Y3V0LCBjb3JlRGVjb3JhdG9yQmVoYXZpb3JzLmVtU2hvcnRjdXQsIGNvcmVEZWNvcmF0b3JCZWhhdmlvcnMudW5kZXJsaW5lU2hvcnRjdXQsIGNvcmVEZWNvcmF0b3JCZWhhdmlvcnMuY29kZVNob3J0Y3V0LCBjb3JlQmxvY2tPYmplY3RCZWhhdmlvcnMuYXJyb3dEb3duT25Mb25lbHlCbG9ja09iamVjdCwgY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzLmFycm93VXBPbkxvbmVseUJsb2NrT2JqZWN0LCBjb3JlQmxvY2tPYmplY3RCZWhhdmlvcnMuYnJlYWtpbmdCbG9ja09iamVjdCwgY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzLmRlbGV0aW5nRW1wdHlUZXh0QmxvY2tBZnRlckJsb2NrT2JqZWN0LCBjb3JlQmxvY2tPYmplY3RCZWhhdmlvcnMuZGVsZXRpbmdFbXB0eVRleHRCbG9ja0JlZm9yZUJsb2NrT2JqZWN0LCBjb3JlTGlzdEJlaGF2aW9ycy5jbGVhckxpc3RPbkJhY2tzcGFjZSwgY29yZUxpc3RCZWhhdmlvcnMudW5pbmRlbnRMaXN0T25CYWNrc3BhY2UsIGNvcmVMaXN0QmVoYXZpb3JzLmNsZWFyTGlzdE9uRW50ZXIsIGNvcmVMaXN0QmVoYXZpb3JzLmluZGVudExpc3RPblRhYiwgY29yZUxpc3RCZWhhdmlvcnMudW5pbmRlbnRMaXN0T25TaGlmdFRhYiwgY29yZUluc2VydEJyZWFrQmVoYXZpb3JzLmJyZWFraW5nQXRUaGVFbmRPZlRleHRCbG9jaywgY29yZUluc2VydEJyZWFrQmVoYXZpb3JzLmJyZWFraW5nQXRUaGVTdGFydE9mVGV4dEJsb2NrXTtcbmV4cG9ydCB7XG4gIGNvcmVCZWhhdmlvcnMsXG4gIGRlZmluZUJlaGF2aW9yLFxuICBpc0N1c3RvbUJlaGF2aW9yRXZlbnQsXG4gIGlzSG90a2V5LFxuICByYWlzZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlaGF2aW9yLmNvcmUuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/behavior.core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/behavior.markdown.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/behavior.markdown.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMarkdownBehaviors: () => (/* binding */ createMarkdownBehaviors)\n/* harmony export */ });\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var _selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selector.is-at-the-start-of-block.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-at-the-start-of-block.js\");\n/* harmony import */ var _util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.slice-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\");\n/* harmony import */ var _selector_get_text_before_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./selector.get-text-before.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.get-text-before.js\");\n/* harmony import */ var _behavior_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./behavior.core.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/behavior.core.js\");\n\n\n\n\n\nfunction createMarkdownBehaviors(config) {\n  const automaticBlockquoteOnSpace = (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if (event.text !== \" \")\n        return !1;\n      const selectionCollapsed = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)(snapshot), focusTextBlock = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)(snapshot), focusSpan = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getFocusSpan)(snapshot);\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const previousInlineObject = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getPreviousInlineObject)(snapshot), blockOffset = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_2__.spanSelectionPointToBlockOffset)({\n        value: snapshot.context.value,\n        selectionPoint: {\n          path: [{\n            _key: focusTextBlock.node._key\n          }, \"children\", {\n            _key: focusSpan.node._key\n          }],\n          offset: snapshot.context.selection?.focus.offset ?? 0\n        }\n      });\n      if (previousInlineObject || !blockOffset)\n        return !1;\n      const blockText = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_2__.getTextBlockText)(focusTextBlock.node), caretAtTheEndOfQuote = blockOffset.offset === 1, looksLikeMarkdownQuote = /^>/.test(blockText), blockquoteStyle = config.blockquoteStyle?.(snapshot.context);\n      return caretAtTheEndOfQuote && looksLikeMarkdownQuote && blockquoteStyle !== void 0 ? {\n        focusTextBlock,\n        style: blockquoteStyle\n      } : !1;\n    },\n    actions: [() => [{\n      type: \"insert.text\",\n      text: \" \"\n    }], (_, {\n      focusTextBlock,\n      style\n    }) => [{\n      type: \"block.unset\",\n      props: [\"listItem\", \"level\"],\n      at: focusTextBlock.path\n    }, {\n      type: \"block.set\",\n      props: {\n        style\n      },\n      at: focusTextBlock.path\n    }, {\n      type: \"delete.text\",\n      anchor: {\n        path: focusTextBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: focusTextBlock.path,\n        offset: 2\n      }\n    }]]\n  }), automaticHr = (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      const hrCharacter = event.text === \"-\" ? \"-\" : event.text === \"*\" ? \"*\" : event.text === \"_\" ? \"_\" : void 0;\n      if (hrCharacter === void 0)\n        return !1;\n      const hrObject = config.horizontalRuleObject?.(snapshot.context), focusBlock = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)(snapshot), selectionCollapsed = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)(snapshot);\n      if (!hrObject || !focusBlock || !selectionCollapsed)\n        return !1;\n      const previousInlineObject = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getPreviousInlineObject)(snapshot), textBefore = (0,_selector_get_text_before_js__WEBPACK_IMPORTED_MODULE_3__.getBlockTextBefore)(snapshot), hrBlockOffsets = {\n        anchor: {\n          path: focusBlock.path,\n          offset: 0\n        },\n        focus: {\n          path: focusBlock.path,\n          offset: 3\n        }\n      };\n      return !previousInlineObject && textBefore === `${hrCharacter}${hrCharacter}` ? {\n        hrObject,\n        focusBlock,\n        hrCharacter,\n        hrBlockOffsets\n      } : !1;\n    },\n    actions: [(_, {\n      hrCharacter\n    }) => [{\n      type: \"insert.text\",\n      text: hrCharacter\n    }], (_, {\n      hrObject,\n      hrBlockOffsets\n    }) => [{\n      type: \"insert.block object\",\n      placement: \"before\",\n      blockObject: hrObject\n    }, {\n      type: \"delete.text\",\n      ...hrBlockOffsets\n    }]]\n  }), automaticHrOnPaste = (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"paste\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      const text = event.data.getData(\"text/plain\"), hrRegExp = /^(---)$|(___)$|(\\*\\*\\*)$/gm, hrCharacters = text.match(hrRegExp)?.[0], hrObject = config.horizontalRuleObject?.(snapshot.context), focusBlock = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getFocusBlock)(snapshot);\n      return !hrCharacters || !hrObject || !focusBlock ? !1 : {\n        hrCharacters,\n        hrObject,\n        focusBlock\n      };\n    },\n    actions: [(_, {\n      hrCharacters\n    }) => [{\n      type: \"insert.text\",\n      text: hrCharacters\n    }], (_, {\n      hrObject,\n      focusBlock\n    }) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_4__.isPortableTextTextBlock)(focusBlock.node) ? [{\n      type: \"insert.text block\",\n      textBlock: {\n        children: focusBlock.node.children\n      },\n      placement: \"after\"\n    }, {\n      type: \"insert.block object\",\n      blockObject: hrObject,\n      placement: \"after\"\n    }, {\n      type: \"delete.block\",\n      blockPath: focusBlock.path\n    }] : [{\n      type: \"insert.block object\",\n      blockObject: hrObject,\n      placement: \"after\"\n    }]]\n  }), automaticHeadingOnSpace = (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if (event.text !== \" \")\n        return !1;\n      const selectionCollapsed = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)(snapshot), focusTextBlock = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)(snapshot), focusSpan = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getFocusSpan)(snapshot);\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const blockOffset = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_2__.spanSelectionPointToBlockOffset)({\n        value: snapshot.context.value,\n        selectionPoint: {\n          path: [{\n            _key: focusTextBlock.node._key\n          }, \"children\", {\n            _key: focusSpan.node._key\n          }],\n          offset: snapshot.context.selection?.focus.offset ?? 0\n        }\n      });\n      if (!blockOffset)\n        return !1;\n      const previousInlineObject = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getPreviousInlineObject)(snapshot), blockText = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_2__.getTextBlockText)(focusTextBlock.node), markdownHeadingSearch = /^#+/.exec(blockText), level = markdownHeadingSearch ? markdownHeadingSearch[0].length : void 0, caretAtTheEndOfHeading = blockOffset.offset === level;\n      if (previousInlineObject || !caretAtTheEndOfHeading)\n        return !1;\n      const style = level !== void 0 ? config.headingStyle?.({\n        schema: snapshot.context.schema,\n        level\n      }) : void 0;\n      return level !== void 0 && style !== void 0 ? {\n        focusTextBlock,\n        style,\n        level\n      } : !1;\n    },\n    actions: [({\n      event\n    }) => [event], (_, {\n      focusTextBlock,\n      style,\n      level\n    }) => [{\n      type: \"block.unset\",\n      props: [\"listItem\", \"level\"],\n      at: focusTextBlock.path\n    }, {\n      type: \"block.set\",\n      props: {\n        style\n      },\n      at: focusTextBlock.path\n    }, {\n      type: \"delete.text\",\n      anchor: {\n        path: focusTextBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: focusTextBlock.path,\n        offset: level + 1\n      }\n    }]]\n  }), clearStyleOnBackspace = (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"delete.backward\",\n    guard: ({\n      snapshot\n    }) => {\n      const selectionCollapsed = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)(snapshot), focusTextBlock = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)(snapshot), focusSpan = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getFocusSpan)(snapshot);\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const atTheBeginningOfBLock = focusTextBlock.node.children[0]._key === focusSpan.node._key && snapshot.context.selection?.focus.offset === 0, defaultStyle = config.defaultStyle?.(snapshot.context);\n      return atTheBeginningOfBLock && defaultStyle && focusTextBlock.node.style !== defaultStyle ? {\n        defaultStyle,\n        focusTextBlock\n      } : !1;\n    },\n    actions: [(_, {\n      defaultStyle,\n      focusTextBlock\n    }) => [{\n      type: \"block.set\",\n      props: {\n        style: defaultStyle\n      },\n      at: focusTextBlock.path\n    }]]\n  }), automaticListOnSpace = (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if (event.text !== \" \")\n        return !1;\n      const selectionCollapsed = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)(snapshot), focusTextBlock = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)(snapshot), focusSpan = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getFocusSpan)(snapshot);\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const previousInlineObject = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getPreviousInlineObject)(snapshot), blockOffset = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_2__.spanSelectionPointToBlockOffset)({\n        value: snapshot.context.value,\n        selectionPoint: {\n          path: [{\n            _key: focusTextBlock.node._key\n          }, \"children\", {\n            _key: focusSpan.node._key\n          }],\n          offset: snapshot.context.selection?.focus.offset ?? 0\n        }\n      });\n      if (previousInlineObject || !blockOffset)\n        return !1;\n      const blockText = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_2__.getTextBlockText)(focusTextBlock.node), defaultStyle = config.defaultStyle?.(snapshot.context), looksLikeUnorderedList = /^(-|\\*)/.test(blockText), unorderedListStyle = config.unorderedListStyle?.(snapshot.context), caretAtTheEndOfUnorderedList = blockOffset.offset === 1;\n      if (defaultStyle && caretAtTheEndOfUnorderedList && looksLikeUnorderedList && unorderedListStyle !== void 0)\n        return {\n          focusTextBlock,\n          listItem: unorderedListStyle,\n          listItemLength: 1,\n          style: defaultStyle\n        };\n      const looksLikeOrderedList = /^1\\./.test(blockText), orderedListStyle = config.orderedListStyle?.(snapshot.context), caretAtTheEndOfOrderedList = blockOffset.offset === 2;\n      return defaultStyle && caretAtTheEndOfOrderedList && looksLikeOrderedList && orderedListStyle !== void 0 ? {\n        focusTextBlock,\n        listItem: orderedListStyle,\n        listItemLength: 2,\n        style: defaultStyle\n      } : !1;\n    },\n    actions: [({\n      event\n    }) => [event], (_, {\n      focusTextBlock,\n      style,\n      listItem,\n      listItemLength\n    }) => [{\n      type: \"block.set\",\n      props: {\n        listItem,\n        level: 1,\n        style\n      },\n      at: focusTextBlock.path\n    }, {\n      type: \"delete.text\",\n      anchor: {\n        path: focusTextBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: focusTextBlock.path,\n        offset: listItemLength + 1\n      }\n    }]]\n  });\n  return [automaticBlockquoteOnSpace, automaticHeadingOnSpace, automaticHr, automaticHrOnPaste, clearStyleOnBackspace, automaticListOnSpace];\n}\n\n//# sourceMappingURL=behavior.markdown.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvYmVoYXZpb3IubWFya2Rvd24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXdEO0FBQytGO0FBQzVEO0FBQ3hCO0FBQ2Y7QUFDcEQ7QUFDQSxxQ0FBcUMsaUVBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQywyRkFBb0IsNkJBQTZCLHdGQUFpQix3QkFBd0IsbUZBQVk7QUFDdkk7QUFDQTtBQUNBLG1DQUFtQyw4RkFBdUIsMEJBQTBCLHNGQUErQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx3QkFBd0IsdUVBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLGlCQUFpQixpRUFBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsd0ZBQWlCLGlDQUFpQywyRkFBb0I7QUFDM0o7QUFDQTtBQUNBLG1DQUFtQyw4RkFBdUIseUJBQXlCLGdGQUFrQjtBQUNyRztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZLEVBQUUsWUFBWTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyx3QkFBd0IsaUVBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaU5BQWlOLG9GQUFhO0FBQzlOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLEtBQUssc0VBQXVCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyw2QkFBNkIsaUVBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQywyRkFBb0IsNkJBQTZCLHdGQUFpQix3QkFBd0IsbUZBQVk7QUFDdkk7QUFDQTtBQUNBLDBCQUEwQixzRkFBK0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsbUNBQW1DLDhGQUF1Qix3QkFBd0IsdUVBQWdCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRywyQkFBMkIsaUVBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlDQUFpQywyRkFBb0IsNkJBQTZCLHdGQUFpQix3QkFBd0IsbUZBQVk7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUcsMEJBQTBCLGlFQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQ0FBaUMsMkZBQW9CLDZCQUE2Qix3RkFBaUIsd0JBQXdCLG1GQUFZO0FBQ3ZJO0FBQ0E7QUFDQSxtQ0FBbUMsOEZBQXVCLDBCQUEwQixzRkFBK0I7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esd0JBQXdCLHVFQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL21hY2Jvb2twcm8vRG93bmxvYWRzL2NvbmljYXBwcy9pZ2VuZS9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvYmVoYXZpb3IubWFya2Rvd24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2sgfSBmcm9tIFwiQHNhbml0eS90eXBlc1wiO1xuaW1wb3J0IHsgaXNTZWxlY3Rpb25Db2xsYXBzZWQsIGdldEZvY3VzVGV4dEJsb2NrLCBnZXRGb2N1c1NwYW4sIGdldFByZXZpb3VzSW5saW5lT2JqZWN0LCBnZXRGb2N1c0Jsb2NrIH0gZnJvbSBcIi4vc2VsZWN0b3IuaXMtYXQtdGhlLXN0YXJ0LW9mLWJsb2NrLmpzXCI7XG5pbXBvcnQgeyBzcGFuU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0LCBnZXRUZXh0QmxvY2tUZXh0IH0gZnJvbSBcIi4vdXRpbC5zbGljZS1ibG9ja3MuanNcIjtcbmltcG9ydCB7IGdldEJsb2NrVGV4dEJlZm9yZSB9IGZyb20gXCIuL3NlbGVjdG9yLmdldC10ZXh0LWJlZm9yZS5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lQmVoYXZpb3IgfSBmcm9tIFwiLi9iZWhhdmlvci5jb3JlLmpzXCI7XG5mdW5jdGlvbiBjcmVhdGVNYXJrZG93bkJlaGF2aW9ycyhjb25maWcpIHtcbiAgY29uc3QgYXV0b21hdGljQmxvY2txdW90ZU9uU3BhY2UgPSBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiaW5zZXJ0LnRleHRcIixcbiAgICBndWFyZDogKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoZXZlbnQudGV4dCAhPT0gXCIgXCIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkKHNuYXBzaG90KSwgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCksIGZvY3VzU3BhbiA9IGdldEZvY3VzU3BhbihzbmFwc2hvdCk7XG4gICAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIWZvY3VzU3BhbilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgcHJldmlvdXNJbmxpbmVPYmplY3QgPSBnZXRQcmV2aW91c0lubGluZU9iamVjdChzbmFwc2hvdCksIGJsb2NrT2Zmc2V0ID0gc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCh7XG4gICAgICAgIHZhbHVlOiBzbmFwc2hvdC5jb250ZXh0LnZhbHVlLFxuICAgICAgICBzZWxlY3Rpb25Qb2ludDoge1xuICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICBfa2V5OiBmb2N1c1RleHRCbG9jay5ub2RlLl9rZXlcbiAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgIF9rZXk6IGZvY3VzU3Bhbi5ub2RlLl9rZXlcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBvZmZzZXQ6IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uPy5mb2N1cy5vZmZzZXQgPz8gMFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChwcmV2aW91c0lubGluZU9iamVjdCB8fCAhYmxvY2tPZmZzZXQpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGJsb2NrVGV4dCA9IGdldFRleHRCbG9ja1RleHQoZm9jdXNUZXh0QmxvY2subm9kZSksIGNhcmV0QXRUaGVFbmRPZlF1b3RlID0gYmxvY2tPZmZzZXQub2Zmc2V0ID09PSAxLCBsb29rc0xpa2VNYXJrZG93blF1b3RlID0gL14+Ly50ZXN0KGJsb2NrVGV4dCksIGJsb2NrcXVvdGVTdHlsZSA9IGNvbmZpZy5ibG9ja3F1b3RlU3R5bGU/LihzbmFwc2hvdC5jb250ZXh0KTtcbiAgICAgIHJldHVybiBjYXJldEF0VGhlRW5kT2ZRdW90ZSAmJiBsb29rc0xpa2VNYXJrZG93blF1b3RlICYmIGJsb2NrcXVvdGVTdHlsZSAhPT0gdm9pZCAwID8ge1xuICAgICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgICAgc3R5bGU6IGJsb2NrcXVvdGVTdHlsZVxuICAgICAgfSA6ICExO1xuICAgIH0sXG4gICAgYWN0aW9uczogWygpID0+IFt7XG4gICAgICB0eXBlOiBcImluc2VydC50ZXh0XCIsXG4gICAgICB0ZXh0OiBcIiBcIlxuICAgIH1dLCAoXywge1xuICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICBzdHlsZVxuICAgIH0pID0+IFt7XG4gICAgICB0eXBlOiBcImJsb2NrLnVuc2V0XCIsXG4gICAgICBwcm9wczogW1wibGlzdEl0ZW1cIiwgXCJsZXZlbFwiXSxcbiAgICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJibG9jay5zZXRcIixcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHN0eWxlXG4gICAgICB9LFxuICAgICAgYXQ6IGZvY3VzVGV4dEJsb2NrLnBhdGhcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcImRlbGV0ZS50ZXh0XCIsXG4gICAgICBhbmNob3I6IHtcbiAgICAgICAgcGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuICAgICAgZm9jdXM6IHtcbiAgICAgICAgcGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aCxcbiAgICAgICAgb2Zmc2V0OiAyXG4gICAgICB9XG4gICAgfV1dXG4gIH0pLCBhdXRvbWF0aWNIciA9IGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJpbnNlcnQudGV4dFwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGhyQ2hhcmFjdGVyID0gZXZlbnQudGV4dCA9PT0gXCItXCIgPyBcIi1cIiA6IGV2ZW50LnRleHQgPT09IFwiKlwiID8gXCIqXCIgOiBldmVudC50ZXh0ID09PSBcIl9cIiA/IFwiX1wiIDogdm9pZCAwO1xuICAgICAgaWYgKGhyQ2hhcmFjdGVyID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGhyT2JqZWN0ID0gY29uZmlnLmhvcml6b250YWxSdWxlT2JqZWN0Py4oc25hcHNob3QuY29udGV4dCksIGZvY3VzQmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCksIHNlbGVjdGlvbkNvbGxhcHNlZCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkKHNuYXBzaG90KTtcbiAgICAgIGlmICghaHJPYmplY3QgfHwgIWZvY3VzQmxvY2sgfHwgIXNlbGVjdGlvbkNvbGxhcHNlZClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgcHJldmlvdXNJbmxpbmVPYmplY3QgPSBnZXRQcmV2aW91c0lubGluZU9iamVjdChzbmFwc2hvdCksIHRleHRCZWZvcmUgPSBnZXRCbG9ja1RleHRCZWZvcmUoc25hcHNob3QpLCBockJsb2NrT2Zmc2V0cyA9IHtcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgcGF0aDogZm9jdXNCbG9jay5wYXRoLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBmb2N1czoge1xuICAgICAgICAgIHBhdGg6IGZvY3VzQmxvY2sucGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IDNcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiAhcHJldmlvdXNJbmxpbmVPYmplY3QgJiYgdGV4dEJlZm9yZSA9PT0gYCR7aHJDaGFyYWN0ZXJ9JHtockNoYXJhY3Rlcn1gID8ge1xuICAgICAgICBock9iamVjdCxcbiAgICAgICAgZm9jdXNCbG9jayxcbiAgICAgICAgaHJDaGFyYWN0ZXIsXG4gICAgICAgIGhyQmxvY2tPZmZzZXRzXG4gICAgICB9IDogITE7XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKF8sIHtcbiAgICAgIGhyQ2hhcmFjdGVyXG4gICAgfSkgPT4gW3tcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LnRleHRcIixcbiAgICAgIHRleHQ6IGhyQ2hhcmFjdGVyXG4gICAgfV0sIChfLCB7XG4gICAgICBock9iamVjdCxcbiAgICAgIGhyQmxvY2tPZmZzZXRzXG4gICAgfSkgPT4gW3tcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrIG9iamVjdFwiLFxuICAgICAgcGxhY2VtZW50OiBcImJlZm9yZVwiLFxuICAgICAgYmxvY2tPYmplY3Q6IGhyT2JqZWN0XG4gICAgfSwge1xuICAgICAgdHlwZTogXCJkZWxldGUudGV4dFwiLFxuICAgICAgLi4uaHJCbG9ja09mZnNldHNcbiAgICB9XV1cbiAgfSksIGF1dG9tYXRpY0hyT25QYXN0ZSA9IGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJwYXN0ZVwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHRleHQgPSBldmVudC5kYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpLCBoclJlZ0V4cCA9IC9eKC0tLSkkfChfX18pJHwoXFwqXFwqXFwqKSQvZ20sIGhyQ2hhcmFjdGVycyA9IHRleHQubWF0Y2goaHJSZWdFeHApPy5bMF0sIGhyT2JqZWN0ID0gY29uZmlnLmhvcml6b250YWxSdWxlT2JqZWN0Py4oc25hcHNob3QuY29udGV4dCksIGZvY3VzQmxvY2sgPSBnZXRGb2N1c0Jsb2NrKHNuYXBzaG90KTtcbiAgICAgIHJldHVybiAhaHJDaGFyYWN0ZXJzIHx8ICFock9iamVjdCB8fCAhZm9jdXNCbG9jayA/ICExIDoge1xuICAgICAgICBockNoYXJhY3RlcnMsXG4gICAgICAgIGhyT2JqZWN0LFxuICAgICAgICBmb2N1c0Jsb2NrXG4gICAgICB9O1xuICAgIH0sXG4gICAgYWN0aW9uczogWyhfLCB7XG4gICAgICBockNoYXJhY3RlcnNcbiAgICB9KSA9PiBbe1xuICAgICAgdHlwZTogXCJpbnNlcnQudGV4dFwiLFxuICAgICAgdGV4dDogaHJDaGFyYWN0ZXJzXG4gICAgfV0sIChfLCB7XG4gICAgICBock9iamVjdCxcbiAgICAgIGZvY3VzQmxvY2tcbiAgICB9KSA9PiBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhmb2N1c0Jsb2NrLm5vZGUpID8gW3tcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LnRleHQgYmxvY2tcIixcbiAgICAgIHRleHRCbG9jazoge1xuICAgICAgICBjaGlsZHJlbjogZm9jdXNCbG9jay5ub2RlLmNoaWxkcmVuXG4gICAgICB9LFxuICAgICAgcGxhY2VtZW50OiBcImFmdGVyXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcImluc2VydC5ibG9jayBvYmplY3RcIixcbiAgICAgIGJsb2NrT2JqZWN0OiBock9iamVjdCxcbiAgICAgIHBsYWNlbWVudDogXCJhZnRlclwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJkZWxldGUuYmxvY2tcIixcbiAgICAgIGJsb2NrUGF0aDogZm9jdXNCbG9jay5wYXRoXG4gICAgfV0gOiBbe1xuICAgICAgdHlwZTogXCJpbnNlcnQuYmxvY2sgb2JqZWN0XCIsXG4gICAgICBibG9ja09iamVjdDogaHJPYmplY3QsXG4gICAgICBwbGFjZW1lbnQ6IFwiYWZ0ZXJcIlxuICAgIH1dXVxuICB9KSwgYXV0b21hdGljSGVhZGluZ09uU3BhY2UgPSBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiaW5zZXJ0LnRleHRcIixcbiAgICBndWFyZDogKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoZXZlbnQudGV4dCAhPT0gXCIgXCIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkKHNuYXBzaG90KSwgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCksIGZvY3VzU3BhbiA9IGdldEZvY3VzU3BhbihzbmFwc2hvdCk7XG4gICAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIWZvY3VzU3BhbilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgYmxvY2tPZmZzZXQgPSBzcGFuU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0KHtcbiAgICAgICAgdmFsdWU6IHNuYXBzaG90LmNvbnRleHQudmFsdWUsXG4gICAgICAgIHNlbGVjdGlvblBvaW50OiB7XG4gICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgIF9rZXk6IGZvY3VzVGV4dEJsb2NrLm5vZGUuX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgX2tleTogZm9jdXNTcGFuLm5vZGUuX2tleVxuICAgICAgICAgIH1dLFxuICAgICAgICAgIG9mZnNldDogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24/LmZvY3VzLm9mZnNldCA/PyAwXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFibG9ja09mZnNldClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgcHJldmlvdXNJbmxpbmVPYmplY3QgPSBnZXRQcmV2aW91c0lubGluZU9iamVjdChzbmFwc2hvdCksIGJsb2NrVGV4dCA9IGdldFRleHRCbG9ja1RleHQoZm9jdXNUZXh0QmxvY2subm9kZSksIG1hcmtkb3duSGVhZGluZ1NlYXJjaCA9IC9eIysvLmV4ZWMoYmxvY2tUZXh0KSwgbGV2ZWwgPSBtYXJrZG93bkhlYWRpbmdTZWFyY2ggPyBtYXJrZG93bkhlYWRpbmdTZWFyY2hbMF0ubGVuZ3RoIDogdm9pZCAwLCBjYXJldEF0VGhlRW5kT2ZIZWFkaW5nID0gYmxvY2tPZmZzZXQub2Zmc2V0ID09PSBsZXZlbDtcbiAgICAgIGlmIChwcmV2aW91c0lubGluZU9iamVjdCB8fCAhY2FyZXRBdFRoZUVuZE9mSGVhZGluZylcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3Qgc3R5bGUgPSBsZXZlbCAhPT0gdm9pZCAwID8gY29uZmlnLmhlYWRpbmdTdHlsZT8uKHtcbiAgICAgICAgc2NoZW1hOiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYSxcbiAgICAgICAgbGV2ZWxcbiAgICAgIH0pIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGxldmVsICE9PSB2b2lkIDAgJiYgc3R5bGUgIT09IHZvaWQgMCA/IHtcbiAgICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICAgIHN0eWxlLFxuICAgICAgICBsZXZlbFxuICAgICAgfSA6ICExO1xuICAgIH0sXG4gICAgYWN0aW9uczogWyh7XG4gICAgICBldmVudFxuICAgIH0pID0+IFtldmVudF0sIChfLCB7XG4gICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgIHN0eWxlLFxuICAgICAgbGV2ZWxcbiAgICB9KSA9PiBbe1xuICAgICAgdHlwZTogXCJibG9jay51bnNldFwiLFxuICAgICAgcHJvcHM6IFtcImxpc3RJdGVtXCIsIFwibGV2ZWxcIl0sXG4gICAgICBhdDogZm9jdXNUZXh0QmxvY2sucGF0aFxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiYmxvY2suc2V0XCIsXG4gICAgICBwcm9wczoge1xuICAgICAgICBzdHlsZVxuICAgICAgfSxcbiAgICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJkZWxldGUudGV4dFwiLFxuICAgICAgYW5jaG9yOiB7XG4gICAgICAgIHBhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGgsXG4gICAgICAgIG9mZnNldDogbGV2ZWwgKyAxXG4gICAgICB9XG4gICAgfV1dXG4gIH0pLCBjbGVhclN0eWxlT25CYWNrc3BhY2UgPSBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiZGVsZXRlLmJhY2t3YXJkXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkKHNuYXBzaG90KSwgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCksIGZvY3VzU3BhbiA9IGdldEZvY3VzU3BhbihzbmFwc2hvdCk7XG4gICAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIWZvY3VzU3BhbilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgYXRUaGVCZWdpbm5pbmdPZkJMb2NrID0gZm9jdXNUZXh0QmxvY2subm9kZS5jaGlsZHJlblswXS5fa2V5ID09PSBmb2N1c1NwYW4ubm9kZS5fa2V5ICYmIHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uPy5mb2N1cy5vZmZzZXQgPT09IDAsIGRlZmF1bHRTdHlsZSA9IGNvbmZpZy5kZWZhdWx0U3R5bGU/LihzbmFwc2hvdC5jb250ZXh0KTtcbiAgICAgIHJldHVybiBhdFRoZUJlZ2lubmluZ09mQkxvY2sgJiYgZGVmYXVsdFN0eWxlICYmIGZvY3VzVGV4dEJsb2NrLm5vZGUuc3R5bGUgIT09IGRlZmF1bHRTdHlsZSA/IHtcbiAgICAgICAgZGVmYXVsdFN0eWxlLFxuICAgICAgICBmb2N1c1RleHRCbG9ja1xuICAgICAgfSA6ICExO1xuICAgIH0sXG4gICAgYWN0aW9uczogWyhfLCB7XG4gICAgICBkZWZhdWx0U3R5bGUsXG4gICAgICBmb2N1c1RleHRCbG9ja1xuICAgIH0pID0+IFt7XG4gICAgICB0eXBlOiBcImJsb2NrLnNldFwiLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgc3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgICAgfSxcbiAgICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gICAgfV1dXG4gIH0pLCBhdXRvbWF0aWNMaXN0T25TcGFjZSA9IGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJpbnNlcnQudGV4dFwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChldmVudC50ZXh0ICE9PSBcIiBcIilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQoc25hcHNob3QpLCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSwgZm9jdXNTcGFuID0gZ2V0Rm9jdXNTcGFuKHNuYXBzaG90KTtcbiAgICAgIGlmICghc2VsZWN0aW9uQ29sbGFwc2VkIHx8ICFmb2N1c1RleHRCbG9jayB8fCAhZm9jdXNTcGFuKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBwcmV2aW91c0lubGluZU9iamVjdCA9IGdldFByZXZpb3VzSW5saW5lT2JqZWN0KHNuYXBzaG90KSwgYmxvY2tPZmZzZXQgPSBzcGFuU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0KHtcbiAgICAgICAgdmFsdWU6IHNuYXBzaG90LmNvbnRleHQudmFsdWUsXG4gICAgICAgIHNlbGVjdGlvblBvaW50OiB7XG4gICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgIF9rZXk6IGZvY3VzVGV4dEJsb2NrLm5vZGUuX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgX2tleTogZm9jdXNTcGFuLm5vZGUuX2tleVxuICAgICAgICAgIH1dLFxuICAgICAgICAgIG9mZnNldDogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24/LmZvY3VzLm9mZnNldCA/PyAwXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHByZXZpb3VzSW5saW5lT2JqZWN0IHx8ICFibG9ja09mZnNldClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgYmxvY2tUZXh0ID0gZ2V0VGV4dEJsb2NrVGV4dChmb2N1c1RleHRCbG9jay5ub2RlKSwgZGVmYXVsdFN0eWxlID0gY29uZmlnLmRlZmF1bHRTdHlsZT8uKHNuYXBzaG90LmNvbnRleHQpLCBsb29rc0xpa2VVbm9yZGVyZWRMaXN0ID0gL14oLXxcXCopLy50ZXN0KGJsb2NrVGV4dCksIHVub3JkZXJlZExpc3RTdHlsZSA9IGNvbmZpZy51bm9yZGVyZWRMaXN0U3R5bGU/LihzbmFwc2hvdC5jb250ZXh0KSwgY2FyZXRBdFRoZUVuZE9mVW5vcmRlcmVkTGlzdCA9IGJsb2NrT2Zmc2V0Lm9mZnNldCA9PT0gMTtcbiAgICAgIGlmIChkZWZhdWx0U3R5bGUgJiYgY2FyZXRBdFRoZUVuZE9mVW5vcmRlcmVkTGlzdCAmJiBsb29rc0xpa2VVbm9yZGVyZWRMaXN0ICYmIHVub3JkZXJlZExpc3RTdHlsZSAhPT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgICAgIGxpc3RJdGVtOiB1bm9yZGVyZWRMaXN0U3R5bGUsXG4gICAgICAgICAgbGlzdEl0ZW1MZW5ndGg6IDEsXG4gICAgICAgICAgc3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgICAgICB9O1xuICAgICAgY29uc3QgbG9va3NMaWtlT3JkZXJlZExpc3QgPSAvXjFcXC4vLnRlc3QoYmxvY2tUZXh0KSwgb3JkZXJlZExpc3RTdHlsZSA9IGNvbmZpZy5vcmRlcmVkTGlzdFN0eWxlPy4oc25hcHNob3QuY29udGV4dCksIGNhcmV0QXRUaGVFbmRPZk9yZGVyZWRMaXN0ID0gYmxvY2tPZmZzZXQub2Zmc2V0ID09PSAyO1xuICAgICAgcmV0dXJuIGRlZmF1bHRTdHlsZSAmJiBjYXJldEF0VGhlRW5kT2ZPcmRlcmVkTGlzdCAmJiBsb29rc0xpa2VPcmRlcmVkTGlzdCAmJiBvcmRlcmVkTGlzdFN0eWxlICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgICBsaXN0SXRlbTogb3JkZXJlZExpc3RTdHlsZSxcbiAgICAgICAgbGlzdEl0ZW1MZW5ndGg6IDIsXG4gICAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICAgIH0gOiAhMTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiBbZXZlbnRdLCAoXywge1xuICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICBzdHlsZSxcbiAgICAgIGxpc3RJdGVtLFxuICAgICAgbGlzdEl0ZW1MZW5ndGhcbiAgICB9KSA9PiBbe1xuICAgICAgdHlwZTogXCJibG9jay5zZXRcIixcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGxpc3RJdGVtLFxuICAgICAgICBsZXZlbDogMSxcbiAgICAgICAgc3R5bGVcbiAgICAgIH0sXG4gICAgICBhdDogZm9jdXNUZXh0QmxvY2sucGF0aFxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiZGVsZXRlLnRleHRcIixcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBmb2N1c1RleHRCbG9jay5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czoge1xuICAgICAgICBwYXRoOiBmb2N1c1RleHRCbG9jay5wYXRoLFxuICAgICAgICBvZmZzZXQ6IGxpc3RJdGVtTGVuZ3RoICsgMVxuICAgICAgfVxuICAgIH1dXVxuICB9KTtcbiAgcmV0dXJuIFthdXRvbWF0aWNCbG9ja3F1b3RlT25TcGFjZSwgYXV0b21hdGljSGVhZGluZ09uU3BhY2UsIGF1dG9tYXRpY0hyLCBhdXRvbWF0aWNIck9uUGFzdGUsIGNsZWFyU3R5bGVPbkJhY2tzcGFjZSwgYXV0b21hdGljTGlzdE9uU3BhY2VdO1xufVxuZXhwb3J0IHtcbiAgY3JlYXRlTWFya2Rvd25CZWhhdmlvcnNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWhhdmlvci5tYXJrZG93bi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/behavior.markdown.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/editor-provider.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/editor-provider.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EditorActorContext: () => (/* binding */ EditorActorContext),\n/* harmony export */   EditorProvider: () => (/* binding */ EditorProvider),\n/* harmony export */   IS_DRAGGING: () => (/* binding */ IS_DRAGGING),\n/* harmony export */   IS_DRAGGING_BLOCK_ELEMENT: () => (/* binding */ IS_DRAGGING_BLOCK_ELEMENT),\n/* harmony export */   IS_DRAGGING_BLOCK_TARGET_POSITION: () => (/* binding */ IS_DRAGGING_BLOCK_TARGET_POSITION),\n/* harmony export */   IS_DRAGGING_ELEMENT_TARGET: () => (/* binding */ IS_DRAGGING_ELEMENT_TARGET),\n/* harmony export */   KEY_TO_VALUE_ELEMENT: () => (/* binding */ KEY_TO_VALUE_ELEMENT),\n/* harmony export */   PortableTextEditor: () => (/* binding */ PortableTextEditor),\n/* harmony export */   debugWithName: () => (/* binding */ debugWithName),\n/* harmony export */   defaultKeyGenerator: () => (/* binding */ defaultKeyGenerator),\n/* harmony export */   defineSchema: () => (/* binding */ defineSchema),\n/* harmony export */   fromSlateValue: () => (/* binding */ fromSlateValue),\n/* harmony export */   isEqualToEmptyEditor: () => (/* binding */ isEqualToEmptyEditor),\n/* harmony export */   moveRangeByOperation: () => (/* binding */ moveRangeByOperation),\n/* harmony export */   toPortableTextRange: () => (/* binding */ toPortableTextRange),\n/* harmony export */   toSlateRange: () => (/* binding */ toSlateRange),\n/* harmony export */   toSlateValue: () => (/* binding */ toSlateValue),\n/* harmony export */   useEditor: () => (/* binding */ useEditor),\n/* harmony export */   useEditorSelector: () => (/* binding */ useEditorSelector),\n/* harmony export */   usePortableTextEditor: () => (/* binding */ usePortableTextEditor),\n/* harmony export */   usePortableTextEditorSelection: () => (/* binding */ usePortableTextEditorSelection)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-compiler-runtime */ \"(ssr)/./node_modules/react-compiler-runtime/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! slate-react */ \"(ssr)/./node_modules/slate-react/dist/index.es.js\");\n/* harmony import */ var _xstate_react__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @xstate/react */ \"(ssr)/./node_modules/@xstate/react/dist/xstate-react.development.esm.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/./node_modules/lodash/isEqual.js\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/xstate.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/log-0acd9069.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/raise-1db27a82.development.esm.js\");\n/* harmony import */ var _portabletext_patches__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @portabletext/patches */ \"(ssr)/./node_modules/@portabletext/patches/dist/index.js\");\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/flatten.js */ \"(ssr)/./node_modules/lodash/flatten.js\");\n/* harmony import */ var lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/isPlainObject.js */ \"(ssr)/./node_modules/lodash/isPlainObject.js\");\n/* harmony import */ var lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/uniq.js */ \"(ssr)/./node_modules/lodash/uniq.js\");\n/* harmony import */ var get_random_values_esm__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! get-random-values-esm */ \"(ssr)/./node_modules/get-random-values-esm/index.mjs\");\n/* harmony import */ var _util_block_offsets_to_selection_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./util.block-offsets-to-selection.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.block-offsets-to-selection.js\");\n/* harmony import */ var _util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./util.slice-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\");\n/* harmony import */ var _portabletext_block_tools__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @portabletext/block-tools */ \"(ssr)/./node_modules/@portabletext/block-tools/lib/index.js\");\n/* harmony import */ var _portabletext_to_html__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @portabletext/to-html */ \"(ssr)/./node_modules/@portabletext/to-html/dist/pt-to-html.mjs\");\n/* harmony import */ var _sanity_schema__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @sanity/schema */ \"(ssr)/./node_modules/@sanity/schema/lib/index.mjs\");\n/* harmony import */ var lodash_get_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/get.js */ \"(ssr)/./node_modules/lodash/get.js\");\n/* harmony import */ var lodash_isUndefined_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash/isUndefined.js */ \"(ssr)/./node_modules/lodash/isUndefined.js\");\n/* harmony import */ var lodash_omitBy_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash/omitBy.js */ \"(ssr)/./node_modules/lodash/omitBy.js\");\n/* harmony import */ var _selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./selector.is-at-the-start-of-block.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-at-the-start-of-block.js\");\n/* harmony import */ var _selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./selector.is-active-style.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-active-style.js\");\n/* harmony import */ var lodash_omit_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash/omit.js */ \"(ssr)/./node_modules/lodash/omit.js\");\n/* harmony import */ var lodash_startcase__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash.startcase */ \"(ssr)/./node_modules/lodash.startcase/index.js\");\n/* harmony import */ var _behavior_core_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./behavior.core.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/behavior.core.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Subject.js\");\n/* harmony import */ var use_effect_event__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! use-effect-event */ \"(ssr)/./node_modules/use-effect-event/dist/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction createEditorSchema(portableTextType) {\n  if (!portableTextType)\n    throw new Error(\"Parameter 'portabletextType' missing (required)\");\n  const blockType = portableTextType.of?.find(findBlockType);\n  if (!blockType)\n    throw new Error(\"Block type is not defined in this schema (required)\");\n  const childrenField = blockType.fields?.find((field) => field.name === \"children\");\n  if (!childrenField)\n    throw new Error(\"Children field for block type found in schema (required)\");\n  const ofType = childrenField.type.of;\n  if (!ofType)\n    throw new Error(\"Valid types for block children not found in schema (required)\");\n  const spanType = ofType.find((memberType) => memberType.name === \"span\");\n  if (!spanType)\n    throw new Error(\"Span type not found in schema (required)\");\n  const inlineObjectTypes = ofType.filter((memberType) => memberType.name !== \"span\") || [], blockObjectTypes = portableTextType.of?.filter((field) => field.name !== blockType.name) || [];\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    lists: resolveEnabledListItems(blockType),\n    block: blockType,\n    span: spanType,\n    portableText: portableTextType,\n    inlineObjects: inlineObjectTypes,\n    blockObjects: blockObjectTypes,\n    annotations: spanType.annotations\n  };\n}\nfunction resolveEnabledStyles(blockType) {\n  const styleField = blockType.fields?.find((btField) => btField.name === \"style\");\n  if (!styleField)\n    throw new Error(\"A field with name 'style' is not defined in the block type (required).\");\n  const textStyles = styleField.type.options?.list && styleField.type.options.list?.filter((style) => style.value);\n  if (!textStyles || textStyles.length === 0)\n    throw new Error(\"The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.\");\n  return textStyles;\n}\nfunction resolveEnabledDecorators(spanType) {\n  return spanType.decorators;\n}\nfunction resolveEnabledListItems(blockType) {\n  const listField = blockType.fields?.find((btField) => btField.name === \"listItem\");\n  if (!listField)\n    throw new Error(\"A field with name 'listItem' is not defined in the block type (required).\");\n  const listItems = listField.type.options?.list && listField.type.options.list.filter((list) => list.value);\n  if (!listItems)\n    throw new Error(\"The list field need at least to be an empty array\");\n  return listItems;\n}\nfunction findBlockType(type) {\n  return type.type ? findBlockType(type.type) : type.name === \"block\" ? type : null;\n}\nfunction defineSchema(definition) {\n  return definition;\n}\nfunction compileSchemaDefinition(definition) {\n  const blockObjects = definition?.blockObjects?.map((blockObject) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.defineType)({\n    type: \"object\",\n    // Very naive way to work around `SanitySchema.compile` adding default\n    // fields to objects with the name `image`\n    name: blockObject.name === \"image\" ? \"tmp-image\" : blockObject.name,\n    title: blockObject.name === \"image\" && blockObject.title === void 0 ? \"Image\" : blockObject.title,\n    fields: []\n  })) ?? [], inlineObjects = definition?.inlineObjects?.map((inlineObject) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.defineType)({\n    type: \"object\",\n    name: inlineObject.name,\n    title: inlineObject.title,\n    fields: []\n  })) ?? [], portableTextSchema = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.defineField)({\n    type: \"array\",\n    name: \"portable-text\",\n    of: [...blockObjects.map((blockObject) => ({\n      type: blockObject.name\n    })), {\n      type: \"block\",\n      name: \"block\",\n      of: inlineObjects.map((inlineObject) => ({\n        type: inlineObject.name\n      })),\n      marks: {\n        decorators: definition?.decorators?.map((decorator) => ({\n          title: decorator.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_12__(decorator.name),\n          value: decorator.name\n        })) ?? [],\n        annotations: definition?.annotations?.map((annotation) => ({\n          name: annotation.name,\n          type: \"object\",\n          title: annotation.title\n        })) ?? []\n      },\n      lists: definition?.lists?.map((list) => ({\n        value: list.name,\n        title: list.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_12__(list.name)\n      })) ?? [],\n      styles: definition?.styles?.map((style) => ({\n        value: style.name,\n        title: style.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_12__(style.name)\n      })) ?? []\n    }]\n  }), schema = _sanity_schema__WEBPACK_IMPORTED_MODULE_14__.Schema.compile({\n    types: [portableTextSchema, ...blockObjects, ...inlineObjects]\n  }).get(\"portable-text\"), pteSchema = createEditorSchema(schema);\n  return {\n    ...pteSchema,\n    blockObjects: pteSchema.blockObjects.map((blockObject) => blockObject.name === \"tmp-image\" ? {\n      ...blockObject,\n      name: \"image\",\n      type: {\n        ...blockObject.type,\n        name: \"image\"\n      }\n    } : blockObject)\n  };\n}\nconst rootName = \"sanity-pte:\";\ndebug__WEBPACK_IMPORTED_MODULE_3__(rootName);\nfunction debugWithName(name) {\n  const namespace = `${rootName}${name}`;\n  return debug__WEBPACK_IMPORTED_MODULE_3__ && debug__WEBPACK_IMPORTED_MODULE_3__.enabled(namespace) ? debug__WEBPACK_IMPORTED_MODULE_3__(namespace) : debug__WEBPACK_IMPORTED_MODULE_3__(rootName);\n}\nfunction createKeyedPath(point, value, types) {\n  const blockPath = [point.path[0]];\n  if (!value)\n    return null;\n  const block = value[blockPath[0]];\n  if (!block)\n    return null;\n  const keyedBlockPath = [{\n    _key: block._key\n  }];\n  if (block._type !== types.block.name)\n    return keyedBlockPath;\n  let keyedChildPath;\n  const childPath = point.path.slice(0, 2), child = Array.isArray(block.children) && block.children[childPath[1]];\n  return child && (keyedChildPath = [\"children\", {\n    _key: child._key\n  }]), keyedChildPath ? [...keyedBlockPath, ...keyedChildPath] : keyedBlockPath;\n}\nfunction toSlatePath(path, editor) {\n  if (!editor)\n    return [];\n  const [block, blockPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n    at: [],\n    match: (n) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isKeySegment)(path[0]) && n._key === path[0]._key\n  }))[0] || [void 0, void 0];\n  if (!block || !slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block))\n    return [];\n  if (editor.isVoid(block))\n    return [blockPath[0], 0];\n  const childPath = [path[2]], childIndex = block.children.findIndex((child) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_4__([{\n    _key: child._key\n  }], childPath));\n  if (childIndex >= 0 && block.children[childIndex]) {\n    const child = block.children[childIndex];\n    return slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(child) && editor.isVoid(child) ? blockPath.concat(childIndex).concat(0) : blockPath.concat(childIndex);\n  }\n  return [blockPath[0], 0];\n}\nfunction toPortableTextRange(value, range, types) {\n  if (!range)\n    return null;\n  let anchor = null, focus = null;\n  const anchorPath = range.anchor && createKeyedPath(range.anchor, value, types);\n  anchorPath && range.anchor && (anchor = {\n    path: anchorPath,\n    offset: range.anchor.offset\n  });\n  const focusPath = range.focus && createKeyedPath(range.focus, value, types);\n  focusPath && range.focus && (focus = {\n    path: focusPath,\n    offset: range.focus.offset\n  });\n  const backward = !!(slate__WEBPACK_IMPORTED_MODULE_15__.Range.isRange(range) && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isBackward(range));\n  return anchor && focus ? {\n    anchor,\n    focus,\n    backward\n  } : null;\n}\nfunction toSlateRange(selection, editor) {\n  if (!selection || !editor)\n    return null;\n  const anchor = {\n    path: toSlatePath(selection.anchor.path, editor),\n    offset: selection.anchor.offset\n  }, focus = {\n    path: toSlatePath(selection.focus.path, editor),\n    offset: selection.focus.offset\n  };\n  return focus.path.length === 0 || anchor.path.length === 0 ? null : focus ? {\n    anchor,\n    focus\n  } : null;\n}\nfunction moveRangeByOperation(range, operation) {\n  const anchor = slate__WEBPACK_IMPORTED_MODULE_15__.Point.transform(range.anchor, operation), focus = slate__WEBPACK_IMPORTED_MODULE_15__.Point.transform(range.focus, operation);\n  return anchor === null || focus === null ? null : slate__WEBPACK_IMPORTED_MODULE_15__.Point.equals(anchor, range.anchor) && slate__WEBPACK_IMPORTED_MODULE_15__.Point.equals(focus, range.focus) ? range : {\n    anchor,\n    focus\n  };\n}\nconst VOID_CHILD_KEY = \"void-child\";\nfunction keepObjectEquality(object, keyMap) {\n  const value = keyMap[object._key];\n  return value && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_4__(object, value) ? value : (keyMap[object._key] = object, object);\n}\nfunction toSlateValue(value, {\n  schemaTypes\n}, keyMap = {}) {\n  return value && Array.isArray(value) ? value.map((block) => {\n    const {\n      _type,\n      _key,\n      ...rest\n    } = block, voidChildren = [{\n      _key: VOID_CHILD_KEY,\n      _type: \"span\",\n      text: \"\",\n      marks: []\n    }];\n    if (block && block._type === schemaTypes.block.name) {\n      const textBlock = block;\n      let hasInlines = !1;\n      const hasMissingStyle = typeof textBlock.style > \"u\", hasMissingMarkDefs = typeof textBlock.markDefs > \"u\", hasMissingChildren = typeof textBlock.children > \"u\", children = (textBlock.children || []).map((child) => {\n        const {\n          _type: cType,\n          _key: cKey,\n          ...cRest\n        } = child;\n        return cType !== \"span\" ? (hasInlines = !0, keepObjectEquality({\n          _type: cType,\n          _key: cKey,\n          children: voidChildren,\n          value: cRest,\n          __inline: !0\n        }, keyMap)) : child;\n      });\n      return !hasMissingStyle && !hasMissingMarkDefs && !hasMissingChildren && !hasInlines && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block) ? block : (hasMissingStyle && (rest.style = schemaTypes.styles[0].value), keepObjectEquality({\n        _type,\n        _key,\n        ...rest,\n        children\n      }, keyMap));\n    }\n    return keepObjectEquality({\n      _type,\n      _key,\n      children: voidChildren,\n      value: rest\n    }, keyMap);\n  }) : [];\n}\nfunction fromSlateValue(value, textBlockType, keyMap = {}) {\n  return value.map((block) => {\n    const {\n      _key,\n      _type\n    } = block;\n    if (!_key || !_type)\n      throw new Error(\"Not a valid block\");\n    if (_type === textBlockType && \"children\" in block && Array.isArray(block.children) && _key) {\n      let hasInlines = !1;\n      const children = block.children.map((child) => {\n        const {\n          _type: _cType\n        } = child;\n        if (\"value\" in child && _cType !== \"span\") {\n          hasInlines = !0;\n          const {\n            value: v,\n            _key: k,\n            _type: t,\n            __inline: _i,\n            children: _c,\n            ...rest\n          } = child;\n          return keepObjectEquality({\n            ...rest,\n            ...v,\n            _key: k,\n            _type: t\n          }, keyMap);\n        }\n        return child;\n      });\n      return hasInlines ? keepObjectEquality({\n        ...block,\n        children,\n        _key,\n        _type\n      }, keyMap) : block;\n    }\n    const blockValue = \"value\" in block && block.value;\n    return keepObjectEquality({\n      _key,\n      _type,\n      ...typeof blockValue == \"object\" ? blockValue : {}\n    }, keyMap);\n  });\n}\nfunction isEqualToEmptyEditor(children, schemaTypes) {\n  return children === void 0 || children && Array.isArray(children) && children.length === 0 || children && Array.isArray(children) && children.length === 1 && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(children[0]) && children[0]._type === schemaTypes.block.name && \"style\" in children[0] && children[0].style === schemaTypes.styles[0].value && !(\"listItem\" in children[0]) && Array.isArray(children[0].children) && children[0].children.length === 1 && slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(children[0].children[0]) && children[0].children[0]._type === \"span\" && !children[0].children[0].marks?.join(\"\") && children[0].children[0].text === \"\";\n}\nconst IS_PROCESSING_REMOTE_CHANGES = /* @__PURE__ */ new WeakMap(), IS_DRAGGING = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_BLOCK_ELEMENT = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_ELEMENT_TARGET = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_BLOCK_TARGET_POSITION = /* @__PURE__ */ new WeakMap(), KEY_TO_SLATE_ELEMENT = /* @__PURE__ */ new WeakMap(), KEY_TO_VALUE_ELEMENT = /* @__PURE__ */ new WeakMap(), SLATE_TO_PORTABLE_TEXT_RANGE = /* @__PURE__ */ new WeakMap(), PortableTextEditorContext = (0,react__WEBPACK_IMPORTED_MODULE_2__.createContext)(null), usePortableTextEditor = () => {\n  const editor = (0,react__WEBPACK_IMPORTED_MODULE_2__.useContext)(PortableTextEditorContext);\n  if (!editor)\n    throw new Error(\"The `usePortableTextEditor` hook must be used inside the <PortableTextEditor> component's context.\");\n  return editor;\n};\nfunction compileType(rawType) {\n  return _sanity_schema__WEBPACK_IMPORTED_MODULE_14__.Schema.compile({\n    name: \"blockTypeSchema\",\n    types: [rawType]\n  }).get(rawType.name);\n}\nconst mutationMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_16__.setup)({\n  types: {\n    context: {},\n    events: {},\n    input: {},\n    emitted: {}\n  },\n  actions: {\n    \"emit has pending patches\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)({\n      type: \"has pending patches\"\n    }),\n    \"emit mutations\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.b)(({\n      context,\n      enqueue\n    }) => {\n      for (const bulk of context.pendingMutations)\n        enqueue.emit({\n          type: \"mutation\",\n          patches: bulk.patches,\n          snapshot: bulk.value\n        });\n    }),\n    \"clear pending mutations\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.a)({\n      pendingMutations: []\n    }),\n    \"defer patch\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.a)({\n      pendingMutations: ({\n        context,\n        event\n      }) => {\n        if ((0,xstate__WEBPACK_IMPORTED_MODULE_16__.assertEvent)(event, \"patch\"), context.pendingMutations.length === 0)\n          return [{\n            actionId: event.actionId,\n            value: event.value,\n            patches: [event.patch]\n          }];\n        const lastBulk = context.pendingMutations.at(-1);\n        return lastBulk && lastBulk.actionId === event.actionId ? context.pendingMutations.slice(0, -1).concat({\n          value: event.value,\n          actionId: lastBulk.actionId,\n          patches: [...lastBulk.patches, event.patch]\n        }) : context.pendingMutations.concat({\n          value: event.value,\n          actionId: event.actionId,\n          patches: [event.patch]\n        });\n      }\n    })\n  },\n  actors: {\n    \"type listener\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.fromCallback)(({\n      input,\n      sendBack\n    }) => {\n      const originalApply = input.slateEditor.apply;\n      return input.slateEditor.apply = (op) => {\n        op.type === \"insert_text\" || op.type === \"remove_text\" ? sendBack({\n          type: \"typing\"\n        }) : sendBack({\n          type: \"not typing\"\n        }), originalApply(op);\n      }, () => {\n        input.slateEditor.apply = originalApply;\n      };\n    })\n  },\n  guards: {\n    \"is typing\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.G)({\n      typing: \"typing\"\n    }),\n    \"no pending mutations\": ({\n      context\n    }) => context.pendingMutations.length === 0,\n    \"slate is normalizing\": ({\n      context\n    }) => slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isNormalizing(context.slateEditor)\n  },\n  delays: {\n    \"mutation debounce\":  false ? 0 : 0,\n    \"type debounce\":  false ? 0 : 250\n  }\n}).createMachine({\n  id: \"mutation\",\n  context: ({\n    input\n  }) => ({\n    pendingMutations: [],\n    schema: input.schema,\n    slateEditor: input.slateEditor\n  }),\n  type: \"parallel\",\n  states: {\n    typing: {\n      initial: \"idle\",\n      invoke: {\n        src: \"type listener\",\n        input: ({\n          context\n        }) => ({\n          slateEditor: context.slateEditor\n        })\n      },\n      states: {\n        idle: {\n          on: {\n            typing: {\n              target: \"typing\"\n            }\n          }\n        },\n        typing: {\n          after: {\n            \"type debounce\": {\n              target: \"idle\"\n            }\n          },\n          on: {\n            \"not typing\": {\n              target: \"idle\"\n            },\n            typing: {\n              target: \"typing\",\n              reenter: !0\n            }\n          }\n        }\n      }\n    },\n    mutations: {\n      initial: \"idle\",\n      states: {\n        idle: {\n          on: {\n            patch: {\n              actions: [\"defer patch\", \"emit has pending patches\"],\n              target: \"emitting mutations\"\n            }\n          }\n        },\n        \"emitting mutations\": {\n          after: {\n            \"mutation debounce\": [{\n              guard: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.D)([(0,xstate__WEBPACK_IMPORTED_MODULE_19__.E)(\"is typing\"), \"slate is normalizing\"]),\n              target: \"idle\",\n              actions: [\"emit mutations\", \"clear pending mutations\"]\n            }, {\n              target: \"emitting mutations\",\n              reenter: !0\n            }]\n          },\n          on: {\n            patch: {\n              target: \"emitting mutations\",\n              actions: [\"defer patch\"],\n              reenter: !0\n            }\n          }\n        }\n      }\n    }\n  }\n});\nfunction validateValue(value, types, keyGenerator) {\n  let resolution = null, valid = !0;\n  const validChildTypes = [types.span.name, ...types.inlineObjects.map((t) => t.name)], validBlockTypes = [types.block.name, ...types.blockObjects.map((t) => t.name)];\n  return value === void 0 ? {\n    valid: !0,\n    resolution: null,\n    value\n  } : !Array.isArray(value) || value.length === 0 ? {\n    valid: !1,\n    resolution: {\n      patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([])],\n      description: \"Editor value must be an array of Portable Text blocks, or undefined.\",\n      action: \"Unset the value\",\n      item: value,\n      i18n: {\n        description: \"inputs.portable-text.invalid-value.not-an-array.description\",\n        action: \"inputs.portable-text.invalid-value.not-an-array.action\"\n      }\n    },\n    value\n  } : (value.some((blk, index) => {\n    if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(blk))\n      return resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([index])],\n        description: `Block must be an object, got ${String(blk)}`,\n        action: \"Unset invalid item\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.not-an-object.description\",\n          action: \"inputs.portable-text.invalid-value.not-an-object.action\",\n          values: {\n            index\n          }\n        }\n      }, !0;\n    if (!blk._key || typeof blk._key != \"string\")\n      return resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)({\n          ...blk,\n          _key: keyGenerator()\n        }, [index])],\n        description: `Block at index ${index} is missing required _key.`,\n        action: \"Set the block with a random _key value\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-key.description\",\n          action: \"inputs.portable-text.invalid-value.missing-key.action\",\n          values: {\n            index\n          }\n        }\n      }, !0;\n    if (!blk._type || !validBlockTypes.includes(blk._type)) {\n      if (blk._type === \"block\") {\n        const currentBlockTypeName = types.block.name;\n        return resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)({\n            ...blk,\n            _type: currentBlockTypeName\n          }, [{\n            _key: blk._key\n          }])],\n          description: `Block with _key '${blk._key}' has invalid type name '${blk._type}'. According to the schema, the block type name is '${currentBlockTypeName}'`,\n          action: `Use type '${currentBlockTypeName}'`,\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.incorrect-block-type.description\",\n            action: \"inputs.portable-text.invalid-value.incorrect-block-type.action\",\n            values: {\n              key: blk._key,\n              expectedTypeName: currentBlockTypeName\n            }\n          }\n        }, !0;\n      }\n      return !blk._type && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isPortableTextTextBlock)({\n        ...blk,\n        _type: types.block.name\n      }) ? (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)({\n          ...blk,\n          _type: types.block.name\n        }, [{\n          _key: blk._key\n        }])],\n        description: `Block with _key '${blk._key}' is missing a type name. According to the schema, the block type name is '${types.block.name}'`,\n        action: `Use type '${types.block.name}'`,\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-block-type.description\",\n          action: \"inputs.portable-text.invalid-value.missing-block-type.action\",\n          values: {\n            key: blk._key,\n            expectedTypeName: types.block.name\n          }\n        }\n      }, !0) : blk._type ? (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n          _key: blk._key\n        }])],\n        description: `Block with _key '${blk._key}' has invalid _type '${blk._type}'`,\n        action: \"Remove the block\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.disallowed-type.description\",\n          action: \"inputs.portable-text.invalid-value.disallowed-type.action\",\n          values: {\n            key: blk._key,\n            typeName: blk._type\n          }\n        }\n      }, !0) : (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n          _key: blk._key\n        }])],\n        description: `Block with _key '${blk._key}' is missing an _type property`,\n        action: \"Remove the block\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-type.description\",\n          action: \"inputs.portable-text.invalid-value.missing-type.action\",\n          values: {\n            key: blk._key\n          }\n        }\n      }, !0);\n    }\n    if (blk._type === types.block.name) {\n      const textBlock = blk;\n      if (textBlock.children && !Array.isArray(textBlock.children))\n        return resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)({\n            children: []\n          }, [{\n            _key: textBlock._key\n          }])],\n          description: `Text block with _key '${textBlock._key}' has a invalid required property 'children'.`,\n          action: \"Reset the children property\",\n          item: textBlock,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.missing-or-invalid-children.description\",\n            action: \"inputs.portable-text.invalid-value.missing-or-invalid-children.action\",\n            values: {\n              key: textBlock._key\n            }\n          }\n        }, !0;\n      if (textBlock.children === void 0 || Array.isArray(textBlock.children) && textBlock.children.length === 0) {\n        const newSpan = {\n          _type: types.span.name,\n          _key: keyGenerator(),\n          text: \"\",\n          marks: []\n        };\n        return resolution = {\n          autoResolve: !0,\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.setIfMissing)([], [{\n            _key: blk._key\n          }, \"children\"]), (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([newSpan], \"after\", [{\n            _key: blk._key\n          }, \"children\", 0])],\n          description: `Children for text block with _key '${blk._key}' is empty.`,\n          action: \"Insert an empty text\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.empty-children.description\",\n            action: \"inputs.portable-text.invalid-value.empty-children.action\",\n            values: {\n              key: blk._key\n            }\n          }\n        }, !0;\n      }\n      const allUsedMarks = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__(lodash_flatten_js__WEBPACK_IMPORTED_MODULE_5__(textBlock.children.filter((cld) => cld._type === types.span.name).map((cld) => cld.marks || [])));\n      if (Array.isArray(blk.markDefs) && blk.markDefs.length > 0) {\n        const unusedMarkDefs = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__(blk.markDefs.map((def) => def._key).filter((key) => !allUsedMarks.includes(key)));\n        if (unusedMarkDefs.length > 0)\n          return resolution = {\n            autoResolve: !0,\n            patches: unusedMarkDefs.map((markDefKey) => (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n              _key: blk._key\n            }, \"markDefs\", {\n              _key: markDefKey\n            }])),\n            description: `Block contains orphaned data (unused mark definitions): ${unusedMarkDefs.join(\", \")}.`,\n            action: \"Remove unused mark definition item\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.orphaned-mark-defs.description\",\n              action: \"inputs.portable-text.invalid-value.orphaned-mark-defs.action\",\n              values: {\n                key: blk._key,\n                unusedMarkDefs: unusedMarkDefs.map((m) => m.toString())\n              }\n            }\n          }, !0;\n      }\n      const orphanedMarks = allUsedMarks.filter((mark) => !types.decorators.map((dec) => dec.value).includes(mark)).filter((mark) => textBlock.markDefs === void 0 || !textBlock.markDefs.find((def) => def._key === mark));\n      if (orphanedMarks.length > 0) {\n        const spanChildren = textBlock.children.filter((cld) => cld._type === types.span.name && Array.isArray(cld.marks) && cld.marks.some((mark) => orphanedMarks.includes(mark)));\n        if (spanChildren) {\n          const orphaned = orphanedMarks.join(\", \");\n          return resolution = {\n            autoResolve: !0,\n            patches: spanChildren.map((child) => (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)((child.marks || []).filter((cMrk) => !orphanedMarks.includes(cMrk)), [{\n              _key: blk._key\n            }, \"children\", {\n              _key: child._key\n            }, \"marks\"])),\n            description: `Block with _key '${blk._key}' contains marks (${orphaned}) not supported by the current content model.`,\n            action: \"Remove invalid marks\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.orphaned-marks.description\",\n              action: \"inputs.portable-text.invalid-value.orphaned-marks.action\",\n              values: {\n                key: blk._key,\n                orphanedMarks: orphanedMarks.map((m) => m.toString())\n              }\n            }\n          }, !0;\n        }\n      }\n      textBlock.children.some((child, cIndex) => {\n        if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(child))\n          return resolution = {\n            patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n              _key: blk._key\n            }, \"children\", cIndex])],\n            description: `Child at index '${cIndex}' in block with key '${blk._key}' is not an object.`,\n            action: \"Remove the item\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.non-object-child.description\",\n              action: \"inputs.portable-text.invalid-value.non-object-child.action\",\n              values: {\n                key: blk._key,\n                index: cIndex\n              }\n            }\n          }, !0;\n        if (!child._key || typeof child._key != \"string\") {\n          const newChild = {\n            ...child,\n            _key: keyGenerator()\n          };\n          return resolution = {\n            autoResolve: !0,\n            patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(newChild, [{\n              _key: blk._key\n            }, \"children\", cIndex])],\n            description: `Child at index ${cIndex} is missing required _key in block with _key ${blk._key}.`,\n            action: \"Set a new random _key on the object\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.missing-child-key.description\",\n              action: \"inputs.portable-text.invalid-value.missing-child-key.action\",\n              values: {\n                key: blk._key,\n                index: cIndex\n              }\n            }\n          }, !0;\n        }\n        return child._type ? validChildTypes.includes(child._type) ? child._type === types.span.name && typeof child.text != \"string\" ? (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)({\n            ...child,\n            text: \"\"\n          }, [{\n            _key: blk._key\n          }, \"children\", {\n            _key: child._key\n          }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' has missing or invalid text property!`,\n          action: \"Write an empty text property to the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.invalid-span-text.description\",\n            action: \"inputs.portable-text.invalid-value.invalid-span-text.action\",\n            values: {\n              key: blk._key,\n              childKey: child._key\n            }\n          }\n        }, !0) : !1 : (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n            _key: blk._key\n          }, \"children\", {\n            _key: child._key\n          }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' has invalid '_type' property (${child._type}).`,\n          action: \"Remove the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.disallowed-child-type.description\",\n            action: \"inputs.portable-text.invalid-value.disallowed-child-type.action\",\n            values: {\n              key: blk._key,\n              childKey: child._key,\n              childType: child._type\n            }\n          }\n        }, !0) : (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n            _key: blk._key\n          }, \"children\", {\n            _key: child._key\n          }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' is missing '_type' property.`,\n          action: \"Remove the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.missing-child-type.description\",\n            action: \"inputs.portable-text.invalid-value.missing-child-type.action\",\n            values: {\n              key: blk._key,\n              childKey: child._key\n            }\n          }\n        }, !0);\n      }) && (valid = !1);\n    }\n    return !1;\n  }) && (valid = !1), {\n    valid,\n    resolution,\n    value\n  });\n}\nfunction withRemoteChanges(editor, fn) {\n  const prev = isChangingRemotely(editor) || !1;\n  IS_PROCESSING_REMOTE_CHANGES.set(editor, !0), fn(), IS_PROCESSING_REMOTE_CHANGES.set(editor, prev);\n}\nfunction isChangingRemotely(editor) {\n  return IS_PROCESSING_REMOTE_CHANGES.get(editor);\n}\nconst PATCHING = /* @__PURE__ */ new WeakMap();\nfunction withoutPatching(editor, fn) {\n  const prev = isPatching(editor);\n  PATCHING.set(editor, !1), fn(), PATCHING.set(editor, prev);\n}\nfunction isPatching(editor) {\n  return PATCHING.get(editor);\n}\nfunction cloneDiff(diff2) {\n  const [type, patch] = diff2;\n  return [type, patch];\n}\nfunction getCommonOverlap(textA, textB) {\n  let text1 = textA, text2 = textB;\n  const text1Length = text1.length, text2Length = text2.length;\n  if (text1Length === 0 || text2Length === 0) return 0;\n  text1Length > text2Length ? text1 = text1.substring(text1Length - text2Length) : text1Length < text2Length && (text2 = text2.substring(0, text1Length));\n  const textLength = Math.min(text1Length, text2Length);\n  if (text1 === text2) return textLength;\n  let best = 0, length = 1;\n  for (let found = 0; found !== -1; ) {\n    const pattern = text1.substring(textLength - length);\n    if (found = text2.indexOf(pattern), found === -1) return best;\n    length += found, (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) && (best = length, length++);\n  }\n  return best;\n}\nfunction getCommonPrefix(text1, text2) {\n  if (!text1 || !text2 || text1[0] !== text2[0]) return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerStart = 0;\n  for (; pointerMin < pointerMid; ) text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid) ? (pointerMin = pointerMid, pointerStart = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction getCommonSuffix(text1, text2) {\n  if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1]) return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerEnd = 0;\n  for (; pointerMin < pointerMid; ) text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd) ? (pointerMin = pointerMid, pointerEnd = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction isHighSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 55296 && charCode <= 56319;\n}\nfunction isLowSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 56320 && charCode <= 57343;\n}\nfunction bisect(text1, text2, deadline) {\n  const text1Length = text1.length, text2Length = text2.length, maxD = Math.ceil((text1Length + text2Length) / 2), vOffset = maxD, vLength = 2 * maxD, v1 = new Array(vLength), v2 = new Array(vLength);\n  for (let x = 0; x < vLength; x++) v1[x] = -1, v2[x] = -1;\n  v1[vOffset + 1] = 0, v2[vOffset + 1] = 0;\n  const delta = text1Length - text2Length, front = delta % 2 !== 0;\n  let k1start = 0, k1end = 0, k2start = 0, k2end = 0;\n  for (let d = 0; d < maxD && !(Date.now() > deadline); d++) {\n    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      const k1Offset = vOffset + k1;\n      let x1;\n      k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1] ? x1 = v1[k1Offset + 1] : x1 = v1[k1Offset - 1] + 1;\n      let y1 = x1 - k1;\n      for (; x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1); ) x1++, y1++;\n      if (v1[k1Offset] = x1, x1 > text1Length) k1end += 2;\n      else if (y1 > text2Length) k1start += 2;\n      else if (front) {\n        const k2Offset = vOffset + delta - k1;\n        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n          const x2 = text1Length - v2[k2Offset];\n          if (x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      const k2Offset = vOffset + k2;\n      let x2;\n      k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1] ? x2 = v2[k2Offset + 1] : x2 = v2[k2Offset - 1] + 1;\n      let y2 = x2 - k2;\n      for (; x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1); ) x2++, y2++;\n      if (v2[k2Offset] = x2, x2 > text1Length) k2end += 2;\n      else if (y2 > text2Length) k2start += 2;\n      else if (!front) {\n        const k1Offset = vOffset + delta - k2;\n        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n          const x1 = v1[k1Offset], y1 = vOffset + x1 - k1Offset;\n          if (x2 = text1Length - x2, x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n  }\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n}\nfunction bisectSplit(text1, text2, x, y, deadline) {\n  const text1a = text1.substring(0, x), text2a = text2.substring(0, y), text1b = text1.substring(x), text2b = text2.substring(y), diffs = doDiff(text1a, text2a, {\n    checkLines: !1,\n    deadline\n  }), diffsb = doDiff(text1b, text2b, {\n    checkLines: !1,\n    deadline\n  });\n  return diffs.concat(diffsb);\n}\nfunction findHalfMatch(text1, text2, timeout = 1) {\n  if (timeout <= 0) return null;\n  const longText = text1.length > text2.length ? text1 : text2, shortText = text1.length > text2.length ? text2 : text1;\n  if (longText.length < 4 || shortText.length * 2 < longText.length) return null;\n  const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4)), halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));\n  let halfMatch;\n  if (halfMatch1 && halfMatch2) halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;\n  else {\n    if (!halfMatch1 && !halfMatch2) return null;\n    halfMatch2 ? halfMatch1 || (halfMatch = halfMatch2) : halfMatch = halfMatch1;\n  }\n  if (!halfMatch) throw new Error(\"Unable to find a half match.\");\n  let text1A, text1B, text2A, text2B;\n  text1.length > text2.length ? (text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3]) : (text2A = halfMatch[0], text2B = halfMatch[1], text1A = halfMatch[2], text1B = halfMatch[3]);\n  const midCommon = halfMatch[4];\n  return [text1A, text1B, text2A, text2B, midCommon];\n}\nfunction halfMatchI(longText, shortText, i) {\n  const seed = longText.slice(i, i + Math.floor(longText.length / 4));\n  let j = -1, bestCommon = \"\", bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;\n  for (; (j = shortText.indexOf(seed, j + 1)) !== -1; ) {\n    const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j)), suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));\n    bestCommon.length < suffixLength + prefixLength && (bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength), bestLongTextA = longText.slice(0, i - suffixLength), bestLongTextB = longText.slice(i + prefixLength), bestShortTextA = shortText.slice(0, j - suffixLength), bestShortTextB = shortText.slice(j + prefixLength));\n  }\n  return bestCommon.length * 2 >= longText.length ? [bestLongTextA || \"\", bestLongTextB || \"\", bestShortTextA || \"\", bestShortTextB || \"\", bestCommon || \"\"] : null;\n}\nfunction charsToLines(diffs, lineArray) {\n  for (let x = 0; x < diffs.length; x++) {\n    const chars = diffs[x][1], text = [];\n    for (let y = 0; y < chars.length; y++) text[y] = lineArray[chars.charCodeAt(y)];\n    diffs[x][1] = text.join(\"\");\n  }\n}\nfunction linesToChars(textA, textB) {\n  const lineArray = [], lineHash = {};\n  lineArray[0] = \"\";\n  function diffLinesToMunge(text) {\n    let chars = \"\", lineStart = 0, lineEnd = -1, lineArrayLength = lineArray.length;\n    for (; lineEnd < text.length - 1; ) {\n      lineEnd = text.indexOf(`\n`, lineStart), lineEnd === -1 && (lineEnd = text.length - 1);\n      let line = text.slice(lineStart, lineEnd + 1);\n      (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) ? chars += String.fromCharCode(lineHash[line]) : (lineArrayLength === maxLines && (line = text.slice(lineStart), lineEnd = text.length), chars += String.fromCharCode(lineArrayLength), lineHash[line] = lineArrayLength, lineArray[lineArrayLength++] = line), lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  let maxLines = 4e4;\n  const chars1 = diffLinesToMunge(textA);\n  maxLines = 65535;\n  const chars2 = diffLinesToMunge(textB);\n  return {\n    chars1,\n    chars2,\n    lineArray\n  };\n}\nfunction doLineModeDiff(textA, textB, opts) {\n  let text1 = textA, text2 = textB;\n  const a = linesToChars(text1, text2);\n  text1 = a.chars1, text2 = a.chars2;\n  const linearray = a.lineArray;\n  let diffs = doDiff(text1, text2, {\n    checkLines: !1,\n    deadline: opts.deadline\n  });\n  charsToLines(diffs, linearray), diffs = cleanupSemantic(diffs), diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\";\n  for (; pointer < diffs.length; ) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++, textInsert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        countDelete++, textDelete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        if (countDelete >= 1 && countInsert >= 1) {\n          diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert), pointer = pointer - countDelete - countInsert;\n          const aa = doDiff(textDelete, textInsert, {\n            checkLines: !1,\n            deadline: opts.deadline\n          });\n          for (let j = aa.length - 1; j >= 0; j--) diffs.splice(pointer, 0, aa[j]);\n          pointer += aa.length;\n        }\n        countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n    pointer++;\n  }\n  return diffs.pop(), diffs;\n}\nfunction computeDiff(text1, text2, opts) {\n  let diffs;\n  if (!text1) return [[DIFF_INSERT, text2]];\n  if (!text2) return [[DIFF_DELETE, text1]];\n  const longtext = text1.length > text2.length ? text1 : text2, shorttext = text1.length > text2.length ? text2 : text1, i = longtext.indexOf(shorttext);\n  if (i !== -1) return diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]], text1.length > text2.length && (diffs[0][0] = DIFF_DELETE, diffs[2][0] = DIFF_DELETE), diffs;\n  if (shorttext.length === 1) return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  const halfMatch = findHalfMatch(text1, text2);\n  if (halfMatch) {\n    const text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3], midCommon = halfMatch[4], diffsA = doDiff(text1A, text2A, opts), diffsB = doDiff(text1B, text2B, opts);\n    return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);\n  }\n  return opts.checkLines && text1.length > 100 && text2.length > 100 ? doLineModeDiff(text1, text2, opts) : bisect(text1, text2, opts.deadline);\n}\nvar __defProp$2 = Object.defineProperty, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value\n}) : obj[key] = value, __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {})) __hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2) for (var prop of __getOwnPropSymbols$2(b)) __propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  return a;\n};\nconst DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;\nfunction diff(textA, textB, opts) {\n  if (textA === null || textB === null) throw new Error(\"Null input. (diff)\");\n  const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));\n  return adjustDiffForSurrogatePairs(diffs), diffs;\n}\nfunction doDiff(textA, textB, options) {\n  let text1 = textA, text2 = textB;\n  if (text1 === text2) return text1 ? [[DIFF_EQUAL, text1]] : [];\n  let commonlength = getCommonPrefix(text1, text2);\n  const commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength), text2 = text2.substring(commonlength), commonlength = getCommonSuffix(text1, text2);\n  const commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength), text2 = text2.substring(0, text2.length - commonlength);\n  let diffs = computeDiff(text1, text2, options);\n  return commonprefix && diffs.unshift([DIFF_EQUAL, commonprefix]), commonsuffix && diffs.push([DIFF_EQUAL, commonsuffix]), diffs = cleanupMerge(diffs), diffs;\n}\nfunction createDeadLine(timeout) {\n  let t = 1;\n  return typeof timeout < \"u\" && (t = timeout <= 0 ? Number.MAX_VALUE : timeout), Date.now() + t * 1e3;\n}\nfunction createInternalOpts(opts) {\n  return __spreadValues$2({\n    checkLines: !0,\n    deadline: createDeadLine(opts.timeout || 1)\n  }, opts);\n}\nfunction combineChar(data, char, dir) {\n  return dir === 1 ? data + char : char + data;\n}\nfunction splitChar(data, dir) {\n  return dir === 1 ? [data.substring(0, data.length - 1), data[data.length - 1]] : [data.substring(1), data[0]];\n}\nfunction hasSharedChar(diffs, i, j, dir) {\n  return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];\n}\nfunction deisolateChar(diffs, i, dir) {\n  const inv = dir === 1 ? -1 : 1;\n  let insertIdx = null, deleteIdx = null, j = i + dir;\n  for (; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir) {\n    const [op, text2] = diffs[j];\n    if (text2.length !== 0) {\n      if (op === DIFF_INSERT) {\n        insertIdx === null && (insertIdx = j);\n        continue;\n      } else if (op === DIFF_DELETE) {\n        deleteIdx === null && (deleteIdx = j);\n        continue;\n      } else if (op === DIFF_EQUAL) {\n        if (insertIdx === null && deleteIdx === null) {\n          const [rest, char2] = splitChar(diffs[i][1], dir);\n          diffs[i][1] = rest, diffs[j][1] = combineChar(diffs[j][1], char2, inv);\n          return;\n        }\n        break;\n      }\n    }\n  }\n  if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {\n    const [insertText2, insertChar] = splitChar(diffs[insertIdx][1], inv), [deleteText] = splitChar(diffs[deleteIdx][1], inv);\n    diffs[insertIdx][1] = insertText2, diffs[deleteIdx][1] = deleteText, diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);\n    return;\n  }\n  const [text, char] = splitChar(diffs[i][1], dir);\n  diffs[i][1] = text, insertIdx === null ? (diffs.splice(j, 0, [DIFF_INSERT, char]), deleteIdx !== null && deleteIdx >= j && deleteIdx++) : diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv), deleteIdx === null ? diffs.splice(j, 0, [DIFF_DELETE, char]) : diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);\n}\nfunction adjustDiffForSurrogatePairs(diffs) {\n  for (let i = 0; i < diffs.length; i++) {\n    const [diffType, diffText] = diffs[i];\n    if (diffText.length === 0) continue;\n    const firstChar = diffText[0], lastChar = diffText[diffText.length - 1];\n    isHighSurrogate(lastChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, 1), isLowSurrogate(firstChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, -1);\n  }\n  for (let i = 0; i < diffs.length; i++) diffs[i][1].length === 0 && diffs.splice(i, 1);\n}\nfunction cleanupSemantic(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0;\n  for (; pointer < diffs.length; ) diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, lengthInsertions1 = lengthInsertions2, lengthDeletions1 = lengthDeletions2, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? lengthInsertions2 += diffs[pointer][1].length : lengthDeletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = null, hasChanges = !0)), pointer++;\n  for (hasChanges && (diffs = cleanupMerge(diffs)), diffs = cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length; ) {\n    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n      const deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlapLength1 = getCommonOverlap(deletion, insertion), overlapLength2 = getCommonOverlap(insertion, deletion);\n      overlapLength1 >= overlapLength2 ? (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1), diffs[pointer + 1][1] = insertion.substring(overlapLength1), pointer++) : (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlapLength2), pointer++), pointer++;\n    }\n    pointer++;\n  }\n  return diffs;\n}\nconst nonAlphaNumericRegex = /[^a-zA-Z0-9]/, whitespaceRegex = /\\s/, linebreakRegex = /[\\r\\n]/, blanklineEndRegex = /\\n\\r?\\n$/, blanklineStartRegex = /^\\r?\\n\\r?\\n/;\nfunction cleanupSemanticLossless(rawDiffs) {\n  const diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  function diffCleanupSemanticScore(one, two) {\n    if (!one || !two) return 6;\n    const char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex), lineBreak1 = whitespace1 && char1.match(linebreakRegex), lineBreak2 = whitespace2 && char2.match(linebreakRegex), blankLine1 = lineBreak1 && one.match(blanklineEndRegex), blankLine2 = lineBreak2 && two.match(blanklineStartRegex);\n    return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;\n  }\n  let pointer = 1;\n  for (; pointer < diffs.length - 1; ) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1];\n      const commonOffset = getCommonSuffix(equality1, edit);\n      if (commonOffset) {\n        const commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;\n      }\n      let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n      for (; edit.charAt(0) === equality2.charAt(0); ) {\n        equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);\n        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n        score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);\n      }\n      diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));\n    }\n    pointer++;\n  }\n  return diffs;\n}\nfunction cleanupMerge(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\", commonlength;\n  for (; pointer < diffs.length; ) switch (diffs[pointer][0]) {\n    case DIFF_INSERT:\n      countInsert++, textInsert += diffs[pointer][1], pointer++;\n      break;\n    case DIFF_DELETE:\n      countDelete++, textDelete += diffs[pointer][1], pointer++;\n      break;\n    case DIFF_EQUAL:\n      countDelete + countInsert > 1 ? (countDelete !== 0 && countInsert !== 0 && (commonlength = getCommonPrefix(textInsert, textDelete), commonlength !== 0 && (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL ? diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength) : (diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]), pointer++), textInsert = textInsert.substring(commonlength), textDelete = textDelete.substring(commonlength)), commonlength = getCommonSuffix(textInsert, textDelete), commonlength !== 0 && (diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1], textInsert = textInsert.substring(0, textInsert.length - commonlength), textDelete = textDelete.substring(0, textDelete.length - commonlength))), pointer -= countDelete + countInsert, diffs.splice(pointer, countDelete + countInsert), textDelete.length && (diffs.splice(pointer, 0, [DIFF_DELETE, textDelete]), pointer++), textInsert.length && (diffs.splice(pointer, 0, [DIFF_INSERT, textInsert]), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n      break;\n    default:\n      throw new Error(\"Unknown diff operation\");\n  }\n  diffs[diffs.length - 1][1] === \"\" && diffs.pop();\n  let hasChanges = !1;\n  for (pointer = 1; pointer < diffs.length - 1; ) diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), hasChanges = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nfunction trueCount(...args) {\n  return args.reduce((n, bool) => n + (bool ? 1 : 0), 0);\n}\nfunction cleanupEfficiency(rawDiffs, editCost = 4) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, preIns = !1, preDel = !1, postIns = !1, postDel = !1;\n  for (; pointer < diffs.length; ) diffs[pointer][0] === DIFF_EQUAL ? (diffs[pointer][1].length < editCost && (postIns || postDel) ? (equalities[equalitiesLength++] = pointer, preIns = postIns, preDel = postDel, lastEquality = diffs[pointer][1]) : (equalitiesLength = 0, lastEquality = null), postIns = !1, postDel = !1) : (diffs[pointer][0] === DIFF_DELETE ? postDel = !0 : postIns = !0, lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, lastEquality = null, preIns && preDel ? (postIns = !0, postDel = !0, equalitiesLength = 0) : (equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, postIns = !1, postDel = !1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nvar __defProp$1 = Object.defineProperty, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value\n}) : obj[key] = value, __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {})) __hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(b)) __propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  return a;\n};\nconst DEFAULT_OPTIONS = {\n  /**\n   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n   */\n  threshold: 0.5,\n  /**\n   * How far to search for a match (0 = exact location, 1000+ = broad match).\n   * A match this many characters away from the expected location will add\n   * 1.0 to the score (0.0 is a perfect match).\n   */\n  distance: 1e3\n};\nfunction applyDefaults(options) {\n  return __spreadValues$1(__spreadValues$1({}, DEFAULT_OPTIONS), options);\n}\nconst MAX_BITS$1 = 32;\nfunction bitap(text, pattern, loc, opts = {}) {\n  if (pattern.length > MAX_BITS$1) throw new Error(\"Pattern too long for this browser.\");\n  const options = applyDefaults(opts), s = getAlphabetFromPattern(pattern);\n  function getBitapScore(e, x) {\n    const accuracy = e / pattern.length, proximity = Math.abs(loc - x);\n    return options.distance ? accuracy + proximity / options.distance : proximity ? 1 : accuracy;\n  }\n  let scoreThreshold = options.threshold, bestLoc = text.indexOf(pattern, loc);\n  bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold), bestLoc = text.lastIndexOf(pattern, loc + pattern.length), bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)));\n  const matchmask = 1 << pattern.length - 1;\n  bestLoc = -1;\n  let binMin, binMid, binMax = pattern.length + text.length, lastRd = [];\n  for (let d = 0; d < pattern.length; d++) {\n    for (binMin = 0, binMid = binMax; binMin < binMid; ) getBitapScore(d, loc + binMid) <= scoreThreshold ? binMin = binMid : binMax = binMid, binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    binMax = binMid;\n    let start = Math.max(1, loc - binMid + 1);\n    const finish = Math.min(loc + binMid, text.length) + pattern.length, rd = new Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (let j = finish; j >= start; j--) {\n      const charMatch = s[text.charAt(j - 1)];\n      if (d === 0 ? rd[j] = (rd[j + 1] << 1 | 1) & charMatch : rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1], rd[j] & matchmask) {\n        const score = getBitapScore(d, j - 1);\n        if (score <= scoreThreshold) if (scoreThreshold = score, bestLoc = j - 1, bestLoc > loc) start = Math.max(1, 2 * loc - bestLoc);\n        else break;\n      }\n    }\n    if (getBitapScore(d + 1, loc) > scoreThreshold) break;\n    lastRd = rd;\n  }\n  return bestLoc;\n}\nfunction getAlphabetFromPattern(pattern) {\n  const s = {};\n  for (let i = 0; i < pattern.length; i++) s[pattern.charAt(i)] = 0;\n  for (let i = 0; i < pattern.length; i++) s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;\n  return s;\n}\nfunction match(text, pattern, searchLocation, options = {}) {\n  if (text === null || pattern === null || searchLocation === null) throw new Error(\"Null input. (match())\");\n  const loc = Math.max(0, Math.min(searchLocation, text.length));\n  if (text === pattern) return 0;\n  if (text.length) {\n    if (text.substring(loc, loc + pattern.length) === pattern) return loc;\n  } else return -1;\n  return bitap(text, pattern, loc, options);\n}\nfunction diffText1(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++) diffs[x][0] !== DIFF_INSERT && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction diffText2(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++) diffs[x][0] !== DIFF_DELETE && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction levenshtein(diffs) {\n  let leven = 0, insertions = 0, deletions = 0;\n  for (let x = 0; x < diffs.length; x++) {\n    const op = diffs[x][0], data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        leven += Math.max(insertions, deletions), insertions = 0, deletions = 0;\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n  }\n  return leven += Math.max(insertions, deletions), leven;\n}\nfunction xIndex(diffs, location) {\n  let chars1 = 0, chars2 = 0, lastChars1 = 0, lastChars2 = 0, x;\n  for (x = 0; x < diffs.length && (diffs[x][0] !== DIFF_INSERT && (chars1 += diffs[x][1].length), diffs[x][0] !== DIFF_DELETE && (chars2 += diffs[x][1].length), !(chars1 > location)); x++) lastChars1 = chars1, lastChars2 = chars2;\n  return diffs.length !== x && diffs[x][0] === DIFF_DELETE ? lastChars2 : lastChars2 + (location - lastChars1);\n}\nfunction countUtf8Bytes(str) {\n  let bytes = 0;\n  for (let i = 0; i < str.length; i++) {\n    const codePoint = str.codePointAt(i);\n    if (typeof codePoint > \"u\") throw new Error(\"Failed to get codepoint\");\n    bytes += utf8len(codePoint);\n  }\n  return bytes;\n}\nfunction adjustIndiciesToUcs2(patches, base, options = {}) {\n  let byteOffset = 0, idx = 0;\n  function advanceTo(target) {\n    for (; byteOffset < target; ) {\n      const codePoint = base.codePointAt(idx);\n      if (typeof codePoint > \"u\") return idx;\n      byteOffset += utf8len(codePoint), codePoint > 65535 ? idx += 2 : idx += 1;\n    }\n    if (!options.allowExceedingIndices && byteOffset !== target) throw new Error(\"Failed to determine byte offset\");\n    return idx;\n  }\n  const adjusted = [];\n  for (const patch of patches) adjusted.push({\n    diffs: patch.diffs.map((diff2) => cloneDiff(diff2)),\n    start1: advanceTo(patch.start1),\n    start2: advanceTo(patch.start2),\n    utf8Start1: patch.utf8Start1,\n    utf8Start2: patch.utf8Start2,\n    length1: patch.length1,\n    length2: patch.length2,\n    utf8Length1: patch.utf8Length1,\n    utf8Length2: patch.utf8Length2\n  });\n  return adjusted;\n}\nfunction utf8len(codePoint) {\n  return codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : 4;\n}\nconst MAX_BITS = 32, DEFAULT_MARGIN = 4;\nfunction addPadding(patches, margin = DEFAULT_MARGIN) {\n  const paddingLength = margin;\n  let nullPadding = \"\";\n  for (let x = 1; x <= paddingLength; x++) nullPadding += String.fromCharCode(x);\n  for (const p of patches) p.start1 += paddingLength, p.start2 += paddingLength, p.utf8Start1 += paddingLength, p.utf8Start2 += paddingLength;\n  let patch = patches[0], diffs = patch.diffs;\n  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL) diffs.unshift([DIFF_EQUAL, nullPadding]), patch.start1 -= paddingLength, patch.start2 -= paddingLength, patch.utf8Start1 -= paddingLength, patch.utf8Start2 -= paddingLength, patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[0][1].length) {\n    const firstDiffLength = diffs[0][1].length, extraLength = paddingLength - firstDiffLength;\n    diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1], patch.start1 -= extraLength, patch.start2 -= extraLength, patch.utf8Start1 -= extraLength, patch.utf8Start2 -= extraLength, patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  if (patch = patches[patches.length - 1], diffs = patch.diffs, diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL) diffs.push([DIFF_EQUAL, nullPadding]), patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    const extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength), patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  return nullPadding;\n}\nfunction createPatchObject(start1, start2) {\n  return {\n    diffs: [],\n    start1,\n    start2,\n    utf8Start1: start1,\n    utf8Start2: start2,\n    length1: 0,\n    length2: 0,\n    utf8Length1: 0,\n    utf8Length2: 0\n  };\n}\nfunction splitMax(patches, margin = DEFAULT_MARGIN) {\n  const patchSize = MAX_BITS;\n  for (let x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patchSize) continue;\n    const bigpatch = patches[x];\n    patches.splice(x--, 1);\n    let start1 = bigpatch.start1, start2 = bigpatch.start2, preContext = \"\";\n    for (; bigpatch.diffs.length !== 0; ) {\n      const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);\n      let empty = !0;\n      if (preContext !== \"\") {\n        const precontextByteCount = countUtf8Bytes(preContext);\n        patch.length1 = preContext.length, patch.utf8Length1 = precontextByteCount, patch.length2 = preContext.length, patch.utf8Length2 = precontextByteCount, patch.diffs.push([DIFF_EQUAL, preContext]);\n      }\n      for (; bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin; ) {\n        const diffType = bigpatch.diffs[0][0];\n        let diffText = bigpatch.diffs[0][1], diffTextByteCount = countUtf8Bytes(diffText);\n        if (diffType === DIFF_INSERT) {\n          patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length;\n          const diff2 = bigpatch.diffs.shift();\n          diff2 && patch.diffs.push(diff2), empty = !1;\n        } else diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize ? (patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, empty = !1, patch.diffs.push([diffType, diffText]), bigpatch.diffs.shift()) : (diffText = diffText.substring(0, patchSize - patch.length1 - margin), diffTextByteCount = countUtf8Bytes(diffText), patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, diffType === DIFF_EQUAL ? (patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length) : empty = !1, patch.diffs.push([diffType, diffText]), diffText === bigpatch.diffs[0][1] ? bigpatch.diffs.shift() : bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length));\n      }\n      preContext = diffText2(patch.diffs), preContext = preContext.substring(preContext.length - margin);\n      const postContext = diffText1(bigpatch.diffs).substring(0, margin), postContextByteCount = countUtf8Bytes(postContext);\n      postContext !== \"\" && (patch.length1 += postContext.length, patch.length2 += postContext.length, patch.utf8Length1 += postContextByteCount, patch.utf8Length2 += postContextByteCount, patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL ? patch.diffs[patch.diffs.length - 1][1] += postContext : patch.diffs.push([DIFF_EQUAL, postContext])), empty || patches.splice(++x, 0, patch);\n    }\n  }\n}\nfunction apply(patches, originalText, opts = {}) {\n  if (typeof patches == \"string\") throw new Error(\"Patches must be an array - pass the patch to `parsePatch()` first\");\n  let text = originalText;\n  if (patches.length === 0) return [text, []];\n  const parsed = adjustIndiciesToUcs2(patches, text, {\n    allowExceedingIndices: opts.allowExceedingIndices\n  }), margin = opts.margin || DEFAULT_MARGIN, deleteThreshold = opts.deleteThreshold || 0.4, nullPadding = addPadding(parsed, margin);\n  text = nullPadding + text + nullPadding, splitMax(parsed, margin);\n  let delta = 0;\n  const results = [];\n  for (let x = 0; x < parsed.length; x++) {\n    const expectedLoc = parsed[x].start2 + delta, text1 = diffText1(parsed[x].diffs);\n    let startLoc, endLoc = -1;\n    if (text1.length > MAX_BITS ? (startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc), startLoc !== -1 && (endLoc = match(text, text1.substring(text1.length - MAX_BITS), expectedLoc + text1.length - MAX_BITS), (endLoc === -1 || startLoc >= endLoc) && (startLoc = -1))) : startLoc = match(text, text1, expectedLoc), startLoc === -1) results[x] = !1, delta -= parsed[x].length2 - parsed[x].length1;\n    else {\n      results[x] = !0, delta = startLoc - expectedLoc;\n      let text2;\n      if (endLoc === -1 ? text2 = text.substring(startLoc, startLoc + text1.length) : text2 = text.substring(startLoc, endLoc + MAX_BITS), text1 === text2) text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);\n      else {\n        let diffs = diff(text1, text2, {\n          checkLines: !1\n        });\n        if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold) results[x] = !1;\n        else {\n          diffs = cleanupSemanticLossless(diffs);\n          let index1 = 0, index2 = 0;\n          for (let y = 0; y < parsed[x].diffs.length; y++) {\n            const mod = parsed[x].diffs[y];\n            mod[0] !== DIFF_EQUAL && (index2 = xIndex(diffs, index1)), mod[0] === DIFF_INSERT ? text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2) : mod[0] === DIFF_DELETE && (text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))), mod[0] !== DIFF_DELETE && (index1 += mod[1].length);\n          }\n        }\n      }\n    }\n  }\n  return text = text.substring(nullPadding.length, text.length - nullPadding.length), [text, results];\n}\nconst patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\nfunction parse(textline) {\n  if (!textline) return [];\n  const patches = [], lines = textline.split(`\n`);\n  let textPointer = 0;\n  for (; textPointer < lines.length; ) {\n    const m = lines[textPointer].match(patchHeader);\n    if (!m) throw new Error(`Invalid patch string: ${lines[textPointer]}`);\n    const patch = createPatchObject(toInt(m[1]), toInt(m[3]));\n    for (patches.push(patch), m[2] === \"\" ? (patch.start1--, patch.utf8Start1--, patch.length1 = 1, patch.utf8Length1 = 1) : m[2] === \"0\" ? (patch.length1 = 0, patch.utf8Length1 = 0) : (patch.start1--, patch.utf8Start1--, patch.utf8Length1 = toInt(m[2]), patch.length1 = patch.utf8Length1), m[4] === \"\" ? (patch.start2--, patch.utf8Start2--, patch.length2 = 1, patch.utf8Length2 = 1) : m[4] === \"0\" ? (patch.length2 = 0, patch.utf8Length2 = 0) : (patch.start2--, patch.utf8Start2--, patch.utf8Length2 = toInt(m[4]), patch.length2 = patch.utf8Length2), textPointer++; textPointer < lines.length; ) {\n      const currentLine = lines[textPointer], sign = currentLine.charAt(0);\n      if (sign === \"@\") break;\n      if (sign === \"\") {\n        textPointer++;\n        continue;\n      }\n      let line;\n      try {\n        line = decodeURI(currentLine.slice(1));\n      } catch {\n        throw new Error(`Illegal escape in parse: ${currentLine}`);\n      }\n      const utf8Diff = countUtf8Bytes(line) - line.length;\n      if (sign === \"-\") patch.diffs.push([DIFF_DELETE, line]), patch.length1 -= utf8Diff;\n      else if (sign === \"+\") patch.diffs.push([DIFF_INSERT, line]), patch.length2 -= utf8Diff;\n      else if (sign === \" \") patch.diffs.push([DIFF_EQUAL, line]), patch.length1 -= utf8Diff, patch.length2 -= utf8Diff;\n      else throw new Error(`Invalid patch mode \"${sign}\" in: ${line}`);\n      textPointer++;\n    }\n  }\n  return patches;\n}\nfunction toInt(num) {\n  return parseInt(num, 10);\n}\nconst IS_UDOING = /* @__PURE__ */ new WeakMap(), IS_REDOING = /* @__PURE__ */ new WeakMap();\nfunction withUndoing(editor, fn) {\n  const prev = isUndoing(editor);\n  IS_UDOING.set(editor, !0), fn(), IS_UDOING.set(editor, prev);\n}\nfunction isUndoing(editor) {\n  return IS_UDOING.get(editor) ?? !1;\n}\nfunction setIsUndoing(editor, isUndoing2) {\n  IS_UDOING.set(editor, isUndoing2);\n}\nfunction withRedoing(editor, fn) {\n  const prev = isRedoing(editor);\n  IS_REDOING.set(editor, !0), fn(), IS_REDOING.set(editor, prev);\n}\nfunction isRedoing(editor) {\n  return IS_REDOING.get(editor) ?? !1;\n}\nfunction setIsRedoing(editor, isRedoing2) {\n  IS_REDOING.set(editor, isRedoing2);\n}\nconst defaultKeyGenerator = () => randomKey(12), getByteHexTable = /* @__PURE__ */ (() => {\n  let table;\n  return () => {\n    if (table)\n      return table;\n    table = [];\n    for (let i = 0; i < 256; ++i)\n      table[i] = (i + 256).toString(16).slice(1);\n    return table;\n  };\n})();\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length);\n  return (0,get_random_values_esm__WEBPACK_IMPORTED_MODULE_21__[\"default\"])(rnds8), rnds8;\n}\nfunction randomKey(length) {\n  const table = getByteHexTable();\n  return whatwgRNG(length).reduce((str, n) => str + table[n], \"\").slice(0, length);\n}\nconst CURRENT_ACTION_ID = /* @__PURE__ */ new WeakMap();\nfunction withApplyingBehaviorActions(editor, fn) {\n  CURRENT_ACTION_ID.set(editor, defaultKeyGenerator()), slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, fn), CURRENT_ACTION_ID.set(editor, void 0);\n}\nfunction getCurrentActionId(editor) {\n  return CURRENT_ACTION_ID.get(editor);\n}\nfunction isApplyingBehaviorActions(editor) {\n  return getCurrentActionId(editor) !== void 0;\n}\nconst CURRENT_BEHAVIOR_ACTION_INTEND_SET = /* @__PURE__ */ new WeakMap();\nfunction withApplyingBehaviorActionIntendSet(editor, fn) {\n  const current = CURRENT_BEHAVIOR_ACTION_INTEND_SET.get(editor);\n  CURRENT_BEHAVIOR_ACTION_INTEND_SET.set(editor, {\n    actionSetId: defaultKeyGenerator()\n  }), withApplyingBehaviorActions(editor, fn), CURRENT_BEHAVIOR_ACTION_INTEND_SET.set(editor, current);\n}\nfunction getCurrentBehaviorActionSetId(editor) {\n  return CURRENT_BEHAVIOR_ACTION_INTEND_SET.get(editor)?.actionSetId;\n}\nconst debug$d = debugWithName(\"plugin:withUndoRedo\"), SAVING = /* @__PURE__ */ new WeakMap(), REMOTE_PATCHES = /* @__PURE__ */ new WeakMap(), UNDO_STEP_LIMIT = 1e3, isSaving = (editor) => {\n  const state = SAVING.get(editor);\n  return state === void 0 ? !0 : state;\n}, getRemotePatches = (editor) => (REMOTE_PATCHES.get(editor) || REMOTE_PATCHES.set(editor, []), REMOTE_PATCHES.get(editor) || []);\nfunction createWithUndoRedo(options) {\n  const {\n    editorActor,\n    blockSchemaType\n  } = options;\n  return (editor) => {\n    let previousSnapshot = fromSlateValue(editor.children, blockSchemaType.name);\n    const remotePatches = getRemotePatches(editor);\n    let previousBehaviorActionIntendSetId = getCurrentBehaviorActionSetId(editor);\n    options.subscriptions.push(() => {\n      debug$d(\"Subscribing to patches\");\n      const sub = editorActor.on(\"patches\", ({\n        patches,\n        snapshot\n      }) => {\n        let reset = !1;\n        patches.forEach((patch) => {\n          if (!reset && patch.origin !== \"local\" && remotePatches) {\n            if (patch.type === \"unset\" && patch.path.length === 0) {\n              debug$d(\"Someone else cleared the content, resetting undo/redo history\"), editor.history = {\n                undos: [],\n                redos: []\n              }, remotePatches.splice(0, remotePatches.length), SAVING.set(editor, !0), reset = !0;\n              return;\n            }\n            remotePatches.push({\n              patch,\n              time: /* @__PURE__ */ new Date(),\n              snapshot,\n              previousSnapshot\n            });\n          }\n        }), previousSnapshot = snapshot;\n      });\n      return () => {\n        debug$d(\"Unsubscribing to patches\"), sub.unsubscribe();\n      };\n    }), editor.history = {\n      undos: [],\n      redos: []\n    };\n    const {\n      apply: apply2\n    } = editor;\n    return editor.apply = (op) => {\n      if (editorActor.getSnapshot().matches({\n        \"edit mode\": \"read only\"\n      })) {\n        apply2(op);\n        return;\n      }\n      if (isChangingRemotely(editor)) {\n        apply2(op);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(op);\n        return;\n      }\n      const {\n        operations,\n        history\n      } = editor, {\n        undos\n      } = history, step = undos[undos.length - 1], lastOp = step && step.operations && step.operations[step.operations.length - 1], overwrite = shouldOverwrite(op, lastOp), save = isSaving(editor), currentBehaviorActionIntendSetId = getCurrentBehaviorActionSetId(editor);\n      let merge = currentBehaviorActionIntendSetId !== void 0 && previousBehaviorActionIntendSetId === void 0 ? !1 : currentBehaviorActionIntendSetId !== void 0 && previousBehaviorActionIntendSetId !== void 0 ? currentBehaviorActionIntendSetId === previousBehaviorActionIntendSetId : !0;\n      if (save) {\n        if (step ? operations.length === 0 && (merge = currentBehaviorActionIntendSetId === void 0 && previousBehaviorActionIntendSetId === void 0 ? shouldMerge(op, lastOp) || overwrite : merge) : merge = !1, step && merge)\n          step.operations.push(op);\n        else {\n          const newStep = {\n            operations: [...editor.selection === null ? [] : [createSelectOperation(editor)], op],\n            timestamp: /* @__PURE__ */ new Date()\n          };\n          undos.push(newStep), debug$d(\"Created new undo step\", step);\n        }\n        for (; undos.length > UNDO_STEP_LIMIT; )\n          undos.shift();\n        shouldClear(op) && (history.redos = []);\n      }\n      previousBehaviorActionIntendSetId = currentBehaviorActionIntendSetId, apply2(op);\n    }, editor;\n  };\n}\nconst historyUndoActionImplementation = ({\n  action\n}) => {\n  const editor = action.editor, {\n    undos\n  } = editor.history, remotePatches = getRemotePatches(editor);\n  if (undos.length > 0) {\n    const step = undos[undos.length - 1];\n    if (debug$d(\"Undoing\", step), step.operations.length > 0) {\n      const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);\n      let transformedOperations = step.operations;\n      otherPatches.forEach((item) => {\n        transformedOperations = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_5__(transformedOperations.map((op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));\n      });\n      const reversedOperations = transformedOperations.map(slate__WEBPACK_IMPORTED_MODULE_15__.Operation.inverse).reverse();\n      try {\n        slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n          withUndoing(editor, () => {\n            withoutSaving(editor, () => {\n              reversedOperations.forEach((op) => {\n                editor.apply(op);\n              });\n            });\n          });\n        });\n      } catch (err) {\n        debug$d(\"Could not perform undo step\", err), remotePatches.splice(0, remotePatches.length), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(editor), editor.history = {\n          undos: [],\n          redos: []\n        }, SAVING.set(editor, !0), setIsUndoing(editor, !1), editor.onChange();\n        return;\n      }\n      editor.history.redos.push(step), editor.history.undos.pop();\n    }\n  }\n}, historyRedoActionImplementation = ({\n  action\n}) => {\n  const editor = action.editor, {\n    redos\n  } = editor.history, remotePatches = getRemotePatches(editor);\n  if (redos.length > 0) {\n    const step = redos[redos.length - 1];\n    if (debug$d(\"Redoing\", step), step.operations.length > 0) {\n      const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);\n      let transformedOperations = step.operations;\n      otherPatches.forEach((item) => {\n        transformedOperations = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_5__(transformedOperations.map((op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));\n      });\n      try {\n        slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n          withRedoing(editor, () => {\n            withoutSaving(editor, () => {\n              transformedOperations.forEach((op) => {\n                editor.apply(op);\n              });\n            });\n          });\n        });\n      } catch (err) {\n        debug$d(\"Could not perform redo step\", err), remotePatches.splice(0, remotePatches.length), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(editor), editor.history = {\n          undos: [],\n          redos: []\n        }, SAVING.set(editor, !0), setIsRedoing(editor, !1), editor.onChange();\n        return;\n      }\n      editor.history.undos.push(step), editor.history.redos.pop();\n    }\n  }\n};\nfunction transformOperation(editor, patch, operation, snapshot, previousSnapshot) {\n  const transformedOperation = {\n    ...operation\n  };\n  if (patch.type === \"insert\" && patch.path.length === 1) {\n    const insertBlockIndex = (snapshot || []).findIndex((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_4__({\n      _key: blk._key\n    }, patch.path[0]));\n    return debug$d(`Adjusting block path (+${patch.items.length}) for '${transformedOperation.type}' operation and patch '${patch.type}'`), [adjustBlockPath(transformedOperation, patch.items.length, insertBlockIndex)];\n  }\n  if (patch.type === \"unset\" && patch.path.length === 1) {\n    const unsetBlockIndex = (previousSnapshot || []).findIndex((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_4__({\n      _key: blk._key\n    }, patch.path[0]));\n    return \"path\" in transformedOperation && Array.isArray(transformedOperation.path) && transformedOperation.path[0] === unsetBlockIndex ? (debug$d(\"Skipping transformation that targeted removed block\"), []) : [adjustBlockPath(transformedOperation, -1, unsetBlockIndex)];\n  }\n  if (patch.type === \"unset\" && patch.path.length === 0)\n    return debug$d(`Adjusting selection for unset everything patch and ${operation.type} operation`), [];\n  if (patch.type === \"diffMatchPatch\") {\n    const operationTargetBlock = findOperationTargetBlock(editor, transformedOperation);\n    return !operationTargetBlock || !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_4__({\n      _key: operationTargetBlock._key\n    }, patch.path[0]) ? [transformedOperation] : (parse(patch.value).forEach((diffPatch) => {\n      let adjustOffsetBy = 0, changedOffset = diffPatch.utf8Start1;\n      const {\n        diffs\n      } = diffPatch;\n      if (diffs.forEach((diff2, index) => {\n        const [diffType, text] = diff2;\n        diffType === DIFF_INSERT ? (adjustOffsetBy += text.length, changedOffset += text.length) : diffType === DIFF_DELETE ? (adjustOffsetBy -= text.length, changedOffset -= text.length) : diffType === DIFF_EQUAL && (diffs.slice(index).every(([dType]) => dType === DIFF_EQUAL) || (changedOffset += text.length));\n      }), transformedOperation.type === \"insert_text\" && changedOffset < transformedOperation.offset && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === \"remove_text\" && changedOffset <= transformedOperation.offset - transformedOperation.text.length && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === \"set_selection\") {\n        const currentFocus = transformedOperation.properties?.focus ? {\n          ...transformedOperation.properties.focus\n        } : void 0, currentAnchor = transformedOperation?.properties?.anchor ? {\n          ...transformedOperation.properties.anchor\n        } : void 0, newFocus = transformedOperation?.newProperties?.focus ? {\n          ...transformedOperation.newProperties.focus\n        } : void 0, newAnchor = transformedOperation?.newProperties?.anchor ? {\n          ...transformedOperation.newProperties.anchor\n        } : void 0;\n        (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {\n          point && changedOffset < point.offset && (point.offset += adjustOffsetBy);\n        }), currentFocus && currentAnchor && (transformedOperation.properties = {\n          focus: currentFocus,\n          anchor: currentAnchor\n        }), newFocus && newAnchor && (transformedOperation.newProperties = {\n          focus: newFocus,\n          anchor: newAnchor\n        }));\n      }\n    }), [transformedOperation]);\n  }\n  return [transformedOperation];\n}\nfunction adjustBlockPath(operation, level, blockIndex) {\n  const transformedOperation = {\n    ...operation\n  };\n  if (blockIndex >= 0 && transformedOperation.type !== \"set_selection\" && Array.isArray(transformedOperation.path) && transformedOperation.path[0] >= blockIndex + level && transformedOperation.path[0] + level > -1) {\n    const newPath = [transformedOperation.path[0] + level, ...transformedOperation.path.slice(1)];\n    transformedOperation.path = newPath;\n  }\n  if (transformedOperation.type === \"set_selection\") {\n    const currentFocus = transformedOperation.properties?.focus ? {\n      ...transformedOperation.properties.focus\n    } : void 0, currentAnchor = transformedOperation?.properties?.anchor ? {\n      ...transformedOperation.properties.anchor\n    } : void 0, newFocus = transformedOperation?.newProperties?.focus ? {\n      ...transformedOperation.newProperties.focus\n    } : void 0, newAnchor = transformedOperation?.newProperties?.anchor ? {\n      ...transformedOperation.newProperties.anchor\n    } : void 0;\n    (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {\n      point && point.path[0] >= blockIndex + level && point.path[0] + level > -1 && (point.path = [point.path[0] + level, ...point.path.slice(1)]);\n    }), currentFocus && currentAnchor && (transformedOperation.properties = {\n      focus: currentFocus,\n      anchor: currentAnchor\n    }), newFocus && newAnchor && (transformedOperation.newProperties = {\n      focus: newFocus,\n      anchor: newAnchor\n    }));\n  }\n  return transformedOperation;\n}\nconst shouldMerge = (op, prev) => !!(op.type === \"set_selection\" || prev && op.type === \"insert_text\" && prev.type === \"insert_text\" && op.offset === prev.offset + prev.text.length && slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(op.path, prev.path) && op.text !== \" \" || prev && op.type === \"remove_text\" && prev.type === \"remove_text\" && op.offset + op.text.length === prev.offset && slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(op.path, prev.path)), shouldOverwrite = (op, prev) => !!(prev && op.type === \"set_selection\" && prev.type === \"set_selection\"), shouldClear = (op) => op.type !== \"set_selection\";\nfunction withoutSaving(editor, fn) {\n  const prev = isSaving(editor);\n  SAVING.set(editor, !1), fn(), SAVING.set(editor, prev);\n}\nfunction createSelectOperation(editor) {\n  return {\n    type: \"set_selection\",\n    properties: {\n      ...editor.selection\n    },\n    newProperties: {\n      ...editor.selection\n    }\n  };\n}\nfunction findOperationTargetBlock(editor, operation) {\n  let block;\n  return operation.type === \"set_selection\" && editor.selection ? block = editor.children[editor.selection.focus.path[0]] : \"path\" in operation && (block = editor.children[operation.path[0]]), block;\n}\nconst debug$c = debugWithName(\"sync machine\"), syncValueCallback = ({\n  sendBack,\n  input\n}) => {\n  updateValue({\n    context: input.context,\n    sendBack,\n    slateEditor: input.slateEditor,\n    value: input.value,\n    streamBlocks: input.streamBlocks\n  });\n}, syncValueLogic = (0,xstate__WEBPACK_IMPORTED_MODULE_18__.fromCallback)(syncValueCallback), syncMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_16__.setup)({\n  types: {\n    context: {},\n    input: {},\n    events: {},\n    emitted: {}\n  },\n  actions: {\n    \"assign initial value synced\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.a)({\n      initialValueSynced: !0\n    }),\n    \"assign readOnly\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.a)({\n      readOnly: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_16__.assertEvent)(event, \"update readOnly\"), event.readOnly)\n    }),\n    \"assign pending value\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.a)({\n      pendingValue: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_16__.assertEvent)(event, \"update value\"), event.value)\n    }),\n    \"clear pending value\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.a)({\n      pendingValue: void 0\n    }),\n    \"assign previous value\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.a)({\n      previousValue: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_16__.assertEvent)(event, \"done syncing\"), event.value)\n    }),\n    \"emit done syncing initial value\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)({\n      type: \"done syncing initial value\"\n    })\n  },\n  guards: {\n    \"initial value synced\": ({\n      context\n    }) => context.initialValueSynced,\n    \"is busy\": ({\n      context\n    }) => {\n      const editable = !context.readOnly, isProcessingLocalChanges = context.isProcessingLocalChanges, isChanging = isChangingRemotely(context.slateEditor) ?? !1, isBusy = editable && (isProcessingLocalChanges || isChanging);\n      return debug$c(\"isBusy\", {\n        isBusy,\n        editable,\n        isProcessingLocalChanges,\n        isChanging\n      }), isBusy;\n    },\n    \"value changed while syncing\": ({\n      context,\n      event\n    }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_16__.assertEvent)(event, \"done syncing\"), context.pendingValue !== event.value),\n    \"pending value equals previous value\": ({\n      context\n    }) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_4__(context.pendingValue, context.previousValue)\n  },\n  actors: {\n    \"sync value\": syncValueLogic\n  }\n}).createMachine({\n  id: \"sync\",\n  context: ({\n    input\n  }) => ({\n    initialValueSynced: !1,\n    isProcessingLocalChanges: !1,\n    keyGenerator: input.keyGenerator,\n    schema: input.schema,\n    readOnly: input.readOnly,\n    slateEditor: input.slateEditor,\n    pendingValue: void 0,\n    previousValue: void 0\n  }),\n  on: {\n    \"has pending patches\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.a)({\n        isProcessingLocalChanges: !0\n      })\n    },\n    mutation: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.a)({\n        isProcessingLocalChanges: !1\n      })\n    },\n    \"update readOnly\": {\n      actions: [\"assign readOnly\"]\n    }\n  },\n  type: \"parallel\",\n  states: {\n    \"setting up\": {\n      initial: \"syncing initial value\",\n      states: {\n        \"syncing initial value\": {\n          entry: [() => {\n            debug$c(\"entry: syncing initial value\");\n          }],\n          exit: [() => {\n            debug$c(\"exit: syncing initial value\");\n          }],\n          always: {\n            guard: \"initial value synced\",\n            target: \"done syncing initial value\"\n          }\n        },\n        \"done syncing initial value\": {\n          entry: [\"emit done syncing initial value\", () => {\n            debug$c(\"entry: done syncing initial value\");\n          }],\n          exit: [() => {\n            debug$c(\"exit: done syncing initial value\");\n          }],\n          type: \"final\"\n        }\n      }\n    },\n    syncing: {\n      initial: \"idle\",\n      states: {\n        idle: {\n          entry: [() => {\n            debug$c(\"entry: syncing->idle\");\n          }],\n          exit: [() => {\n            debug$c(\"exit: syncing->idle\");\n          }],\n          on: {\n            \"update value\": [{\n              guard: \"is busy\",\n              target: \"busy\",\n              actions: [\"assign pending value\"]\n            }, {\n              target: \"syncing\",\n              actions: [\"assign pending value\"]\n            }]\n          }\n        },\n        busy: {\n          entry: [() => {\n            debug$c(\"entry: syncing->busy\");\n          }],\n          exit: [() => {\n            debug$c(\"exit: syncing->busy\");\n          }],\n          after: {\n            1e3: [{\n              guard: \"is busy\",\n              target: \".\",\n              reenter: !0,\n              actions: [() => {\n                debug$c(\"reenter: syncing->busy\");\n              }]\n            }, {\n              target: \"syncing\"\n            }]\n          },\n          on: {\n            \"update value\": [{\n              actions: [\"assign pending value\"]\n            }]\n          }\n        },\n        syncing: {\n          entry: [() => {\n            debug$c(\"entry: syncing->syncing\");\n          }],\n          exit: [() => {\n            debug$c(\"exit: syncing->syncing\");\n          }],\n          always: {\n            guard: \"pending value equals previous value\",\n            target: \"idle\",\n            actions: [\"clear pending value\", \"assign initial value synced\"]\n          },\n          invoke: {\n            src: \"sync value\",\n            id: \"sync value\",\n            input: ({\n              context\n            }) => ({\n              context: {\n                keyGenerator: context.keyGenerator,\n                previousValue: context.previousValue,\n                readOnly: context.readOnly,\n                schema: context.schema\n              },\n              slateEditor: context.slateEditor,\n              streamBlocks: !context.initialValueSynced,\n              value: context.pendingValue\n            })\n          },\n          on: {\n            \"update value\": {\n              actions: [\"assign pending value\"]\n            },\n            patch: {\n              actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n                event\n              }) => event)]\n            },\n            \"invalid value\": {\n              actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n                event\n              }) => event)]\n            },\n            \"value changed\": {\n              actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n                event\n              }) => event)]\n            },\n            \"done syncing\": [{\n              guard: \"value changed while syncing\",\n              actions: [\"assign previous value\", \"assign initial value synced\"],\n              reenter: !0\n            }, {\n              target: \"idle\",\n              actions: [\"clear pending value\", \"assign previous value\", \"assign initial value synced\"]\n            }]\n          }\n        }\n      }\n    }\n  }\n});\nasync function updateValue({\n  context,\n  sendBack,\n  slateEditor,\n  streamBlocks,\n  value\n}) {\n  let isChanged = !1, isValid = !0;\n  const hadSelection = !!slateEditor.selection;\n  if ((!value || value.length === 0) && (debug$c(\"Value is empty\"), slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(slateEditor, () => {\n    withoutSaving(slateEditor, () => {\n      withoutPatching(slateEditor, () => {\n        hadSelection && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(slateEditor);\n        const childrenLength = slateEditor.children.length;\n        slateEditor.children.forEach((_, index) => {\n          slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n            at: [childrenLength - 1 - index]\n          });\n        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, slateEditor.pteCreateTextBlock({\n          decorators: []\n        }), {\n          at: [0]\n        }), hadSelection && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, [0, 0]);\n      });\n    });\n  }), isChanged = !0), value && value.length > 0) {\n    const slateValueFromProps = toSlateValue(value, {\n      schemaTypes: context.schema\n    });\n    await new Promise((resolve) => {\n      slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(slateEditor, () => {\n        withRemoteChanges(slateEditor, () => {\n          withoutPatching(slateEditor, async () => {\n            const childrenLength = slateEditor.children.length;\n            if (slateValueFromProps.length < childrenLength) {\n              for (let i = childrenLength - 1; i > slateValueFromProps.length - 1; i--)\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n                  at: [i]\n                });\n              isChanged = !0;\n            }\n            for await (const [currentBlock, currentBlockIndex] of getBlocks({\n              slateValue: slateValueFromProps,\n              streamBlocks\n            })) {\n              const {\n                blockChanged,\n                blockValid\n              } = syncBlock({\n                context,\n                sendBack,\n                block: currentBlock,\n                index: currentBlockIndex,\n                slateEditor,\n                value\n              });\n              isChanged = blockChanged || isChanged, isValid = isValid && blockValid;\n            }\n            resolve();\n          });\n        });\n      });\n    });\n  }\n  if (!isValid) {\n    debug$c(\"Invalid value, returning\"), sendBack({\n      type: \"done syncing\",\n      value\n    });\n    return;\n  }\n  if (isChanged) {\n    debug$c(\"Server value changed, syncing editor\");\n    try {\n      slateEditor.onChange();\n    } catch (err) {\n      console.error(err), sendBack({\n        type: \"invalid value\",\n        resolution: null,\n        value\n      }), sendBack({\n        type: \"done syncing\",\n        value\n      });\n      return;\n    }\n    hadSelection && !slateEditor.selection && (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, {\n      anchor: {\n        path: [0, 0],\n        offset: 0\n      },\n      focus: {\n        path: [0, 0],\n        offset: 0\n      }\n    }), slateEditor.onChange()), sendBack({\n      type: \"value changed\",\n      value\n    });\n  } else\n    debug$c(\"Server value and editor value is equal, no need to sync.\");\n  sendBack({\n    type: \"done syncing\",\n    value\n  });\n}\nasync function* getBlocks({\n  slateValue,\n  streamBlocks\n}) {\n  let index = 0;\n  for await (const block of slateValue)\n    streamBlocks && await new Promise((resolve) => setTimeout(resolve, 0)), yield [block, index], index++;\n}\nfunction syncBlock({\n  context,\n  sendBack,\n  block,\n  index,\n  slateEditor,\n  value\n}) {\n  let blockChanged = !1, blockValid = !0;\n  const currentBlock = block, currentBlockIndex = index, oldBlock = slateEditor.children[currentBlockIndex], hasChanges = oldBlock && !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_4__(currentBlock, oldBlock);\n  return slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(slateEditor, () => {\n    withRemoteChanges(slateEditor, () => {\n      withoutPatching(slateEditor, () => {\n        if (hasChanges && blockValid) {\n          const validationValue = [value[currentBlockIndex]], validation = validateValue(validationValue, context.schema, context.keyGenerator);\n          !validation.valid && validation.resolution?.autoResolve && validation.resolution?.patches.length > 0 && !context.readOnly && context.previousValue && context.previousValue !== value && (console.warn(`${validation.resolution.action} for block with _key '${validationValue[0]._key}'. ${validation.resolution?.description}`), validation.resolution.patches.forEach((patch) => {\n            sendBack({\n              type: \"patch\",\n              patch\n            });\n          })), validation.valid || validation.resolution?.autoResolve ? (oldBlock._key === currentBlock._key ? (debug$c.enabled && debug$c(\"Updating block\", oldBlock, currentBlock), _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex)) : (debug$c.enabled && debug$c(\"Replacing block\", oldBlock, currentBlock), _replaceBlock(slateEditor, currentBlock, currentBlockIndex)), blockChanged = !0) : (sendBack({\n            type: \"invalid value\",\n            resolution: validation.resolution,\n            value\n          }), blockValid = !1);\n        }\n        if (!oldBlock && blockValid) {\n          const validationValue = [value[currentBlockIndex]], validation = validateValue(validationValue, context.schema, context.keyGenerator);\n          debug$c.enabled && debug$c(\"Validating and inserting new block in the end of the value\", currentBlock), validation.valid || validation.resolution?.autoResolve ? slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, currentBlock, {\n            at: [currentBlockIndex]\n          }) : (debug$c(\"Invalid\", validation), sendBack({\n            type: \"invalid value\",\n            resolution: validation.resolution,\n            value\n          }), blockValid = !1);\n        }\n      });\n    });\n  }), {\n    blockChanged,\n    blockValid\n  };\n}\nfunction _replaceBlock(slateEditor, currentBlock, currentBlockIndex) {\n  const currentSelection = slateEditor.selection, selectionFocusOnBlock = currentSelection && currentSelection.focus.path[0] === currentBlockIndex;\n  selectionFocusOnBlock && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(slateEditor), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n    at: [currentBlockIndex]\n  }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, currentBlock, {\n    at: [currentBlockIndex]\n  }), slateEditor.onChange(), selectionFocusOnBlock && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, currentSelection);\n}\nfunction _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex) {\n  if (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(slateEditor, currentBlock, {\n    at: [currentBlockIndex]\n  }), slateEditor.isTextBlock(currentBlock) && slateEditor.isTextBlock(oldBlock)) {\n    const oldBlockChildrenLength = oldBlock.children.length;\n    currentBlock.children.length < oldBlockChildrenLength && Array.from(Array(oldBlockChildrenLength - currentBlock.children.length)).forEach((_, index) => {\n      const childIndex = oldBlockChildrenLength - 1 - index;\n      childIndex > 0 && (debug$c(\"Removing child\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n        at: [currentBlockIndex, childIndex]\n      }));\n    }), currentBlock.children.forEach((currentBlockChild, currentBlockChildIndex) => {\n      const oldBlockChild = oldBlock.children[currentBlockChildIndex], isChildChanged = !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_4__(currentBlockChild, oldBlockChild), isTextChanged = !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_4__(currentBlockChild.text, oldBlockChild?.text), path = [currentBlockIndex, currentBlockChildIndex];\n      if (isChildChanged)\n        if (currentBlockChild._key === oldBlockChild?._key) {\n          debug$c(\"Updating changed child\", currentBlockChild, oldBlockChild), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(slateEditor, currentBlockChild, {\n            at: path\n          });\n          const isSpanNode = slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(currentBlockChild) && currentBlockChild._type === \"span\" && slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(oldBlockChild) && oldBlockChild._type === \"span\";\n          isSpanNode && isTextChanged ? (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.delete(slateEditor, {\n            at: {\n              focus: {\n                path,\n                offset: 0\n              },\n              anchor: {\n                path,\n                offset: oldBlockChild.text.length\n              }\n            }\n          }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertText(slateEditor, currentBlockChild.text, {\n            at: path\n          }), slateEditor.onChange()) : isSpanNode || (debug$c(\"Updating changed inline object child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(slateEditor, {\n            _key: VOID_CHILD_KEY\n          }, {\n            at: [...path, 0],\n            voids: !0\n          }));\n        } else oldBlockChild ? (debug$c(\"Replacing child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n          at: [currentBlockIndex, currentBlockChildIndex]\n        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, currentBlockChild, {\n          at: [currentBlockIndex, currentBlockChildIndex]\n        }), slateEditor.onChange()) : oldBlockChild || (debug$c(\"Inserting new child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, currentBlockChild, {\n          at: [currentBlockIndex, currentBlockChildIndex]\n        }), slateEditor.onChange());\n    });\n  }\n}\nconst debug$b = debugWithName(\"component:PortableTextEditor:Synchronizer\");\nfunction Synchronizer(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__.c)(41), {\n    editorActor,\n    slateEditor\n  } = props, value = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_22__.useSelector)(props.editorActor, _temp), readOnly = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_22__.useSelector)(props.editorActor, _temp2);\n  let t0;\n  $[0] !== props.editorActor ? (t0 = props.editorActor.getSnapshot(), $[0] = props.editorActor, $[1] = t0) : t0 = $[1];\n  const t1 = t0.context.keyGenerator;\n  let t2;\n  $[2] !== props.editorActor ? (t2 = props.editorActor.getSnapshot().matches({\n    \"edit mode\": \"read only\"\n  }), $[2] = props.editorActor, $[3] = t2) : t2 = $[3];\n  let t3;\n  $[4] !== props.editorActor ? (t3 = props.editorActor.getSnapshot(), $[4] = props.editorActor, $[5] = t3) : t3 = $[5];\n  let t4;\n  $[6] !== slateEditor || $[7] !== t0.context.keyGenerator || $[8] !== t2 || $[9] !== t3.context.schema ? (t4 = {\n    input: {\n      keyGenerator: t1,\n      readOnly: t2,\n      schema: t3.context.schema,\n      slateEditor\n    }\n  }, $[6] = slateEditor, $[7] = t0.context.keyGenerator, $[8] = t2, $[9] = t3.context.schema, $[10] = t4) : t4 = $[10];\n  const syncActorRef = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_22__.useActorRef)(syncMachine, t4);\n  let t5;\n  $[11] !== editorActor ? (t5 = editorActor.getSnapshot(), $[11] = editorActor, $[12] = t5) : t5 = $[12];\n  let t6;\n  $[13] !== slateEditor || $[14] !== t5.context.schema ? (t6 = {\n    input: {\n      schema: t5.context.schema,\n      slateEditor\n    }\n  }, $[13] = slateEditor, $[14] = t5.context.schema, $[15] = t6) : t6 = $[15];\n  const mutationActorRef = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_22__.useActorRef)(mutationMachine, t6);\n  let t7, t8;\n  $[16] !== editorActor || $[17] !== mutationActorRef || $[18] !== syncActorRef ? (t7 = () => {\n    const subscription = mutationActorRef.on(\"*\", (event) => {\n      event.type === \"has pending patches\" && syncActorRef.send({\n        type: \"has pending patches\"\n      }), event.type === \"mutation\" && (syncActorRef.send({\n        type: \"mutation\"\n      }), editorActor.send({\n        type: \"mutation\",\n        patches: event.patches,\n        snapshot: event.snapshot,\n        value: event.snapshot\n      }));\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, t8 = [mutationActorRef, syncActorRef, editorActor], $[16] = editorActor, $[17] = mutationActorRef, $[18] = syncActorRef, $[19] = t7, $[20] = t8) : (t7 = $[19], t8 = $[20]), (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(t7, t8);\n  let t10, t9;\n  $[21] !== props.editorActor || $[22] !== slateEditor || $[23] !== syncActorRef ? (t9 = () => {\n    const subscription_0 = syncActorRef.on(\"*\", (event_0) => {\n      bb15: switch (event_0.type) {\n        case \"invalid value\": {\n          props.editorActor.send({\n            ...event_0,\n            type: \"notify.invalid value\"\n          });\n          break bb15;\n        }\n        case \"value changed\": {\n          props.editorActor.send({\n            ...event_0,\n            type: \"notify.value changed\"\n          });\n          break bb15;\n        }\n        case \"patch\": {\n          props.editorActor.send({\n            ...event_0,\n            type: \"internal.patch\",\n            value: fromSlateValue(slateEditor.children, props.editorActor.getSnapshot().context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(slateEditor))\n          });\n          break bb15;\n        }\n        default:\n          props.editorActor.send(event_0);\n      }\n    });\n    return () => {\n      subscription_0.unsubscribe();\n    };\n  }, t10 = [props.editorActor, slateEditor, syncActorRef], $[21] = props.editorActor, $[22] = slateEditor, $[23] = syncActorRef, $[24] = t10, $[25] = t9) : (t10 = $[24], t9 = $[25]), (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(t9, t10);\n  let t11, t12;\n  $[26] !== readOnly || $[27] !== syncActorRef ? (t11 = () => {\n    syncActorRef.send({\n      type: \"update readOnly\",\n      readOnly\n    });\n  }, t12 = [syncActorRef, readOnly], $[26] = readOnly, $[27] = syncActorRef, $[28] = t11, $[29] = t12) : (t11 = $[28], t12 = $[29]), (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(t11, t12);\n  let t13, t14;\n  $[30] !== syncActorRef || $[31] !== value ? (t13 = () => {\n    debug$b(\"Value from props changed, syncing new value\"), syncActorRef.send({\n      type: \"update value\",\n      value\n    });\n  }, t14 = [syncActorRef, value], $[30] = syncActorRef, $[31] = value, $[32] = t13, $[33] = t14) : (t13 = $[32], t14 = $[33]), (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(t13, t14);\n  let t15;\n  $[34] !== editorActor || $[35] !== mutationActorRef ? (t15 = () => {\n    debug$b(\"Subscribing to patch events\");\n    const sub = editorActor.on(\"internal.patch\", (event_1) => {\n      mutationActorRef.send({\n        ...event_1,\n        type: \"patch\"\n      });\n    });\n    return () => {\n      debug$b(\"Unsubscribing to patch events\"), sub.unsubscribe();\n    };\n  }, $[34] = editorActor, $[35] = mutationActorRef, $[36] = t15) : t15 = $[36];\n  let t16;\n  return $[37] !== editorActor || $[38] !== mutationActorRef || $[39] !== slateEditor ? (t16 = [editorActor, mutationActorRef, slateEditor], $[37] = editorActor, $[38] = mutationActorRef, $[39] = slateEditor, $[40] = t16) : t16 = $[40], (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(t15, t16), null;\n}\nfunction _temp2(s_0) {\n  return s_0.matches({\n    \"edit mode\": \"read only\"\n  });\n}\nfunction _temp(s) {\n  return s.context.value;\n}\nSynchronizer.displayName = \"Synchronizer\";\nconst converterJson = {\n  mimeType: \"application/json\",\n  serialize: ({\n    snapshot,\n    event\n  }) => {\n    const portableTextConverter = snapshot.context.converters.find((converter) => converter.mimeType === \"application/x-portable-text\");\n    return portableTextConverter ? {\n      ...portableTextConverter.serialize({\n        snapshot,\n        event\n      }),\n      mimeType: \"application/json\",\n      originEvent: event.originEvent\n    } : {\n      type: \"serialization.failure\",\n      mimeType: \"application/json\",\n      originEvent: event.originEvent,\n      reason: \"No application/x-portable-text Converter found\"\n    };\n  },\n  deserialize: ({\n    snapshot,\n    event\n  }) => {\n    const portableTextConverter = snapshot.context.converters.find((converter) => converter.mimeType === \"application/x-portable-text\");\n    return portableTextConverter ? {\n      ...portableTextConverter.deserialize({\n        snapshot,\n        event\n      }),\n      mimeType: \"application/json\"\n    } : {\n      type: \"deserialization.failure\",\n      mimeType: \"application/json\",\n      reason: \"No application/x-portable-text Converter found\"\n    };\n  }\n}, converterPortableText = {\n  mimeType: \"application/x-portable-text\",\n  serialize: ({\n    snapshot,\n    event\n  }) => {\n    if (!snapshot.context.selection)\n      return {\n        type: \"serialization.failure\",\n        mimeType: \"application/x-portable-text\",\n        originEvent: event.originEvent,\n        reason: \"No selection\"\n      };\n    const blocks = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_23__.sliceBlocks)({\n      blocks: snapshot.context.value,\n      selection: snapshot.context.selection\n    });\n    return {\n      type: \"serialization.success\",\n      data: JSON.stringify(blocks),\n      mimeType: \"application/x-portable-text\",\n      originEvent: event.originEvent\n    };\n  },\n  deserialize: ({\n    snapshot,\n    event\n  }) => {\n    const blocks = JSON.parse(event.data);\n    if (!Array.isArray(blocks))\n      return {\n        type: \"deserialization.failure\",\n        mimeType: \"application/x-portable-text\",\n        reason: \"Data is not an array\"\n      };\n    const parsedBlocks = blocks.flatMap((block) => {\n      const parsedBlock = (0,_util_block_offsets_to_selection_js__WEBPACK_IMPORTED_MODULE_24__.parseBlock)({\n        context: snapshot.context,\n        block,\n        options: {\n          /**\n           * If we are dragging internally then we would like to keep the\n           * dropped portable text as is.\n           */\n          refreshKeys: !snapshot.beta.hasTag?.(\"dragging internally\")\n        }\n      });\n      return parsedBlock ? [parsedBlock] : [];\n    });\n    return parsedBlocks.length === 0 && blocks.length > 0 ? {\n      type: \"deserialization.failure\",\n      mimeType: \"application/x-portable-text\",\n      reason: \"No blocks were parsed\"\n    } : {\n      type: \"deserialization.success\",\n      data: parsedBlocks,\n      mimeType: \"application/x-portable-text\"\n    };\n  }\n}, converterTextHtml = {\n  mimeType: \"text/html\",\n  serialize: ({\n    snapshot,\n    event\n  }) => {\n    if (!snapshot.context.selection)\n      return {\n        type: \"serialization.failure\",\n        mimeType: \"text/html\",\n        originEvent: event.originEvent,\n        reason: \"No selection\"\n      };\n    const blocks = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_23__.sliceBlocks)({\n      blocks: snapshot.context.value,\n      selection: snapshot.context.selection\n    }), html = (0,_portabletext_to_html__WEBPACK_IMPORTED_MODULE_25__.toHTML)(blocks, {\n      onMissingComponent: !1,\n      components: {\n        unknownType: ({\n          children\n        }) => children !== void 0 ? `${children}` : \"\"\n      }\n    });\n    return html === \"\" ? {\n      type: \"serialization.failure\",\n      mimeType: \"text/html\",\n      originEvent: event.originEvent,\n      reason: \"Serialized HTML is empty\"\n    } : {\n      type: \"serialization.success\",\n      data: html,\n      mimeType: \"text/html\",\n      originEvent: event.originEvent\n    };\n  },\n  deserialize: ({\n    snapshot,\n    event\n  }) => ({\n    type: \"deserialization.success\",\n    data: (0,_portabletext_block_tools__WEBPACK_IMPORTED_MODULE_26__.htmlToBlocks)(event.data, snapshot.context.schema.portableText, {\n      keyGenerator: snapshot.context.keyGenerator,\n      unstable_whitespaceOnPasteMode: snapshot.context.schema.block.options.unstable_whitespaceOnPasteMode\n    }),\n    mimeType: \"text/html\"\n  })\n}, converterTextPlain = {\n  mimeType: \"text/plain\",\n  serialize: ({\n    snapshot,\n    event\n  }) => snapshot.context.selection ? {\n    type: \"serialization.success\",\n    data: (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_23__.sliceBlocks)({\n      blocks: snapshot.context.value,\n      selection: snapshot.context.selection\n    }).map((block) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isPortableTextTextBlock)(block) ? block.children.map((child) => child._type === snapshot.context.schema.span.name ? child.text : `[${snapshot.context.schema.inlineObjects.find((inlineObjectType) => inlineObjectType.name === child._type)?.title ?? \"Object\"}]`).join(\"\") : `[${snapshot.context.schema.blockObjects.find((blockObjectType) => blockObjectType.name === block._type)?.title ?? \"Object\"}]`).join(`\n\n`),\n    mimeType: \"text/plain\",\n    originEvent: event.originEvent\n  } : {\n    type: \"serialization.failure\",\n    mimeType: \"text/plain\",\n    originEvent: event.originEvent,\n    reason: \"No selection\"\n  },\n  deserialize: ({\n    snapshot,\n    event\n  }) => {\n    const textToHtml = `<html><body>${escapeHtml(event.data).split(/\\n{2,}/).map((line) => line ? `<p>${line.replace(/(?:\\r\\n|\\r|\\n)/g, \"<br/>\")}</p>` : \"<p></p>\").join(\"\")}</body></html>`;\n    return {\n      type: \"deserialization.success\",\n      data: (0,_portabletext_block_tools__WEBPACK_IMPORTED_MODULE_26__.htmlToBlocks)(textToHtml, snapshot.context.schema.portableText, {\n        keyGenerator: snapshot.context.keyGenerator\n      }),\n      mimeType: \"text/plain\"\n    };\n  }\n}, entityMap = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\",\n  \"/\": \"&#x2F;\",\n  \"`\": \"&#x60;\",\n  \"=\": \"&#x3D;\"\n};\nfunction escapeHtml(str) {\n  return String(str).replace(/[&<>\"'`=/]/g, (s) => entityMap[s]);\n}\nconst coreConverters = [converterJson, converterPortableText, converterTextHtml, converterTextPlain], debug$a = debugWithName(\"operationToPatches\");\nfunction createOperationToPatches(types) {\n  const textBlockName = types.block.name;\n  function insertTextPatch(editor, operation, beforeValue) {\n    debug$a.enabled && debug$a(\"Operation\", JSON.stringify(operation, null, 2));\n    const block = editor.isTextBlock(editor.children[operation.path[0]]) && editor.children[operation.path[0]];\n    if (!block)\n      throw new Error(\"Could not find block\");\n    const textChild = editor.isTextBlock(block) && editor.isTextSpan(block.children[operation.path[1]]) && block.children[operation.path[1]];\n    if (!textChild)\n      throw new Error(\"Could not find child\");\n    const path = [{\n      _key: block._key\n    }, \"children\", {\n      _key: textChild._key\n    }, \"text\"], prevBlock = beforeValue[operation.path[0]], prevChild = editor.isTextBlock(prevBlock) && prevBlock.children[operation.path[1]], prevText = editor.isTextSpan(prevChild) ? prevChild.text : \"\", patch = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.diffMatchPatch)(prevText, textChild.text, path);\n    return patch.value.length ? [patch] : [];\n  }\n  function removeTextPatch(editor, operation, beforeValue) {\n    const block = editor && editor.children[operation.path[0]];\n    if (!block)\n      throw new Error(\"Could not find block\");\n    const child = editor.isTextBlock(block) && block.children[operation.path[1]] || void 0, textChild = editor.isTextSpan(child) ? child : void 0;\n    if (child && !textChild)\n      throw new Error(\"Expected span\");\n    if (!textChild)\n      throw new Error(\"Could not find child\");\n    const path = [{\n      _key: block._key\n    }, \"children\", {\n      _key: textChild._key\n    }, \"text\"], beforeBlock = beforeValue[operation.path[0]], prevTextChild = editor.isTextBlock(beforeBlock) && beforeBlock.children[operation.path[1]], prevText = editor.isTextSpan(prevTextChild) && prevTextChild.text, patch = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.diffMatchPatch)(prevText || \"\", textChild.text, path);\n    return patch.value ? [patch] : [];\n  }\n  function setNodePatch(editor, operation) {\n    if (operation.path.length === 1) {\n      const block = editor.children[operation.path[0]];\n      if (typeof block._key != \"string\")\n        throw new Error(\"Expected block to have a _key\");\n      const setNode = lodash_omitBy_js__WEBPACK_IMPORTED_MODULE_10__({\n        ...editor.children[operation.path[0]],\n        ...operation.newProperties\n      }, lodash_isUndefined_js__WEBPACK_IMPORTED_MODULE_9__);\n      return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(fromSlateValue([setNode], textBlockName)[0], [{\n        _key: block._key\n      }])];\n    } else if (operation.path.length === 2) {\n      const block = editor.children[operation.path[0]];\n      if (editor.isTextBlock(block)) {\n        const child = block.children[operation.path[1]];\n        if (child) {\n          const blockKey = block._key, childKey = child._key, patches = [], keys = Object.keys(operation.newProperties);\n          return keys.forEach((keyName) => {\n            if (keys.length === 1 && keyName === \"_key\") {\n              const val = lodash_get_js__WEBPACK_IMPORTED_MODULE_8__(operation.newProperties, keyName);\n              patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(val, [{\n                _key: blockKey\n              }, \"children\", block.children.indexOf(child), keyName]));\n            } else {\n              const val = lodash_get_js__WEBPACK_IMPORTED_MODULE_8__(operation.newProperties, keyName);\n              patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(val, [{\n                _key: blockKey\n              }, \"children\", {\n                _key: childKey\n              }, keyName]));\n            }\n          }), patches;\n        }\n        throw new Error(\"Could not find a valid child\");\n      }\n      throw new Error(\"Could not find a valid block\");\n    } else\n      throw new Error(`Unexpected path encountered: ${JSON.stringify(operation.path)}`);\n  }\n  function insertNodePatch(editor, operation, beforeValue) {\n    const block = beforeValue[operation.path[0]], isTextBlock2 = editor.isTextBlock(block);\n    if (operation.path.length === 1) {\n      const position = operation.path[0] === 0 ? \"before\" : \"after\", beforeBlock = beforeValue[operation.path[0] - 1], targetKey = operation.path[0] === 0 ? block?._key : beforeBlock?._key;\n      return targetKey ? [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([fromSlateValue([operation.node], textBlockName)[0]], position, [{\n        _key: targetKey\n      }])] : [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.setIfMissing)(beforeValue, []), (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([fromSlateValue([operation.node], textBlockName)[0]], \"before\", [operation.path[0]])];\n    } else if (isTextBlock2 && operation.path.length === 2 && editor.children[operation.path[0]]) {\n      const position = block.children.length === 0 || !block.children[operation.path[1] - 1] ? \"before\" : \"after\", node = {\n        ...operation.node\n      };\n      !node._type && slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(node) && (node._type = \"span\", node.marks = []);\n      const child = fromSlateValue([{\n        _key: \"bogus\",\n        _type: textBlockName,\n        children: [node]\n      }], textBlockName)[0].children[0];\n      return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([child], position, [{\n        _key: block._key\n      }, \"children\", block.children.length <= 1 || !block.children[operation.path[1] - 1] ? 0 : {\n        _key: block.children[operation.path[1] - 1]._key\n      }])];\n    }\n    return debug$a(\"Something was inserted into a void block. Not producing editor patches.\"), [];\n  }\n  function splitNodePatch(editor, operation, beforeValue) {\n    const patches = [], splitBlock = editor.children[operation.path[0]];\n    if (!editor.isTextBlock(splitBlock))\n      throw new Error(`Block with path ${JSON.stringify(operation.path[0])} is not a text block and can't be split`);\n    if (operation.path.length === 1) {\n      const oldBlock = beforeValue[operation.path[0]];\n      if (editor.isTextBlock(oldBlock)) {\n        const targetValue = fromSlateValue([editor.children[operation.path[0] + 1]], textBlockName)[0];\n        targetValue && (patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([targetValue], \"after\", [{\n          _key: splitBlock._key\n        }])), oldBlock.children.slice(operation.position).forEach((span) => {\n          const path = [{\n            _key: oldBlock._key\n          }, \"children\", {\n            _key: span._key\n          }];\n          patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)(path));\n        }));\n      }\n      return patches;\n    }\n    if (operation.path.length === 2) {\n      const splitSpan = splitBlock.children[operation.path[1]];\n      if (editor.isTextSpan(splitSpan)) {\n        const targetSpans = fromSlateValue([{\n          ...splitBlock,\n          children: splitBlock.children.slice(operation.path[1] + 1, operation.path[1] + 2)\n        }], textBlockName)[0].children;\n        patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)(targetSpans, \"after\", [{\n          _key: splitBlock._key\n        }, \"children\", {\n          _key: splitSpan._key\n        }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(splitSpan.text, [{\n          _key: splitBlock._key\n        }, \"children\", {\n          _key: splitSpan._key\n        }, \"text\"]));\n      }\n      return patches;\n    }\n    return patches;\n  }\n  function removeNodePatch(editor, operation, beforeValue) {\n    const block = beforeValue[operation.path[0]];\n    if (operation.path.length === 1) {\n      if (block && block._key)\n        return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n          _key: block._key\n        }])];\n      throw new Error(\"Block not found\");\n    } else if (editor.isTextBlock(block) && operation.path.length === 2) {\n      const spanToRemove = block.children[operation.path[1]];\n      return spanToRemove ? block.children.filter((span) => span._key === operation.node._key).length > 1 ? (console.warn(`Multiple spans have \\`_key\\` ${operation.node._key}. It's ambiguous which one to remove.`, JSON.stringify(block, null, 2)), []) : [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n        _key: block._key\n      }, \"children\", {\n        _key: spanToRemove._key\n      }])] : (debug$a(\"Span not found in editor trying to remove node\"), []);\n    } else\n      return debug$a(\"Not creating patch inside object block\"), [];\n  }\n  function mergeNodePatch(editor, operation, beforeValue) {\n    const patches = [], block = beforeValue[operation.path[0]], updatedBlock = editor.children[operation.path[0]];\n    if (operation.path.length === 1)\n      if (block?._key) {\n        const newBlock = fromSlateValue([editor.children[operation.path[0] - 1]], textBlockName)[0];\n        patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(newBlock, [{\n          _key: newBlock._key\n        }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n          _key: block._key\n        }]));\n      } else\n        throw new Error(\"Target key not found!\");\n    else if (editor.isTextBlock(block) && editor.isTextBlock(updatedBlock) && operation.path.length === 2) {\n      const updatedSpan = updatedBlock.children[operation.path[1] - 1] && editor.isTextSpan(updatedBlock.children[operation.path[1] - 1]) ? updatedBlock.children[operation.path[1] - 1] : void 0, removedSpan = block.children[operation.path[1]] && editor.isTextSpan(block.children[operation.path[1]]) ? block.children[operation.path[1]] : void 0;\n      updatedSpan && (block.children.filter((span) => span._key === updatedSpan._key).length === 1 ? patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(updatedSpan.text, [{\n        _key: block._key\n      }, \"children\", {\n        _key: updatedSpan._key\n      }, \"text\"])) : console.warn(`Multiple spans have \\`_key\\` ${updatedSpan._key}. It's ambiguous which one to update.`, JSON.stringify(block, null, 2))), removedSpan && (block.children.filter((span) => span._key === removedSpan._key).length === 1 ? patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n        _key: block._key\n      }, \"children\", {\n        _key: removedSpan._key\n      }])) : console.warn(`Multiple spans have \\`_key\\` ${removedSpan._key}. It's ambiguous which one to remove.`, JSON.stringify(block, null, 2)));\n    } else\n      debug$a(\"Void nodes can't be merged, not creating any patches\");\n    return patches;\n  }\n  function moveNodePatch(editor, operation, beforeValue) {\n    const patches = [], block = beforeValue[operation.path[0]], targetBlock = beforeValue[operation.newPath[0]];\n    if (!targetBlock)\n      return patches;\n    if (operation.path.length === 1) {\n      const position = operation.path[0] > operation.newPath[0] ? \"before\" : \"after\";\n      patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n        _key: block._key\n      }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([fromSlateValue([block], textBlockName)[0]], position, [{\n        _key: targetBlock._key\n      }]));\n    } else if (operation.path.length === 2 && editor.isTextBlock(block) && editor.isTextBlock(targetBlock)) {\n      const child = block.children[operation.path[1]], targetChild = targetBlock.children[operation.newPath[1]], position = operation.newPath[1] === targetBlock.children.length ? \"after\" : \"before\", childToInsert = fromSlateValue([block], textBlockName)[0].children[operation.path[1]];\n      patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n        _key: block._key\n      }, \"children\", {\n        _key: child._key\n      }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([childToInsert], position, [{\n        _key: targetBlock._key\n      }, \"children\", {\n        _key: targetChild._key\n      }]));\n    }\n    return patches;\n  }\n  return {\n    insertNodePatch,\n    insertTextPatch,\n    mergeNodePatch,\n    moveNodePatch,\n    removeNodePatch,\n    removeTextPatch,\n    setNodePatch,\n    splitNodePatch\n  };\n}\nconst insertBreakActionImplementation = ({\n  context,\n  action\n}) => {\n  const keyGenerator = context.keyGenerator, schema = context.schema, editor = action.editor;\n  if (!editor.selection)\n    return;\n  const anchorBlockPath = editor.selection.anchor.path.slice(0, 1), focusBlockPath = editor.selection.focus.path.slice(0, 1), focusBlock = slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendant(editor, focusBlockPath);\n  if (editor.isTextBlock(focusBlock) && anchorBlockPath[0] === focusBlockPath[0]) {\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.splitNodes(editor, {\n      at: editor.selection\n    });\n    const [nextBlock, nextBlockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, slate__WEBPACK_IMPORTED_MODULE_15__.Path.next(focusBlockPath), {\n      depth: 1\n    }), nextChild = slate__WEBPACK_IMPORTED_MODULE_15__.Node.child(nextBlock, 0);\n    if (!editor.isTextSpan(nextChild) && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n      _key: context.keyGenerator(),\n      _type: \"span\",\n      text: \"\",\n      marks: []\n    }, {\n      at: [nextBlockPath[0], 0]\n    }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setSelection(editor, {\n      anchor: {\n        path: [...nextBlockPath, 0],\n        offset: 0\n      },\n      focus: {\n        path: [...nextBlockPath, 0],\n        offset: 0\n      }\n    }), editor.isTextBlock(nextBlock) && nextBlock.markDefs && nextBlock.markDefs.length > 0) {\n      const newMarkDefKeys = /* @__PURE__ */ new Map(), prevNodeSpans = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, focusBlockPath)).map((entry) => entry[0]).filter((node) => editor.isTextSpan(node)), children = slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, nextBlockPath);\n      for (const [child, childPath] of children) {\n        if (!editor.isTextSpan(child))\n          continue;\n        const marks = child.marks ?? [];\n        for (const mark of marks)\n          schema.decorators.some((decorator) => decorator.value === mark) || prevNodeSpans.some((prevNodeSpan) => prevNodeSpan.marks?.includes(mark)) && !newMarkDefKeys.has(mark) && newMarkDefKeys.set(mark, keyGenerator());\n        const newMarks = marks.map((mark) => newMarkDefKeys.get(mark) ?? mark);\n        lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_4__(marks, newMarks) || slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          marks: newMarks\n        }, {\n          at: childPath\n        });\n      }\n      const newMarkDefs = nextBlock.markDefs.map((markDef) => ({\n        ...markDef,\n        _key: newMarkDefKeys.get(markDef._key) ?? markDef._key\n      }));\n      lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_4__(nextBlock.markDefs, newMarkDefs) || slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n        markDefs: newMarkDefs\n      }, {\n        at: nextBlockPath,\n        match: (node) => editor.isTextBlock(node)\n      });\n    }\n    return;\n  }\n  slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.splitNodes(editor, {\n    always: !0\n  });\n}, insertSoftBreakActionImplementation = ({\n  action\n}) => {\n  (0,slate__WEBPACK_IMPORTED_MODULE_15__.insertText)(action.editor, `\n`);\n}, toggleListItemActionImplementation = ({\n  context,\n  action\n}) => {\n  isListItemActive({\n    editor: action.editor,\n    listItem: action.listItem\n  }) ? removeListItemActionImplementation({\n    context,\n    action: {\n      ...action,\n      type: \"list item.remove\"\n    }\n  }) : addListItemActionImplementation({\n    context,\n    action: {\n      ...action,\n      type: \"list item.add\"\n    }\n  });\n}, removeListItemActionImplementation = ({\n  context,\n  action\n}) => {\n  if (!action.editor.selection)\n    return;\n  const guards = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_27__.createGuards)(context), selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(action.editor, {\n    at: action.editor.selection,\n    match: (node) => guards.isListBlock(node)\n  })];\n  for (const [, at] of selectedBlocks)\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.unsetNodes(action.editor, [\"listItem\", \"level\"], {\n      at\n    });\n}, addListItemActionImplementation = ({\n  context,\n  action\n}) => {\n  if (!action.editor.selection)\n    return;\n  const guards = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_27__.createGuards)(context), selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(action.editor, {\n    at: action.editor.selection,\n    match: (node) => guards.isTextBlock(node)\n  })];\n  for (const [, at] of selectedBlocks)\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(action.editor, {\n      level: 1,\n      listItem: action.listItem\n    }, {\n      at\n    });\n};\nfunction isListItemActive({\n  editor,\n  listItem\n}) {\n  if (!editor.selection)\n    return !1;\n  const selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n    at: editor.selection,\n    match: (node) => editor.isTextBlock(node)\n  })];\n  return selectedBlocks.length > 0 ? selectedBlocks.every(([node]) => editor.isListBlock(node) && node.listItem === listItem) : !1;\n}\nconst toggleStyleActionImplementation = ({\n  context,\n  action\n}) => {\n  isStyleActive({\n    editor: action.editor,\n    style: action.style\n  }) ? removeStyleActionImplementation({\n    context,\n    action: {\n      ...action,\n      type: \"style.remove\"\n    }\n  }) : addStyleActionImplementation({\n    context,\n    action: {\n      ...action,\n      type: \"style.add\"\n    }\n  });\n}, removeStyleActionImplementation = ({\n  context,\n  action\n}) => {\n  if (!action.editor.selection)\n    return;\n  const defaultStyle = context.schema.styles[0].value, guards = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_27__.createGuards)(context), selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(action.editor, {\n    at: action.editor.selection,\n    match: (node) => guards.isTextBlock(node)\n  })];\n  for (const [, at] of selectedBlocks)\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(action.editor, {\n      style: defaultStyle\n    }, {\n      at\n    });\n}, addStyleActionImplementation = ({\n  context,\n  action\n}) => {\n  if (!action.editor.selection)\n    return;\n  const guards = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_27__.createGuards)(context), selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(action.editor, {\n    at: action.editor.selection,\n    match: (node) => guards.isTextBlock(node)\n  })];\n  for (const [, at] of selectedBlocks)\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(action.editor, {\n      style: action.style\n    }, {\n      at\n    });\n};\nfunction isStyleActive({\n  editor,\n  style\n}) {\n  if (!editor.selection)\n    return !1;\n  const selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n    at: editor.selection,\n    match: (node) => editor.isTextBlock(node)\n  })];\n  return selectedBlocks.length > 0 ? selectedBlocks.every(([node]) => node.style === style) : !1;\n}\nfunction isPortableTextSpan(node) {\n  return node._type === \"span\" && \"text\" in node && typeof node.text == \"string\" && (typeof node.marks > \"u\" || Array.isArray(node.marks) && node.marks.every((mark) => typeof mark == \"string\"));\n}\nfunction isPortableTextBlock(node) {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type == \"string\" && // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== \"@\" && // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    (!(\"markDefs\" in node) || !node.markDefs || Array.isArray(node.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans\n    node.markDefs.every((def) => typeof def._key == \"string\")) && // `children` is required and needs to be an array\n    \"children\" in node && Array.isArray(node.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every((child) => typeof child == \"object\" && \"_type\" in child)\n  );\n}\nconst decoratorAddActionImplementation = ({\n  context,\n  action\n}) => {\n  const editor = action.editor, mark = action.decorator, value = fromSlateValue(editor.children, context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), manualAnchor = action.offsets?.anchor ? (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_23__.blockOffsetToSpanSelectionPoint)({\n    value,\n    blockOffset: action.offsets.anchor,\n    direction: \"backward\"\n  }) : void 0, manualFocus = action.offsets?.focus ? (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_23__.blockOffsetToSpanSelectionPoint)({\n    value,\n    blockOffset: action.offsets.focus,\n    direction: \"forward\"\n  }) : void 0, manualSelection = manualAnchor && manualFocus ? {\n    anchor: manualAnchor,\n    focus: manualFocus\n  } : void 0, selection = manualSelection ? toSlateRange(manualSelection, action.editor) ?? editor.selection : editor.selection;\n  if (!selection)\n    return;\n  const editorSelection = toPortableTextRange(value, selection, context.schema), anchorOffset = editorSelection ? (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_23__.spanSelectionPointToBlockOffset)({\n    value,\n    selectionPoint: editorSelection.anchor\n  }) : void 0, focusOffset = editorSelection ? (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_23__.spanSelectionPointToBlockOffset)({\n    value,\n    selectionPoint: editorSelection.focus\n  }) : void 0;\n  if (!anchorOffset || !focusOffset)\n    throw new Error(\"Unable to find anchor or focus offset\");\n  if (slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(selection)) {\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {}, {\n      at: selection,\n      match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n      split: !0,\n      hanging: !0\n    });\n    const newValue = fromSlateValue(editor.children, context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), newSelection = (0,_util_block_offsets_to_selection_js__WEBPACK_IMPORTED_MODULE_24__.blockOffsetsToSelection)({\n      value: newValue,\n      offsets: {\n        anchor: anchorOffset,\n        focus: focusOffset\n      },\n      backward: editorSelection?.backward\n    }), trimmedSelection = (0,_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_28__.getTrimmedSelection)({\n      beta: {\n        hasTag: () => !1\n      },\n      context: {\n        activeDecorators: [],\n        converters: [],\n        keyGenerator: context.keyGenerator,\n        schema: context.schema,\n        selection: newSelection,\n        value: newValue\n      }\n    });\n    if (!trimmedSelection)\n      throw new Error(\"Unable to find trimmed selection\");\n    const newRange = toSlateRange(trimmedSelection, editor);\n    if (!newRange)\n      throw new Error(\"Unable to find new selection\");\n    const splitTextNodes = slate__WEBPACK_IMPORTED_MODULE_15__.Range.isRange(newRange) ? [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n      at: newRange,\n      match: (node) => slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(node)\n    })] : [];\n    for (const [node, path] of splitTextNodes) {\n      const marks = [...(Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark), mark];\n      slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n        marks\n      }, {\n        at: path,\n        match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n        split: !0,\n        hanging: !0\n      });\n    }\n  } else {\n    const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection, {\n      depth: 1\n    }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === \"\" ? block.children[0] : void 0;\n    if (lonelyEmptySpan) {\n      const existingMarks = lonelyEmptySpan.marks ?? [], existingMarksWithoutDecorator = existingMarks.filter((existingMark) => existingMark !== mark);\n      slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n        marks: existingMarks.length === existingMarksWithoutDecorator.length ? [...existingMarks, mark] : existingMarksWithoutDecorator\n      }, {\n        at: blockPath,\n        match: (node) => editor.isTextSpan(node)\n      });\n    } else {\n      const existingMarks = {\n        ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n      }.marks || [], marks = {\n        ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {},\n        marks: [...existingMarks, mark]\n      };\n      editor.marks = marks;\n    }\n  }\n  if (editor.selection) {\n    const selection2 = editor.selection;\n    editor.selection = {\n      ...selection2\n    };\n  }\n};\nfunction getPreviousSpan({\n  editor,\n  blockPath,\n  spanPath\n}) {\n  let previousSpan;\n  for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath, {\n    reverse: !0\n  }))\n    if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_15__.Path.isBefore(childPath, spanPath)) {\n      previousSpan = child;\n      break;\n    }\n  return previousSpan;\n}\nfunction getNextSpan({\n  editor,\n  blockPath,\n  spanPath\n}) {\n  let nextSpan;\n  for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath))\n    if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_15__.Path.isAfter(childPath, spanPath)) {\n      nextSpan = child;\n      break;\n    }\n  return nextSpan;\n}\nconst debug$9 = debugWithName(\"plugin:withPortableTextMarkModel\");\nfunction createWithPortableTextMarkModel(editorActor, types) {\n  return function(editor) {\n    const {\n      apply: apply2,\n      normalizeNode\n    } = editor, decorators = types.decorators.map((t) => t.value);\n    return editor.normalizeNode = (nodeEntry) => {\n      const [node, path] = nodeEntry;\n      if (editor.isTextBlock(node)) {\n        const children = slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, path);\n        for (const [child, childPath] of children) {\n          const nextNode = node.children[childPath[1] + 1];\n          if (editor.isTextSpan(child) && editor.isTextSpan(nextNode) && child.marks?.every((mark) => nextNode.marks?.includes(mark)) && nextNode.marks?.every((mark) => child.marks?.includes(mark))) {\n            debug$9(\"Merging spans\", JSON.stringify(child, null, 2), JSON.stringify(nextNode, null, 2)), editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.mergeNodes(editor, {\n              at: [childPath[0], childPath[1] + 1],\n              voids: !0\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n        }\n      }\n      if (editor.isTextBlock(node) && !Array.isArray(node.markDefs)) {\n        debug$9(\"Adding .markDefs to block node\"), editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          markDefs: []\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      if (editor.isTextSpan(node) && !Array.isArray(node.marks)) {\n        debug$9(\"Adding .marks to span node\"), editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          marks: []\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      if (editor.isTextSpan(node)) {\n        const blockPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.parent(path), [block] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, blockPath), decorators2 = types.decorators.map((decorator) => decorator.value), annotations = node.marks?.filter((mark) => !decorators2.includes(mark));\n        if (editor.isTextBlock(block) && node.text === \"\" && annotations && annotations.length > 0) {\n          debug$9(\"Removing annotations from empty span node\"), editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            marks: node.marks?.filter((mark) => decorators2.includes(mark))\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n      }\n      if (editor.isTextBlock(node)) {\n        const decorators2 = types.decorators.map((decorator) => decorator.value);\n        for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, path))\n          if (editor.isTextSpan(child)) {\n            const marks = child.marks ?? [], orphanedAnnotations = marks.filter((mark) => !decorators2.includes(mark) && !node.markDefs?.find((def) => def._key === mark));\n            if (orphanedAnnotations.length > 0) {\n              debug$9(\"Removing orphaned annotations from span node\"), editorActor.send({\n                type: \"normalizing\"\n              }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                marks: marks.filter((mark) => !orphanedAnnotations.includes(mark))\n              }, {\n                at: childPath\n              }), editorActor.send({\n                type: \"done normalizing\"\n              });\n              return;\n            }\n          }\n      }\n      if (editor.isTextSpan(node)) {\n        const blockPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.parent(path), [block] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, blockPath);\n        if (editor.isTextBlock(block)) {\n          const decorators2 = types.decorators.map((decorator) => decorator.value), marks = node.marks ?? [], orphanedAnnotations = marks.filter((mark) => !decorators2.includes(mark) && !block.markDefs?.find((def) => def._key === mark));\n          if (orphanedAnnotations.length > 0) {\n            debug$9(\"Removing orphaned annotations from span node\"), editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n              marks: marks.filter((mark) => !orphanedAnnotations.includes(mark))\n            }, {\n              at: path\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n        }\n      }\n      if (editor.isTextBlock(node)) {\n        const markDefs = node.markDefs ?? [], markDefKeys = /* @__PURE__ */ new Set(), newMarkDefs = [];\n        for (const markDef of markDefs)\n          markDefKeys.has(markDef._key) || (markDefKeys.add(markDef._key), newMarkDefs.push(markDef));\n        if (markDefs.length !== newMarkDefs.length) {\n          debug$9(\"Removing duplicate markDefs\"), editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n      }\n      if (editor.isTextBlock(node) && !editor.operations.some((op) => op.type === \"merge_node\" && \"markDefs\" in op.properties && op.path.length === 1)) {\n        const newMarkDefs = (node.markDefs || []).filter((def) => node.children.find((child) => slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(child) && Array.isArray(child.marks) && child.marks.includes(def._key)));\n        if (node.markDefs && !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_4__(newMarkDefs, node.markDefs)) {\n          debug$9(\"Removing markDef not in use\"), editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n      }\n      normalizeNode(nodeEntry);\n    }, editor.apply = (op) => {\n      if (isChangingRemotely(editor)) {\n        apply2(op);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(op);\n        return;\n      }\n      if (op.type === \"set_selection\" && slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) && op.properties && op.newProperties && op.properties.anchor && op.properties.focus && op.newProperties.anchor && op.newProperties.focus) {\n        const previousSelectionIsCollapsed = slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed({\n          anchor: op.properties.anchor,\n          focus: op.properties.focus\n        }), newSelectionIsCollapsed = slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed({\n          anchor: op.newProperties.anchor,\n          focus: op.newProperties.focus\n        });\n        if (previousSelectionIsCollapsed && newSelectionIsCollapsed) {\n          const focusSpan = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: op.properties.focus,\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0]?.[0], newFocusSpan = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: op.newProperties.focus,\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0]?.[0], movedToNextSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] + 1 && focusSpan.text.length === op.properties.focus.offset && op.newProperties.focus.offset === 0, movedToPreviousSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] - 1 && op.properties.focus.offset === 0 && newFocusSpan.text.length === op.newProperties.focus.offset;\n          if (movedToNextSpan || movedToPreviousSpan)\n            return;\n        }\n      }\n      if (op.type === \"insert_node\") {\n        const {\n          selection\n        } = editor;\n        if (selection) {\n          const [_block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection, {\n            depth: 1\n          }), previousSpan = getPreviousSpan({\n            editor,\n            blockPath,\n            spanPath: op.path\n          }), previousSpanAnnotations = previousSpan ? previousSpan.marks?.filter((mark) => !decorators.includes(mark)) : [], nextSpan = getNextSpan({\n            editor,\n            blockPath,\n            spanPath: [op.path[0], op.path[1] - 1]\n          }), nextSpanAnnotations = nextSpan ? nextSpan.marks?.filter((mark) => !decorators.includes(mark)) : [], annotationsEnding = previousSpanAnnotations?.filter((annotation) => !nextSpanAnnotations?.includes(annotation)) ?? [], atTheEndOfAnnotation = annotationsEnding.length > 0;\n          if (atTheEndOfAnnotation && isPortableTextSpan(op.node) && op.node.marks?.some((mark) => annotationsEnding.includes(mark))) {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n              ...op.node,\n              _key: editorActor.getSnapshot().context.keyGenerator(),\n              marks: op.node.marks?.filter((mark) => !annotationsEnding.includes(mark)) ?? []\n            });\n            return;\n          }\n          const annotationsStarting = nextSpanAnnotations?.filter((annotation) => !previousSpanAnnotations?.includes(annotation)) ?? [], atTheStartOfAnnotation = annotationsStarting.length > 0;\n          if (atTheStartOfAnnotation && isPortableTextSpan(op.node) && op.node.marks?.some((mark) => annotationsStarting.includes(mark))) {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n              ...op.node,\n              _key: editorActor.getSnapshot().context.keyGenerator(),\n              marks: op.node.marks?.filter((mark) => !annotationsStarting.includes(mark)) ?? []\n            });\n            return;\n          }\n          const nextSpanDecorators = nextSpan?.marks?.filter((mark) => decorators.includes(mark)) ?? [];\n          if (nextSpanDecorators.length > 0 && atTheEndOfAnnotation && !atTheStartOfAnnotation && isPortableTextSpan(op.node) && op.node.marks?.length === 0) {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n              ...op.node,\n              _key: editorActor.getSnapshot().context.keyGenerator(),\n              marks: nextSpanDecorators\n            });\n            return;\n          }\n        }\n      }\n      if (op.type === \"insert_text\") {\n        const {\n          selection\n        } = editor, collapsedSelection = selection ? slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(selection) : !1;\n        if (selection && collapsedSelection) {\n          const [_block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection, {\n            depth: 1\n          }), [span, spanPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: selection.focus,\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0] ?? [void 0, void 0], marks = span.marks ?? [], marksWithoutAnnotations = marks.filter((mark) => decorators.includes(mark)), spanHasAnnotations = marks.length > marksWithoutAnnotations.length, spanIsEmpty = span.text.length === 0, atTheBeginningOfSpan = selection.anchor.offset === 0, atTheEndOfSpan = selection.anchor.offset === span.text.length, previousSpan = getPreviousSpan({\n            editor,\n            blockPath,\n            spanPath\n          }), nextSpan = getNextSpan({\n            editor,\n            blockPath,\n            spanPath\n          }), nextSpanAnnotations = nextSpan?.marks?.filter((mark) => !decorators.includes(mark)) ?? [], spanAnnotations = marks.filter((mark) => !decorators.includes(mark)), previousSpanHasAnnotations = previousSpan ? previousSpan.marks?.some((mark) => !decorators.includes(mark)) : !1, previousSpanHasSameAnnotations = previousSpan ? previousSpan.marks?.filter((mark) => !decorators.includes(mark)).every((mark) => marks.includes(mark)) : !1, previousSpanHasSameAnnotation = previousSpan ? previousSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1, previousSpanHasSameMarks = previousSpan ? previousSpan.marks?.every((mark) => marks.includes(mark)) : !1, nextSpanSharesSomeAnnotations = spanAnnotations.some((mark) => nextSpanAnnotations?.includes(mark));\n          if (spanHasAnnotations && !spanIsEmpty) {\n            if (atTheBeginningOfSpan) {\n              if (previousSpanHasSameMarks) {\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: previousSpan?.marks ?? []\n                });\n                return;\n              } else if (previousSpanHasSameAnnotations) {\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: previousSpan?.marks ?? []\n                });\n                return;\n              } else if (previousSpanHasSameAnnotation) {\n                apply2(op);\n                return;\n              } else if (!previousSpan) {\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: []\n                });\n                return;\n              }\n            }\n            if (atTheEndOfSpan) {\n              if (nextSpan && nextSpanSharesSomeAnnotations && nextSpanAnnotations.length < spanAnnotations.length || !nextSpanSharesSomeAnnotations) {\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: nextSpan?.marks ?? []\n                });\n                return;\n              }\n              if (!nextSpan) {\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: []\n                });\n                return;\n              }\n            }\n          }\n          if (atTheBeginningOfSpan && !spanIsEmpty && previousSpan) {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n              _type: \"span\",\n              _key: editorActor.getSnapshot().context.keyGenerator(),\n              text: op.text,\n              marks: previousSpanHasAnnotations ? [] : (previousSpan.marks ?? []).filter((mark) => decorators.includes(mark))\n            });\n            return;\n          }\n        }\n      }\n      if (op.type === \"remove_text\") {\n        const {\n          selection\n        } = editor;\n        if (selection && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(selection)) {\n          const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection, {\n            depth: 1\n          }), [span, spanPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: {\n              path: op.path,\n              offset: op.offset\n            },\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0] ?? [void 0, void 0];\n          if (span && block && isPortableTextBlock(block)) {\n            const markDefs = block.markDefs ?? [], marks = span.marks ?? [], spanHasAnnotations = marks.some((mark) => markDefs.find((markDef) => markDef._key === mark)), deletingFromTheEnd = op.offset + op.text.length === span.text.length, deletingAllText = op.offset === 0 && deletingFromTheEnd, previousSpan = getPreviousSpan({\n              editor,\n              blockPath,\n              spanPath\n            }), nextSpan = getNextSpan({\n              editor,\n              blockPath,\n              spanPath\n            }), previousSpanHasSameAnnotation = previousSpan ? previousSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1, nextSpanHasSameAnnotation = nextSpan ? nextSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1;\n            if (spanHasAnnotations && deletingAllText && !previousSpanHasSameAnnotation && !nextSpanHasSameAnnotation) {\n              const marksWithoutAnnotationMarks = ({\n                ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n              }.marks || []).filter((mark) => decorators.includes(mark));\n              slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n                apply2(op), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                  marks: marksWithoutAnnotationMarks\n                }, {\n                  at: op.path\n                });\n              }), editor.onChange();\n              return;\n            }\n          }\n        }\n      }\n      if (op.type === \"merge_node\" && op.path.length === 1 && \"markDefs\" in op.properties && op.properties._type === types.block.name && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] - 1 >= 0) {\n        const [targetBlock, targetPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, [op.path[0] - 1]);\n        if (editor.isTextBlock(targetBlock)) {\n          const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [], newMarkDefs = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__([...oldDefs, ...op.properties.markDefs]);\n          debug$9(\"Copying markDefs over to merged block\", op), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: targetPath,\n            voids: !1\n          }), apply2(op);\n          return;\n        }\n      }\n      apply2(op);\n    }, editor;\n  };\n}\nconst removeDecoratorActionImplementation = ({\n  action\n}) => {\n  const editor = action.editor, mark = action.decorator, {\n    selection\n  } = editor;\n  if (selection) {\n    if (slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(selection))\n      slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {}, {\n        match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n        split: !0,\n        hanging: !0\n      }), editor.selection && [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText\n      })].forEach(([node, path]) => {\n        const block = editor.children[path[0]];\n        slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block) && block.children.includes(node) && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          marks: (Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark),\n          _type: \"span\"\n        }, {\n          at: path\n        });\n      });\n    else {\n      const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection, {\n        depth: 1\n      }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === \"\" ? block.children[0] : void 0;\n      if (lonelyEmptySpan) {\n        const existingMarksWithoutDecorator = (lonelyEmptySpan.marks ?? []).filter((existingMark) => existingMark !== mark);\n        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          marks: existingMarksWithoutDecorator\n        }, {\n          at: blockPath,\n          match: (node) => editor.isTextSpan(node)\n        });\n      } else {\n        const existingMarks = {\n          ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n        }.marks || [], marks = {\n          ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {},\n          marks: existingMarks.filter((eMark) => eMark !== mark)\n        };\n        editor.marks = {\n          marks: marks.marks,\n          _type: \"span\"\n        };\n      }\n    }\n    if (editor.selection) {\n      const selection2 = editor.selection;\n      editor.selection = {\n        ...selection2\n      };\n    }\n  }\n};\nfunction isDecoratorActive({\n  editor,\n  decorator\n}) {\n  if (!editor.selection)\n    return !1;\n  const selectedTextNodes = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n    match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n    at: editor.selection\n  }));\n  return selectedTextNodes.length === 0 ? !1 : slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(editor.selection) ? selectedTextNodes.every((n) => {\n    const [node] = n;\n    return node.marks?.includes(decorator);\n  }) : ({\n    ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n  }.marks || []).includes(decorator);\n}\nconst toggleDecoratorActionImplementation = ({\n  context,\n  action\n}) => {\n  isDecoratorActive({\n    editor: action.editor,\n    decorator: action.decorator\n  }) ? removeDecoratorActionImplementation({\n    context,\n    action: {\n      type: \"decorator.remove\",\n      editor: action.editor,\n      decorator: action.decorator\n    }\n  }) : decoratorAddActionImplementation({\n    context,\n    action: {\n      type: \"decorator.add\",\n      editor: action.editor,\n      decorator: action.decorator\n    }\n  });\n}, debug$8 = debugWithName(\"API:editable\");\nfunction createEditableAPI(editor, editorActor) {\n  const types = editorActor.getSnapshot().context.schema;\n  return {\n    focus: () => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"focus\"\n        },\n        editor\n      });\n    },\n    blur: () => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"blur\"\n        },\n        editor\n      });\n    },\n    toggleMark: (mark) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"decorator.toggle\",\n          decorator: mark\n        },\n        editor\n      });\n    },\n    toggleList: (listItem) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"list item.toggle\",\n          listItem\n        },\n        editor\n      });\n    },\n    toggleBlockStyle: (style) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"style.toggle\",\n          style\n        },\n        editor\n      });\n    },\n    isMarkActive: (mark) => {\n      try {\n        return isDecoratorActive({\n          editor,\n          decorator: mark\n        });\n      } catch (err) {\n        return console.warn(err), !1;\n      }\n    },\n    marks: () => ({\n      ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n    }).marks || [],\n    undo: () => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"history.undo\"\n        },\n        editor\n      });\n    },\n    redo: () => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"history.redo\"\n        },\n        editor\n      });\n    },\n    select: (selection) => {\n      const slateSelection = toSlateRange(selection, editor);\n      slateSelection ? slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(editor, slateSelection) : slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(editor), editor.onChange();\n    },\n    focusBlock: () => {\n      if (editor.selection) {\n        const block = slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n        if (block)\n          return fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];\n      }\n    },\n    focusChild: () => {\n      if (editor.selection) {\n        const block = slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n        if (block && editor.isTextBlock(block))\n          return fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0].children[editor.selection.focus.path[1]];\n      }\n    },\n    insertChild: (type, value) => {\n      if (type.name !== types.span.name)\n        return editorActor.send({\n          type: \"behavior event\",\n          behaviorEvent: {\n            type: \"insert.inline object\",\n            inlineObject: {\n              name: type.name,\n              value\n            }\n          },\n          editor\n        }), toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types)?.focus.path ?? [];\n      if (!editor.selection)\n        throw new Error(\"The editor has no selection\");\n      const [focusBlock] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n        at: editor.selection.focus.path.slice(0, 1),\n        match: (n) => n._type === types.block.name\n      }))[0] || [void 0];\n      if (!focusBlock)\n        throw new Error(\"No focused text block\");\n      if (type.name !== types.span.name && !types.inlineObjects.some((t) => t.name === type.name))\n        throw new Error(\"This type cannot be inserted as a child to a text block\");\n      const child = toSlateValue([{\n        _key: editorActor.getSnapshot().context.keyGenerator(),\n        _type: types.block.name,\n        children: [{\n          _key: editorActor.getSnapshot().context.keyGenerator(),\n          _type: type.name,\n          ...value || {}\n        }]\n      }], {\n        schemaTypes: editorActor.getSnapshot().context.schema\n      })[0].children[0], focusChildPath = editor.selection.focus.path.slice(0, 2), isSpanNode = child._type === types.span.name, focusNode = slate__WEBPACK_IMPORTED_MODULE_15__.Node.get(editor, focusChildPath);\n      return isSpanNode && focusNode._type !== types.span.name && (debug$8(\"Inserting span child next to inline object child, moving selection + 1\"), editor.move({\n        distance: 1,\n        unit: \"character\"\n      })), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, child, {\n        select: !0,\n        at: editor.selection\n      }), editor.onChange(), toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types)?.focus.path || [];\n    },\n    insertBlock: (type, value) => (editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"insert.block object\",\n        blockObject: {\n          name: type.name,\n          value\n        },\n        placement: \"auto\"\n      },\n      editor\n    }), toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types)?.focus.path ?? []),\n    hasBlockStyle: (style) => {\n      try {\n        return isStyleActive({\n          editor,\n          style\n        });\n      } catch {\n        return !1;\n      }\n    },\n    hasListStyle: (listItem) => {\n      try {\n        return isListItemActive({\n          editor,\n          listItem\n        });\n      } catch {\n        return !1;\n      }\n    },\n    isVoid: (element) => ![types.block.name, types.span.name].includes(element._type),\n    findByPath: (path) => {\n      const slatePath = toSlateRange({\n        focus: {\n          path,\n          offset: 0\n        },\n        anchor: {\n          path,\n          offset: 0\n        }\n      }, editor);\n      if (slatePath) {\n        const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, slatePath.focus.path.slice(0, 1));\n        if (block && blockPath && typeof block._key == \"string\") {\n          if (path.length === 1 && slatePath.focus.path.length === 1)\n            return [fromSlateValue([block], types.block.name)[0], [{\n              _key: block._key\n            }]];\n          const ptBlock = fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];\n          if (editor.isTextBlock(ptBlock)) {\n            const ptChild = ptBlock.children[slatePath.focus.path[1]];\n            if (ptChild)\n              return [ptChild, [{\n                _key: block._key\n              }, \"children\", {\n                _key: ptChild._key\n              }]];\n          }\n        }\n      }\n      return [void 0, void 0];\n    },\n    findDOMNode: (element) => {\n      let node;\n      try {\n        const [item] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n          at: [],\n          match: (n) => n._key === element._key\n        }) || [])[0] || [void 0];\n        node = slate_react__WEBPACK_IMPORTED_MODULE_29__.ReactEditor.toDOMNode(editor, item);\n      } catch {\n      }\n      return node;\n    },\n    activeAnnotations: () => {\n      if (!editor.selection || editor.selection.focus.path.length < 2)\n        return [];\n      try {\n        const activeAnnotations = [], spans = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n          at: editor.selection,\n          match: (node) => slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(node) && node.marks !== void 0 && Array.isArray(node.marks) && node.marks.length > 0\n        });\n        for (const [span, path] of spans) {\n          const [block] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, path, {\n            depth: 1\n          });\n          editor.isTextBlock(block) && block.markDefs?.forEach((def) => {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(span) && span.marks && Array.isArray(span.marks) && span.marks.includes(def._key) && activeAnnotations.push(def);\n          });\n        }\n        return activeAnnotations;\n      } catch {\n        return [];\n      }\n    },\n    isAnnotationActive: (annotationType) => isAnnotationActive({\n      editor,\n      annotation: {\n        name: annotationType\n      }\n    }),\n    addAnnotation: (type, value) => {\n      let paths;\n      return slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n        paths = addAnnotationActionImplementation({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: types\n          },\n          action: {\n            type: \"annotation.add\",\n            annotation: {\n              name: type.name,\n              value: value ?? {}\n            },\n            editor\n          }\n        });\n      }), editor.onChange(), paths;\n    },\n    delete: (selection, options) => {\n      if (selection) {\n        const range = toSlateRange(selection, editor);\n        if (!(range && range.anchor.path.length > 0 && range.focus.path.length > 0))\n          throw new Error(\"Invalid range\");\n        if (range) {\n          if (!options?.mode || options?.mode === \"selected\") {\n            debug$8(\"Deleting content in selection\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.delete(editor, {\n              at: range,\n              hanging: !0,\n              voids: !0\n            }), editor.onChange();\n            return;\n          }\n          options?.mode === \"blocks\" && (debug$8(\"Deleting blocks touched by selection\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n            at: range,\n            voids: !0,\n            match: (node) => editor.isTextBlock(node) || !editor.isTextBlock(node) && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(node)\n          })), options?.mode === \"children\" && (debug$8(\"Deleting children touched by selection\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n            at: range,\n            voids: !0,\n            match: (node) => node._type === types.span.name || // Text children\n            !editor.isTextBlock(node) && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(node)\n          })), editor.children.length === 0 && (editor.children = [editor.pteCreateTextBlock({\n            decorators: []\n          })]), editor.onChange();\n        }\n      }\n    },\n    removeAnnotation: (type) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"annotation.remove\",\n          annotation: {\n            name: type.name\n          }\n        },\n        editor\n      });\n    },\n    getSelection: () => {\n      let ptRange = null;\n      if (editor.selection) {\n        const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);\n        if (existing)\n          return existing;\n        ptRange = toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);\n      }\n      return ptRange;\n    },\n    getValue: () => fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),\n    isCollapsedSelection: () => !!editor.selection && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(editor.selection),\n    isExpandedSelection: () => !!editor.selection && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(editor.selection),\n    insertBreak: () => {\n      editor.insertBreak(), editor.onChange();\n    },\n    getFragment: () => fromSlateValue(editor.getFragment(), types.block.name),\n    isSelectionsOverlapping: (selectionA, selectionB) => {\n      const rangeA = toSlateRange(selectionA, editor), rangeB = toSlateRange(selectionB, editor);\n      return slate__WEBPACK_IMPORTED_MODULE_15__.Range.isRange(rangeA) && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isRange(rangeB) && slate__WEBPACK_IMPORTED_MODULE_15__.Range.includes(rangeA, rangeB);\n    }\n  };\n}\nfunction isAnnotationActive({\n  editor,\n  annotation\n}) {\n  if (!editor.selection || editor.selection.focus.path.length < 2)\n    return !1;\n  try {\n    const spans = [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n      at: editor.selection,\n      match: (node) => slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(node)\n    })];\n    if (spans.length === 0 || spans.some(([span]) => !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isPortableTextSpan)(span) || !span.marks || span.marks?.length === 0)) return !1;\n    const selectionMarkDefs = spans.reduce((accMarkDefs, [, path]) => {\n      const [block] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, path, {\n        depth: 1\n      });\n      return editor.isTextBlock(block) && block.markDefs ? [...accMarkDefs, ...block.markDefs] : accMarkDefs;\n    }, []);\n    return spans.every(([span]) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isPortableTextSpan)(span) ? span.marks?.map((markKey) => selectionMarkDefs.find((def) => def?._key === markKey)?._type)?.includes(annotation.name) : !1);\n  } catch {\n    return !1;\n  }\n}\nconst addAnnotationActionImplementation = ({\n  context,\n  action\n}) => {\n  const editor = action.editor;\n  if (!editor.selection || slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(editor.selection))\n    return;\n  let paths, spanPath, markDefPath;\n  const markDefPaths = [], selectedBlocks = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n    at: editor.selection,\n    match: (node) => editor.isTextBlock(node),\n    reverse: slate__WEBPACK_IMPORTED_MODULE_15__.Range.isBackward(editor.selection)\n  });\n  for (const [block, blockPath] of selectedBlocks) {\n    if (block.children.length === 0 || block.children.length === 1 && block.children[0].text === \"\")\n      continue;\n    const annotationKey = context.keyGenerator(), markDefs = block.markDefs ?? [];\n    markDefs.find((markDef) => markDef._type === action.annotation.name && markDef._key === annotationKey) === void 0 && (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n      markDefs: [...markDefs, {\n        _type: action.annotation.name,\n        _key: annotationKey,\n        ...action.annotation.value\n      }]\n    }, {\n      at: blockPath\n    }), markDefPath = [{\n      _key: block._key\n    }, \"markDefs\", {\n      _key: annotationKey\n    }], slate__WEBPACK_IMPORTED_MODULE_15__.Range.isBackward(editor.selection) ? markDefPaths.unshift(markDefPath) : markDefPaths.push(markDefPath)), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {}, {\n      match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n      split: !0\n    });\n    const children = slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath);\n    for (const [span, path] of children) {\n      if (!editor.isTextSpan(span) || !slate__WEBPACK_IMPORTED_MODULE_15__.Range.includes(editor.selection, path))\n        continue;\n      const marks = span.marks ?? [], existingSameTypeAnnotations = marks.filter((mark) => markDefs.some((markDef) => markDef._key === mark && markDef._type === action.annotation.name));\n      slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n        marks: [...marks.filter((mark) => !existingSameTypeAnnotations.includes(mark)), annotationKey]\n      }, {\n        at: path\n      }), spanPath = [{\n        _key: block._key\n      }, \"children\", {\n        _key: span._key\n      }];\n    }\n  }\n  return markDefPath && spanPath && (paths = {\n    markDefPath,\n    markDefPaths,\n    spanPath\n  }), paths;\n}, removeAnnotationActionImplementation = ({\n  action\n}) => {\n  const editor = action.editor;\n  if (debug$8(\"Removing annotation\", action.annotation.name), !!editor.selection)\n    if (slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(editor.selection)) {\n      const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, editor.selection, {\n        depth: 1\n      });\n      if (!editor.isTextBlock(block))\n        return;\n      const potentialAnnotations = (block.markDefs ?? []).filter((markDef) => markDef._type === action.annotation.name), [selectedChild, selectedChildPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, editor.selection, {\n        depth: 2\n      });\n      if (!editor.isTextSpan(selectedChild))\n        return;\n      const annotationToRemove = selectedChild.marks?.find((mark) => potentialAnnotations.some((markDef) => markDef._key === mark));\n      if (!annotationToRemove)\n        return;\n      const previousSpansWithSameAnnotation = [];\n      for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath, {\n        reverse: !0\n      }))\n        if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_15__.Path.isBefore(childPath, selectedChildPath))\n          if (child.marks?.includes(annotationToRemove))\n            previousSpansWithSameAnnotation.push([child, childPath]);\n          else\n            break;\n      const nextSpansWithSameAnnotation = [];\n      for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath))\n        if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_15__.Path.isAfter(childPath, selectedChildPath))\n          if (child.marks?.includes(annotationToRemove))\n            nextSpansWithSameAnnotation.push([child, childPath]);\n          else\n            break;\n      for (const [child, childPath] of [...previousSpansWithSameAnnotation, [selectedChild, selectedChildPath], ...nextSpansWithSameAnnotation])\n        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          marks: child.marks?.filter((mark) => mark !== annotationToRemove)\n        }, {\n          at: childPath\n        });\n    } else {\n      slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {}, {\n        match: (node) => editor.isTextSpan(node),\n        split: !0,\n        hanging: !0\n      });\n      const blocks = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => editor.isTextBlock(node)\n      });\n      for (const [block, blockPath] of blocks) {\n        const children = slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath);\n        for (const [child, childPath] of children) {\n          if (!editor.isTextSpan(child) || !slate__WEBPACK_IMPORTED_MODULE_15__.Range.includes(editor.selection, childPath))\n            continue;\n          const markDefs = block.markDefs ?? [], marks = child.marks ?? [], marksWithoutAnnotation = marks.filter((mark) => markDefs.find((markDef2) => markDef2._key === mark)?._type !== action.annotation.name);\n          marksWithoutAnnotation.length !== marks.length && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            marks: marksWithoutAnnotation\n          }, {\n            at: childPath\n          });\n        }\n      }\n    }\n}, toggleAnnotationActionImplementation = ({\n  context,\n  action\n}) => {\n  if (isAnnotationActive({\n    editor: action.editor,\n    annotation: {\n      name: action.annotation.name\n    }\n  }))\n    removeAnnotationActionImplementation({\n      context,\n      action: {\n        type: \"annotation.remove\",\n        annotation: action.annotation,\n        editor: action.editor\n      }\n    });\n  else\n    return addAnnotationActionImplementation({\n      context,\n      action: {\n        type: \"annotation.add\",\n        annotation: action.annotation,\n        editor: action.editor\n      }\n    });\n};\nfunction insertBlock({\n  block,\n  placement,\n  editor,\n  schema\n}) {\n  if (editor.selection) {\n    const [focusBlock, focusBlockPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n      at: editor.selection.focus.path.slice(0, 1),\n      match: (n) => !slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isEditor(n)\n    }))[0] ?? [void 0, void 0];\n    if (placement === \"after\") {\n      const nextPath = [focusBlockPath[0] + 1];\n      slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, block, {\n        at: nextPath\n      }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(editor, {\n        anchor: {\n          path: [nextPath[0], 0],\n          offset: 0\n        },\n        focus: {\n          path: [nextPath[0], 0],\n          offset: 0\n        }\n      });\n    } else placement === \"before\" ? slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, block, {\n      at: focusBlockPath\n    }) : (slate__WEBPACK_IMPORTED_MODULE_15__.Editor.insertNode(editor, block), focusBlock && isEqualToEmptyEditor([focusBlock], schema) && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n      at: focusBlockPath\n    }));\n  } else {\n    const lastBlock = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n      match: (n) => !slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isEditor(n),\n      at: [],\n      reverse: !0\n    }))[0];\n    slate__WEBPACK_IMPORTED_MODULE_15__.Editor.insertNode(editor, block), lastBlock && isEqualToEmptyEditor([lastBlock[0]], schema) && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n      at: lastBlock[1]\n    });\n  }\n}\nconst blockSetBehaviorActionImplementation = ({\n  context,\n  action\n}) => {\n  const location = toSlateRange({\n    anchor: {\n      path: action.at,\n      offset: 0\n    },\n    focus: {\n      path: action.at,\n      offset: 0\n    }\n  }, action.editor);\n  if (!location)\n    throw new Error(`Unable to convert ${JSON.stringify(action.at)} into a Slate Range`);\n  const block = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(action.editor, location, {\n    depth: 1\n  })?.[0];\n  if (!block)\n    throw new Error(`Unable to find block at ${JSON.stringify(action.at)}`);\n  const parsedBlock = fromSlateValue([block], context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(action.editor)).at(0);\n  if (!parsedBlock)\n    throw new Error(`Unable to parse block at ${JSON.stringify(action.at)}`);\n  const {\n    _type,\n    ...filteredProps\n  } = action.props, updatedBlock = (0,_util_block_offsets_to_selection_js__WEBPACK_IMPORTED_MODULE_24__.parseBlock)({\n    context,\n    block: {\n      ...parsedBlock,\n      ...filteredProps\n    },\n    options: {\n      refreshKeys: !1\n    }\n  });\n  if (!updatedBlock)\n    throw new Error(`Unable to update block at ${JSON.stringify(action.at)}`);\n  const slateBlock = toSlateValue([updatedBlock], {\n    schemaTypes: context.schema\n  })?.at(0);\n  if (!slateBlock)\n    throw new Error(\"Unable to convert block to Slate value\");\n  slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(action.editor, slateBlock, {\n    at: location\n  });\n}, blockUnsetBehaviorActionImplementation = ({\n  context,\n  action\n}) => {\n  const location = toSlateRange({\n    anchor: {\n      path: action.at,\n      offset: 0\n    },\n    focus: {\n      path: action.at,\n      offset: 0\n    }\n  }, action.editor);\n  if (!location)\n    throw new Error(`Unable to convert ${JSON.stringify(action.at)} into a Slate Range`);\n  const block = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(action.editor, location, {\n    depth: 1\n  })?.[0];\n  if (!block)\n    throw new Error(`Unable to find block at ${JSON.stringify(action.at)}`);\n  const parsedBlock = fromSlateValue([block], context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(action.editor)).at(0);\n  if (!parsedBlock)\n    throw new Error(`Unable to parse block at ${JSON.stringify(action.at)}`);\n  if ((0,_util_block_offsets_to_selection_js__WEBPACK_IMPORTED_MODULE_24__.isTextBlock)(context.schema, parsedBlock)) {\n    const propsToRemove = action.props.filter((prop) => prop !== \"_type\"), updatedTextBlock = (0,_util_block_offsets_to_selection_js__WEBPACK_IMPORTED_MODULE_24__.parseBlock)({\n      context,\n      block: lodash_omit_js__WEBPACK_IMPORTED_MODULE_11__(parsedBlock, propsToRemove),\n      options: {\n        refreshKeys: !1\n      }\n    });\n    if (!updatedTextBlock)\n      throw new Error(`Unable to update block at ${JSON.stringify(action.at)}`);\n    const propsToSet = {};\n    for (const prop of propsToRemove)\n      prop in updatedTextBlock ? propsToSet[prop] = updatedTextBlock[prop] : propsToSet[prop] = void 0;\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(action.editor, propsToSet, {\n      at: location\n    });\n    return;\n  }\n  const updatedBlockObject = (0,_util_block_offsets_to_selection_js__WEBPACK_IMPORTED_MODULE_24__.parseBlock)({\n    context,\n    block: lodash_omit_js__WEBPACK_IMPORTED_MODULE_11__(parsedBlock, action.props.filter((prop) => prop !== \"_type\")),\n    options: {\n      refreshKeys: !1\n    }\n  });\n  if (!updatedBlockObject)\n    throw new Error(`Unable to update block at ${JSON.stringify(action.at)}`);\n  const {\n    _type,\n    _key,\n    ...props\n  } = updatedBlockObject;\n  slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(action.editor, {\n    _type,\n    _key,\n    value: props\n  }, {\n    at: location\n  });\n}, dataTransferSetActionImplementation = ({\n  action\n}) => {\n  action.dataTransfer.setData(action.mimeType, action.data);\n}, deleteActionImplementation = ({\n  action\n}) => {\n  const range = toSlateRange(action.selection, action.editor);\n  if (!range)\n    throw new Error(`Failed to get Slate Range for selection ${JSON.stringify(action.selection)}`);\n  (0,slate__WEBPACK_IMPORTED_MODULE_15__.select)(action.editor, range), (0,slate__WEBPACK_IMPORTED_MODULE_15__.deleteFragment)(action.editor);\n}, deleteTextActionImplementation = ({\n  context,\n  action\n}) => {\n  const value = fromSlateValue(action.editor.children, context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(action.editor)), selection = (0,_util_block_offsets_to_selection_js__WEBPACK_IMPORTED_MODULE_24__.blockOffsetsToSelection)({\n    value,\n    offsets: {\n      anchor: action.anchor,\n      focus: action.focus\n    }\n  });\n  if (!selection)\n    throw new Error(\"Unable to find selection from block offsets\");\n  const trimmedSelection = (0,_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_28__.getTrimmedSelection)({\n    beta: {\n      hasTag: () => !1\n    },\n    context: {\n      converters: [],\n      schema: context.schema,\n      keyGenerator: context.keyGenerator,\n      activeDecorators: [],\n      value,\n      selection\n    }\n  });\n  if (!trimmedSelection)\n    throw new Error(\"Unable to find trimmed selection\");\n  const range = toSlateRange(trimmedSelection, action.editor);\n  if (!range)\n    throw new Error(\"Unable to find Slate range from trimmed selection\");\n  slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.delete(action.editor, {\n    at: range\n  });\n}, insertBlockObjectActionImplementation = ({\n  context,\n  action\n}) => {\n  const block = toSlateValue([{\n    _key: context.keyGenerator(),\n    _type: action.blockObject.name,\n    ...action.blockObject.value ? action.blockObject.value : {}\n  }], {\n    schemaTypes: context.schema\n  })[0];\n  insertBlock({\n    block,\n    placement: action.placement,\n    editor: action.editor,\n    schema: context.schema\n  });\n}, insertBlocksActionImplementation = ({\n  context,\n  action\n}) => {\n  const fragment = toSlateValue(action.blocks, {\n    schemaTypes: context.schema\n  });\n  if (!action.editor.selection)\n    return;\n  const [focusBlock, focusPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(action.editor, action.editor.selection, {\n    depth: 1\n  });\n  if (action.editor.isTextBlock(focusBlock) && action.editor.isTextBlock(fragment[0])) {\n    const {\n      markDefs\n    } = focusBlock;\n    lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_4__(markDefs, fragment[0].markDefs) || slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(action.editor, {\n      markDefs: lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__([...fragment[0].markDefs || [], ...markDefs || []])\n    }, {\n      at: focusPath,\n      mode: \"lowest\",\n      voids: !1\n    });\n  }\n  isEqualToEmptyEditor(action.editor.children, context.schema) ? (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.splitNodes(action.editor, {\n    at: [0, 0]\n  }), action.editor.insertFragment(fragment), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(action.editor, {\n    at: [0]\n  })) : action.editor.insertFragment(fragment);\n}, insertInlineObjectActionImplementation = ({\n  context,\n  action\n}) => {\n  if (!context.schema.inlineObjects.some((inlineObject) => inlineObject.name === action.inlineObject.name)) {\n    console.error(\"Unable to insert unknown inline object\");\n    return;\n  }\n  if (!action.editor.selection) {\n    console.error(\"Unable to insert inline object without selection\");\n    return;\n  }\n  const [focusTextBlock] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(action.editor, {\n    at: action.editor.selection.focus.path,\n    match: (node) => action.editor.isTextBlock(node)\n  })).at(0) ?? [void 0, void 0];\n  if (!focusTextBlock) {\n    console.error(\"Unable to perform action without focus text block\");\n    return;\n  }\n  const child = toSlateValue([{\n    _type: context.schema.block.name,\n    _key: context.keyGenerator(),\n    children: [{\n      _type: action.inlineObject.name,\n      _key: context.keyGenerator(),\n      ...action.inlineObject.value ?? {}\n    }]\n  }], {\n    schemaTypes: context.schema\n  }).at(0)?.children.at(0);\n  if (!child) {\n    console.error(\"Unable to insert inline object\");\n    return;\n  }\n  slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(action.editor, child);\n}, insertSpanActionImplementation = ({\n  context,\n  action\n}) => {\n  if (!action.editor.selection) {\n    console.error(\"Unable to perform action without selection\", action);\n    return;\n  }\n  const [focusBlock, focusBlockPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(action.editor, {\n    at: action.editor.selection.focus.path,\n    match: (node) => action.editor.isTextBlock(node)\n  }))[0] ?? [void 0, void 0];\n  if (!focusBlock || !focusBlockPath) {\n    console.error(\"Unable to perform action without focus block\", action);\n    return;\n  }\n  const markDefs = focusBlock.markDefs ?? [], annotations = action.annotations ? action.annotations.map((annotation) => ({\n    _type: annotation.name,\n    _key: context.keyGenerator(),\n    ...annotation.value\n  })) : void 0;\n  annotations && annotations.length > 0 && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(action.editor, {\n    markDefs: [...markDefs, ...annotations]\n  }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(action.editor, {\n    _type: \"span\",\n    _key: context.keyGenerator(),\n    text: action.text,\n    marks: [...annotations?.map((annotation) => annotation._key) ?? [], ...action.decorators ?? []]\n  });\n}, insertBlockActionImplementation = ({\n  context,\n  action\n}) => {\n  const parsedBlock = (0,_util_block_offsets_to_selection_js__WEBPACK_IMPORTED_MODULE_24__.parseBlock)({\n    block: action.block,\n    context,\n    options: {\n      refreshKeys: !1\n    }\n  });\n  if (!parsedBlock)\n    throw new Error(`Failed to parse block ${JSON.stringify(action.block)}`);\n  const fragment = toSlateValue([parsedBlock], {\n    schemaTypes: context.schema\n  })[0];\n  if (!fragment)\n    throw new Error(`Failed to convert block to Slate fragment ${JSON.stringify(parsedBlock)}`);\n  insertBlock({\n    block: fragment,\n    placement: action.placement,\n    editor: action.editor,\n    schema: context.schema\n  });\n}, behaviorActionImplementations = {\n  \"annotation.add\": addAnnotationActionImplementation,\n  \"annotation.remove\": removeAnnotationActionImplementation,\n  \"annotation.toggle\": toggleAnnotationActionImplementation,\n  \"block.set\": blockSetBehaviorActionImplementation,\n  \"block.unset\": blockUnsetBehaviorActionImplementation,\n  blur: ({\n    action\n  }) => {\n    slate_react__WEBPACK_IMPORTED_MODULE_29__.ReactEditor.blur(action.editor);\n  },\n  \"data transfer.set\": dataTransferSetActionImplementation,\n  \"decorator.add\": decoratorAddActionImplementation,\n  \"decorator.remove\": removeDecoratorActionImplementation,\n  \"decorator.toggle\": toggleDecoratorActionImplementation,\n  focus: ({\n    action\n  }) => {\n    slate_react__WEBPACK_IMPORTED_MODULE_29__.ReactEditor.focus(action.editor);\n  },\n  delete: deleteActionImplementation,\n  \"delete.backward\": ({\n    action\n  }) => {\n    action.editor.deleteBackward(action.unit);\n  },\n  \"delete.forward\": ({\n    action\n  }) => {\n    (0,slate__WEBPACK_IMPORTED_MODULE_15__.deleteForward)(action.editor, action.unit);\n  },\n  \"delete.block\": ({\n    action\n  }) => {\n    const range = toSlateRange({\n      anchor: {\n        path: action.blockPath,\n        offset: 0\n      },\n      focus: {\n        path: action.blockPath,\n        offset: 0\n      }\n    }, action.editor);\n    if (!range) {\n      console.error(\"Unable to find Slate range from selection points\");\n      return;\n    }\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(action.editor, {\n      at: range\n    });\n  },\n  \"delete.text\": deleteTextActionImplementation,\n  \"deserialization.failure\": ({\n    action\n  }) => {\n    console.error(`Deserialization of ${action.mimeType} failed with reason ${action.reason}`);\n  },\n  \"deserialization.success\": ({\n    context,\n    action\n  }) => {\n    insertBlocksActionImplementation({\n      context,\n      action: {\n        type: \"insert.blocks\",\n        blocks: action.data,\n        editor: action.editor\n      }\n    });\n  },\n  \"history.redo\": historyRedoActionImplementation,\n  \"history.undo\": historyUndoActionImplementation,\n  \"insert.block\": insertBlockActionImplementation,\n  \"insert.blocks\": insertBlocksActionImplementation,\n  \"insert.block object\": insertBlockObjectActionImplementation,\n  \"insert.break\": insertBreakActionImplementation,\n  \"insert.inline object\": insertInlineObjectActionImplementation,\n  \"insert.soft break\": insertSoftBreakActionImplementation,\n  \"insert.span\": insertSpanActionImplementation,\n  \"insert.text\": ({\n    action\n  }) => {\n    (0,slate__WEBPACK_IMPORTED_MODULE_15__.insertText)(action.editor, action.text);\n  },\n  \"insert.text block\": ({\n    context,\n    action\n  }) => {\n    const block = toSlateValue([{\n      _key: context.keyGenerator(),\n      _type: context.schema.block.name,\n      style: context.schema.styles[0].value ?? \"normal\",\n      markDefs: [],\n      children: action.textBlock?.children?.map((child) => ({\n        ...child,\n        _key: context.keyGenerator()\n      })) ?? [{\n        _type: context.schema.span.name,\n        _key: context.keyGenerator(),\n        text: \"\"\n      }]\n    }], {\n      schemaTypes: context.schema\n    })[0];\n    insertBlock({\n      block,\n      editor: action.editor,\n      schema: context.schema,\n      placement: action.placement\n    });\n  },\n  effect: ({\n    action\n  }) => {\n    action.effect();\n  },\n  \"list item.add\": addListItemActionImplementation,\n  \"list item.remove\": removeListItemActionImplementation,\n  \"list item.toggle\": toggleListItemActionImplementation,\n  \"move.block\": ({\n    action\n  }) => {\n    const at = [toSlatePath(action.at, action.editor)[0]], to = [toSlatePath(action.to, action.editor)[0]];\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.moveNodes(action.editor, {\n      at,\n      to,\n      mode: \"highest\"\n    });\n  },\n  \"move.block down\": ({\n    action\n  }) => {\n    const at = [toSlatePath(action.at, action.editor)[0]], to = [slate__WEBPACK_IMPORTED_MODULE_15__.Path.next(at)[0]];\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.moveNodes(action.editor, {\n      at,\n      to,\n      mode: \"highest\"\n    });\n  },\n  \"move.block up\": ({\n    action\n  }) => {\n    const at = [toSlatePath(action.at, action.editor)[0]];\n    if (!slate__WEBPACK_IMPORTED_MODULE_15__.Path.hasPrevious(at))\n      return;\n    const to = [slate__WEBPACK_IMPORTED_MODULE_15__.Path.previous(at)[0]];\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.moveNodes(action.editor, {\n      at,\n      to,\n      mode: \"highest\"\n    });\n  },\n  noop: () => {\n  },\n  select: ({\n    action\n  }) => {\n    const newSelection = toSlateRange(action.selection, action.editor);\n    newSelection ? slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(action.editor, newSelection) : slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(action.editor);\n  },\n  \"select.previous block\": ({\n    action\n  }) => {\n    if (!action.editor.selection) {\n      console.error(\"Unable to select previous block without a selection\");\n      return;\n    }\n    const blockPath = action.editor.selection.focus.path.slice(0, 1);\n    if (!slate__WEBPACK_IMPORTED_MODULE_15__.Path.hasPrevious(blockPath)) {\n      console.error(\"There's no previous block to select\");\n      return;\n    }\n    const previousBlockPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.previous(blockPath);\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(action.editor, previousBlockPath);\n  },\n  \"select.next block\": ({\n    action\n  }) => {\n    if (!action.editor.selection) {\n      console.error(\"Unable to select next block without a selection\");\n      return;\n    }\n    const nextBlockPath = [action.editor.selection.focus.path.slice(0, 1)[0] + 1];\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(action.editor, nextBlockPath);\n  },\n  \"serialization.failure\": ({\n    action\n  }) => {\n    console.error(`Serialization of ${action.mimeType} failed with reason ${action.reason}`);\n  },\n  \"serialization.success\": ({\n    context,\n    action\n  }) => {\n    dataTransferSetActionImplementation({\n      context,\n      action: {\n        ...action,\n        type: \"data transfer.set\"\n      }\n    });\n  },\n  \"style.toggle\": toggleStyleActionImplementation,\n  \"style.add\": addStyleActionImplementation,\n  \"style.remove\": removeStyleActionImplementation\n};\nfunction performAction({\n  context,\n  action\n}) {\n  switch (action.type) {\n    case \"noop\":\n      break;\n    case \"effect\": {\n      behaviorActionImplementations.effect({\n        context,\n        action\n      });\n      break;\n    }\n    default:\n      performDefaultAction({\n        context,\n        action\n      });\n  }\n}\nfunction performDefaultAction({\n  context,\n  action\n}) {\n  switch (action.type) {\n    case \"annotation.add\": {\n      behaviorActionImplementations[\"annotation.add\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"annotation.remove\": {\n      behaviorActionImplementations[\"annotation.remove\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"annotation.toggle\": {\n      behaviorActionImplementations[\"annotation.toggle\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"block.set\": {\n      behaviorActionImplementations[\"block.set\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"block.unset\": {\n      behaviorActionImplementations[\"block.unset\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"blur\": {\n      behaviorActionImplementations.blur({\n        context,\n        action\n      });\n      break;\n    }\n    case \"data transfer.set\": {\n      behaviorActionImplementations[\"data transfer.set\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"decorator.add\": {\n      behaviorActionImplementations[\"decorator.add\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"decorator.remove\": {\n      behaviorActionImplementations[\"decorator.remove\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"decorator.toggle\": {\n      behaviorActionImplementations[\"decorator.toggle\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"delete\": {\n      behaviorActionImplementations.delete({\n        context,\n        action\n      });\n      break;\n    }\n    case \"delete.backward\": {\n      behaviorActionImplementations[\"delete.backward\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"delete.block\": {\n      behaviorActionImplementations[\"delete.block\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"delete.forward\": {\n      behaviorActionImplementations[\"delete.forward\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"delete.text\": {\n      behaviorActionImplementations[\"delete.text\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"deserialization.failure\": {\n      behaviorActionImplementations[\"deserialization.failure\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"deserialization.success\": {\n      behaviorActionImplementations[\"deserialization.success\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"focus\": {\n      behaviorActionImplementations.focus({\n        context,\n        action\n      });\n      break;\n    }\n    case \"history.redo\": {\n      behaviorActionImplementations[\"history.redo\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"history.undo\": {\n      behaviorActionImplementations[\"history.undo\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert.block\": {\n      behaviorActionImplementations[\"insert.block\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert.blocks\": {\n      behaviorActionImplementations[\"insert.blocks\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert.block object\": {\n      behaviorActionImplementations[\"insert.block object\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert.inline object\": {\n      behaviorActionImplementations[\"insert.inline object\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert.break\": {\n      behaviorActionImplementations[\"insert.break\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert.soft break\": {\n      behaviorActionImplementations[\"insert.soft break\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert.span\": {\n      behaviorActionImplementations[\"insert.span\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert.text\": {\n      behaviorActionImplementations[\"insert.text\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert.text block\": {\n      behaviorActionImplementations[\"insert.text block\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"list item.add\": {\n      behaviorActionImplementations[\"list item.add\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"list item.remove\": {\n      behaviorActionImplementations[\"list item.remove\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"list item.toggle\": {\n      behaviorActionImplementations[\"list item.toggle\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"move.block\": {\n      behaviorActionImplementations[\"move.block\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"move.block down\": {\n      behaviorActionImplementations[\"move.block down\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"move.block up\": {\n      behaviorActionImplementations[\"move.block up\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"select\": {\n      behaviorActionImplementations.select({\n        context,\n        action\n      });\n      break;\n    }\n    case \"select.previous block\": {\n      behaviorActionImplementations[\"select.previous block\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"select.next block\": {\n      behaviorActionImplementations[\"select.next block\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"serialization.failure\": {\n      behaviorActionImplementations[\"serialization.failure\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"serialization.success\": {\n      behaviorActionImplementations[\"serialization.success\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"style.add\": {\n      behaviorActionImplementations[\"style.add\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"style.remove\": {\n      behaviorActionImplementations[\"style.remove\"]({\n        context,\n        action\n      });\n      break;\n    }\n    default: {\n      behaviorActionImplementations[\"style.toggle\"]({\n        context,\n        action\n      });\n      break;\n    }\n  }\n}\nfunction createWithEventListeners(editorActor, subscriptions) {\n  return function(editor) {\n    if (editorActor.getSnapshot().context.maxBlocks !== void 0)\n      return editor;\n    subscriptions.push(() => {\n      const subscription = editorActor.on(\"*\", (event) => {\n        switch (event.type) {\n          // These events are not relevant for Behaviors\n          case \"blurred\":\n          case \"done loading\":\n          case \"editable\":\n          case \"error\":\n          case \"focused\":\n          case \"invalid value\":\n          case \"loading\":\n          case \"mutation\":\n          case \"patch\":\n          case \"internal.patch\":\n          case \"patches\":\n          case \"read only\":\n          case \"ready\":\n          case \"selection\":\n          case \"value changed\":\n          case \"unset\":\n            break;\n          case \"custom.*\":\n            editorActor.send({\n              type: \"custom behavior event\",\n              behaviorEvent: event.event,\n              editor\n            });\n            break;\n          default:\n            editorActor.send({\n              type: \"behavior event\",\n              behaviorEvent: event,\n              editor\n            });\n            break;\n        }\n      });\n      return () => {\n        subscription.unsubscribe();\n      };\n    });\n    const {\n      deleteBackward,\n      deleteForward: deleteForward2,\n      insertBreak,\n      insertData,\n      insertText: insertText2,\n      select: select2,\n      setFragmentData\n    } = editor;\n    return editor.deleteBackward = (unit) => {\n      if (isApplyingBehaviorActions(editor)) {\n        deleteBackward(unit);\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"delete.backward\",\n          unit\n        },\n        editor\n      });\n    }, editor.deleteForward = (unit) => {\n      if (isApplyingBehaviorActions(editor)) {\n        deleteForward2(unit);\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"delete.forward\",\n          unit\n        },\n        editor\n      });\n    }, editor.insertBreak = () => {\n      if (isApplyingBehaviorActions(editor)) {\n        insertBreak();\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"insert.break\"\n        },\n        editor\n      });\n    }, editor.insertData = (dataTransfer) => {\n      if (isApplyingBehaviorActions(editor)) {\n        insertData(dataTransfer);\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"deserialize\",\n          dataTransfer\n        },\n        editor\n      });\n    }, editor.insertSoftBreak = () => {\n      if (isApplyingBehaviorActions(editor)) {\n        insertSoftBreakActionImplementation({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: editorActor.getSnapshot().context.schema\n          },\n          action: {\n            type: \"insert.soft break\",\n            editor\n          }\n        });\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"insert.soft break\"\n        },\n        editor\n      });\n    }, editor.insertText = (text, options) => {\n      if (isApplyingBehaviorActions(editor)) {\n        insertText2(text, options);\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"insert.text\",\n          text,\n          options\n        },\n        editor,\n        defaultActionCallback: () => {\n          insertText2(text, options);\n        }\n      });\n    }, editor.redo = () => {\n      if (isApplyingBehaviorActions(editor)) {\n        performAction({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: editorActor.getSnapshot().context.schema\n          },\n          action: {\n            type: \"history.redo\",\n            editor\n          }\n        });\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"history.redo\"\n        },\n        editor\n      });\n    }, editor.select = (location) => {\n      if (isApplyingBehaviorActions(editor)) {\n        select2(location);\n        return;\n      }\n      const range = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.range(editor, location);\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"select\",\n          selection: toPortableTextRange(fromSlateValue(editor.children, editorActor.getSnapshot().context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), range, editorActor.getSnapshot().context.schema)\n        },\n        editor,\n        defaultActionCallback: () => {\n          select2(location);\n        }\n      });\n    }, editor.setFragmentData = (dataTransfer, originEvent) => {\n      if (isApplyingBehaviorActions(editor)) {\n        setFragmentData(dataTransfer);\n        return;\n      }\n      dataTransfer.clearData(), editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"serialize\",\n          dataTransfer,\n          originEvent: originEvent ?? \"unknown\"\n        },\n        editor\n      });\n    }, editor.undo = () => {\n      if (isApplyingBehaviorActions(editor)) {\n        performAction({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: editorActor.getSnapshot().context.schema\n          },\n          action: {\n            type: \"history.undo\",\n            editor\n          }\n        });\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"history.undo\"\n        },\n        editor\n      });\n    }, editor;\n  };\n}\nfunction createWithMaxBlocks(editorActor) {\n  return function(editor) {\n    const {\n      apply: apply2\n    } = editor;\n    return editor.apply = (operation) => {\n      if (editorActor.getSnapshot().matches({\n        \"edit mode\": \"read only\"\n      })) {\n        apply2(operation);\n        return;\n      }\n      if (isChangingRemotely(editor)) {\n        apply2(operation);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(operation);\n        return;\n      }\n      const rows = editorActor.getSnapshot().context.maxBlocks ?? -1;\n      rows > 0 && editor.children.length >= rows && (operation.type === \"insert_node\" || operation.type === \"split_node\") && operation.path.length === 1 || apply2(operation);\n    }, editor;\n  };\n}\nfunction createWithObjectKeys(editorActor, schemaTypes) {\n  return function(editor) {\n    const {\n      apply: apply2,\n      normalizeNode\n    } = editor;\n    return editor.apply = (operation) => {\n      if (isChangingRemotely(editor)) {\n        apply2(operation);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(operation);\n        return;\n      }\n      if (operation.type === \"split_node\") {\n        const existingKeys = [...slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendants(editor)].map(([node]) => node._key);\n        apply2({\n          ...operation,\n          properties: {\n            ...operation.properties,\n            _key: operation.properties._key === void 0 || existingKeys.includes(operation.properties._key) ? editorActor.getSnapshot().context.keyGenerator() : operation.properties._key\n          }\n        });\n        return;\n      }\n      if (operation.type === \"insert_node\" && !slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isEditor(operation.node)) {\n        const existingKeys = [...slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendants(editor)].map(([node]) => node._key);\n        apply2({\n          ...operation,\n          node: {\n            ...operation.node,\n            _key: operation.node._key === void 0 || existingKeys.includes(operation.node._key) ? editorActor.getSnapshot().context.keyGenerator() : operation.node._key\n          }\n        });\n        return;\n      }\n      apply2(operation);\n    }, editor.normalizeNode = (entry) => {\n      const [node, path] = entry;\n      if (slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(node) && node._type === schemaTypes.block.name) {\n        if (!node._key) {\n          editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            _key: editorActor.getSnapshot().context.keyGenerator()\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n        for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, path))\n          if (!child._key) {\n            editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n              _key: editorActor.getSnapshot().context.keyGenerator()\n            }, {\n              at: childPath\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n      }\n      normalizeNode(entry);\n    }, editor;\n  };\n}\nconst debug$7 = debugWithName(\"applyPatches\"), debugVerbose = debug$7.enabled && !0;\nfunction createApplyPatch(schemaTypes) {\n  return (editor, patch) => {\n    let changed = !1;\n    debugVerbose && (debug$7(`\n\nNEW PATCH =============================================================`), debug$7(JSON.stringify(patch, null, 2)));\n    try {\n      switch (patch.type) {\n        case \"insert\":\n          changed = insertPatch(editor, patch, schemaTypes);\n          break;\n        case \"unset\":\n          changed = unsetPatch(editor, patch);\n          break;\n        case \"set\":\n          changed = setPatch(editor, patch);\n          break;\n        case \"diffMatchPatch\":\n          changed = diffMatchPatch(editor, patch);\n          break;\n        default:\n          debug$7(\"Unhandled patch\", patch.type);\n      }\n    } catch (err) {\n      console.error(err);\n    }\n    return changed;\n  };\n}\nfunction diffMatchPatch(editor, patch) {\n  const {\n    block,\n    child,\n    childPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (!block)\n    return debug$7(\"Block not found\"), !1;\n  if (!child || !childPath)\n    return debug$7(\"Child not found\"), !1;\n  if (!(block && editor.isTextBlock(block) && patch.path.length === 4 && patch.path[1] === \"children\" && patch.path[3] === \"text\") || !slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(child))\n    return !1;\n  const patches = parse(patch.value), [newValue] = apply(patches, child.text, {\n    allowExceedingIndices: !0\n  }), diff$1 = cleanupEfficiency(diff(child.text, newValue), 5);\n  debugState(editor, \"before\");\n  let offset = 0;\n  for (const [op, text] of diff$1)\n    op === DIFF_INSERT ? (editor.apply({\n      type: \"insert_text\",\n      path: childPath,\n      offset,\n      text\n    }), offset += text.length) : op === DIFF_DELETE ? editor.apply({\n      type: \"remove_text\",\n      path: childPath,\n      offset,\n      text\n    }) : op === DIFF_EQUAL && (offset += text.length);\n  return debugState(editor, \"after\"), !0;\n}\nfunction insertPatch(editor, patch, schemaTypes) {\n  const {\n    block: targetBlock,\n    child: targetChild,\n    blockPath: targetBlockPath,\n    childPath: targetChildPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (!targetBlock || !targetBlockPath)\n    return debug$7(\"Block not found\"), !1;\n  if (patch.path.length > 1 && patch.path[1] !== \"children\")\n    return debug$7(\"Ignoring patch targeting void value\"), !1;\n  if (patch.path.length === 1) {\n    const {\n      items: items2,\n      position: position2\n    } = patch, blocksToInsert = toSlateValue(items2, {\n      schemaTypes\n    }, KEY_TO_SLATE_ELEMENT.get(editor)), targetBlockIndex = targetBlockPath[0], normalizedIdx2 = position2 === \"after\" ? targetBlockIndex + 1 : targetBlockIndex;\n    return debug$7(`Inserting blocks at path [${normalizedIdx2}]`), debugState(editor, \"before\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, blocksToInsert, {\n      at: [normalizedIdx2]\n    }), debugState(editor, \"after\"), !0;\n  }\n  const {\n    items,\n    position\n  } = patch;\n  if (!targetChild || !targetChildPath)\n    return debug$7(\"Child not found\"), !1;\n  const childrenToInsert = targetBlock && toSlateValue([{\n    ...targetBlock,\n    children: items\n  }], {\n    schemaTypes\n  }, KEY_TO_SLATE_ELEMENT.get(editor)), targetChildIndex = targetChildPath[1], normalizedIdx = position === \"after\" ? targetChildIndex + 1 : targetChildIndex, childInsertPath = [targetChildPath[0], normalizedIdx];\n  return debug$7(`Inserting children at path ${childInsertPath}`), debugState(editor, \"before\"), childrenToInsert && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(childrenToInsert[0]) && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, childrenToInsert[0].children, {\n    at: childInsertPath\n  }), debugState(editor, \"after\"), !0;\n}\nfunction setPatch(editor, patch) {\n  let value = patch.value;\n  typeof patch.path[3] == \"string\" && (value = {}, value[patch.path[3]] = patch.value);\n  const {\n    block,\n    blockPath,\n    child,\n    childPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (!block)\n    return debug$7(\"Block not found\"), !1;\n  const isTextBlock2 = editor.isTextBlock(block);\n  if (isTextBlock2 && patch.path.length > 1 && patch.path[1] !== \"children\")\n    return debug$7(\"Ignoring setting void value\"), !1;\n  if (debugState(editor, \"before\"), isTextBlock2 && child && childPath) {\n    if (slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(value) && slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(child)) {\n      const newText = child.text;\n      value.text !== newText && (debug$7(\"Setting text property\"), editor.apply({\n        type: \"remove_text\",\n        path: childPath,\n        offset: 0,\n        text: newText\n      }), editor.apply({\n        type: \"insert_text\",\n        path: childPath,\n        offset: 0,\n        text: value.text\n      }), editor.onChange());\n    } else\n      debug$7(\"Setting non-text property\"), editor.apply({\n        type: \"set_node\",\n        path: childPath,\n        properties: {},\n        newProperties: value\n      });\n    return !0;\n  } else if (slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block) && patch.path.length === 1 && blockPath) {\n    debug$7(\"Setting block property\");\n    const {\n      children,\n      ...nextRest\n    } = value, {\n      children: prevChildren,\n      ...prevRest\n    } = block || {\n      children: void 0\n    };\n    editor.apply({\n      type: \"set_node\",\n      path: blockPath,\n      properties: {\n        ...prevRest\n      },\n      newProperties: nextRest\n    }), debug$7(\"Setting children\"), block.children.forEach((c2, cIndex) => {\n      editor.apply({\n        type: \"remove_node\",\n        path: blockPath.concat(block.children.length - 1 - cIndex),\n        node: c2\n      });\n    }), Array.isArray(children) && children.forEach((c2, cIndex) => {\n      editor.apply({\n        type: \"insert_node\",\n        path: blockPath.concat(cIndex),\n        node: c2\n      });\n    });\n  } else if (block && \"value\" in block)\n    if (patch.path.length > 1 && patch.path[1] !== \"children\") {\n      const newVal = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.applyAll)(block.value, [{\n        ...patch,\n        path: patch.path.slice(1)\n      }]);\n      slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n        ...block,\n        value: newVal\n      }, {\n        at: blockPath\n      });\n    } else\n      return !1;\n  return debugState(editor, \"after\"), !0;\n}\nfunction unsetPatch(editor, patch) {\n  if (patch.path.length === 0) {\n    debug$7(\"Removing everything\"), debugState(editor, \"before\");\n    const previousSelection = editor.selection;\n    return slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(editor), editor.children.forEach((_child, i) => {\n      slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n        at: [i]\n      });\n    }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, editor.pteCreateTextBlock({\n      decorators: []\n    })), previousSelection && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(editor, {\n      anchor: {\n        path: [0, 0],\n        offset: 0\n      },\n      focus: {\n        path: [0, 0],\n        offset: 0\n      }\n    }), editor.onChange(), debugState(editor, \"after\"), !0;\n  }\n  const {\n    block,\n    blockPath,\n    child,\n    childPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (patch.path.length === 1) {\n    if (!block || !blockPath)\n      return debug$7(\"Block not found\"), !1;\n    const blockIndex = blockPath[0];\n    return debug$7(`Removing block at path [${blockIndex}]`), debugState(editor, \"before\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n      at: [blockIndex]\n    }), debugState(editor, \"after\"), !0;\n  }\n  return editor.isTextBlock(block) && patch.path[1] === \"children\" && patch.path.length === 3 ? !child || !childPath ? (debug$7(\"Child not found\"), !1) : (debug$7(`Unsetting child at path ${JSON.stringify(childPath)}`), debugState(editor, \"before\"), debugVerbose && debug$7(`Removing child at path ${JSON.stringify(childPath)}`), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n    at: childPath\n  }), debugState(editor, \"after\"), !0) : !1;\n}\nfunction isKeyedSegment(segment) {\n  return typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction debugState(editor, stateName) {\n  debugVerbose && (debug$7(`Children ${stateName}:`, JSON.stringify(editor.children, null, 2)), debug$7(`Selection ${stateName}: `, JSON.stringify(editor.selection, null, 2)));\n}\nfunction findBlockFromPath(editor, path) {\n  let blockIndex = -1;\n  const block = editor.children.find((node, index) => {\n    const isMatch = isKeyedSegment(path[0]) ? node._key === path[0]._key : index === path[0];\n    return isMatch && (blockIndex = index), isMatch;\n  });\n  return block ? {\n    block,\n    path: [blockIndex]\n  } : {};\n}\nfunction findBlockAndChildFromPath(editor, path) {\n  const {\n    block,\n    path: blockPath\n  } = findBlockFromPath(editor, path);\n  if (!(slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block) && path[1] === \"children\"))\n    return {\n      block,\n      blockPath,\n      child: void 0,\n      childPath: void 0\n    };\n  let childIndex = -1;\n  const child = block.children.find((node, index) => {\n    const isMatch = isKeyedSegment(path[2]) ? node._key === path[2]._key : index === path[2];\n    return isMatch && (childIndex = index), isMatch;\n  });\n  return child ? {\n    block,\n    child,\n    blockPath,\n    childPath: blockPath?.concat(childIndex)\n  } : {\n    block,\n    blockPath,\n    child: void 0,\n    childPath: void 0\n  };\n}\nconst debug$6 = debugWithName(\"plugin:withPatches\");\nfunction createWithPatches({\n  editorActor,\n  patchFunctions,\n  schemaTypes,\n  subscriptions\n}) {\n  let previousChildren;\n  const applyPatch = createApplyPatch(schemaTypes);\n  return function(editor) {\n    IS_PROCESSING_REMOTE_CHANGES.set(editor, !1), PATCHING.set(editor, !0), previousChildren = [...editor.children];\n    const {\n      apply: apply2\n    } = editor;\n    let bufferedPatches = [];\n    const handleBufferedRemotePatches = () => {\n      if (bufferedPatches.length === 0)\n        return;\n      const patches = bufferedPatches;\n      bufferedPatches = [];\n      let changed = !1;\n      withRemoteChanges(editor, () => {\n        slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n          withoutPatching(editor, () => {\n            withoutSaving(editor, () => {\n              patches.forEach((patch) => {\n                debug$6.enabled && debug$6(`Handling remote patch ${JSON.stringify(patch)}`), changed = applyPatch(editor, patch);\n              });\n            });\n          });\n        }), changed && (editor.normalize(), editor.onChange());\n      });\n    }, handlePatches = ({\n      patches\n    }) => {\n      const remotePatches = patches.filter((p) => p.origin !== \"local\");\n      remotePatches.length !== 0 && (bufferedPatches = bufferedPatches.concat(remotePatches), handleBufferedRemotePatches());\n    };\n    return subscriptions.push(() => {\n      debug$6(\"Subscribing to remote patches\");\n      const sub = editorActor.on(\"patches\", handlePatches);\n      return () => {\n        debug$6(\"Unsubscribing to remote patches\"), sub.unsubscribe();\n      };\n    }), editor.apply = (operation) => {\n      let patches = [];\n      previousChildren = editor.children;\n      const editorWasEmpty = isEqualToEmptyEditor(previousChildren, schemaTypes);\n      apply2(operation);\n      const editorIsEmpty = isEqualToEmptyEditor(editor.children, schemaTypes);\n      if (!isPatching(editor))\n        return editor;\n      switch (editorWasEmpty && !editorIsEmpty && operation.type !== \"set_selection\" && patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)(previousChildren, \"before\", [0])), operation.type) {\n        case \"insert_text\":\n          patches = [...patches, ...patchFunctions.insertTextPatch(editor, operation, previousChildren)];\n          break;\n        case \"remove_text\":\n          patches = [...patches, ...patchFunctions.removeTextPatch(editor, operation, previousChildren)];\n          break;\n        case \"remove_node\":\n          patches = [...patches, ...patchFunctions.removeNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"split_node\":\n          patches = [...patches, ...patchFunctions.splitNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"insert_node\":\n          patches = [...patches, ...patchFunctions.insertNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"set_node\":\n          patches = [...patches, ...patchFunctions.setNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"merge_node\":\n          patches = [...patches, ...patchFunctions.mergeNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"move_node\":\n          patches = [...patches, ...patchFunctions.moveNodePatch(editor, operation, previousChildren)];\n          break;\n      }\n      if (!editorWasEmpty && editorIsEmpty && [\"merge_node\", \"set_node\", \"remove_text\", \"remove_node\"].includes(operation.type) && (patches = [...patches, (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([])], editorActor.send({\n        type: \"notify.unset\",\n        previousValue: fromSlateValue(previousChildren, schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))\n      })), editorWasEmpty && patches.length > 0 && (patches = [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.setIfMissing)([], []), ...patches]), patches.length > 0)\n        for (const patch of patches)\n          editorActor.send({\n            type: \"internal.patch\",\n            patch: {\n              ...patch,\n              origin: \"local\"\n            },\n            actionId: getCurrentActionId(editor),\n            value: fromSlateValue(editor.children, schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))\n          });\n      return editor;\n    }, editor;\n  };\n}\nconst debug$5 = debugWithName(\"plugin:withPlaceholderBlock\");\nfunction createWithPlaceholderBlock(editorActor) {\n  return function(editor) {\n    const {\n      apply: apply2\n    } = editor;\n    return editor.apply = (op) => {\n      if (editorActor.getSnapshot().matches({\n        \"edit mode\": \"read only\"\n      })) {\n        apply2(op);\n        return;\n      }\n      if (isChangingRemotely(editor)) {\n        apply2(op);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(op);\n        return;\n      }\n      if (op.type === \"remove_node\") {\n        const node = op.node;\n        if (op.path[0] === 0 && slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isVoid(editor, node)) {\n          const nextPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.next(op.path);\n          editor.children[nextPath[0]] || (debug$5(\"Adding placeholder block\"), slate__WEBPACK_IMPORTED_MODULE_15__.Editor.insertNode(editor, editor.pteCreateTextBlock({\n            decorators: []\n          })));\n        }\n      }\n      apply2(op);\n    }, editor;\n  };\n}\nconst debug$4 = debugWithName(\"plugin:withPortableTextBlockStyle\");\nfunction createWithPortableTextBlockStyle(editorActor, types) {\n  const defaultStyle = types.styles[0].value;\n  return function(editor) {\n    const {\n      normalizeNode\n    } = editor;\n    return editor.normalizeNode = (nodeEntry) => {\n      const [, path] = nodeEntry;\n      for (const op of editor.operations)\n        if (op.type === \"split_node\" && op.path.length === 1 && editor.isTextBlock(op.properties) && op.properties.style !== defaultStyle && op.path[0] === path[0] && !slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(path, op.path)) {\n          const [child] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, [op.path[0] + 1, 0]);\n          if (slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(child) && child.text === \"\") {\n            debug$4(`Normalizing split node to ${defaultStyle} style`, op), editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n              style: defaultStyle\n            }, {\n              at: [op.path[0] + 1],\n              voids: !1\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n        }\n      normalizeNode(nodeEntry);\n    }, editor;\n  };\n}\ndebugWithName(\"plugin:withPortableTextSelections\");\nfunction createWithPortableTextSelections(editorActor, types) {\n  let prevSelection = null;\n  return function(editor) {\n    const emitPortableTextSelection = () => {\n      if (prevSelection !== editor.selection) {\n        let ptRange = null;\n        if (editor.selection) {\n          const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);\n          if (existing)\n            ptRange = existing;\n          else {\n            const value = editor.children;\n            ptRange = toPortableTextRange(value, editor.selection, types), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);\n          }\n        }\n        ptRange ? editorActor.send({\n          type: \"notify.selection\",\n          selection: ptRange\n        }) : editorActor.send({\n          type: \"notify.selection\",\n          selection: null\n        });\n      }\n      prevSelection = editor.selection;\n    }, {\n      onChange\n    } = editor;\n    return editor.onChange = () => {\n      onChange(), editorActor.getSnapshot().matches({\n        setup: \"setting up\"\n      }) || emitPortableTextSelection();\n    }, editor;\n  };\n}\nconst debug$3 = debugWithName(\"plugin:withSchemaTypes\");\nfunction createWithSchemaTypes({\n  editorActor,\n  schemaTypes\n}) {\n  return function(editor) {\n    editor.isTextBlock = (value) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isPortableTextTextBlock)(value) && value._type === schemaTypes.block.name, editor.isTextSpan = (value) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isPortableTextSpan)(value) && value._type === schemaTypes.span.name, editor.isListBlock = (value) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isPortableTextListBlock)(value) && value._type === schemaTypes.block.name, editor.isVoid = (element) => schemaTypes.block.name !== element._type && (schemaTypes.blockObjects.map((obj) => obj.name).includes(element._type) || schemaTypes.inlineObjects.map((obj) => obj.name).includes(element._type)), editor.isInline = (element) => schemaTypes.inlineObjects.map((obj) => obj.name).includes(element._type) && \"__inline\" in element && element.__inline === !0;\n    const {\n      normalizeNode\n    } = editor;\n    return editor.normalizeNode = (entry) => {\n      const [node, path] = entry;\n      if (node._type === void 0 && path.length === 2) {\n        debug$3(\"Setting span type on text node without a type\");\n        const span = node, key = span._key || editorActor.getSnapshot().context.keyGenerator();\n        editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          ...span,\n          _type: schemaTypes.span.name,\n          _key: key\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      if (node._key === void 0 && (path.length === 1 || path.length === 2)) {\n        debug$3(\"Setting missing key on child node without a key\");\n        const key = editorActor.getSnapshot().context.keyGenerator();\n        editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          _key: key\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      normalizeNode(entry);\n    }, editor;\n  };\n}\nfunction createWithUtils({\n  editorActor,\n  schemaTypes\n}) {\n  return function(editor) {\n    return editor.pteCreateTextBlock = (options) => toSlateValue([{\n      _type: schemaTypes.block.name,\n      _key: editorActor.getSnapshot().context.keyGenerator(),\n      style: schemaTypes.styles[0].value || \"normal\",\n      ...options.listItem ? {\n        listItem: options.listItem\n      } : {},\n      ...options.level ? {\n        level: options.level\n      } : {},\n      markDefs: [],\n      children: [{\n        _type: \"span\",\n        _key: editorActor.getSnapshot().context.keyGenerator(),\n        text: \"\",\n        marks: options.decorators.filter((decorator) => schemaTypes.decorators.find(({\n          value\n        }) => value === decorator))\n      }]\n    }], {\n      schemaTypes\n    })[0], editor;\n  };\n}\nconst withPlugins = (editor, options) => {\n  const e = editor, {\n    editorActor\n  } = options, schemaTypes = editorActor.getSnapshot().context.schema, operationToPatches = createOperationToPatches(schemaTypes), withObjectKeys = createWithObjectKeys(editorActor, schemaTypes), withSchemaTypes = createWithSchemaTypes({\n    editorActor,\n    schemaTypes\n  }), withPatches = createWithPatches({\n    editorActor,\n    patchFunctions: operationToPatches,\n    schemaTypes,\n    subscriptions: options.subscriptions\n  }), withMaxBlocks = createWithMaxBlocks(editorActor), withUndoRedo = createWithUndoRedo({\n    editorActor,\n    blockSchemaType: schemaTypes.block,\n    subscriptions: options.subscriptions\n  }), withPortableTextMarkModel = createWithPortableTextMarkModel(editorActor, schemaTypes), withPortableTextBlockStyle = createWithPortableTextBlockStyle(editorActor, schemaTypes), withPlaceholderBlock = createWithPlaceholderBlock(editorActor), withUtils = createWithUtils({\n    editorActor,\n    schemaTypes\n  }), withPortableTextSelections = createWithPortableTextSelections(editorActor, schemaTypes);\n  return createWithEventListeners(editorActor, options.subscriptions)(withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withPlaceholderBlock(withUtils(withMaxBlocks(withUndoRedo(withPatches(withPortableTextSelections(e)))))))))));\n}, debug$2 = debugWithName(\"component:PortableTextEditor:SlateContainer\"), slateEditors = /* @__PURE__ */ new WeakMap();\nfunction createSlateEditor(config) {\n  const existingSlateEditor = slateEditors.get(config.editorActor);\n  if (existingSlateEditor)\n    return debug$2(\"Reusing existing Slate editor instance\", config.editorActor.id), existingSlateEditor;\n  debug$2(\"Creating new Slate editor instance\", config.editorActor.id);\n  const unsubscriptions = [], subscriptions = [], instance = withPlugins((0,slate_react__WEBPACK_IMPORTED_MODULE_29__.withReact)((0,slate__WEBPACK_IMPORTED_MODULE_15__.createEditor)()), {\n    editorActor: config.editorActor,\n    subscriptions\n  });\n  KEY_TO_VALUE_ELEMENT.set(instance, {}), KEY_TO_SLATE_ELEMENT.set(instance, {});\n  for (const subscription of subscriptions)\n    unsubscriptions.push(subscription());\n  const initialValue = [instance.pteCreateTextBlock({\n    decorators: []\n  })], slateEditor = {\n    instance,\n    initialValue\n  };\n  return slateEditors.set(config.editorActor, slateEditor), slateEditor;\n}\nconst toggleAnnotationOff = (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.defineBehavior)({\n  on: \"annotation.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => (0,_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_28__.isActiveAnnotation)(event.annotation.name)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.raise)({\n    type: \"annotation.remove\",\n    annotation: event.annotation\n  })]]\n}), toggleAnnotationOn = (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.defineBehavior)({\n  on: \"annotation.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => !(0,_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_28__.isActiveAnnotation)(event.annotation.name)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.raise)({\n    type: \"annotation.add\",\n    annotation: event.annotation\n  })]]\n}), toggleDecoratorOff = (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.defineBehavior)({\n  on: \"decorator.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => (0,_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_28__.isActiveDecorator)(event.decorator)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.raise)({\n    type: \"decorator.remove\",\n    decorator: event.decorator\n  })]]\n}), toggleDecoratorOn = (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.defineBehavior)({\n  on: \"decorator.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => !(0,_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_28__.isActiveDecorator)(event.decorator)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.raise)({\n    type: \"decorator.add\",\n    decorator: event.decorator\n  })]]\n}), toggleListItemOff = (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.defineBehavior)({\n  on: \"list item.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => (0,_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_28__.isActiveListItem)(event.listItem)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.raise)({\n    type: \"list item.remove\",\n    listItem: event.listItem\n  })]]\n}), toggleListItemOn = (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.defineBehavior)({\n  on: \"list item.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => !(0,_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_28__.isActiveListItem)(event.listItem)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.raise)({\n    type: \"list item.add\",\n    listItem: event.listItem\n  })]]\n}), toggleStyleOff = (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.defineBehavior)({\n  on: \"style.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => (0,_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_28__.isActiveStyle)(event.style)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.raise)({\n    type: \"style.remove\",\n    style: event.style\n  })]]\n}), toggleStyleOn = (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.defineBehavior)({\n  on: \"style.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => !(0,_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_28__.isActiveStyle)(event.style)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.raise)({\n    type: \"style.add\",\n    style: event.style\n  })]]\n}), raiseDeserializationSuccessOrFailure = (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.defineBehavior)({\n  on: \"deserialize\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const deserializeEvents = snapshot.context.converters.flatMap((converter) => {\n      const data = event.dataTransfer.getData(converter.mimeType);\n      return data ? [converter.deserialize({\n        snapshot,\n        event: {\n          type: \"deserialize\",\n          data\n        }\n      })] : [];\n    });\n    return deserializeEvents.find((deserializeEvent) => deserializeEvent.type === \"deserialization.success\") || {\n      type: \"deserialization.failure\",\n      mimeType: \"*/*\",\n      reason: deserializeEvents.map((deserializeEvent) => deserializeEvent.type === \"deserialization.failure\" ? deserializeEvent.reason : \"\").join(\", \")\n    };\n  },\n  actions: [({\n    event\n  }, deserializeEvent) => [(0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.raise)({\n    ...deserializeEvent,\n    dataTransfer: event.dataTransfer\n  })]]\n}), raiseInsertBlocks = (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.defineBehavior)({\n  on: \"deserialization.success\",\n  actions: [({\n    event\n  }) => [(0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.raise)({\n    type: \"insert.blocks\",\n    blocks: event.data\n  })]]\n}), raiseSerializationSuccessOrFailure = (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.defineBehavior)({\n  on: \"serialize\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (snapshot.context.converters.length === 0)\n      return !1;\n    const serializeEvents = snapshot.context.converters.map((converter) => converter.serialize({\n      snapshot,\n      event\n    }));\n    return serializeEvents.length === 0 ? !1 : serializeEvents;\n  },\n  actions: [({\n    event\n  }, serializeEvents) => serializeEvents.map((serializeEvent) => (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.raise)({\n    ...serializeEvent,\n    dataTransfer: event.dataTransfer\n  }))]\n}), raiseDataTransferSet = (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.defineBehavior)({\n  on: \"serialization.success\",\n  actions: [({\n    event\n  }) => [(0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.raise)({\n    type: \"data transfer.set\",\n    data: event.data,\n    dataTransfer: event.dataTransfer,\n    mimeType: event.mimeType\n  })]]\n}), defaultBehaviors = [toggleAnnotationOff, toggleAnnotationOn, toggleDecoratorOff, toggleDecoratorOn, toggleListItemOff, toggleListItemOn, toggleStyleOff, toggleStyleOn, raiseDeserializationSuccessOrFailure, raiseInsertBlocks, raiseSerializationSuccessOrFailure, raiseDataTransferSet], keyIs = {\n  lineBreak: (event) => event.key === \"Enter\" && event.shiftKey\n}, raiseSoftBreak = (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.defineBehavior)({\n  on: \"key.down\",\n  guard: ({\n    event\n  }) => keyIs.lineBreak(event.keyboardEvent),\n  actions: [() => [(0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.raise)({\n    type: \"insert.soft break\"\n  })]]\n}), foundationalBehaviors = [raiseSoftBreak];\nfunction getActiveDecorators({\n  schema,\n  slateEditorInstance\n}) {\n  const decorators = schema.decorators.map((decorator) => decorator.value);\n  return ({\n    ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(slateEditorInstance) ?? {}\n  }.marks ?? []).filter((mark) => decorators.includes(mark));\n}\nfunction createEditorSnapshot({\n  converters,\n  editor,\n  keyGenerator,\n  schema,\n  hasTag\n}) {\n  const value = fromSlateValue(editor.children, schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), selection = toPortableTextRange(value, editor.selection, schema);\n  return {\n    context: {\n      activeDecorators: getActiveDecorators({\n        schema,\n        slateEditorInstance: editor\n      }),\n      converters,\n      keyGenerator,\n      schema,\n      selection,\n      value\n    },\n    beta: {\n      hasTag\n    }\n  };\n}\nconst editorMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_16__.setup)({\n  types: {\n    context: {},\n    events: {},\n    emitted: {},\n    input: {},\n    tags: {}\n  },\n  actions: {\n    \"add behavior to context\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.a)({\n      behaviors: ({\n        context,\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_16__.assertEvent)(event, \"add behavior\"), /* @__PURE__ */ new Set([...context.behaviors, event.behavior]))\n    }),\n    \"remove behavior from context\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.a)({\n      behaviors: ({\n        context,\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_16__.assertEvent)(event, \"remove behavior\"), context.behaviors.delete(event.behavior), /* @__PURE__ */ new Set([...context.behaviors]))\n    }),\n    \"assign behaviors\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.a)({\n      behaviors: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_16__.assertEvent)(event, \"update behaviors\"), /* @__PURE__ */ new Set([...event.behaviors]))\n    }),\n    \"assign schema\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.a)({\n      schema: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_16__.assertEvent)(event, \"update schema\"), event.schema)\n    }),\n    \"emit patch event\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.b)(({\n      event,\n      enqueue\n    }) => {\n      (0,xstate__WEBPACK_IMPORTED_MODULE_16__.assertEvent)(event, \"internal.patch\"), enqueue.emit(event), enqueue.emit({\n        type: \"patch\",\n        patch: event.patch\n      });\n    }),\n    \"emit mutation event\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n      event\n    }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_16__.assertEvent)(event, \"mutation\"), event)),\n    \"emit read only\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)({\n      type: \"read only\"\n    }),\n    \"emit editable\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)({\n      type: \"editable\"\n    }),\n    \"defer event\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.a)({\n      pendingEvents: ({\n        context,\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_16__.assertEvent)(event, [\"internal.patch\", \"mutation\"]), [...context.pendingEvents, event])\n    }),\n    \"emit pending events\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.b)(({\n      context,\n      enqueue\n    }) => {\n      for (const event of context.pendingEvents)\n        event.type === \"internal.patch\" ? (enqueue.emit(event), enqueue.emit({\n          type: \"patch\",\n          patch: event.patch\n        })) : enqueue.emit(event);\n    }),\n    \"emit ready\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)({\n      type: \"ready\"\n    }),\n    \"clear pending events\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.a)({\n      pendingEvents: []\n    }),\n    \"handle behavior event\": (0,xstate__WEBPACK_IMPORTED_MODULE_17__.b)(({\n      context,\n      event,\n      enqueue,\n      self\n    }) => {\n      (0,xstate__WEBPACK_IMPORTED_MODULE_16__.assertEvent)(event, [\"behavior event\", \"custom behavior event\"]);\n      const defaultAction = event.type === \"custom behavior event\" || event.behaviorEvent.type === \"copy\" || event.behaviorEvent.type === \"deserialize\" || event.behaviorEvent.type === \"key.down\" || event.behaviorEvent.type === \"key.up\" || event.behaviorEvent.type === \"paste\" || event.behaviorEvent.type === \"serialize\" ? void 0 : {\n        ...event.behaviorEvent,\n        editor: event.editor\n      }, defaultActionCallback = event.type === \"behavior event\" ? event.defaultActionCallback : void 0, eventBehaviors = [...foundationalBehaviors, ...context.behaviors.values(), ...defaultBehaviors].filter((behavior) => behavior.on === event.behaviorEvent.type);\n      if (eventBehaviors.length === 0) {\n        if (defaultActionCallback) {\n          withApplyingBehaviorActions(event.editor, () => {\n            try {\n              defaultActionCallback();\n            } catch (error) {\n              console.error(new Error(`Performing action \"${event.behaviorEvent.type}\" failed due to: ${error.message}`));\n            }\n          });\n          return;\n        }\n        if (!defaultAction)\n          return;\n        withApplyingBehaviorActions(event.editor, () => {\n          try {\n            performAction({\n              context,\n              action: defaultAction\n            });\n          } catch (error) {\n            console.error(new Error(`Performing action \"${defaultAction.type}\" as a result of \"${event.behaviorEvent.type}\" failed due to: ${error.message}`));\n          }\n        }), event.editor.onChange();\n        return;\n      }\n      const editorSnapshot = createEditorSnapshot({\n        converters: [...context.converters],\n        editor: event.editor,\n        keyGenerator: context.keyGenerator,\n        schema: context.schema,\n        hasTag: (tag) => self.getSnapshot().hasTag(tag)\n      });\n      let behaviorOverwritten = !1;\n      for (const eventBehavior of eventBehaviors) {\n        const shouldRun = eventBehavior.guard === void 0 || eventBehavior.guard({\n          context: editorSnapshot.context,\n          snapshot: editorSnapshot,\n          event: event.behaviorEvent\n        });\n        if (!shouldRun)\n          continue;\n        const actionIntendSets = eventBehavior.actions.map((actionSet) => actionSet({\n          context: editorSnapshot.context,\n          snapshot: editorSnapshot,\n          event: event.behaviorEvent\n        }, shouldRun));\n        for (const actionIntends of actionIntendSets)\n          behaviorOverwritten = behaviorOverwritten || actionIntends.length > 0 && actionIntends.some((actionIntend) => actionIntend.type !== \"effect\"), withApplyingBehaviorActionIntendSet(event.editor, () => {\n            for (const actionIntend of actionIntends) {\n              if (actionIntend.type === \"raise\") {\n                (0,_behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.isCustomBehaviorEvent)(actionIntend.event) ? enqueue.raise({\n                  type: \"custom behavior event\",\n                  behaviorEvent: actionIntend.event,\n                  editor: event.editor\n                }) : enqueue.raise({\n                  type: \"behavior event\",\n                  behaviorEvent: actionIntend.event,\n                  editor: event.editor\n                });\n                continue;\n              }\n              const action = {\n                ...actionIntend,\n                editor: event.editor\n              };\n              try {\n                performAction({\n                  context,\n                  action\n                });\n              } catch (error) {\n                console.error(new Error(`Performing action \"${action.type}\" as a result of \"${event.behaviorEvent.type}\" failed due to: ${error.message}`));\n                break;\n              }\n            }\n          }), event.editor.onChange();\n        if (behaviorOverwritten) {\n          event.nativeEvent?.preventDefault();\n          break;\n        }\n      }\n      if (!behaviorOverwritten) {\n        if (defaultActionCallback) {\n          withApplyingBehaviorActions(event.editor, () => {\n            try {\n              defaultActionCallback();\n            } catch (error) {\n              console.error(new Error(`Performing \"${event.behaviorEvent.type}\" failed due to: ${error.message}`));\n            }\n          });\n          return;\n        }\n        if (!defaultAction)\n          return;\n        withApplyingBehaviorActions(event.editor, () => {\n          try {\n            performAction({\n              context,\n              action: defaultAction\n            });\n          } catch (error) {\n            console.error(new Error(`Performing action \"${defaultAction.type}\" as a result of \"${event.behaviorEvent.type}\" failed due to: ${error.message}`));\n          }\n        }), event.editor.onChange();\n      }\n    })\n  }\n}).createMachine({\n  id: \"editor\",\n  context: ({\n    input\n  }) => ({\n    behaviors: /* @__PURE__ */ new Set([...input.behaviors ?? _behavior_core_js__WEBPACK_IMPORTED_MODULE_30__.coreBehaviors]),\n    converters: new Set(input.converters ?? []),\n    keyGenerator: input.keyGenerator,\n    pendingEvents: [],\n    schema: input.schema,\n    selection: null,\n    initialReadOnly: input.readOnly ?? !1,\n    maxBlocks: input.maxBlocks,\n    value: input.value\n  }),\n  on: {\n    \"notify.blurred\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n        event\n      }) => ({\n        ...event,\n        type: \"blurred\"\n      }))\n    },\n    \"notify.done loading\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)({\n        type: \"done loading\"\n      })\n    },\n    \"notify.error\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n        event\n      }) => ({\n        ...event,\n        type: \"error\"\n      }))\n    },\n    \"notify.invalid value\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n        event\n      }) => ({\n        ...event,\n        type: \"invalid value\"\n      }))\n    },\n    \"notify.focused\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n        event\n      }) => ({\n        ...event,\n        type: \"focused\"\n      }))\n    },\n    \"notify.selection\": {\n      actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_17__.a)({\n        selection: ({\n          event\n        }) => event.selection\n      }), (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n        event\n      }) => ({\n        ...event,\n        type: \"selection\"\n      }))]\n    },\n    \"notify.unset\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n        event\n      }) => ({\n        ...event,\n        type: \"unset\"\n      }))\n    },\n    \"notify.loading\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)({\n        type: \"loading\"\n      })\n    },\n    \"notify.value changed\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n        event\n      }) => ({\n        ...event,\n        type: \"value changed\"\n      }))\n    },\n    \"add behavior\": {\n      actions: \"add behavior to context\"\n    },\n    \"remove behavior\": {\n      actions: \"remove behavior from context\"\n    },\n    patches: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n        event\n      }) => event)\n    },\n    \"update behaviors\": {\n      actions: \"assign behaviors\"\n    },\n    \"update key generator\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.a)({\n        keyGenerator: ({\n          event\n        }) => event.keyGenerator\n      })\n    },\n    \"update schema\": {\n      actions: \"assign schema\"\n    },\n    \"update value\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.a)({\n        value: ({\n          event\n        }) => event.value\n      })\n    },\n    \"update maxBlocks\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.a)({\n        maxBlocks: ({\n          event\n        }) => event.maxBlocks\n      })\n    }\n  },\n  type: \"parallel\",\n  states: {\n    \"edit mode\": {\n      initial: \"read only\",\n      states: {\n        \"read only\": {\n          initial: \"determine initial edit mode\",\n          on: {\n            \"behavior event\": {\n              actions: \"handle behavior event\",\n              guard: ({\n                event\n              }) => event.behaviorEvent.type === \"copy\" || event.behaviorEvent.type === \"data transfer.set\" || event.behaviorEvent.type === \"serialize\" || event.behaviorEvent.type === \"serialization.failure\" || event.behaviorEvent.type === \"serialization.success\" || event.behaviorEvent.type === \"select\"\n            }\n          },\n          states: {\n            \"determine initial edit mode\": {\n              on: {\n                \"done syncing initial value\": [{\n                  target: \"#editor.edit mode.read only.read only\",\n                  guard: ({\n                    context\n                  }) => context.initialReadOnly\n                }, {\n                  target: \"#editor.edit mode.editable\"\n                }]\n              }\n            },\n            \"read only\": {\n              on: {\n                \"update readOnly\": {\n                  guard: ({\n                    event\n                  }) => !event.readOnly,\n                  target: \"#editor.edit mode.editable\",\n                  actions: [\"emit editable\"]\n                }\n              }\n            }\n          }\n        },\n        editable: {\n          on: {\n            \"update readOnly\": {\n              guard: ({\n                event\n              }) => event.readOnly,\n              target: \"#editor.edit mode.read only.read only\",\n              actions: [\"emit read only\"]\n            },\n            \"behavior event\": {\n              actions: \"handle behavior event\"\n            },\n            \"custom behavior event\": {\n              actions: \"handle behavior event\"\n            },\n            \"annotation.*\": {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n                event\n              }) => event)\n            },\n            \"block.*\": {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n                event\n              }) => event)\n            },\n            blur: {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n                event\n              }) => event)\n            },\n            \"custom.*\": {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n                event\n              }) => ({\n                type: \"custom.*\",\n                event\n              }))\n            },\n            \"decorator.*\": {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n                event\n              }) => event)\n            },\n            \"delete.*\": {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n                event\n              }) => event)\n            },\n            focus: {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n                event\n              }) => event)\n            },\n            \"history.*\": {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n                event\n              }) => event)\n            },\n            \"insert.*\": {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n                event\n              }) => event)\n            },\n            \"list item.*\": {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n                event\n              }) => event)\n            },\n            \"move.*\": {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n                event\n              }) => event)\n            },\n            select: {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n                event\n              }) => event)\n            },\n            \"select.*\": {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n                event\n              }) => event)\n            },\n            \"style.*\": {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n                event\n              }) => event)\n            },\n            \"text block.*\": {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_17__.e)(({\n                event\n              }) => event)\n            }\n          },\n          initial: \"idle\",\n          states: {\n            idle: {\n              on: {\n                dragstart: {\n                  target: \"dragging internally\"\n                }\n              }\n            },\n            \"dragging internally\": {\n              tags: [\"dragging internally\"],\n              on: {\n                dragend: {\n                  target: \"idle\"\n                },\n                drop: {\n                  target: \"idle\"\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    setup: {\n      initial: \"setting up\",\n      states: {\n        \"setting up\": {\n          exit: [\"emit ready\"],\n          on: {\n            \"internal.patch\": {\n              actions: \"defer event\"\n            },\n            mutation: {\n              actions: \"defer event\"\n            },\n            \"done syncing initial value\": {\n              target: \"pristine\"\n            }\n          }\n        },\n        pristine: {\n          initial: \"idle\",\n          states: {\n            idle: {\n              on: {\n                normalizing: {\n                  target: \"normalizing\"\n                },\n                \"internal.patch\": {\n                  actions: \"defer event\",\n                  target: \"#editor.setup.dirty\"\n                },\n                mutation: {\n                  actions: \"defer event\",\n                  target: \"#editor.setup.dirty\"\n                }\n              }\n            },\n            normalizing: {\n              on: {\n                \"done normalizing\": {\n                  target: \"idle\"\n                },\n                \"internal.patch\": {\n                  actions: \"defer event\"\n                },\n                mutation: {\n                  actions: \"defer event\"\n                }\n              }\n            }\n          }\n        },\n        dirty: {\n          entry: [\"emit pending events\", \"clear pending events\"],\n          on: {\n            \"internal.patch\": {\n              actions: \"emit patch event\"\n            },\n            mutation: {\n              actions: \"emit mutation event\"\n            }\n          }\n        }\n      }\n    }\n  }\n});\nfunction getValue({\n  editorActorSnapshot,\n  slateEditorInstance\n}) {\n  return fromSlateValue(slateEditorInstance.children, editorActorSnapshot.context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(slateEditorInstance));\n}\nfunction defaultCompare(a, b) {\n  return a === b;\n}\nfunction useEditorSelector(editor, selector, t0) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__.c)(3), compare = t0 === void 0 ? defaultCompare : t0;\n  let t1;\n  return $[0] !== editor._internal.slateEditor.instance || $[1] !== selector ? (t1 = (editorActorSnapshot) => {\n    const snapshot = getEditorSnapshot({\n      editorActorSnapshot,\n      slateEditorInstance: editor._internal.slateEditor.instance\n    });\n    return selector(snapshot);\n  }, $[0] = editor._internal.slateEditor.instance, $[1] = selector, $[2] = t1) : t1 = $[2], (0,_xstate_react__WEBPACK_IMPORTED_MODULE_22__.useSelector)(editor._internal.editorActor, t1, compare);\n}\nfunction getEditorSnapshot({\n  editorActorSnapshot,\n  slateEditorInstance\n}) {\n  return {\n    context: {\n      converters: [...editorActorSnapshot.context.converters],\n      activeDecorators: getActiveDecorators({\n        schema: editorActorSnapshot.context.schema,\n        slateEditorInstance\n      }),\n      keyGenerator: editorActorSnapshot.context.keyGenerator,\n      schema: editorActorSnapshot.context.schema,\n      selection: editorActorSnapshot.context.selection,\n      value: getValue({\n        editorActorSnapshot,\n        slateEditorInstance\n      })\n    },\n    beta: {\n      hasTag: (tag) => editorActorSnapshot.hasTag(tag)\n    }\n  };\n}\nfunction createEditor(config) {\n  const editorActor = (0,xstate__WEBPACK_IMPORTED_MODULE_19__.A)(editorMachine, {\n    input: editorConfigToMachineInput(config)\n  });\n  return editorActor.start(), createEditorFromActor(editorActor);\n}\nfunction useCreateEditor(config) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__.c)(6);\n  let t0;\n  $[0] !== config ? (t0 = editorConfigToMachineInput(config), $[0] = config, $[1] = t0) : t0 = $[1];\n  let t1;\n  $[2] !== t0 ? (t1 = {\n    input: t0\n  }, $[2] = t0, $[3] = t1) : t1 = $[3];\n  const editorActor = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_22__.useActorRef)(editorMachine, t1);\n  let t2, t3;\n  return $[4] !== editorActor ? (t3 = createEditorFromActor(editorActor), $[4] = editorActor, $[5] = t3) : t3 = $[5], t2 = t3, t2;\n}\nfunction editorConfigToMachineInput(config) {\n  return {\n    behaviors: config.behaviors,\n    converters: coreConverters,\n    keyGenerator: config.keyGenerator ?? defaultKeyGenerator,\n    maxBlocks: config.maxBlocks,\n    readOnly: config.readOnly,\n    schema: config.schemaDefinition ? compileSchemaDefinition(config.schemaDefinition) : createEditorSchema(config.schema.hasOwnProperty(\"jsonType\") ? config.schema : compileType(config.schema)),\n    value: config.initialValue\n  };\n}\nfunction createEditorFromActor(editorActor) {\n  const slateEditor = createSlateEditor({\n    editorActor\n  }), editable = createEditableAPI(slateEditor.instance, editorActor);\n  return {\n    getSnapshot: () => getEditorSnapshot({\n      editorActorSnapshot: editorActor.getSnapshot(),\n      slateEditorInstance: slateEditor.instance\n    }),\n    registerBehavior: (config) => (editorActor.send({\n      type: \"add behavior\",\n      behavior: config.behavior\n    }), () => {\n      editorActor.send({\n        type: \"remove behavior\",\n        behavior: config.behavior\n      });\n    }),\n    send: (event) => {\n      editorActor.send(event);\n    },\n    on: (event, listener) => editorActor.on(event, (event2) => {\n      switch (event2.type) {\n        case \"blurred\":\n        case \"done loading\":\n        case \"editable\":\n        case \"error\":\n        case \"focused\":\n        case \"invalid value\":\n        case \"loading\":\n        case \"mutation\":\n        case \"patch\":\n        case \"read only\":\n        case \"ready\":\n        case \"selection\":\n        case \"value changed\":\n          listener(event2);\n          break;\n      }\n    }),\n    _internal: {\n      editable,\n      editorActor,\n      slateEditor\n    }\n  };\n}\nconst EditorActorContext = (0,react__WEBPACK_IMPORTED_MODULE_2__.createContext)({}), PortableTextEditorSelectionContext = (0,react__WEBPACK_IMPORTED_MODULE_2__.createContext)(null), usePortableTextEditorSelection = () => {\n  const selection = (0,react__WEBPACK_IMPORTED_MODULE_2__.useContext)(PortableTextEditorSelectionContext);\n  if (selection === void 0)\n    throw new Error(\"The `usePortableTextEditorSelection` hook must be used inside the <PortableTextEditor> component's context.\");\n  return selection;\n}, debug$1 = debugWithName(\"component:PortableTextEditor:SelectionProvider\");\nfunction PortableTextEditorSelectionProvider(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__.c)(6), [selection, setSelection] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n  let t0, t1;\n  $[0] !== props.editorActor ? (t0 = () => {\n    debug$1(\"Subscribing to selection changes\");\n    const subscription = props.editorActor.on(\"selection\", (event) => {\n      (0,react__WEBPACK_IMPORTED_MODULE_2__.startTransition)(() => {\n        setSelection(event.selection);\n      });\n    });\n    return () => {\n      debug$1(\"Unsubscribing to selection changes\"), subscription.unsubscribe();\n    };\n  }, t1 = [props.editorActor], $[0] = props.editorActor, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(t0, t1);\n  let t2;\n  return $[3] !== props.children || $[4] !== selection ? (t2 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PortableTextEditorSelectionContext.Provider, { value: selection, children: props.children }), $[3] = props.children, $[4] = selection, $[5] = t2) : t2 = $[5], t2;\n}\nconst debug = debugWithName(\"component:PortableTextEditor\");\nclass PortableTextEditor extends react__WEBPACK_IMPORTED_MODULE_2__.Component {\n  static displayName = \"PortableTextEditor\";\n  /**\n   * An observable of all the editor changes.\n   */\n  change$ = new rxjs__WEBPACK_IMPORTED_MODULE_31__.Subject();\n  /**\n   * A lookup table for all the relevant schema types for this portable text type.\n   */\n  /**\n   * The editor instance\n   */\n  /*\n   * The editor API (currently implemented with Slate).\n   */\n  constructor(props) {\n    super(props), props.editor ? this.editor = props.editor : this.editor = createEditor({\n      keyGenerator: props.keyGenerator ?? defaultKeyGenerator,\n      schema: props.schemaType,\n      initialValue: props.value,\n      maxBlocks: props.maxBlocks === void 0 ? void 0 : Number.parseInt(props.maxBlocks.toString(), 10),\n      readOnly: props.readOnly\n    }), this.schemaTypes = this.editor._internal.editorActor.getSnapshot().context.schema, this.editable = this.editor._internal.editable;\n  }\n  componentDidUpdate(prevProps) {\n    !this.props.editor && !prevProps.editor && this.props.schemaType !== prevProps.schemaType && (this.schemaTypes = createEditorSchema(this.props.schemaType.hasOwnProperty(\"jsonType\") ? this.props.schemaType : compileType(this.props.schemaType)), this.editor._internal.editorActor.send({\n      type: \"update schema\",\n      schema: this.schemaTypes\n    })), !this.props.editor && !prevProps.editor && (this.props.readOnly !== prevProps.readOnly && this.editor._internal.editorActor.send({\n      type: \"update readOnly\",\n      readOnly: this.props.readOnly ?? !1\n    }), this.props.maxBlocks !== prevProps.maxBlocks && this.editor._internal.editorActor.send({\n      type: \"update maxBlocks\",\n      maxBlocks: this.props.maxBlocks === void 0 ? void 0 : Number.parseInt(this.props.maxBlocks.toString(), 10)\n    }), this.props.value !== prevProps.value && this.editor._internal.editorActor.send({\n      type: \"update value\",\n      value: this.props.value\n    }), this.props.editorRef !== prevProps.editorRef && this.props.editorRef && (this.props.editorRef.current = this));\n  }\n  setEditable = (editable) => {\n    this.editor._internal.editable = {\n      ...this.editor._internal.editable,\n      ...editable\n    };\n  };\n  render() {\n    const legacyPatches = this.props.editor ? void 0 : this.props.incomingPatches$ ?? this.props.patches$;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [\n      legacyPatches ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(RoutePatchesObservableToEditorActor, { editorActor: this.editor._internal.editorActor, patches$: legacyPatches }) : null,\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(RouteEventsToChanges, { editorActor: this.editor._internal.editorActor, onChange: (change) => {\n        this.props.editor || this.props.onChange(change), this.change$.next(change);\n      } }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Synchronizer, { editorActor: this.editor._internal.editorActor, slateEditor: this.editor._internal.slateEditor.instance }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EditorActorContext.Provider, { value: this.editor._internal.editorActor, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(slate_react__WEBPACK_IMPORTED_MODULE_29__.Slate, { editor: this.editor._internal.slateEditor.instance, initialValue: this.editor._internal.slateEditor.initialValue, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PortableTextEditorContext.Provider, { value: this, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PortableTextEditorSelectionProvider, { editorActor: this.editor._internal.editorActor, children: this.props.children }) }) }) })\n    ] });\n  }\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.getActiveAnnotations)\n   * ```\n   */\n  static activeAnnotations = (editor) => editor && editor.editable ? editor.editable.activeAnnotations() : [];\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.isActiveAnnotation(...))\n   * ```\n   */\n  static isAnnotationActive = (editor, annotationType) => editor && editor.editable ? editor.editable.isAnnotationActive(annotationType) : !1;\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'annotation.add',\n   *  annotation: {\n   *    name: '...',\n   *    value: {...},\n   *  }\n   * })\n   * ```\n   */\n  static addAnnotation = (editor, type, value) => editor.editable?.addAnnotation(type, value);\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'blur',\n   * })\n   * ```\n   */\n  static blur = (editor) => {\n    debug(\"Host blurred\"), editor.editable?.blur();\n  };\n  static delete = (editor, selection, options) => editor.editable?.delete(selection, options);\n  static findDOMNode = (editor, element) => editor.editable?.findDOMNode(element);\n  static findByPath = (editor, path) => editor.editable?.findByPath(path) || [];\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'focus',\n   * })\n   * ```\n   */\n  static focus = (editor) => {\n    debug(\"Host requesting focus\"), editor.editable?.focus();\n  };\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const focusBlock = useEditorSelector(editor, selectors.getFocusBlock)\n   * ```\n   */\n  static focusBlock = (editor) => editor.editable?.focusBlock();\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const focusChild = useEditorSelector(editor, selectors.getFocusChild)\n   * ```\n   */\n  static focusChild = (editor) => editor.editable?.focusChild();\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const selection = useEditorSelector(editor, selectors.getSelection)\n   * ```\n   */\n  static getSelection = (editor) => editor.editable ? editor.editable.getSelection() : null;\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const value = useEditorSelector(editor, selectors.getValue)\n   * ```\n   */\n  static getValue = (editor) => editor.editable?.getValue();\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.isActiveStyle(...))\n   * ```\n   */\n  static hasBlockStyle = (editor, blockStyle) => editor.editable?.hasBlockStyle(blockStyle);\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.isActiveListItem(...))\n   * ```\n   */\n  static hasListStyle = (editor, listStyle) => editor.editable?.hasListStyle(listStyle);\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isSelectionCollapsed = useEditorSelector(editor, selectors.isSelectionCollapsed)\n   * ```\n   */\n  static isCollapsedSelection = (editor) => editor.editable?.isCollapsedSelection();\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isSelectionExpanded = useEditorSelector(editor, selectors.isSelectionExpanded)\n   * ```\n   */\n  static isExpandedSelection = (editor) => editor.editable?.isExpandedSelection();\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.isActiveDecorator(...))\n   * ```\n   */\n  static isMarkActive = (editor, mark) => editor.editable?.isMarkActive(mark);\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'insert.span',\n   *  text: '...',\n   *  annotations: [{name: '...', value: {...}}],\n   *  decorators: ['...'],\n   * })\n   * editor.send({\n   *  type: 'insert.inline object',\n   *  inlineObject: {\n   *    name: '...',\n   *    value: {...},\n   *  },\n   * })\n   * ```\n   */\n  static insertChild = (editor, type, value) => (debug(\"Host inserting child\"), editor.editable?.insertChild(type, value));\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'insert.block object',\n   *  blockObject: {\n   *    name: '...',\n   *    value: {...},\n   *  },\n   *  placement: 'auto' | 'after' | 'before',\n   * })\n   * ```\n   */\n  static insertBlock = (editor, type, value) => editor.editable?.insertBlock(type, value);\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'insert.break',\n   * })\n   * ```\n   */\n  static insertBreak = (editor) => editor.editable?.insertBreak();\n  static isVoid = (editor, element) => editor.editable?.isVoid(element);\n  static isObjectPath = (_editor, path) => {\n    if (!path || !Array.isArray(path)) return !1;\n    const isChildObjectEditPath = path.length > 3 && path[1] === \"children\";\n    return path.length > 1 && path[1] !== \"children\" || isChildObjectEditPath;\n  };\n  static marks = (editor) => editor.editable?.marks();\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'select',\n   *  selection: {...},\n   * })\n   * ```\n   */\n  static select = (editor, selection) => {\n    debug(\"Host setting selection\", selection), editor.editable?.select(selection);\n  };\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'annotation.remove',\n   *  annotation: {\n   *    name: '...',\n   *  },\n   * })\n   * ```\n   */\n  static removeAnnotation = (editor, type) => editor.editable?.removeAnnotation(type);\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'style.toggle',\n   *  style: '...',\n   * })\n   * ```\n   */\n  static toggleBlockStyle = (editor, blockStyle) => (debug(\"Host is toggling block style\"), editor.editable?.toggleBlockStyle(blockStyle));\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'list item.toggle',\n   *  listItem: '...',\n   * })\n   * ```\n   */\n  static toggleList = (editor, listStyle) => editor.editable?.toggleList(listStyle);\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'decorator.toggle',\n   *  decorator: '...',\n   * })\n   * ```\n   */\n  static toggleMark = (editor, mark) => {\n    debug(\"Host toggling mark\", mark), editor.editable?.toggleMark(mark);\n  };\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const selectedSlice = useEditorSelector(editor, selectors.getSelectedSlice)\n   * ```\n   */\n  static getFragment = (editor) => editor.editable?.getFragment();\n  static undo = (editor) => {\n    debug(\"Host undoing\"), editor.editable?.undo();\n  };\n  static redo = (editor) => {\n    debug(\"Host redoing\"), editor.editable?.redo();\n  };\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isOverlapping = useEditorSelector(editor, selectors.isOverlappingSelection(selectionB))\n   * ```\n   */\n  static isSelectionsOverlapping = (editor, selectionA, selectionB) => editor.editable?.isSelectionsOverlapping(selectionA, selectionB);\n}\nfunction RoutePatchesObservableToEditorActor(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__.c)(4);\n  let t0, t1;\n  return $[0] !== props.editorActor || $[1] !== props.patches$ ? (t0 = () => {\n    const subscription = props.patches$.subscribe((payload) => {\n      props.editorActor.send({\n        type: \"patches\",\n        ...payload\n      });\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, t1 = [props.editorActor, props.patches$], $[0] = props.editorActor, $[1] = props.patches$, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(t0, t1), null;\n}\nfunction RouteEventsToChanges(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__.c)(7);\n  let t0;\n  $[0] !== props ? (t0 = (change) => props.onChange(change), $[0] = props, $[1] = t0) : t0 = $[1];\n  const handleChange = (0,use_effect_event__WEBPACK_IMPORTED_MODULE_32__.useEffectEvent)(t0);\n  let t1;\n  $[2] !== handleChange || $[3] !== props.editorActor ? (t1 = () => {\n    debug(\"Subscribing to editor changes\");\n    const sub = props.editorActor.on(\"*\", (event) => {\n      bb5: switch (event.type) {\n        case \"blurred\": {\n          handleChange({\n            type: \"blur\",\n            event: event.event\n          });\n          break bb5;\n        }\n        case \"patch\": {\n          handleChange(event);\n          break bb5;\n        }\n        case \"loading\": {\n          handleChange({\n            type: \"loading\",\n            isLoading: !0\n          });\n          break bb5;\n        }\n        case \"done loading\": {\n          handleChange({\n            type: \"loading\",\n            isLoading: !1\n          });\n          break bb5;\n        }\n        case \"focused\": {\n          handleChange({\n            type: \"focus\",\n            event: event.event\n          });\n          break bb5;\n        }\n        case \"value changed\": {\n          handleChange({\n            type: \"value\",\n            value: event.value\n          });\n          break bb5;\n        }\n        case \"invalid value\": {\n          handleChange({\n            type: \"invalidValue\",\n            resolution: event.resolution,\n            value: event.value\n          });\n          break bb5;\n        }\n        case \"error\": {\n          handleChange({\n            ...event,\n            level: \"warning\"\n          });\n          break bb5;\n        }\n        case \"mutation\": {\n          handleChange(event);\n          break bb5;\n        }\n        case \"ready\": {\n          handleChange(event);\n          break bb5;\n        }\n        case \"selection\": {\n          handleChange(event);\n          break bb5;\n        }\n        case \"unset\":\n          handleChange(event);\n      }\n    });\n    return () => {\n      debug(\"Unsubscribing to changes\"), sub.unsubscribe();\n    };\n  }, $[2] = handleChange, $[3] = props.editorActor, $[4] = t1) : t1 = $[4];\n  let t2;\n  return $[5] !== props.editorActor ? (t2 = [props.editorActor], $[5] = props.editorActor, $[6] = t2) : t2 = $[6], (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(t1, t2), null;\n}\nconst EditorContext = react__WEBPACK_IMPORTED_MODULE_2__.createContext(void 0);\nfunction EditorProvider(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__.c)(28), editor = useCreateEditor(props.initialConfig), editorActor = editor._internal.editorActor, slateEditor = editor._internal.slateEditor;\n  let t0, t1;\n  $[0] !== editor ? (t1 = new PortableTextEditor({\n    editor\n  }), $[0] = editor, $[1] = t1) : t1 = $[1], t0 = t1;\n  const portableTextEditor = t0;\n  let t2;\n  $[2] !== portableTextEditor.change$ ? (t2 = (change) => {\n    portableTextEditor.change$.next(change);\n  }, $[2] = portableTextEditor.change$, $[3] = t2) : t2 = $[3];\n  let t3;\n  $[4] !== editorActor || $[5] !== t2 ? (t3 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(RouteEventsToChanges, { editorActor, onChange: t2 }), $[4] = editorActor, $[5] = t2, $[6] = t3) : t3 = $[6];\n  let t4;\n  $[7] !== editorActor || $[8] !== slateEditor.instance ? (t4 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Synchronizer, { editorActor, slateEditor: slateEditor.instance }), $[7] = editorActor, $[8] = slateEditor.instance, $[9] = t4) : t4 = $[9];\n  let t5;\n  $[10] !== editorActor || $[11] !== props.children ? (t5 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PortableTextEditorSelectionProvider, { editorActor, children: props.children }), $[10] = editorActor, $[11] = props.children, $[12] = t5) : t5 = $[12];\n  let t6;\n  $[13] !== portableTextEditor || $[14] !== t5 ? (t6 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PortableTextEditorContext.Provider, { value: portableTextEditor, children: t5 }), $[13] = portableTextEditor, $[14] = t5, $[15] = t6) : t6 = $[15];\n  let t7;\n  $[16] !== slateEditor.initialValue || $[17] !== slateEditor.instance || $[18] !== t6 ? (t7 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(slate_react__WEBPACK_IMPORTED_MODULE_29__.Slate, { editor: slateEditor.instance, initialValue: slateEditor.initialValue, children: t6 }), $[16] = slateEditor.initialValue, $[17] = slateEditor.instance, $[18] = t6, $[19] = t7) : t7 = $[19];\n  let t8;\n  $[20] !== editorActor || $[21] !== t7 ? (t8 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EditorActorContext.Provider, { value: editorActor, children: t7 }), $[20] = editorActor, $[21] = t7, $[22] = t8) : t8 = $[22];\n  let t9;\n  return $[23] !== editor || $[24] !== t3 || $[25] !== t4 || $[26] !== t8 ? (t9 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(EditorContext.Provider, { value: editor, children: [\n    t3,\n    t4,\n    t8\n  ] }), $[23] = editor, $[24] = t3, $[25] = t4, $[26] = t8, $[27] = t9) : t9 = $[27], t9;\n}\nfunction useEditor() {\n  const editor = react__WEBPACK_IMPORTED_MODULE_2__.useContext(EditorContext);\n  if (!editor)\n    throw new Error(\"No Editor set. Use EditorProvider to set one.\");\n  return editor;\n}\n\n//# sourceMappingURL=editor-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvZWRpdG9yLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3RDtBQUNiO0FBQytEO0FBQzlDO0FBQ0g7QUFDN0I7QUFDWTtBQUMwSTtBQUMxRDtBQUNEO0FBQzZDO0FBQzVIO0FBQ1k7QUFDbEI7QUFDa0I7QUFDb0Q7QUFDZTtBQUM5RDtBQUNWO0FBQ1A7QUFDUjtBQUNnQjtBQUNWO0FBQ2dDO0FBQ3NFO0FBQzFHO0FBQ087QUFDd0Q7QUFDbEU7QUFDbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsaUNBQWlDO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSwwREFBVTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDJFQUEyRSwwREFBVTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsK0JBQStCLDJEQUFXO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxvQ0FBb0MsOENBQVM7QUFDN0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FB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Q0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQ0FBc0MsaUJBQWlCLHFCQUFxQixjQUFjO0FBQzFGLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCLEtBQUs7QUFDL0M7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBSTtBQUNwQixPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQUk7QUFDcEIsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLElBQUk7QUFDdEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQUM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNklBQTZJLGdEQUFTO0FBQ3pKO0FBQ0E7QUFDQSxZQUFZLHlEQUFDO0FBQ2I7QUFDQTtBQUNBLHVCQUF1QixpRUFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsbUhBQW1ILGdEQUFTO0FBQzVIO0FBQ0Esc0JBQXNCLGdEQUFtQjtBQUN6QztBQUNBLFlBQVkseURBQUM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw4REFBOEQsc0RBQUcseUJBQXlCLDJCQUEyQjtBQUNySDtBQUNBLGdGQUFnRixzREFBRyxpQkFBaUIsZ0RBQWdEO0FBQ3BKO0FBQ0EsNEVBQTRFLHNEQUFHLHdDQUF3Qyx1Q0FBdUM7QUFDOUo7QUFDQSx1RUFBdUUsc0RBQUcsdUNBQXVDLHlDQUF5QztBQUMxSjtBQUNBLCtHQUErRyxzREFBRyxDQUFDLCtDQUFLLElBQUksb0ZBQW9GO0FBQ2hOO0FBQ0EsZ0VBQWdFLHNEQUFHLGdDQUFnQyxrQ0FBa0M7QUFDckk7QUFDQSxrR0FBa0csdURBQUksMkJBQTJCO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCLDZDQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQXVCRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbWFjYm9va3Byby9Eb3dubG9hZHMvY29uaWNhcHBzL2lnZW5lL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvX2NodW5rcy1lcy9lZGl0b3ItcHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4LCBqc3hzLCBGcmFnbWVudCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgYyB9IGZyb20gXCJyZWFjdC1jb21waWxlci1ydW50aW1lXCI7XG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgc3RhcnRUcmFuc2l0aW9uLCBDb21wb25lbnQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFJlYWN0RWRpdG9yLCB3aXRoUmVhY3QsIFNsYXRlIH0gZnJvbSBcInNsYXRlLXJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTZWxlY3RvciwgdXNlQWN0b3JSZWYgfSBmcm9tIFwiQHhzdGF0ZS9yZWFjdFwiO1xuaW1wb3J0IGRlYnVnJGUgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgaXNFcXVhbCBmcm9tIFwibG9kYXNoL2lzRXF1YWwuanNcIjtcbmltcG9ydCB7IEVkaXRvciwgRWxlbWVudCwgUmFuZ2UsIFBvaW50LCBUZXh0LCBPcGVyYXRpb24sIFRyYW5zZm9ybXMsIFBhdGgsIE5vZGUsIGluc2VydFRleHQsIHNlbGVjdCwgZGVsZXRlRnJhZ21lbnQsIGRlbGV0ZUZvcndhcmQsIGNyZWF0ZUVkaXRvciBhcyBjcmVhdGVFZGl0b3IkMSB9IGZyb20gXCJzbGF0ZVwiO1xuaW1wb3J0IHsgc2V0dXAsIGVtaXQsIGVucXVldWVBY3Rpb25zLCBhc3NpZ24sIGFzc2VydEV2ZW50LCBmcm9tQ2FsbGJhY2ssIHN0YXRlSW4sIGFuZCwgbm90LCBjcmVhdGVBY3RvciB9IGZyb20gXCJ4c3RhdGVcIjtcbmltcG9ydCB7IHVuc2V0LCBzZXQsIHNldElmTWlzc2luZywgaW5zZXJ0LCBkaWZmTWF0Y2hQYXRjaCBhcyBkaWZmTWF0Y2hQYXRjaCQxLCBhcHBseUFsbCB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3BhdGNoZXNcIjtcbmltcG9ydCB7IGRlZmluZVR5cGUsIGRlZmluZUZpZWxkLCBpc0tleVNlZ21lbnQsIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrLCBpc1BvcnRhYmxlVGV4dFNwYW4gYXMgaXNQb3J0YWJsZVRleHRTcGFuJDEsIGlzUG9ydGFibGVUZXh0TGlzdEJsb2NrIH0gZnJvbSBcIkBzYW5pdHkvdHlwZXNcIjtcbmltcG9ydCBmbGF0dGVuIGZyb20gXCJsb2Rhc2gvZmxhdHRlbi5qc1wiO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSBcImxvZGFzaC9pc1BsYWluT2JqZWN0LmpzXCI7XG5pbXBvcnQgdW5pcSBmcm9tIFwibG9kYXNoL3VuaXEuanNcIjtcbmltcG9ydCBnZXRSYW5kb21WYWx1ZXMgZnJvbSBcImdldC1yYW5kb20tdmFsdWVzLWVzbVwiO1xuaW1wb3J0IHsgcGFyc2VCbG9jaywgYmxvY2tPZmZzZXRzVG9TZWxlY3Rpb24sIGlzVGV4dEJsb2NrIH0gZnJvbSBcIi4vdXRpbC5ibG9jay1vZmZzZXRzLXRvLXNlbGVjdGlvbi5qc1wiO1xuaW1wb3J0IHsgc2xpY2VCbG9ja3MsIGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQsIHNwYW5TZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQgfSBmcm9tIFwiLi91dGlsLnNsaWNlLWJsb2Nrcy5qc1wiO1xuaW1wb3J0IHsgaHRtbFRvQmxvY2tzIH0gZnJvbSBcIkBwb3J0YWJsZXRleHQvYmxvY2stdG9vbHNcIjtcbmltcG9ydCB7IHRvSFRNTCB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3RvLWh0bWxcIjtcbmltcG9ydCB7IFNjaGVtYSB9IGZyb20gXCJAc2FuaXR5L3NjaGVtYVwiO1xuaW1wb3J0IGdldCBmcm9tIFwibG9kYXNoL2dldC5qc1wiO1xuaW1wb3J0IGlzVW5kZWZpbmVkIGZyb20gXCJsb2Rhc2gvaXNVbmRlZmluZWQuanNcIjtcbmltcG9ydCBvbWl0QnkgZnJvbSBcImxvZGFzaC9vbWl0QnkuanNcIjtcbmltcG9ydCB7IGNyZWF0ZUd1YXJkcyB9IGZyb20gXCIuL3NlbGVjdG9yLmlzLWF0LXRoZS1zdGFydC1vZi1ibG9jay5qc1wiO1xuaW1wb3J0IHsgZ2V0VHJpbW1lZFNlbGVjdGlvbiwgaXNBY3RpdmVBbm5vdGF0aW9uLCBpc0FjdGl2ZURlY29yYXRvciwgaXNBY3RpdmVMaXN0SXRlbSwgaXNBY3RpdmVTdHlsZSB9IGZyb20gXCIuL3NlbGVjdG9yLmlzLWFjdGl2ZS1zdHlsZS5qc1wiO1xuaW1wb3J0IG9taXQgZnJvbSBcImxvZGFzaC9vbWl0LmpzXCI7XG5pbXBvcnQgc3RhcnRDYXNlIGZyb20gXCJsb2Rhc2guc3RhcnRjYXNlXCI7XG5pbXBvcnQgeyBkZWZpbmVCZWhhdmlvciwgcmFpc2UsIGNvcmVCZWhhdmlvcnMsIGlzQ3VzdG9tQmVoYXZpb3JFdmVudCB9IGZyb20gXCIuL2JlaGF2aW9yLmNvcmUuanNcIjtcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tIFwicnhqc1wiO1xuaW1wb3J0IHsgdXNlRWZmZWN0RXZlbnQgfSBmcm9tIFwidXNlLWVmZmVjdC1ldmVudFwiO1xuZnVuY3Rpb24gY3JlYXRlRWRpdG9yU2NoZW1hKHBvcnRhYmxlVGV4dFR5cGUpIHtcbiAgaWYgKCFwb3J0YWJsZVRleHRUeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciAncG9ydGFibGV0ZXh0VHlwZScgbWlzc2luZyAocmVxdWlyZWQpXCIpO1xuICBjb25zdCBibG9ja1R5cGUgPSBwb3J0YWJsZVRleHRUeXBlLm9mPy5maW5kKGZpbmRCbG9ja1R5cGUpO1xuICBpZiAoIWJsb2NrVHlwZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCbG9jayB0eXBlIGlzIG5vdCBkZWZpbmVkIGluIHRoaXMgc2NoZW1hIChyZXF1aXJlZClcIik7XG4gIGNvbnN0IGNoaWxkcmVuRmllbGQgPSBibG9ja1R5cGUuZmllbGRzPy5maW5kKChmaWVsZCkgPT4gZmllbGQubmFtZSA9PT0gXCJjaGlsZHJlblwiKTtcbiAgaWYgKCFjaGlsZHJlbkZpZWxkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNoaWxkcmVuIGZpZWxkIGZvciBibG9jayB0eXBlIGZvdW5kIGluIHNjaGVtYSAocmVxdWlyZWQpXCIpO1xuICBjb25zdCBvZlR5cGUgPSBjaGlsZHJlbkZpZWxkLnR5cGUub2Y7XG4gIGlmICghb2ZUeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkIHR5cGVzIGZvciBibG9jayBjaGlsZHJlbiBub3QgZm91bmQgaW4gc2NoZW1hIChyZXF1aXJlZClcIik7XG4gIGNvbnN0IHNwYW5UeXBlID0gb2ZUeXBlLmZpbmQoKG1lbWJlclR5cGUpID0+IG1lbWJlclR5cGUubmFtZSA9PT0gXCJzcGFuXCIpO1xuICBpZiAoIXNwYW5UeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNwYW4gdHlwZSBub3QgZm91bmQgaW4gc2NoZW1hIChyZXF1aXJlZClcIik7XG4gIGNvbnN0IGlubGluZU9iamVjdFR5cGVzID0gb2ZUeXBlLmZpbHRlcigobWVtYmVyVHlwZSkgPT4gbWVtYmVyVHlwZS5uYW1lICE9PSBcInNwYW5cIikgfHwgW10sIGJsb2NrT2JqZWN0VHlwZXMgPSBwb3J0YWJsZVRleHRUeXBlLm9mPy5maWx0ZXIoKGZpZWxkKSA9PiBmaWVsZC5uYW1lICE9PSBibG9ja1R5cGUubmFtZSkgfHwgW107XG4gIHJldHVybiB7XG4gICAgc3R5bGVzOiByZXNvbHZlRW5hYmxlZFN0eWxlcyhibG9ja1R5cGUpLFxuICAgIGRlY29yYXRvcnM6IHJlc29sdmVFbmFibGVkRGVjb3JhdG9ycyhzcGFuVHlwZSksXG4gICAgbGlzdHM6IHJlc29sdmVFbmFibGVkTGlzdEl0ZW1zKGJsb2NrVHlwZSksXG4gICAgYmxvY2s6IGJsb2NrVHlwZSxcbiAgICBzcGFuOiBzcGFuVHlwZSxcbiAgICBwb3J0YWJsZVRleHQ6IHBvcnRhYmxlVGV4dFR5cGUsXG4gICAgaW5saW5lT2JqZWN0czogaW5saW5lT2JqZWN0VHlwZXMsXG4gICAgYmxvY2tPYmplY3RzOiBibG9ja09iamVjdFR5cGVzLFxuICAgIGFubm90YXRpb25zOiBzcGFuVHlwZS5hbm5vdGF0aW9uc1xuICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuYWJsZWRTdHlsZXMoYmxvY2tUeXBlKSB7XG4gIGNvbnN0IHN0eWxlRmllbGQgPSBibG9ja1R5cGUuZmllbGRzPy5maW5kKChidEZpZWxkKSA9PiBidEZpZWxkLm5hbWUgPT09IFwic3R5bGVcIik7XG4gIGlmICghc3R5bGVGaWVsZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGZpZWxkIHdpdGggbmFtZSAnc3R5bGUnIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBibG9jayB0eXBlIChyZXF1aXJlZCkuXCIpO1xuICBjb25zdCB0ZXh0U3R5bGVzID0gc3R5bGVGaWVsZC50eXBlLm9wdGlvbnM/Lmxpc3QgJiYgc3R5bGVGaWVsZC50eXBlLm9wdGlvbnMubGlzdD8uZmlsdGVyKChzdHlsZSkgPT4gc3R5bGUudmFsdWUpO1xuICBpZiAoIXRleHRTdHlsZXMgfHwgdGV4dFN0eWxlcy5sZW5ndGggPT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlIGZpZWxkcyBuZWVkIGF0IGxlYXN0IG9uZSBzdHlsZSBkZWZpbmVkLiBJLmU6IHt0aXRsZTogJ05vcm1hbCcsIHZhbHVlOiAnbm9ybWFsJ30uXCIpO1xuICByZXR1cm4gdGV4dFN0eWxlcztcbn1cbmZ1bmN0aW9uIHJlc29sdmVFbmFibGVkRGVjb3JhdG9ycyhzcGFuVHlwZSkge1xuICByZXR1cm4gc3BhblR5cGUuZGVjb3JhdG9ycztcbn1cbmZ1bmN0aW9uIHJlc29sdmVFbmFibGVkTGlzdEl0ZW1zKGJsb2NrVHlwZSkge1xuICBjb25zdCBsaXN0RmllbGQgPSBibG9ja1R5cGUuZmllbGRzPy5maW5kKChidEZpZWxkKSA9PiBidEZpZWxkLm5hbWUgPT09IFwibGlzdEl0ZW1cIik7XG4gIGlmICghbGlzdEZpZWxkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkEgZmllbGQgd2l0aCBuYW1lICdsaXN0SXRlbScgaXMgbm90IGRlZmluZWQgaW4gdGhlIGJsb2NrIHR5cGUgKHJlcXVpcmVkKS5cIik7XG4gIGNvbnN0IGxpc3RJdGVtcyA9IGxpc3RGaWVsZC50eXBlLm9wdGlvbnM/Lmxpc3QgJiYgbGlzdEZpZWxkLnR5cGUub3B0aW9ucy5saXN0LmZpbHRlcigobGlzdCkgPT4gbGlzdC52YWx1ZSk7XG4gIGlmICghbGlzdEl0ZW1zKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBsaXN0IGZpZWxkIG5lZWQgYXQgbGVhc3QgdG8gYmUgYW4gZW1wdHkgYXJyYXlcIik7XG4gIHJldHVybiBsaXN0SXRlbXM7XG59XG5mdW5jdGlvbiBmaW5kQmxvY2tUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUudHlwZSA/IGZpbmRCbG9ja1R5cGUodHlwZS50eXBlKSA6IHR5cGUubmFtZSA9PT0gXCJibG9ja1wiID8gdHlwZSA6IG51bGw7XG59XG5mdW5jdGlvbiBkZWZpbmVTY2hlbWEoZGVmaW5pdGlvbikge1xuICByZXR1cm4gZGVmaW5pdGlvbjtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVTY2hlbWFEZWZpbml0aW9uKGRlZmluaXRpb24pIHtcbiAgY29uc3QgYmxvY2tPYmplY3RzID0gZGVmaW5pdGlvbj8uYmxvY2tPYmplY3RzPy5tYXAoKGJsb2NrT2JqZWN0KSA9PiBkZWZpbmVUeXBlKHtcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIC8vIFZlcnkgbmFpdmUgd2F5IHRvIHdvcmsgYXJvdW5kIGBTYW5pdHlTY2hlbWEuY29tcGlsZWAgYWRkaW5nIGRlZmF1bHRcbiAgICAvLyBmaWVsZHMgdG8gb2JqZWN0cyB3aXRoIHRoZSBuYW1lIGBpbWFnZWBcbiAgICBuYW1lOiBibG9ja09iamVjdC5uYW1lID09PSBcImltYWdlXCIgPyBcInRtcC1pbWFnZVwiIDogYmxvY2tPYmplY3QubmFtZSxcbiAgICB0aXRsZTogYmxvY2tPYmplY3QubmFtZSA9PT0gXCJpbWFnZVwiICYmIGJsb2NrT2JqZWN0LnRpdGxlID09PSB2b2lkIDAgPyBcIkltYWdlXCIgOiBibG9ja09iamVjdC50aXRsZSxcbiAgICBmaWVsZHM6IFtdXG4gIH0pKSA/PyBbXSwgaW5saW5lT2JqZWN0cyA9IGRlZmluaXRpb24/LmlubGluZU9iamVjdHM/Lm1hcCgoaW5saW5lT2JqZWN0KSA9PiBkZWZpbmVUeXBlKHtcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIG5hbWU6IGlubGluZU9iamVjdC5uYW1lLFxuICAgIHRpdGxlOiBpbmxpbmVPYmplY3QudGl0bGUsXG4gICAgZmllbGRzOiBbXVxuICB9KSkgPz8gW10sIHBvcnRhYmxlVGV4dFNjaGVtYSA9IGRlZmluZUZpZWxkKHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgbmFtZTogXCJwb3J0YWJsZS10ZXh0XCIsXG4gICAgb2Y6IFsuLi5ibG9ja09iamVjdHMubWFwKChibG9ja09iamVjdCkgPT4gKHtcbiAgICAgIHR5cGU6IGJsb2NrT2JqZWN0Lm5hbWVcbiAgICB9KSksIHtcbiAgICAgIHR5cGU6IFwiYmxvY2tcIixcbiAgICAgIG5hbWU6IFwiYmxvY2tcIixcbiAgICAgIG9mOiBpbmxpbmVPYmplY3RzLm1hcCgoaW5saW5lT2JqZWN0KSA9PiAoe1xuICAgICAgICB0eXBlOiBpbmxpbmVPYmplY3QubmFtZVxuICAgICAgfSkpLFxuICAgICAgbWFya3M6IHtcbiAgICAgICAgZGVjb3JhdG9yczogZGVmaW5pdGlvbj8uZGVjb3JhdG9ycz8ubWFwKChkZWNvcmF0b3IpID0+ICh7XG4gICAgICAgICAgdGl0bGU6IGRlY29yYXRvci50aXRsZSA/PyBzdGFydENhc2UoZGVjb3JhdG9yLm5hbWUpLFxuICAgICAgICAgIHZhbHVlOiBkZWNvcmF0b3IubmFtZVxuICAgICAgICB9KSkgPz8gW10sXG4gICAgICAgIGFubm90YXRpb25zOiBkZWZpbml0aW9uPy5hbm5vdGF0aW9ucz8ubWFwKChhbm5vdGF0aW9uKSA9PiAoe1xuICAgICAgICAgIG5hbWU6IGFubm90YXRpb24ubmFtZSxcbiAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgIHRpdGxlOiBhbm5vdGF0aW9uLnRpdGxlXG4gICAgICAgIH0pKSA/PyBbXVxuICAgICAgfSxcbiAgICAgIGxpc3RzOiBkZWZpbml0aW9uPy5saXN0cz8ubWFwKChsaXN0KSA9PiAoe1xuICAgICAgICB2YWx1ZTogbGlzdC5uYW1lLFxuICAgICAgICB0aXRsZTogbGlzdC50aXRsZSA/PyBzdGFydENhc2UobGlzdC5uYW1lKVxuICAgICAgfSkpID8/IFtdLFxuICAgICAgc3R5bGVzOiBkZWZpbml0aW9uPy5zdHlsZXM/Lm1hcCgoc3R5bGUpID0+ICh7XG4gICAgICAgIHZhbHVlOiBzdHlsZS5uYW1lLFxuICAgICAgICB0aXRsZTogc3R5bGUudGl0bGUgPz8gc3RhcnRDYXNlKHN0eWxlLm5hbWUpXG4gICAgICB9KSkgPz8gW11cbiAgICB9XVxuICB9KSwgc2NoZW1hID0gU2NoZW1hLmNvbXBpbGUoe1xuICAgIHR5cGVzOiBbcG9ydGFibGVUZXh0U2NoZW1hLCAuLi5ibG9ja09iamVjdHMsIC4uLmlubGluZU9iamVjdHNdXG4gIH0pLmdldChcInBvcnRhYmxlLXRleHRcIiksIHB0ZVNjaGVtYSA9IGNyZWF0ZUVkaXRvclNjaGVtYShzY2hlbWEpO1xuICByZXR1cm4ge1xuICAgIC4uLnB0ZVNjaGVtYSxcbiAgICBibG9ja09iamVjdHM6IHB0ZVNjaGVtYS5ibG9ja09iamVjdHMubWFwKChibG9ja09iamVjdCkgPT4gYmxvY2tPYmplY3QubmFtZSA9PT0gXCJ0bXAtaW1hZ2VcIiA/IHtcbiAgICAgIC4uLmJsb2NrT2JqZWN0LFxuICAgICAgbmFtZTogXCJpbWFnZVwiLFxuICAgICAgdHlwZToge1xuICAgICAgICAuLi5ibG9ja09iamVjdC50eXBlLFxuICAgICAgICBuYW1lOiBcImltYWdlXCJcbiAgICAgIH1cbiAgICB9IDogYmxvY2tPYmplY3QpXG4gIH07XG59XG5jb25zdCByb290TmFtZSA9IFwic2FuaXR5LXB0ZTpcIjtcbmRlYnVnJGUocm9vdE5hbWUpO1xuZnVuY3Rpb24gZGVidWdXaXRoTmFtZShuYW1lKSB7XG4gIGNvbnN0IG5hbWVzcGFjZSA9IGAke3Jvb3ROYW1lfSR7bmFtZX1gO1xuICByZXR1cm4gZGVidWckZSAmJiBkZWJ1ZyRlLmVuYWJsZWQobmFtZXNwYWNlKSA/IGRlYnVnJGUobmFtZXNwYWNlKSA6IGRlYnVnJGUocm9vdE5hbWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlS2V5ZWRQYXRoKHBvaW50LCB2YWx1ZSwgdHlwZXMpIHtcbiAgY29uc3QgYmxvY2tQYXRoID0gW3BvaW50LnBhdGhbMF1dO1xuICBpZiAoIXZhbHVlKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBibG9jayA9IHZhbHVlW2Jsb2NrUGF0aFswXV07XG4gIGlmICghYmxvY2spXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGtleWVkQmxvY2tQYXRoID0gW3tcbiAgICBfa2V5OiBibG9jay5fa2V5XG4gIH1dO1xuICBpZiAoYmxvY2suX3R5cGUgIT09IHR5cGVzLmJsb2NrLm5hbWUpXG4gICAgcmV0dXJuIGtleWVkQmxvY2tQYXRoO1xuICBsZXQga2V5ZWRDaGlsZFBhdGg7XG4gIGNvbnN0IGNoaWxkUGF0aCA9IHBvaW50LnBhdGguc2xpY2UoMCwgMiksIGNoaWxkID0gQXJyYXkuaXNBcnJheShibG9jay5jaGlsZHJlbikgJiYgYmxvY2suY2hpbGRyZW5bY2hpbGRQYXRoWzFdXTtcbiAgcmV0dXJuIGNoaWxkICYmIChrZXllZENoaWxkUGF0aCA9IFtcImNoaWxkcmVuXCIsIHtcbiAgICBfa2V5OiBjaGlsZC5fa2V5XG4gIH1dKSwga2V5ZWRDaGlsZFBhdGggPyBbLi4ua2V5ZWRCbG9ja1BhdGgsIC4uLmtleWVkQ2hpbGRQYXRoXSA6IGtleWVkQmxvY2tQYXRoO1xufVxuZnVuY3Rpb24gdG9TbGF0ZVBhdGgocGF0aCwgZWRpdG9yKSB7XG4gIGlmICghZWRpdG9yKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgYXQ6IFtdLFxuICAgIG1hdGNoOiAobikgPT4gaXNLZXlTZWdtZW50KHBhdGhbMF0pICYmIG4uX2tleSA9PT0gcGF0aFswXS5fa2V5XG4gIH0pKVswXSB8fCBbdm9pZCAwLCB2b2lkIDBdO1xuICBpZiAoIWJsb2NrIHx8ICFFbGVtZW50LmlzRWxlbWVudChibG9jaykpXG4gICAgcmV0dXJuIFtdO1xuICBpZiAoZWRpdG9yLmlzVm9pZChibG9jaykpXG4gICAgcmV0dXJuIFtibG9ja1BhdGhbMF0sIDBdO1xuICBjb25zdCBjaGlsZFBhdGggPSBbcGF0aFsyXV0sIGNoaWxkSW5kZXggPSBibG9jay5jaGlsZHJlbi5maW5kSW5kZXgoKGNoaWxkKSA9PiBpc0VxdWFsKFt7XG4gICAgX2tleTogY2hpbGQuX2tleVxuICB9XSwgY2hpbGRQYXRoKSk7XG4gIGlmIChjaGlsZEluZGV4ID49IDAgJiYgYmxvY2suY2hpbGRyZW5bY2hpbGRJbmRleF0pIHtcbiAgICBjb25zdCBjaGlsZCA9IGJsb2NrLmNoaWxkcmVuW2NoaWxkSW5kZXhdO1xuICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChjaGlsZCkgJiYgZWRpdG9yLmlzVm9pZChjaGlsZCkgPyBibG9ja1BhdGguY29uY2F0KGNoaWxkSW5kZXgpLmNvbmNhdCgwKSA6IGJsb2NrUGF0aC5jb25jYXQoY2hpbGRJbmRleCk7XG4gIH1cbiAgcmV0dXJuIFtibG9ja1BhdGhbMF0sIDBdO1xufVxuZnVuY3Rpb24gdG9Qb3J0YWJsZVRleHRSYW5nZSh2YWx1ZSwgcmFuZ2UsIHR5cGVzKSB7XG4gIGlmICghcmFuZ2UpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBhbmNob3IgPSBudWxsLCBmb2N1cyA9IG51bGw7XG4gIGNvbnN0IGFuY2hvclBhdGggPSByYW5nZS5hbmNob3IgJiYgY3JlYXRlS2V5ZWRQYXRoKHJhbmdlLmFuY2hvciwgdmFsdWUsIHR5cGVzKTtcbiAgYW5jaG9yUGF0aCAmJiByYW5nZS5hbmNob3IgJiYgKGFuY2hvciA9IHtcbiAgICBwYXRoOiBhbmNob3JQYXRoLFxuICAgIG9mZnNldDogcmFuZ2UuYW5jaG9yLm9mZnNldFxuICB9KTtcbiAgY29uc3QgZm9jdXNQYXRoID0gcmFuZ2UuZm9jdXMgJiYgY3JlYXRlS2V5ZWRQYXRoKHJhbmdlLmZvY3VzLCB2YWx1ZSwgdHlwZXMpO1xuICBmb2N1c1BhdGggJiYgcmFuZ2UuZm9jdXMgJiYgKGZvY3VzID0ge1xuICAgIHBhdGg6IGZvY3VzUGF0aCxcbiAgICBvZmZzZXQ6IHJhbmdlLmZvY3VzLm9mZnNldFxuICB9KTtcbiAgY29uc3QgYmFja3dhcmQgPSAhIShSYW5nZS5pc1JhbmdlKHJhbmdlKSAmJiBSYW5nZS5pc0JhY2t3YXJkKHJhbmdlKSk7XG4gIHJldHVybiBhbmNob3IgJiYgZm9jdXMgPyB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzLFxuICAgIGJhY2t3YXJkXG4gIH0gOiBudWxsO1xufVxuZnVuY3Rpb24gdG9TbGF0ZVJhbmdlKHNlbGVjdGlvbiwgZWRpdG9yKSB7XG4gIGlmICghc2VsZWN0aW9uIHx8ICFlZGl0b3IpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGFuY2hvciA9IHtcbiAgICBwYXRoOiB0b1NsYXRlUGF0aChzZWxlY3Rpb24uYW5jaG9yLnBhdGgsIGVkaXRvciksXG4gICAgb2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldFxuICB9LCBmb2N1cyA9IHtcbiAgICBwYXRoOiB0b1NsYXRlUGF0aChzZWxlY3Rpb24uZm9jdXMucGF0aCwgZWRpdG9yKSxcbiAgICBvZmZzZXQ6IHNlbGVjdGlvbi5mb2N1cy5vZmZzZXRcbiAgfTtcbiAgcmV0dXJuIGZvY3VzLnBhdGgubGVuZ3RoID09PSAwIHx8IGFuY2hvci5wYXRoLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBmb2N1cyA/IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfSA6IG51bGw7XG59XG5mdW5jdGlvbiBtb3ZlUmFuZ2VCeU9wZXJhdGlvbihyYW5nZSwgb3BlcmF0aW9uKSB7XG4gIGNvbnN0IGFuY2hvciA9IFBvaW50LnRyYW5zZm9ybShyYW5nZS5hbmNob3IsIG9wZXJhdGlvbiksIGZvY3VzID0gUG9pbnQudHJhbnNmb3JtKHJhbmdlLmZvY3VzLCBvcGVyYXRpb24pO1xuICByZXR1cm4gYW5jaG9yID09PSBudWxsIHx8IGZvY3VzID09PSBudWxsID8gbnVsbCA6IFBvaW50LmVxdWFscyhhbmNob3IsIHJhbmdlLmFuY2hvcikgJiYgUG9pbnQuZXF1YWxzKGZvY3VzLCByYW5nZS5mb2N1cykgPyByYW5nZSA6IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfTtcbn1cbmNvbnN0IFZPSURfQ0hJTERfS0VZID0gXCJ2b2lkLWNoaWxkXCI7XG5mdW5jdGlvbiBrZWVwT2JqZWN0RXF1YWxpdHkob2JqZWN0LCBrZXlNYXApIHtcbiAgY29uc3QgdmFsdWUgPSBrZXlNYXBbb2JqZWN0Ll9rZXldO1xuICByZXR1cm4gdmFsdWUgJiYgaXNFcXVhbChvYmplY3QsIHZhbHVlKSA/IHZhbHVlIDogKGtleU1hcFtvYmplY3QuX2tleV0gPSBvYmplY3QsIG9iamVjdCk7XG59XG5mdW5jdGlvbiB0b1NsYXRlVmFsdWUodmFsdWUsIHtcbiAgc2NoZW1hVHlwZXNcbn0sIGtleU1hcCA9IHt9KSB7XG4gIHJldHVybiB2YWx1ZSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCgoYmxvY2spID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBfdHlwZSxcbiAgICAgIF9rZXksXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IGJsb2NrLCB2b2lkQ2hpbGRyZW4gPSBbe1xuICAgICAgX2tleTogVk9JRF9DSElMRF9LRVksXG4gICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICB0ZXh0OiBcIlwiLFxuICAgICAgbWFya3M6IFtdXG4gICAgfV07XG4gICAgaWYgKGJsb2NrICYmIGJsb2NrLl90eXBlID09PSBzY2hlbWFUeXBlcy5ibG9jay5uYW1lKSB7XG4gICAgICBjb25zdCB0ZXh0QmxvY2sgPSBibG9jaztcbiAgICAgIGxldCBoYXNJbmxpbmVzID0gITE7XG4gICAgICBjb25zdCBoYXNNaXNzaW5nU3R5bGUgPSB0eXBlb2YgdGV4dEJsb2NrLnN0eWxlID4gXCJ1XCIsIGhhc01pc3NpbmdNYXJrRGVmcyA9IHR5cGVvZiB0ZXh0QmxvY2subWFya0RlZnMgPiBcInVcIiwgaGFzTWlzc2luZ0NoaWxkcmVuID0gdHlwZW9mIHRleHRCbG9jay5jaGlsZHJlbiA+IFwidVwiLCBjaGlsZHJlbiA9ICh0ZXh0QmxvY2suY2hpbGRyZW4gfHwgW10pLm1hcCgoY2hpbGQpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIF90eXBlOiBjVHlwZSxcbiAgICAgICAgICBfa2V5OiBjS2V5LFxuICAgICAgICAgIC4uLmNSZXN0XG4gICAgICAgIH0gPSBjaGlsZDtcbiAgICAgICAgcmV0dXJuIGNUeXBlICE9PSBcInNwYW5cIiA/IChoYXNJbmxpbmVzID0gITAsIGtlZXBPYmplY3RFcXVhbGl0eSh7XG4gICAgICAgICAgX3R5cGU6IGNUeXBlLFxuICAgICAgICAgIF9rZXk6IGNLZXksXG4gICAgICAgICAgY2hpbGRyZW46IHZvaWRDaGlsZHJlbixcbiAgICAgICAgICB2YWx1ZTogY1Jlc3QsXG4gICAgICAgICAgX19pbmxpbmU6ICEwXG4gICAgICAgIH0sIGtleU1hcCkpIDogY2hpbGQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhaGFzTWlzc2luZ1N0eWxlICYmICFoYXNNaXNzaW5nTWFya0RlZnMgJiYgIWhhc01pc3NpbmdDaGlsZHJlbiAmJiAhaGFzSW5saW5lcyAmJiBFbGVtZW50LmlzRWxlbWVudChibG9jaykgPyBibG9jayA6IChoYXNNaXNzaW5nU3R5bGUgJiYgKHJlc3Quc3R5bGUgPSBzY2hlbWFUeXBlcy5zdHlsZXNbMF0udmFsdWUpLCBrZWVwT2JqZWN0RXF1YWxpdHkoe1xuICAgICAgICBfdHlwZSxcbiAgICAgICAgX2tleSxcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgIH0sIGtleU1hcCkpO1xuICAgIH1cbiAgICByZXR1cm4ga2VlcE9iamVjdEVxdWFsaXR5KHtcbiAgICAgIF90eXBlLFxuICAgICAgX2tleSxcbiAgICAgIGNoaWxkcmVuOiB2b2lkQ2hpbGRyZW4sXG4gICAgICB2YWx1ZTogcmVzdFxuICAgIH0sIGtleU1hcCk7XG4gIH0pIDogW107XG59XG5mdW5jdGlvbiBmcm9tU2xhdGVWYWx1ZSh2YWx1ZSwgdGV4dEJsb2NrVHlwZSwga2V5TWFwID0ge30pIHtcbiAgcmV0dXJuIHZhbHVlLm1hcCgoYmxvY2spID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBfa2V5LFxuICAgICAgX3R5cGVcbiAgICB9ID0gYmxvY2s7XG4gICAgaWYgKCFfa2V5IHx8ICFfdHlwZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBhIHZhbGlkIGJsb2NrXCIpO1xuICAgIGlmIChfdHlwZSA9PT0gdGV4dEJsb2NrVHlwZSAmJiBcImNoaWxkcmVuXCIgaW4gYmxvY2sgJiYgQXJyYXkuaXNBcnJheShibG9jay5jaGlsZHJlbikgJiYgX2tleSkge1xuICAgICAgbGV0IGhhc0lubGluZXMgPSAhMTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gYmxvY2suY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgX3R5cGU6IF9jVHlwZVxuICAgICAgICB9ID0gY2hpbGQ7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gY2hpbGQgJiYgX2NUeXBlICE9PSBcInNwYW5cIikge1xuICAgICAgICAgIGhhc0lubGluZXMgPSAhMDtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB2YWx1ZTogdixcbiAgICAgICAgICAgIF9rZXk6IGssXG4gICAgICAgICAgICBfdHlwZTogdCxcbiAgICAgICAgICAgIF9faW5saW5lOiBfaSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBfYyxcbiAgICAgICAgICAgIC4uLnJlc3RcbiAgICAgICAgICB9ID0gY2hpbGQ7XG4gICAgICAgICAgcmV0dXJuIGtlZXBPYmplY3RFcXVhbGl0eSh7XG4gICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgICAgLi4udixcbiAgICAgICAgICAgIF9rZXk6IGssXG4gICAgICAgICAgICBfdHlwZTogdFxuICAgICAgICAgIH0sIGtleU1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gaGFzSW5saW5lcyA/IGtlZXBPYmplY3RFcXVhbGl0eSh7XG4gICAgICAgIC4uLmJsb2NrLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgX2tleSxcbiAgICAgICAgX3R5cGVcbiAgICAgIH0sIGtleU1hcCkgOiBibG9jaztcbiAgICB9XG4gICAgY29uc3QgYmxvY2tWYWx1ZSA9IFwidmFsdWVcIiBpbiBibG9jayAmJiBibG9jay52YWx1ZTtcbiAgICByZXR1cm4ga2VlcE9iamVjdEVxdWFsaXR5KHtcbiAgICAgIF9rZXksXG4gICAgICBfdHlwZSxcbiAgICAgIC4uLnR5cGVvZiBibG9ja1ZhbHVlID09IFwib2JqZWN0XCIgPyBibG9ja1ZhbHVlIDoge31cbiAgICB9LCBrZXlNYXApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzRXF1YWxUb0VtcHR5RWRpdG9yKGNoaWxkcmVuLCBzY2hlbWFUeXBlcykge1xuICByZXR1cm4gY2hpbGRyZW4gPT09IHZvaWQgMCB8fCBjaGlsZHJlbiAmJiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgY2hpbGRyZW4gJiYgQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIEVsZW1lbnQuaXNFbGVtZW50KGNoaWxkcmVuWzBdKSAmJiBjaGlsZHJlblswXS5fdHlwZSA9PT0gc2NoZW1hVHlwZXMuYmxvY2submFtZSAmJiBcInN0eWxlXCIgaW4gY2hpbGRyZW5bMF0gJiYgY2hpbGRyZW5bMF0uc3R5bGUgPT09IHNjaGVtYVR5cGVzLnN0eWxlc1swXS52YWx1ZSAmJiAhKFwibGlzdEl0ZW1cIiBpbiBjaGlsZHJlblswXSkgJiYgQXJyYXkuaXNBcnJheShjaGlsZHJlblswXS5jaGlsZHJlbikgJiYgY2hpbGRyZW5bMF0uY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIFRleHQuaXNUZXh0KGNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdKSAmJiBjaGlsZHJlblswXS5jaGlsZHJlblswXS5fdHlwZSA9PT0gXCJzcGFuXCIgJiYgIWNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLm1hcmtzPy5qb2luKFwiXCIpICYmIGNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLnRleHQgPT09IFwiXCI7XG59XG5jb25zdCBJU19QUk9DRVNTSU5HX1JFTU9URV9DSEFOR0VTID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIElTX0RSQUdHSU5HID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIElTX0RSQUdHSU5HX0JMT0NLX0VMRU1FTlQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgSVNfRFJBR0dJTkdfRUxFTUVOVF9UQVJHRVQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgSVNfRFJBR0dJTkdfQkxPQ0tfVEFSR0VUX1BPU0lUSU9OID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIEtFWV9UT19TTEFURV9FTEVNRU5UID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIEtFWV9UT19WQUxVRV9FTEVNRU5UID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFNMQVRFX1RPX1BPUlRBQkxFX1RFWFRfUkFOR0UgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgUG9ydGFibGVUZXh0RWRpdG9yQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCksIHVzZVBvcnRhYmxlVGV4dEVkaXRvciA9ICgpID0+IHtcbiAgY29uc3QgZWRpdG9yID0gdXNlQ29udGV4dChQb3J0YWJsZVRleHRFZGl0b3JDb250ZXh0KTtcbiAgaWYgKCFlZGl0b3IpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGB1c2VQb3J0YWJsZVRleHRFZGl0b3JgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFBvcnRhYmxlVGV4dEVkaXRvcj4gY29tcG9uZW50J3MgY29udGV4dC5cIik7XG4gIHJldHVybiBlZGl0b3I7XG59O1xuZnVuY3Rpb24gY29tcGlsZVR5cGUocmF3VHlwZSkge1xuICByZXR1cm4gU2NoZW1hLmNvbXBpbGUoe1xuICAgIG5hbWU6IFwiYmxvY2tUeXBlU2NoZW1hXCIsXG4gICAgdHlwZXM6IFtyYXdUeXBlXVxuICB9KS5nZXQocmF3VHlwZS5uYW1lKTtcbn1cbmNvbnN0IG11dGF0aW9uTWFjaGluZSA9IHNldHVwKHtcbiAgdHlwZXM6IHtcbiAgICBjb250ZXh0OiB7fSxcbiAgICBldmVudHM6IHt9LFxuICAgIGlucHV0OiB7fSxcbiAgICBlbWl0dGVkOiB7fVxuICB9LFxuICBhY3Rpb25zOiB7XG4gICAgXCJlbWl0IGhhcyBwZW5kaW5nIHBhdGNoZXNcIjogZW1pdCh7XG4gICAgICB0eXBlOiBcImhhcyBwZW5kaW5nIHBhdGNoZXNcIlxuICAgIH0pLFxuICAgIFwiZW1pdCBtdXRhdGlvbnNcIjogZW5xdWV1ZUFjdGlvbnMoKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBlbnF1ZXVlXG4gICAgfSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBidWxrIG9mIGNvbnRleHQucGVuZGluZ011dGF0aW9ucylcbiAgICAgICAgZW5xdWV1ZS5lbWl0KHtcbiAgICAgICAgICB0eXBlOiBcIm11dGF0aW9uXCIsXG4gICAgICAgICAgcGF0Y2hlczogYnVsay5wYXRjaGVzLFxuICAgICAgICAgIHNuYXBzaG90OiBidWxrLnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH0pLFxuICAgIFwiY2xlYXIgcGVuZGluZyBtdXRhdGlvbnNcIjogYXNzaWduKHtcbiAgICAgIHBlbmRpbmdNdXRhdGlvbnM6IFtdXG4gICAgfSksXG4gICAgXCJkZWZlciBwYXRjaFwiOiBhc3NpZ24oe1xuICAgICAgcGVuZGluZ011dGF0aW9uczogKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKGFzc2VydEV2ZW50KGV2ZW50LCBcInBhdGNoXCIpLCBjb250ZXh0LnBlbmRpbmdNdXRhdGlvbnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgYWN0aW9uSWQ6IGV2ZW50LmFjdGlvbklkLFxuICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnZhbHVlLFxuICAgICAgICAgICAgcGF0Y2hlczogW2V2ZW50LnBhdGNoXVxuICAgICAgICAgIH1dO1xuICAgICAgICBjb25zdCBsYXN0QnVsayA9IGNvbnRleHQucGVuZGluZ011dGF0aW9ucy5hdCgtMSk7XG4gICAgICAgIHJldHVybiBsYXN0QnVsayAmJiBsYXN0QnVsay5hY3Rpb25JZCA9PT0gZXZlbnQuYWN0aW9uSWQgPyBjb250ZXh0LnBlbmRpbmdNdXRhdGlvbnMuc2xpY2UoMCwgLTEpLmNvbmNhdCh7XG4gICAgICAgICAgdmFsdWU6IGV2ZW50LnZhbHVlLFxuICAgICAgICAgIGFjdGlvbklkOiBsYXN0QnVsay5hY3Rpb25JZCxcbiAgICAgICAgICBwYXRjaGVzOiBbLi4ubGFzdEJ1bGsucGF0Y2hlcywgZXZlbnQucGF0Y2hdXG4gICAgICAgIH0pIDogY29udGV4dC5wZW5kaW5nTXV0YXRpb25zLmNvbmNhdCh7XG4gICAgICAgICAgdmFsdWU6IGV2ZW50LnZhbHVlLFxuICAgICAgICAgIGFjdGlvbklkOiBldmVudC5hY3Rpb25JZCxcbiAgICAgICAgICBwYXRjaGVzOiBbZXZlbnQucGF0Y2hdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pXG4gIH0sXG4gIGFjdG9yczoge1xuICAgIFwidHlwZSBsaXN0ZW5lclwiOiBmcm9tQ2FsbGJhY2soKHtcbiAgICAgIGlucHV0LFxuICAgICAgc2VuZEJhY2tcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbEFwcGx5ID0gaW5wdXQuc2xhdGVFZGl0b3IuYXBwbHk7XG4gICAgICByZXR1cm4gaW5wdXQuc2xhdGVFZGl0b3IuYXBwbHkgPSAob3ApID0+IHtcbiAgICAgICAgb3AudHlwZSA9PT0gXCJpbnNlcnRfdGV4dFwiIHx8IG9wLnR5cGUgPT09IFwicmVtb3ZlX3RleHRcIiA/IHNlbmRCYWNrKHtcbiAgICAgICAgICB0eXBlOiBcInR5cGluZ1wiXG4gICAgICAgIH0pIDogc2VuZEJhY2soe1xuICAgICAgICAgIHR5cGU6IFwibm90IHR5cGluZ1wiXG4gICAgICAgIH0pLCBvcmlnaW5hbEFwcGx5KG9wKTtcbiAgICAgIH0sICgpID0+IHtcbiAgICAgICAgaW5wdXQuc2xhdGVFZGl0b3IuYXBwbHkgPSBvcmlnaW5hbEFwcGx5O1xuICAgICAgfTtcbiAgICB9KVxuICB9LFxuICBndWFyZHM6IHtcbiAgICBcImlzIHR5cGluZ1wiOiBzdGF0ZUluKHtcbiAgICAgIHR5cGluZzogXCJ0eXBpbmdcIlxuICAgIH0pLFxuICAgIFwibm8gcGVuZGluZyBtdXRhdGlvbnNcIjogKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSA9PiBjb250ZXh0LnBlbmRpbmdNdXRhdGlvbnMubGVuZ3RoID09PSAwLFxuICAgIFwic2xhdGUgaXMgbm9ybWFsaXppbmdcIjogKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSA9PiBFZGl0b3IuaXNOb3JtYWxpemluZyhjb250ZXh0LnNsYXRlRWRpdG9yKVxuICB9LFxuICBkZWxheXM6IHtcbiAgICBcIm11dGF0aW9uIGRlYm91bmNlXCI6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IDI1MCA6IDAsXG4gICAgXCJ0eXBlIGRlYm91bmNlXCI6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IDAgOiAyNTBcbiAgfVxufSkuY3JlYXRlTWFjaGluZSh7XG4gIGlkOiBcIm11dGF0aW9uXCIsXG4gIGNvbnRleHQ6ICh7XG4gICAgaW5wdXRcbiAgfSkgPT4gKHtcbiAgICBwZW5kaW5nTXV0YXRpb25zOiBbXSxcbiAgICBzY2hlbWE6IGlucHV0LnNjaGVtYSxcbiAgICBzbGF0ZUVkaXRvcjogaW5wdXQuc2xhdGVFZGl0b3JcbiAgfSksXG4gIHR5cGU6IFwicGFyYWxsZWxcIixcbiAgc3RhdGVzOiB7XG4gICAgdHlwaW5nOiB7XG4gICAgICBpbml0aWFsOiBcImlkbGVcIixcbiAgICAgIGludm9rZToge1xuICAgICAgICBzcmM6IFwidHlwZSBsaXN0ZW5lclwiLFxuICAgICAgICBpbnB1dDogKHtcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgIH0pID0+ICh7XG4gICAgICAgICAgc2xhdGVFZGl0b3I6IGNvbnRleHQuc2xhdGVFZGl0b3JcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgaWRsZToge1xuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICB0eXBpbmc6IHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcInR5cGluZ1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0eXBpbmc6IHtcbiAgICAgICAgICBhZnRlcjoge1xuICAgICAgICAgICAgXCJ0eXBlIGRlYm91bmNlXCI6IHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcImlkbGVcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIFwibm90IHR5cGluZ1wiOiB7XG4gICAgICAgICAgICAgIHRhcmdldDogXCJpZGxlXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBpbmc6IHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcInR5cGluZ1wiLFxuICAgICAgICAgICAgICByZWVudGVyOiAhMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbXV0YXRpb25zOiB7XG4gICAgICBpbml0aWFsOiBcImlkbGVcIixcbiAgICAgIHN0YXRlczoge1xuICAgICAgICBpZGxlOiB7XG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIHBhdGNoOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFtcImRlZmVyIHBhdGNoXCIsIFwiZW1pdCBoYXMgcGVuZGluZyBwYXRjaGVzXCJdLFxuICAgICAgICAgICAgICB0YXJnZXQ6IFwiZW1pdHRpbmcgbXV0YXRpb25zXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiZW1pdHRpbmcgbXV0YXRpb25zXCI6IHtcbiAgICAgICAgICBhZnRlcjoge1xuICAgICAgICAgICAgXCJtdXRhdGlvbiBkZWJvdW5jZVwiOiBbe1xuICAgICAgICAgICAgICBndWFyZDogYW5kKFtub3QoXCJpcyB0eXBpbmdcIiksIFwic2xhdGUgaXMgbm9ybWFsaXppbmdcIl0pLFxuICAgICAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiLFxuICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJlbWl0IG11dGF0aW9uc1wiLCBcImNsZWFyIHBlbmRpbmcgbXV0YXRpb25zXCJdXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIHRhcmdldDogXCJlbWl0dGluZyBtdXRhdGlvbnNcIixcbiAgICAgICAgICAgICAgcmVlbnRlcjogITBcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgcGF0Y2g6IHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcImVtaXR0aW5nIG11dGF0aW9uc1wiLFxuICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJkZWZlciBwYXRjaFwiXSxcbiAgICAgICAgICAgICAgcmVlbnRlcjogITBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZSh2YWx1ZSwgdHlwZXMsIGtleUdlbmVyYXRvcikge1xuICBsZXQgcmVzb2x1dGlvbiA9IG51bGwsIHZhbGlkID0gITA7XG4gIGNvbnN0IHZhbGlkQ2hpbGRUeXBlcyA9IFt0eXBlcy5zcGFuLm5hbWUsIC4uLnR5cGVzLmlubGluZU9iamVjdHMubWFwKCh0KSA9PiB0Lm5hbWUpXSwgdmFsaWRCbG9ja1R5cGVzID0gW3R5cGVzLmJsb2NrLm5hbWUsIC4uLnR5cGVzLmJsb2NrT2JqZWN0cy5tYXAoKHQpID0+IHQubmFtZSldO1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHtcbiAgICB2YWxpZDogITAsXG4gICAgcmVzb2x1dGlvbjogbnVsbCxcbiAgICB2YWx1ZVxuICB9IDogIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCA/IHtcbiAgICB2YWxpZDogITEsXG4gICAgcmVzb2x1dGlvbjoge1xuICAgICAgcGF0Y2hlczogW3Vuc2V0KFtdKV0sXG4gICAgICBkZXNjcmlwdGlvbjogXCJFZGl0b3IgdmFsdWUgbXVzdCBiZSBhbiBhcnJheSBvZiBQb3J0YWJsZSBUZXh0IGJsb2Nrcywgb3IgdW5kZWZpbmVkLlwiLFxuICAgICAgYWN0aW9uOiBcIlVuc2V0IHRoZSB2YWx1ZVwiLFxuICAgICAgaXRlbTogdmFsdWUsXG4gICAgICBpMThuOiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubm90LWFuLWFycmF5LmRlc2NyaXB0aW9uXCIsXG4gICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm5vdC1hbi1hcnJheS5hY3Rpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgdmFsdWVcbiAgfSA6ICh2YWx1ZS5zb21lKChibGssIGluZGV4KSA9PiB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGJsaykpXG4gICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgcGF0Y2hlczogW3Vuc2V0KFtpbmRleF0pXSxcbiAgICAgICAgZGVzY3JpcHRpb246IGBCbG9jayBtdXN0IGJlIGFuIG9iamVjdCwgZ290ICR7U3RyaW5nKGJsayl9YCxcbiAgICAgICAgYWN0aW9uOiBcIlVuc2V0IGludmFsaWQgaXRlbVwiLFxuICAgICAgICBpdGVtOiBibGssXG4gICAgICAgIGkxOG46IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm5vdC1hbi1vYmplY3QuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5ub3QtYW4tb2JqZWN0LmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sICEwO1xuICAgIGlmICghYmxrLl9rZXkgfHwgdHlwZW9mIGJsay5fa2V5ICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgcGF0Y2hlczogW3NldCh7XG4gICAgICAgICAgLi4uYmxrLFxuICAgICAgICAgIF9rZXk6IGtleUdlbmVyYXRvcigpXG4gICAgICAgIH0sIFtpbmRleF0pXSxcbiAgICAgICAgZGVzY3JpcHRpb246IGBCbG9jayBhdCBpbmRleCAke2luZGV4fSBpcyBtaXNzaW5nIHJlcXVpcmVkIF9rZXkuYCxcbiAgICAgICAgYWN0aW9uOiBcIlNldCB0aGUgYmxvY2sgd2l0aCBhIHJhbmRvbSBfa2V5IHZhbHVlXCIsXG4gICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1rZXkuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWtleS5hY3Rpb25cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCAhMDtcbiAgICBpZiAoIWJsay5fdHlwZSB8fCAhdmFsaWRCbG9ja1R5cGVzLmluY2x1ZGVzKGJsay5fdHlwZSkpIHtcbiAgICAgIGlmIChibGsuX3R5cGUgPT09IFwiYmxvY2tcIikge1xuICAgICAgICBjb25zdCBjdXJyZW50QmxvY2tUeXBlTmFtZSA9IHR5cGVzLmJsb2NrLm5hbWU7XG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgIHBhdGNoZXM6IFtzZXQoe1xuICAgICAgICAgICAgLi4uYmxrLFxuICAgICAgICAgICAgX3R5cGU6IGN1cnJlbnRCbG9ja1R5cGVOYW1lXG4gICAgICAgICAgfSwgW3tcbiAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgfV0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGhhcyBpbnZhbGlkIHR5cGUgbmFtZSAnJHtibGsuX3R5cGV9Jy4gQWNjb3JkaW5nIHRvIHRoZSBzY2hlbWEsIHRoZSBibG9jayB0eXBlIG5hbWUgaXMgJyR7Y3VycmVudEJsb2NrVHlwZU5hbWV9J2AsXG4gICAgICAgICAgYWN0aW9uOiBgVXNlIHR5cGUgJyR7Y3VycmVudEJsb2NrVHlwZU5hbWV9J2AsXG4gICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuaW5jb3JyZWN0LWJsb2NrLXR5cGUuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmluY29ycmVjdC1ibG9jay10eXBlLmFjdGlvblwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICAgIGV4cGVjdGVkVHlwZU5hbWU6IGN1cnJlbnRCbG9ja1R5cGVOYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCAhMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhYmxrLl90eXBlICYmIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKHtcbiAgICAgICAgLi4uYmxrLFxuICAgICAgICBfdHlwZTogdHlwZXMuYmxvY2submFtZVxuICAgICAgfSkgPyAocmVzb2x1dGlvbiA9IHtcbiAgICAgICAgcGF0Y2hlczogW3NldCh7XG4gICAgICAgICAgLi4uYmxrLFxuICAgICAgICAgIF90eXBlOiB0eXBlcy5ibG9jay5uYW1lXG4gICAgICAgIH0sIFt7XG4gICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgfV0pXSxcbiAgICAgICAgZGVzY3JpcHRpb246IGBCbG9jayB3aXRoIF9rZXkgJyR7YmxrLl9rZXl9JyBpcyBtaXNzaW5nIGEgdHlwZSBuYW1lLiBBY2NvcmRpbmcgdG8gdGhlIHNjaGVtYSwgdGhlIGJsb2NrIHR5cGUgbmFtZSBpcyAnJHt0eXBlcy5ibG9jay5uYW1lfSdgLFxuICAgICAgICBhY3Rpb246IGBVc2UgdHlwZSAnJHt0eXBlcy5ibG9jay5uYW1lfSdgLFxuICAgICAgICBpdGVtOiBibGssXG4gICAgICAgIGkxOG46IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3NpbmctYmxvY2stdHlwZS5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3NpbmctYmxvY2stdHlwZS5hY3Rpb25cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICBleHBlY3RlZFR5cGVOYW1lOiB0eXBlcy5ibG9jay5uYW1lXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCAhMCkgOiBibGsuX3R5cGUgPyAocmVzb2x1dGlvbiA9IHtcbiAgICAgICAgcGF0Y2hlczogW3Vuc2V0KFt7XG4gICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgfV0pXSxcbiAgICAgICAgZGVzY3JpcHRpb246IGBCbG9jayB3aXRoIF9rZXkgJyR7YmxrLl9rZXl9JyBoYXMgaW52YWxpZCBfdHlwZSAnJHtibGsuX3R5cGV9J2AsXG4gICAgICAgIGFjdGlvbjogXCJSZW1vdmUgdGhlIGJsb2NrXCIsXG4gICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuZGlzYWxsb3dlZC10eXBlLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuZGlzYWxsb3dlZC10eXBlLmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBibGsuX3R5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sICEwKSA6IChyZXNvbHV0aW9uID0ge1xuICAgICAgICBwYXRjaGVzOiBbdW5zZXQoW3tcbiAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICB9XSldLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGlzIG1pc3NpbmcgYW4gX3R5cGUgcHJvcGVydHlgLFxuICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIHRoZSBibG9ja1wiLFxuICAgICAgICBpdGVtOiBibGssXG4gICAgICAgIGkxOG46IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3NpbmctdHlwZS5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3NpbmctdHlwZS5hY3Rpb25cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIGtleTogYmxrLl9rZXlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sICEwKTtcbiAgICB9XG4gICAgaWYgKGJsay5fdHlwZSA9PT0gdHlwZXMuYmxvY2submFtZSkge1xuICAgICAgY29uc3QgdGV4dEJsb2NrID0gYmxrO1xuICAgICAgaWYgKHRleHRCbG9jay5jaGlsZHJlbiAmJiAhQXJyYXkuaXNBcnJheSh0ZXh0QmxvY2suY2hpbGRyZW4pKVxuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICBwYXRjaGVzOiBbc2V0KHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICAgIH0sIFt7XG4gICAgICAgICAgICBfa2V5OiB0ZXh0QmxvY2suX2tleVxuICAgICAgICAgIH1dKV0sXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBUZXh0IGJsb2NrIHdpdGggX2tleSAnJHt0ZXh0QmxvY2suX2tleX0nIGhhcyBhIGludmFsaWQgcmVxdWlyZWQgcHJvcGVydHkgJ2NoaWxkcmVuJy5gLFxuICAgICAgICAgIGFjdGlvbjogXCJSZXNldCB0aGUgY2hpbGRyZW4gcHJvcGVydHlcIixcbiAgICAgICAgICBpdGVtOiB0ZXh0QmxvY2ssXG4gICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLW9yLWludmFsaWQtY2hpbGRyZW4uZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3Npbmctb3ItaW52YWxpZC1jaGlsZHJlbi5hY3Rpb25cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBrZXk6IHRleHRCbG9jay5fa2V5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCAhMDtcbiAgICAgIGlmICh0ZXh0QmxvY2suY2hpbGRyZW4gPT09IHZvaWQgMCB8fCBBcnJheS5pc0FycmF5KHRleHRCbG9jay5jaGlsZHJlbikgJiYgdGV4dEJsb2NrLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zdCBuZXdTcGFuID0ge1xuICAgICAgICAgIF90eXBlOiB0eXBlcy5zcGFuLm5hbWUsXG4gICAgICAgICAgX2tleToga2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICBtYXJrczogW11cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgYXV0b1Jlc29sdmU6ICEwLFxuICAgICAgICAgIHBhdGNoZXM6IFtzZXRJZk1pc3NpbmcoW10sIFt7XG4gICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIl0pLCBpbnNlcnQoW25ld1NwYW5dLCBcImFmdGVyXCIsIFt7XG4gICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwgMF0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYENoaWxkcmVuIGZvciB0ZXh0IGJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGlzIGVtcHR5LmAsXG4gICAgICAgICAgYWN0aW9uOiBcIkluc2VydCBhbiBlbXB0eSB0ZXh0XCIsXG4gICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuZW1wdHktY2hpbGRyZW4uZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmVtcHR5LWNoaWxkcmVuLmFjdGlvblwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGtleTogYmxrLl9rZXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sICEwO1xuICAgICAgfVxuICAgICAgY29uc3QgYWxsVXNlZE1hcmtzID0gdW5pcShmbGF0dGVuKHRleHRCbG9jay5jaGlsZHJlbi5maWx0ZXIoKGNsZCkgPT4gY2xkLl90eXBlID09PSB0eXBlcy5zcGFuLm5hbWUpLm1hcCgoY2xkKSA9PiBjbGQubWFya3MgfHwgW10pKSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShibGsubWFya0RlZnMpICYmIGJsay5tYXJrRGVmcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHVudXNlZE1hcmtEZWZzID0gdW5pcShibGsubWFya0RlZnMubWFwKChkZWYpID0+IGRlZi5fa2V5KS5maWx0ZXIoKGtleSkgPT4gIWFsbFVzZWRNYXJrcy5pbmNsdWRlcyhrZXkpKSk7XG4gICAgICAgIGlmICh1bnVzZWRNYXJrRGVmcy5sZW5ndGggPiAwKVxuICAgICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgICAgYXV0b1Jlc29sdmU6ICEwLFxuICAgICAgICAgICAgcGF0Y2hlczogdW51c2VkTWFya0RlZnMubWFwKChtYXJrRGVmS2V5KSA9PiB1bnNldChbe1xuICAgICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgICAgfSwgXCJtYXJrRGVmc1wiLCB7XG4gICAgICAgICAgICAgIF9rZXk6IG1hcmtEZWZLZXlcbiAgICAgICAgICAgIH1dKSksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIGNvbnRhaW5zIG9ycGhhbmVkIGRhdGEgKHVudXNlZCBtYXJrIGRlZmluaXRpb25zKTogJHt1bnVzZWRNYXJrRGVmcy5qb2luKFwiLCBcIil9LmAsXG4gICAgICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIHVudXNlZCBtYXJrIGRlZmluaXRpb24gaXRlbVwiLFxuICAgICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm9ycGhhbmVkLW1hcmstZGVmcy5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5vcnBoYW5lZC1tYXJrLWRlZnMuYWN0aW9uXCIsXG4gICAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICAgICAgdW51c2VkTWFya0RlZnM6IHVudXNlZE1hcmtEZWZzLm1hcCgobSkgPT4gbS50b1N0cmluZygpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgITA7XG4gICAgICB9XG4gICAgICBjb25zdCBvcnBoYW5lZE1hcmtzID0gYWxsVXNlZE1hcmtzLmZpbHRlcigobWFyaykgPT4gIXR5cGVzLmRlY29yYXRvcnMubWFwKChkZWMpID0+IGRlYy52YWx1ZSkuaW5jbHVkZXMobWFyaykpLmZpbHRlcigobWFyaykgPT4gdGV4dEJsb2NrLm1hcmtEZWZzID09PSB2b2lkIDAgfHwgIXRleHRCbG9jay5tYXJrRGVmcy5maW5kKChkZWYpID0+IGRlZi5fa2V5ID09PSBtYXJrKSk7XG4gICAgICBpZiAob3JwaGFuZWRNYXJrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHNwYW5DaGlsZHJlbiA9IHRleHRCbG9jay5jaGlsZHJlbi5maWx0ZXIoKGNsZCkgPT4gY2xkLl90eXBlID09PSB0eXBlcy5zcGFuLm5hbWUgJiYgQXJyYXkuaXNBcnJheShjbGQubWFya3MpICYmIGNsZC5tYXJrcy5zb21lKChtYXJrKSA9PiBvcnBoYW5lZE1hcmtzLmluY2x1ZGVzKG1hcmspKSk7XG4gICAgICAgIGlmIChzcGFuQ2hpbGRyZW4pIHtcbiAgICAgICAgICBjb25zdCBvcnBoYW5lZCA9IG9ycGhhbmVkTWFya3Muam9pbihcIiwgXCIpO1xuICAgICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgICAgYXV0b1Jlc29sdmU6ICEwLFxuICAgICAgICAgICAgcGF0Y2hlczogc3BhbkNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IHNldCgoY2hpbGQubWFya3MgfHwgW10pLmZpbHRlcigoY01yaykgPT4gIW9ycGhhbmVkTWFya3MuaW5jbHVkZXMoY01yaykpLCBbe1xuICAgICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICAgIH0sIFwibWFya3NcIl0pKSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvY2sgd2l0aCBfa2V5ICcke2Jsay5fa2V5fScgY29udGFpbnMgbWFya3MgKCR7b3JwaGFuZWR9KSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGNvbnRlbnQgbW9kZWwuYCxcbiAgICAgICAgICAgIGFjdGlvbjogXCJSZW1vdmUgaW52YWxpZCBtYXJrc1wiLFxuICAgICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm9ycGhhbmVkLW1hcmtzLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm9ycGhhbmVkLW1hcmtzLmFjdGlvblwiLFxuICAgICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgICAgIG9ycGhhbmVkTWFya3M6IG9ycGhhbmVkTWFya3MubWFwKChtKSA9PiBtLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGV4dEJsb2NrLmNoaWxkcmVuLnNvbWUoKGNoaWxkLCBjSW5kZXgpID0+IHtcbiAgICAgICAgaWYgKCFpc1BsYWluT2JqZWN0KGNoaWxkKSlcbiAgICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICAgIHBhdGNoZXM6IFt1bnNldChbe1xuICAgICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCBjSW5kZXhdKV0sXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYENoaWxkIGF0IGluZGV4ICcke2NJbmRleH0nIGluIGJsb2NrIHdpdGgga2V5ICcke2Jsay5fa2V5fScgaXMgbm90IGFuIG9iamVjdC5gLFxuICAgICAgICAgICAgYWN0aW9uOiBcIlJlbW92ZSB0aGUgaXRlbVwiLFxuICAgICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm5vbi1vYmplY3QtY2hpbGQuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubm9uLW9iamVjdC1jaGlsZC5hY3Rpb25cIixcbiAgICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgICBpbmRleDogY0luZGV4XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAhMDtcbiAgICAgICAgaWYgKCFjaGlsZC5fa2V5IHx8IHR5cGVvZiBjaGlsZC5fa2V5ICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCBuZXdDaGlsZCA9IHtcbiAgICAgICAgICAgIC4uLmNoaWxkLFxuICAgICAgICAgICAgX2tleToga2V5R2VuZXJhdG9yKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgICAgYXV0b1Jlc29sdmU6ICEwLFxuICAgICAgICAgICAgcGF0Y2hlczogW3NldChuZXdDaGlsZCwgW3tcbiAgICAgICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwgY0luZGV4XSldLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBDaGlsZCBhdCBpbmRleCAke2NJbmRleH0gaXMgbWlzc2luZyByZXF1aXJlZCBfa2V5IGluIGJsb2NrIHdpdGggX2tleSAke2Jsay5fa2V5fS5gLFxuICAgICAgICAgICAgYWN0aW9uOiBcIlNldCBhIG5ldyByYW5kb20gX2tleSBvbiB0aGUgb2JqZWN0XCIsXG4gICAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1jaGlsZC1rZXkuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1jaGlsZC1rZXkuYWN0aW9uXCIsXG4gICAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICAgICAgaW5kZXg6IGNJbmRleFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgITA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkLl90eXBlID8gdmFsaWRDaGlsZFR5cGVzLmluY2x1ZGVzKGNoaWxkLl90eXBlKSA/IGNoaWxkLl90eXBlID09PSB0eXBlcy5zcGFuLm5hbWUgJiYgdHlwZW9mIGNoaWxkLnRleHQgIT0gXCJzdHJpbmdcIiA/IChyZXNvbHV0aW9uID0ge1xuICAgICAgICAgIHBhdGNoZXM6IFtzZXQoe1xuICAgICAgICAgICAgLi4uY2hpbGQsXG4gICAgICAgICAgICB0ZXh0OiBcIlwiXG4gICAgICAgICAgfSwgW3tcbiAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgfV0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYENoaWxkIHdpdGggX2tleSAnJHtjaGlsZC5fa2V5fScgaW4gYmxvY2sgd2l0aCBrZXkgJyR7YmxrLl9rZXl9JyBoYXMgbWlzc2luZyBvciBpbnZhbGlkIHRleHQgcHJvcGVydHkhYCxcbiAgICAgICAgICBhY3Rpb246IFwiV3JpdGUgYW4gZW1wdHkgdGV4dCBwcm9wZXJ0eSB0byB0aGUgb2JqZWN0XCIsXG4gICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuaW52YWxpZC1zcGFuLXRleHQuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmludmFsaWQtc3Bhbi10ZXh0LmFjdGlvblwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICAgIGNoaWxkS2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCAhMCkgOiAhMSA6IChyZXNvbHV0aW9uID0ge1xuICAgICAgICAgIHBhdGNoZXM6IFt1bnNldChbe1xuICAgICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICB9XSldLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ2hpbGQgd2l0aCBfa2V5ICcke2NoaWxkLl9rZXl9JyBpbiBibG9jayB3aXRoIGtleSAnJHtibGsuX2tleX0nIGhhcyBpbnZhbGlkICdfdHlwZScgcHJvcGVydHkgKCR7Y2hpbGQuX3R5cGV9KS5gLFxuICAgICAgICAgIGFjdGlvbjogXCJSZW1vdmUgdGhlIG9iamVjdFwiLFxuICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmRpc2FsbG93ZWQtY2hpbGQtdHlwZS5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuZGlzYWxsb3dlZC1jaGlsZC10eXBlLmFjdGlvblwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICAgIGNoaWxkS2V5OiBjaGlsZC5fa2V5LFxuICAgICAgICAgICAgICBjaGlsZFR5cGU6IGNoaWxkLl90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCAhMCkgOiAocmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICBwYXRjaGVzOiBbdW5zZXQoW3tcbiAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgfV0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYENoaWxkIHdpdGggX2tleSAnJHtjaGlsZC5fa2V5fScgaW4gYmxvY2sgd2l0aCBrZXkgJyR7YmxrLl9rZXl9JyBpcyBtaXNzaW5nICdfdHlwZScgcHJvcGVydHkuYCxcbiAgICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIHRoZSBvYmplY3RcIixcbiAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWNoaWxkLXR5cGUuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3NpbmctY2hpbGQtdHlwZS5hY3Rpb25cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgICBjaGlsZEtleTogY2hpbGQuX2tleVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgITApO1xuICAgICAgfSkgJiYgKHZhbGlkID0gITEpO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH0pICYmICh2YWxpZCA9ICExKSwge1xuICAgIHZhbGlkLFxuICAgIHJlc29sdXRpb24sXG4gICAgdmFsdWVcbiAgfSk7XG59XG5mdW5jdGlvbiB3aXRoUmVtb3RlQ2hhbmdlcyhlZGl0b3IsIGZuKSB7XG4gIGNvbnN0IHByZXYgPSBpc0NoYW5naW5nUmVtb3RlbHkoZWRpdG9yKSB8fCAhMTtcbiAgSVNfUFJPQ0VTU0lOR19SRU1PVEVfQ0hBTkdFUy5zZXQoZWRpdG9yLCAhMCksIGZuKCksIElTX1BST0NFU1NJTkdfUkVNT1RFX0NIQU5HRVMuc2V0KGVkaXRvciwgcHJldik7XG59XG5mdW5jdGlvbiBpc0NoYW5naW5nUmVtb3RlbHkoZWRpdG9yKSB7XG4gIHJldHVybiBJU19QUk9DRVNTSU5HX1JFTU9URV9DSEFOR0VTLmdldChlZGl0b3IpO1xufVxuY29uc3QgUEFUQ0hJTkcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHdpdGhvdXRQYXRjaGluZyhlZGl0b3IsIGZuKSB7XG4gIGNvbnN0IHByZXYgPSBpc1BhdGNoaW5nKGVkaXRvcik7XG4gIFBBVENISU5HLnNldChlZGl0b3IsICExKSwgZm4oKSwgUEFUQ0hJTkcuc2V0KGVkaXRvciwgcHJldik7XG59XG5mdW5jdGlvbiBpc1BhdGNoaW5nKGVkaXRvcikge1xuICByZXR1cm4gUEFUQ0hJTkcuZ2V0KGVkaXRvcik7XG59XG5mdW5jdGlvbiBjbG9uZURpZmYoZGlmZjIpIHtcbiAgY29uc3QgW3R5cGUsIHBhdGNoXSA9IGRpZmYyO1xuICByZXR1cm4gW3R5cGUsIHBhdGNoXTtcbn1cbmZ1bmN0aW9uIGdldENvbW1vbk92ZXJsYXAodGV4dEEsIHRleHRCKSB7XG4gIGxldCB0ZXh0MSA9IHRleHRBLCB0ZXh0MiA9IHRleHRCO1xuICBjb25zdCB0ZXh0MUxlbmd0aCA9IHRleHQxLmxlbmd0aCwgdGV4dDJMZW5ndGggPSB0ZXh0Mi5sZW5ndGg7XG4gIGlmICh0ZXh0MUxlbmd0aCA9PT0gMCB8fCB0ZXh0Mkxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XG4gIHRleHQxTGVuZ3RoID4gdGV4dDJMZW5ndGggPyB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZyh0ZXh0MUxlbmd0aCAtIHRleHQyTGVuZ3RoKSA6IHRleHQxTGVuZ3RoIDwgdGV4dDJMZW5ndGggJiYgKHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKDAsIHRleHQxTGVuZ3RoKSk7XG4gIGNvbnN0IHRleHRMZW5ndGggPSBNYXRoLm1pbih0ZXh0MUxlbmd0aCwgdGV4dDJMZW5ndGgpO1xuICBpZiAodGV4dDEgPT09IHRleHQyKSByZXR1cm4gdGV4dExlbmd0aDtcbiAgbGV0IGJlc3QgPSAwLCBsZW5ndGggPSAxO1xuICBmb3IgKGxldCBmb3VuZCA9IDA7IGZvdW5kICE9PSAtMTsgKSB7XG4gICAgY29uc3QgcGF0dGVybiA9IHRleHQxLnN1YnN0cmluZyh0ZXh0TGVuZ3RoIC0gbGVuZ3RoKTtcbiAgICBpZiAoZm91bmQgPSB0ZXh0Mi5pbmRleE9mKHBhdHRlcm4pLCBmb3VuZCA9PT0gLTEpIHJldHVybiBiZXN0O1xuICAgIGxlbmd0aCArPSBmb3VuZCwgKGZvdW5kID09PSAwIHx8IHRleHQxLnN1YnN0cmluZyh0ZXh0TGVuZ3RoIC0gbGVuZ3RoKSA9PT0gdGV4dDIuc3Vic3RyaW5nKDAsIGxlbmd0aCkpICYmIChiZXN0ID0gbGVuZ3RoLCBsZW5ndGgrKyk7XG4gIH1cbiAgcmV0dXJuIGJlc3Q7XG59XG5mdW5jdGlvbiBnZXRDb21tb25QcmVmaXgodGV4dDEsIHRleHQyKSB7XG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxWzBdICE9PSB0ZXh0MlswXSkgcmV0dXJuIDA7XG4gIGxldCBwb2ludGVyTWluID0gMCwgcG9pbnRlck1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKSwgcG9pbnRlck1pZCA9IHBvaW50ZXJNYXgsIHBvaW50ZXJTdGFydCA9IDA7XG4gIGZvciAoOyBwb2ludGVyTWluIDwgcG9pbnRlck1pZDsgKSB0ZXh0MS5zdWJzdHJpbmcocG9pbnRlclN0YXJ0LCBwb2ludGVyTWlkKSA9PT0gdGV4dDIuc3Vic3RyaW5nKHBvaW50ZXJTdGFydCwgcG9pbnRlck1pZCkgPyAocG9pbnRlck1pbiA9IHBvaW50ZXJNaWQsIHBvaW50ZXJTdGFydCA9IHBvaW50ZXJNaW4pIDogcG9pbnRlck1heCA9IHBvaW50ZXJNaWQsIHBvaW50ZXJNaWQgPSBNYXRoLmZsb29yKChwb2ludGVyTWF4IC0gcG9pbnRlck1pbikgLyAyICsgcG9pbnRlck1pbik7XG4gIHJldHVybiBwb2ludGVyTWlkO1xufVxuZnVuY3Rpb24gZ2V0Q29tbW9uU3VmZml4KHRleHQxLCB0ZXh0Mikge1xuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MVt0ZXh0MS5sZW5ndGggLSAxXSAhPT0gdGV4dDJbdGV4dDIubGVuZ3RoIC0gMV0pIHJldHVybiAwO1xuICBsZXQgcG9pbnRlck1pbiA9IDAsIHBvaW50ZXJNYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCksIHBvaW50ZXJNaWQgPSBwb2ludGVyTWF4LCBwb2ludGVyRW5kID0gMDtcbiAgZm9yICg7IHBvaW50ZXJNaW4gPCBwb2ludGVyTWlkOyApIHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBwb2ludGVyTWlkLCB0ZXh0MS5sZW5ndGggLSBwb2ludGVyRW5kKSA9PT0gdGV4dDIuc3Vic3RyaW5nKHRleHQyLmxlbmd0aCAtIHBvaW50ZXJNaWQsIHRleHQyLmxlbmd0aCAtIHBvaW50ZXJFbmQpID8gKHBvaW50ZXJNaW4gPSBwb2ludGVyTWlkLCBwb2ludGVyRW5kID0gcG9pbnRlck1pbikgOiBwb2ludGVyTWF4ID0gcG9pbnRlck1pZCwgcG9pbnRlck1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJNYXggLSBwb2ludGVyTWluKSAvIDIgKyBwb2ludGVyTWluKTtcbiAgcmV0dXJuIHBvaW50ZXJNaWQ7XG59XG5mdW5jdGlvbiBpc0hpZ2hTdXJyb2dhdGUoY2hhcikge1xuICBjb25zdCBjaGFyQ29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDU1Mjk2ICYmIGNoYXJDb2RlIDw9IDU2MzE5O1xufVxuZnVuY3Rpb24gaXNMb3dTdXJyb2dhdGUoY2hhcikge1xuICBjb25zdCBjaGFyQ29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDU2MzIwICYmIGNoYXJDb2RlIDw9IDU3MzQzO1xufVxuZnVuY3Rpb24gYmlzZWN0KHRleHQxLCB0ZXh0MiwgZGVhZGxpbmUpIHtcbiAgY29uc3QgdGV4dDFMZW5ndGggPSB0ZXh0MS5sZW5ndGgsIHRleHQyTGVuZ3RoID0gdGV4dDIubGVuZ3RoLCBtYXhEID0gTWF0aC5jZWlsKCh0ZXh0MUxlbmd0aCArIHRleHQyTGVuZ3RoKSAvIDIpLCB2T2Zmc2V0ID0gbWF4RCwgdkxlbmd0aCA9IDIgKiBtYXhELCB2MSA9IG5ldyBBcnJheSh2TGVuZ3RoKSwgdjIgPSBuZXcgQXJyYXkodkxlbmd0aCk7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgdkxlbmd0aDsgeCsrKSB2MVt4XSA9IC0xLCB2Mlt4XSA9IC0xO1xuICB2MVt2T2Zmc2V0ICsgMV0gPSAwLCB2Mlt2T2Zmc2V0ICsgMV0gPSAwO1xuICBjb25zdCBkZWx0YSA9IHRleHQxTGVuZ3RoIC0gdGV4dDJMZW5ndGgsIGZyb250ID0gZGVsdGEgJSAyICE9PSAwO1xuICBsZXQgazFzdGFydCA9IDAsIGsxZW5kID0gMCwgazJzdGFydCA9IDAsIGsyZW5kID0gMDtcbiAgZm9yIChsZXQgZCA9IDA7IGQgPCBtYXhEICYmICEoRGF0ZS5ub3coKSA+IGRlYWRsaW5lKTsgZCsrKSB7XG4gICAgZm9yIChsZXQgazEgPSAtZCArIGsxc3RhcnQ7IGsxIDw9IGQgLSBrMWVuZDsgazEgKz0gMikge1xuICAgICAgY29uc3QgazFPZmZzZXQgPSB2T2Zmc2V0ICsgazE7XG4gICAgICBsZXQgeDE7XG4gICAgICBrMSA9PT0gLWQgfHwgazEgIT09IGQgJiYgdjFbazFPZmZzZXQgLSAxXSA8IHYxW2sxT2Zmc2V0ICsgMV0gPyB4MSA9IHYxW2sxT2Zmc2V0ICsgMV0gOiB4MSA9IHYxW2sxT2Zmc2V0IC0gMV0gKyAxO1xuICAgICAgbGV0IHkxID0geDEgLSBrMTtcbiAgICAgIGZvciAoOyB4MSA8IHRleHQxTGVuZ3RoICYmIHkxIDwgdGV4dDJMZW5ndGggJiYgdGV4dDEuY2hhckF0KHgxKSA9PT0gdGV4dDIuY2hhckF0KHkxKTsgKSB4MSsrLCB5MSsrO1xuICAgICAgaWYgKHYxW2sxT2Zmc2V0XSA9IHgxLCB4MSA+IHRleHQxTGVuZ3RoKSBrMWVuZCArPSAyO1xuICAgICAgZWxzZSBpZiAoeTEgPiB0ZXh0Mkxlbmd0aCkgazFzdGFydCArPSAyO1xuICAgICAgZWxzZSBpZiAoZnJvbnQpIHtcbiAgICAgICAgY29uc3QgazJPZmZzZXQgPSB2T2Zmc2V0ICsgZGVsdGEgLSBrMTtcbiAgICAgICAgaWYgKGsyT2Zmc2V0ID49IDAgJiYgazJPZmZzZXQgPCB2TGVuZ3RoICYmIHYyW2syT2Zmc2V0XSAhPT0gLTEpIHtcbiAgICAgICAgICBjb25zdCB4MiA9IHRleHQxTGVuZ3RoIC0gdjJbazJPZmZzZXRdO1xuICAgICAgICAgIGlmICh4MSA+PSB4MikgcmV0dXJuIGJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0MiwgeDEsIHkxLCBkZWFkbGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgazIgPSAtZCArIGsyc3RhcnQ7IGsyIDw9IGQgLSBrMmVuZDsgazIgKz0gMikge1xuICAgICAgY29uc3QgazJPZmZzZXQgPSB2T2Zmc2V0ICsgazI7XG4gICAgICBsZXQgeDI7XG4gICAgICBrMiA9PT0gLWQgfHwgazIgIT09IGQgJiYgdjJbazJPZmZzZXQgLSAxXSA8IHYyW2syT2Zmc2V0ICsgMV0gPyB4MiA9IHYyW2syT2Zmc2V0ICsgMV0gOiB4MiA9IHYyW2syT2Zmc2V0IC0gMV0gKyAxO1xuICAgICAgbGV0IHkyID0geDIgLSBrMjtcbiAgICAgIGZvciAoOyB4MiA8IHRleHQxTGVuZ3RoICYmIHkyIDwgdGV4dDJMZW5ndGggJiYgdGV4dDEuY2hhckF0KHRleHQxTGVuZ3RoIC0geDIgLSAxKSA9PT0gdGV4dDIuY2hhckF0KHRleHQyTGVuZ3RoIC0geTIgLSAxKTsgKSB4MisrLCB5MisrO1xuICAgICAgaWYgKHYyW2syT2Zmc2V0XSA9IHgyLCB4MiA+IHRleHQxTGVuZ3RoKSBrMmVuZCArPSAyO1xuICAgICAgZWxzZSBpZiAoeTIgPiB0ZXh0Mkxlbmd0aCkgazJzdGFydCArPSAyO1xuICAgICAgZWxzZSBpZiAoIWZyb250KSB7XG4gICAgICAgIGNvbnN0IGsxT2Zmc2V0ID0gdk9mZnNldCArIGRlbHRhIC0gazI7XG4gICAgICAgIGlmIChrMU9mZnNldCA+PSAwICYmIGsxT2Zmc2V0IDwgdkxlbmd0aCAmJiB2MVtrMU9mZnNldF0gIT09IC0xKSB7XG4gICAgICAgICAgY29uc3QgeDEgPSB2MVtrMU9mZnNldF0sIHkxID0gdk9mZnNldCArIHgxIC0gazFPZmZzZXQ7XG4gICAgICAgICAgaWYgKHgyID0gdGV4dDFMZW5ndGggLSB4MiwgeDEgPj0geDIpIHJldHVybiBiaXNlY3RTcGxpdCh0ZXh0MSwgdGV4dDIsIHgxLCB5MSwgZGVhZGxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbW0RJRkZfREVMRVRFLCB0ZXh0MV0sIFtESUZGX0lOU0VSVCwgdGV4dDJdXTtcbn1cbmZ1bmN0aW9uIGJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0MiwgeCwgeSwgZGVhZGxpbmUpIHtcbiAgY29uc3QgdGV4dDFhID0gdGV4dDEuc3Vic3RyaW5nKDAsIHgpLCB0ZXh0MmEgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgeSksIHRleHQxYiA9IHRleHQxLnN1YnN0cmluZyh4KSwgdGV4dDJiID0gdGV4dDIuc3Vic3RyaW5nKHkpLCBkaWZmcyA9IGRvRGlmZih0ZXh0MWEsIHRleHQyYSwge1xuICAgIGNoZWNrTGluZXM6ICExLFxuICAgIGRlYWRsaW5lXG4gIH0pLCBkaWZmc2IgPSBkb0RpZmYodGV4dDFiLCB0ZXh0MmIsIHtcbiAgICBjaGVja0xpbmVzOiAhMSxcbiAgICBkZWFkbGluZVxuICB9KTtcbiAgcmV0dXJuIGRpZmZzLmNvbmNhdChkaWZmc2IpO1xufVxuZnVuY3Rpb24gZmluZEhhbGZNYXRjaCh0ZXh0MSwgdGV4dDIsIHRpbWVvdXQgPSAxKSB7XG4gIGlmICh0aW1lb3V0IDw9IDApIHJldHVybiBudWxsO1xuICBjb25zdCBsb25nVGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDIsIHNob3J0VGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XG4gIGlmIChsb25nVGV4dC5sZW5ndGggPCA0IHx8IHNob3J0VGV4dC5sZW5ndGggKiAyIDwgbG9uZ1RleHQubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgaGFsZk1hdGNoMSA9IGhhbGZNYXRjaEkobG9uZ1RleHQsIHNob3J0VGV4dCwgTWF0aC5jZWlsKGxvbmdUZXh0Lmxlbmd0aCAvIDQpKSwgaGFsZk1hdGNoMiA9IGhhbGZNYXRjaEkobG9uZ1RleHQsIHNob3J0VGV4dCwgTWF0aC5jZWlsKGxvbmdUZXh0Lmxlbmd0aCAvIDIpKTtcbiAgbGV0IGhhbGZNYXRjaDtcbiAgaWYgKGhhbGZNYXRjaDEgJiYgaGFsZk1hdGNoMikgaGFsZk1hdGNoID0gaGFsZk1hdGNoMVs0XS5sZW5ndGggPiBoYWxmTWF0Y2gyWzRdLmxlbmd0aCA/IGhhbGZNYXRjaDEgOiBoYWxmTWF0Y2gyO1xuICBlbHNlIHtcbiAgICBpZiAoIWhhbGZNYXRjaDEgJiYgIWhhbGZNYXRjaDIpIHJldHVybiBudWxsO1xuICAgIGhhbGZNYXRjaDIgPyBoYWxmTWF0Y2gxIHx8IChoYWxmTWF0Y2ggPSBoYWxmTWF0Y2gyKSA6IGhhbGZNYXRjaCA9IGhhbGZNYXRjaDE7XG4gIH1cbiAgaWYgKCFoYWxmTWF0Y2gpIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIGEgaGFsZiBtYXRjaC5cIik7XG4gIGxldCB0ZXh0MUEsIHRleHQxQiwgdGV4dDJBLCB0ZXh0MkI7XG4gIHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/ICh0ZXh0MUEgPSBoYWxmTWF0Y2hbMF0sIHRleHQxQiA9IGhhbGZNYXRjaFsxXSwgdGV4dDJBID0gaGFsZk1hdGNoWzJdLCB0ZXh0MkIgPSBoYWxmTWF0Y2hbM10pIDogKHRleHQyQSA9IGhhbGZNYXRjaFswXSwgdGV4dDJCID0gaGFsZk1hdGNoWzFdLCB0ZXh0MUEgPSBoYWxmTWF0Y2hbMl0sIHRleHQxQiA9IGhhbGZNYXRjaFszXSk7XG4gIGNvbnN0IG1pZENvbW1vbiA9IGhhbGZNYXRjaFs0XTtcbiAgcmV0dXJuIFt0ZXh0MUEsIHRleHQxQiwgdGV4dDJBLCB0ZXh0MkIsIG1pZENvbW1vbl07XG59XG5mdW5jdGlvbiBoYWxmTWF0Y2hJKGxvbmdUZXh0LCBzaG9ydFRleHQsIGkpIHtcbiAgY29uc3Qgc2VlZCA9IGxvbmdUZXh0LnNsaWNlKGksIGkgKyBNYXRoLmZsb29yKGxvbmdUZXh0Lmxlbmd0aCAvIDQpKTtcbiAgbGV0IGogPSAtMSwgYmVzdENvbW1vbiA9IFwiXCIsIGJlc3RMb25nVGV4dEEsIGJlc3RMb25nVGV4dEIsIGJlc3RTaG9ydFRleHRBLCBiZXN0U2hvcnRUZXh0QjtcbiAgZm9yICg7IChqID0gc2hvcnRUZXh0LmluZGV4T2Yoc2VlZCwgaiArIDEpKSAhPT0gLTE7ICkge1xuICAgIGNvbnN0IHByZWZpeExlbmd0aCA9IGdldENvbW1vblByZWZpeChsb25nVGV4dC5zbGljZShpKSwgc2hvcnRUZXh0LnNsaWNlKGopKSwgc3VmZml4TGVuZ3RoID0gZ2V0Q29tbW9uU3VmZml4KGxvbmdUZXh0LnNsaWNlKDAsIGkpLCBzaG9ydFRleHQuc2xpY2UoMCwgaikpO1xuICAgIGJlc3RDb21tb24ubGVuZ3RoIDwgc3VmZml4TGVuZ3RoICsgcHJlZml4TGVuZ3RoICYmIChiZXN0Q29tbW9uID0gc2hvcnRUZXh0LnNsaWNlKGogLSBzdWZmaXhMZW5ndGgsIGopICsgc2hvcnRUZXh0LnNsaWNlKGosIGogKyBwcmVmaXhMZW5ndGgpLCBiZXN0TG9uZ1RleHRBID0gbG9uZ1RleHQuc2xpY2UoMCwgaSAtIHN1ZmZpeExlbmd0aCksIGJlc3RMb25nVGV4dEIgPSBsb25nVGV4dC5zbGljZShpICsgcHJlZml4TGVuZ3RoKSwgYmVzdFNob3J0VGV4dEEgPSBzaG9ydFRleHQuc2xpY2UoMCwgaiAtIHN1ZmZpeExlbmd0aCksIGJlc3RTaG9ydFRleHRCID0gc2hvcnRUZXh0LnNsaWNlKGogKyBwcmVmaXhMZW5ndGgpKTtcbiAgfVxuICByZXR1cm4gYmVzdENvbW1vbi5sZW5ndGggKiAyID49IGxvbmdUZXh0Lmxlbmd0aCA/IFtiZXN0TG9uZ1RleHRBIHx8IFwiXCIsIGJlc3RMb25nVGV4dEIgfHwgXCJcIiwgYmVzdFNob3J0VGV4dEEgfHwgXCJcIiwgYmVzdFNob3J0VGV4dEIgfHwgXCJcIiwgYmVzdENvbW1vbiB8fCBcIlwiXSA6IG51bGw7XG59XG5mdW5jdGlvbiBjaGFyc1RvTGluZXMoZGlmZnMsIGxpbmVBcnJheSkge1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgY29uc3QgY2hhcnMgPSBkaWZmc1t4XVsxXSwgdGV4dCA9IFtdO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgY2hhcnMubGVuZ3RoOyB5KyspIHRleHRbeV0gPSBsaW5lQXJyYXlbY2hhcnMuY2hhckNvZGVBdCh5KV07XG4gICAgZGlmZnNbeF1bMV0gPSB0ZXh0LmpvaW4oXCJcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpbmVzVG9DaGFycyh0ZXh0QSwgdGV4dEIpIHtcbiAgY29uc3QgbGluZUFycmF5ID0gW10sIGxpbmVIYXNoID0ge307XG4gIGxpbmVBcnJheVswXSA9IFwiXCI7XG4gIGZ1bmN0aW9uIGRpZmZMaW5lc1RvTXVuZ2UodGV4dCkge1xuICAgIGxldCBjaGFycyA9IFwiXCIsIGxpbmVTdGFydCA9IDAsIGxpbmVFbmQgPSAtMSwgbGluZUFycmF5TGVuZ3RoID0gbGluZUFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKDsgbGluZUVuZCA8IHRleHQubGVuZ3RoIC0gMTsgKSB7XG4gICAgICBsaW5lRW5kID0gdGV4dC5pbmRleE9mKGBcbmAsIGxpbmVTdGFydCksIGxpbmVFbmQgPT09IC0xICYmIChsaW5lRW5kID0gdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIGxldCBsaW5lID0gdGV4dC5zbGljZShsaW5lU3RhcnQsIGxpbmVFbmQgKyAxKTtcbiAgICAgIChsaW5lSGFzaC5oYXNPd25Qcm9wZXJ0eSA/IGxpbmVIYXNoLmhhc093blByb3BlcnR5KGxpbmUpIDogbGluZUhhc2hbbGluZV0gIT09IHZvaWQgMCkgPyBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVIYXNoW2xpbmVdKSA6IChsaW5lQXJyYXlMZW5ndGggPT09IG1heExpbmVzICYmIChsaW5lID0gdGV4dC5zbGljZShsaW5lU3RhcnQpLCBsaW5lRW5kID0gdGV4dC5sZW5ndGgpLCBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVBcnJheUxlbmd0aCksIGxpbmVIYXNoW2xpbmVdID0gbGluZUFycmF5TGVuZ3RoLCBsaW5lQXJyYXlbbGluZUFycmF5TGVuZ3RoKytdID0gbGluZSksIGxpbmVTdGFydCA9IGxpbmVFbmQgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH1cbiAgbGV0IG1heExpbmVzID0gNGU0O1xuICBjb25zdCBjaGFyczEgPSBkaWZmTGluZXNUb011bmdlKHRleHRBKTtcbiAgbWF4TGluZXMgPSA2NTUzNTtcbiAgY29uc3QgY2hhcnMyID0gZGlmZkxpbmVzVG9NdW5nZSh0ZXh0Qik7XG4gIHJldHVybiB7XG4gICAgY2hhcnMxLFxuICAgIGNoYXJzMixcbiAgICBsaW5lQXJyYXlcbiAgfTtcbn1cbmZ1bmN0aW9uIGRvTGluZU1vZGVEaWZmKHRleHRBLCB0ZXh0Qiwgb3B0cykge1xuICBsZXQgdGV4dDEgPSB0ZXh0QSwgdGV4dDIgPSB0ZXh0QjtcbiAgY29uc3QgYSA9IGxpbmVzVG9DaGFycyh0ZXh0MSwgdGV4dDIpO1xuICB0ZXh0MSA9IGEuY2hhcnMxLCB0ZXh0MiA9IGEuY2hhcnMyO1xuICBjb25zdCBsaW5lYXJyYXkgPSBhLmxpbmVBcnJheTtcbiAgbGV0IGRpZmZzID0gZG9EaWZmKHRleHQxLCB0ZXh0Miwge1xuICAgIGNoZWNrTGluZXM6ICExLFxuICAgIGRlYWRsaW5lOiBvcHRzLmRlYWRsaW5lXG4gIH0pO1xuICBjaGFyc1RvTGluZXMoZGlmZnMsIGxpbmVhcnJheSksIGRpZmZzID0gY2xlYW51cFNlbWFudGljKGRpZmZzKSwgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgXCJcIl0pO1xuICBsZXQgcG9pbnRlciA9IDAsIGNvdW50RGVsZXRlID0gMCwgY291bnRJbnNlcnQgPSAwLCB0ZXh0RGVsZXRlID0gXCJcIiwgdGV4dEluc2VydCA9IFwiXCI7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoOyApIHtcbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBjb3VudEluc2VydCsrLCB0ZXh0SW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGNvdW50RGVsZXRlKyssIHRleHREZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBpZiAoY291bnREZWxldGUgPj0gMSAmJiBjb3VudEluc2VydCA+PSAxKSB7XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0LCBjb3VudERlbGV0ZSArIGNvdW50SW5zZXJ0KSwgcG9pbnRlciA9IHBvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0O1xuICAgICAgICAgIGNvbnN0IGFhID0gZG9EaWZmKHRleHREZWxldGUsIHRleHRJbnNlcnQsIHtcbiAgICAgICAgICAgIGNoZWNrTGluZXM6ICExLFxuICAgICAgICAgICAgZGVhZGxpbmU6IG9wdHMuZGVhZGxpbmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gYWEubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBhYVtqXSk7XG4gICAgICAgICAgcG9pbnRlciArPSBhYS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRJbnNlcnQgPSAwLCBjb3VudERlbGV0ZSA9IDAsIHRleHREZWxldGUgPSBcIlwiLCB0ZXh0SW5zZXJ0ID0gXCJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRpZmYgb3BlcmF0aW9uLlwiKTtcbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIHJldHVybiBkaWZmcy5wb3AoKSwgZGlmZnM7XG59XG5mdW5jdGlvbiBjb21wdXRlRGlmZih0ZXh0MSwgdGV4dDIsIG9wdHMpIHtcbiAgbGV0IGRpZmZzO1xuICBpZiAoIXRleHQxKSByZXR1cm4gW1tESUZGX0lOU0VSVCwgdGV4dDJdXTtcbiAgaWYgKCF0ZXh0MikgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXV07XG4gIGNvbnN0IGxvbmd0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0Miwgc2hvcnR0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MSwgaSA9IGxvbmd0ZXh0LmluZGV4T2Yoc2hvcnR0ZXh0KTtcbiAgaWYgKGkgIT09IC0xKSByZXR1cm4gZGlmZnMgPSBbW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSldLCBbRElGRl9FUVVBTCwgc2hvcnR0ZXh0XSwgW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoaSArIHNob3J0dGV4dC5sZW5ndGgpXV0sIHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCAmJiAoZGlmZnNbMF1bMF0gPSBESUZGX0RFTEVURSwgZGlmZnNbMl1bMF0gPSBESUZGX0RFTEVURSksIGRpZmZzO1xuICBpZiAoc2hvcnR0ZXh0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xuICBjb25zdCBoYWxmTWF0Y2ggPSBmaW5kSGFsZk1hdGNoKHRleHQxLCB0ZXh0Mik7XG4gIGlmIChoYWxmTWF0Y2gpIHtcbiAgICBjb25zdCB0ZXh0MUEgPSBoYWxmTWF0Y2hbMF0sIHRleHQxQiA9IGhhbGZNYXRjaFsxXSwgdGV4dDJBID0gaGFsZk1hdGNoWzJdLCB0ZXh0MkIgPSBoYWxmTWF0Y2hbM10sIG1pZENvbW1vbiA9IGhhbGZNYXRjaFs0XSwgZGlmZnNBID0gZG9EaWZmKHRleHQxQSwgdGV4dDJBLCBvcHRzKSwgZGlmZnNCID0gZG9EaWZmKHRleHQxQiwgdGV4dDJCLCBvcHRzKTtcbiAgICByZXR1cm4gZGlmZnNBLmNvbmNhdChbW0RJRkZfRVFVQUwsIG1pZENvbW1vbl1dLCBkaWZmc0IpO1xuICB9XG4gIHJldHVybiBvcHRzLmNoZWNrTGluZXMgJiYgdGV4dDEubGVuZ3RoID4gMTAwICYmIHRleHQyLmxlbmd0aCA+IDEwMCA/IGRvTGluZU1vZGVEaWZmKHRleHQxLCB0ZXh0Miwgb3B0cykgOiBiaXNlY3QodGV4dDEsIHRleHQyLCBvcHRzLmRlYWRsaW5lKTtcbn1cbnZhciBfX2RlZlByb3AkMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19nZXRPd25Qcm9wU3ltYm9scyQyID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgX19oYXNPd25Qcm9wJDIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBfX3Byb3BJc0VudW0kMiA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIF9fZGVmTm9ybWFsUHJvcCQyID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQyKG9iaiwga2V5LCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBjb25maWd1cmFibGU6ICEwLFxuICB3cml0YWJsZTogITAsXG4gIHZhbHVlXG59KSA6IG9ialtrZXldID0gdmFsdWUsIF9fc3ByZWFkVmFsdWVzJDIgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpIF9faGFzT3duUHJvcCQyLmNhbGwoYiwgcHJvcCkgJiYgX19kZWZOb3JtYWxQcm9wJDIoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzJDIpIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyQyKGIpKSBfX3Byb3BJc0VudW0kMi5jYWxsKGIsIHByb3ApICYmIF9fZGVmTm9ybWFsUHJvcCQyKGEsIHByb3AsIGJbcHJvcF0pO1xuICByZXR1cm4gYTtcbn07XG5jb25zdCBESUZGX0RFTEVURSA9IC0xLCBESUZGX0lOU0VSVCA9IDEsIERJRkZfRVFVQUwgPSAwO1xuZnVuY3Rpb24gZGlmZih0ZXh0QSwgdGV4dEIsIG9wdHMpIHtcbiAgaWYgKHRleHRBID09PSBudWxsIHx8IHRleHRCID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJOdWxsIGlucHV0LiAoZGlmZilcIik7XG4gIGNvbnN0IGRpZmZzID0gZG9EaWZmKHRleHRBLCB0ZXh0QiwgY3JlYXRlSW50ZXJuYWxPcHRzKG9wdHMgfHwge30pKTtcbiAgcmV0dXJuIGFkanVzdERpZmZGb3JTdXJyb2dhdGVQYWlycyhkaWZmcyksIGRpZmZzO1xufVxuZnVuY3Rpb24gZG9EaWZmKHRleHRBLCB0ZXh0Qiwgb3B0aW9ucykge1xuICBsZXQgdGV4dDEgPSB0ZXh0QSwgdGV4dDIgPSB0ZXh0QjtcbiAgaWYgKHRleHQxID09PSB0ZXh0MikgcmV0dXJuIHRleHQxID8gW1tESUZGX0VRVUFMLCB0ZXh0MV1dIDogW107XG4gIGxldCBjb21tb25sZW5ndGggPSBnZXRDb21tb25QcmVmaXgodGV4dDEsIHRleHQyKTtcbiAgY29uc3QgY29tbW9ucHJlZml4ID0gdGV4dDEuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCksIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCksIGNvbW1vbmxlbmd0aCA9IGdldENvbW1vblN1ZmZpeCh0ZXh0MSwgdGV4dDIpO1xuICBjb25zdCBjb21tb25zdWZmaXggPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKSwgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDIubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgbGV0IGRpZmZzID0gY29tcHV0ZURpZmYodGV4dDEsIHRleHQyLCBvcHRpb25zKTtcbiAgcmV0dXJuIGNvbW1vbnByZWZpeCAmJiBkaWZmcy51bnNoaWZ0KFtESUZGX0VRVUFMLCBjb21tb25wcmVmaXhdKSwgY29tbW9uc3VmZml4ICYmIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIGNvbW1vbnN1ZmZpeF0pLCBkaWZmcyA9IGNsZWFudXBNZXJnZShkaWZmcyksIGRpZmZzO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVhZExpbmUodGltZW91dCkge1xuICBsZXQgdCA9IDE7XG4gIHJldHVybiB0eXBlb2YgdGltZW91dCA8IFwidVwiICYmICh0ID0gdGltZW91dCA8PSAwID8gTnVtYmVyLk1BWF9WQUxVRSA6IHRpbWVvdXQpLCBEYXRlLm5vdygpICsgdCAqIDFlMztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsT3B0cyhvcHRzKSB7XG4gIHJldHVybiBfX3NwcmVhZFZhbHVlcyQyKHtcbiAgICBjaGVja0xpbmVzOiAhMCxcbiAgICBkZWFkbGluZTogY3JlYXRlRGVhZExpbmUob3B0cy50aW1lb3V0IHx8IDEpXG4gIH0sIG9wdHMpO1xufVxuZnVuY3Rpb24gY29tYmluZUNoYXIoZGF0YSwgY2hhciwgZGlyKSB7XG4gIHJldHVybiBkaXIgPT09IDEgPyBkYXRhICsgY2hhciA6IGNoYXIgKyBkYXRhO1xufVxuZnVuY3Rpb24gc3BsaXRDaGFyKGRhdGEsIGRpcikge1xuICByZXR1cm4gZGlyID09PSAxID8gW2RhdGEuc3Vic3RyaW5nKDAsIGRhdGEubGVuZ3RoIC0gMSksIGRhdGFbZGF0YS5sZW5ndGggLSAxXV0gOiBbZGF0YS5zdWJzdHJpbmcoMSksIGRhdGFbMF1dO1xufVxuZnVuY3Rpb24gaGFzU2hhcmVkQ2hhcihkaWZmcywgaSwgaiwgZGlyKSB7XG4gIHJldHVybiBkaXIgPT09IDEgPyBkaWZmc1tpXVsxXVtkaWZmc1tpXVsxXS5sZW5ndGggLSAxXSA9PT0gZGlmZnNbal1bMV1bZGlmZnNbal1bMV0ubGVuZ3RoIC0gMV0gOiBkaWZmc1tpXVsxXVswXSA9PT0gZGlmZnNbal1bMV1bMF07XG59XG5mdW5jdGlvbiBkZWlzb2xhdGVDaGFyKGRpZmZzLCBpLCBkaXIpIHtcbiAgY29uc3QgaW52ID0gZGlyID09PSAxID8gLTEgOiAxO1xuICBsZXQgaW5zZXJ0SWR4ID0gbnVsbCwgZGVsZXRlSWR4ID0gbnVsbCwgaiA9IGkgKyBkaXI7XG4gIGZvciAoOyBqID49IDAgJiYgaiA8IGRpZmZzLmxlbmd0aCAmJiAoaW5zZXJ0SWR4ID09PSBudWxsIHx8IGRlbGV0ZUlkeCA9PT0gbnVsbCk7IGogKz0gZGlyKSB7XG4gICAgY29uc3QgW29wLCB0ZXh0Ml0gPSBkaWZmc1tqXTtcbiAgICBpZiAodGV4dDIubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpZiAob3AgPT09IERJRkZfSU5TRVJUKSB7XG4gICAgICAgIGluc2VydElkeCA9PT0gbnVsbCAmJiAoaW5zZXJ0SWR4ID0gaik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChvcCA9PT0gRElGRl9ERUxFVEUpIHtcbiAgICAgICAgZGVsZXRlSWR4ID09PSBudWxsICYmIChkZWxldGVJZHggPSBqKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKG9wID09PSBESUZGX0VRVUFMKSB7XG4gICAgICAgIGlmIChpbnNlcnRJZHggPT09IG51bGwgJiYgZGVsZXRlSWR4ID09PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgW3Jlc3QsIGNoYXIyXSA9IHNwbGl0Q2hhcihkaWZmc1tpXVsxXSwgZGlyKTtcbiAgICAgICAgICBkaWZmc1tpXVsxXSA9IHJlc3QsIGRpZmZzW2pdWzFdID0gY29tYmluZUNoYXIoZGlmZnNbal1bMV0sIGNoYXIyLCBpbnYpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGluc2VydElkeCAhPT0gbnVsbCAmJiBkZWxldGVJZHggIT09IG51bGwgJiYgaGFzU2hhcmVkQ2hhcihkaWZmcywgaW5zZXJ0SWR4LCBkZWxldGVJZHgsIGRpcikpIHtcbiAgICBjb25zdCBbaW5zZXJ0VGV4dDIsIGluc2VydENoYXJdID0gc3BsaXRDaGFyKGRpZmZzW2luc2VydElkeF1bMV0sIGludiksIFtkZWxldGVUZXh0XSA9IHNwbGl0Q2hhcihkaWZmc1tkZWxldGVJZHhdWzFdLCBpbnYpO1xuICAgIGRpZmZzW2luc2VydElkeF1bMV0gPSBpbnNlcnRUZXh0MiwgZGlmZnNbZGVsZXRlSWR4XVsxXSA9IGRlbGV0ZVRleHQsIGRpZmZzW2ldWzFdID0gY29tYmluZUNoYXIoZGlmZnNbaV1bMV0sIGluc2VydENoYXIsIGRpcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IFt0ZXh0LCBjaGFyXSA9IHNwbGl0Q2hhcihkaWZmc1tpXVsxXSwgZGlyKTtcbiAgZGlmZnNbaV1bMV0gPSB0ZXh0LCBpbnNlcnRJZHggPT09IG51bGwgPyAoZGlmZnMuc3BsaWNlKGosIDAsIFtESUZGX0lOU0VSVCwgY2hhcl0pLCBkZWxldGVJZHggIT09IG51bGwgJiYgZGVsZXRlSWR4ID49IGogJiYgZGVsZXRlSWR4KyspIDogZGlmZnNbaW5zZXJ0SWR4XVsxXSA9IGNvbWJpbmVDaGFyKGRpZmZzW2luc2VydElkeF1bMV0sIGNoYXIsIGludiksIGRlbGV0ZUlkeCA9PT0gbnVsbCA/IGRpZmZzLnNwbGljZShqLCAwLCBbRElGRl9ERUxFVEUsIGNoYXJdKSA6IGRpZmZzW2RlbGV0ZUlkeF1bMV0gPSBjb21iaW5lQ2hhcihkaWZmc1tkZWxldGVJZHhdWzFdLCBjaGFyLCBpbnYpO1xufVxuZnVuY3Rpb24gYWRqdXN0RGlmZkZvclN1cnJvZ2F0ZVBhaXJzKGRpZmZzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBbZGlmZlR5cGUsIGRpZmZUZXh0XSA9IGRpZmZzW2ldO1xuICAgIGlmIChkaWZmVGV4dC5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuICAgIGNvbnN0IGZpcnN0Q2hhciA9IGRpZmZUZXh0WzBdLCBsYXN0Q2hhciA9IGRpZmZUZXh0W2RpZmZUZXh0Lmxlbmd0aCAtIDFdO1xuICAgIGlzSGlnaFN1cnJvZ2F0ZShsYXN0Q2hhcikgJiYgZGlmZlR5cGUgPT09IERJRkZfRVFVQUwgJiYgZGVpc29sYXRlQ2hhcihkaWZmcywgaSwgMSksIGlzTG93U3Vycm9nYXRlKGZpcnN0Q2hhcikgJiYgZGlmZlR5cGUgPT09IERJRkZfRVFVQUwgJiYgZGVpc29sYXRlQ2hhcihkaWZmcywgaSwgLTEpO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZnMubGVuZ3RoOyBpKyspIGRpZmZzW2ldWzFdLmxlbmd0aCA9PT0gMCAmJiBkaWZmcy5zcGxpY2UoaSwgMSk7XG59XG5mdW5jdGlvbiBjbGVhbnVwU2VtYW50aWMocmF3RGlmZnMpIHtcbiAgbGV0IGRpZmZzID0gcmF3RGlmZnMubWFwKChkaWZmMikgPT4gY2xvbmVEaWZmKGRpZmYyKSksIGhhc0NoYW5nZXMgPSAhMTtcbiAgY29uc3QgZXF1YWxpdGllcyA9IFtdO1xuICBsZXQgZXF1YWxpdGllc0xlbmd0aCA9IDAsIGxhc3RFcXVhbGl0eSA9IG51bGwsIHBvaW50ZXIgPSAwLCBsZW5ndGhJbnNlcnRpb25zMSA9IDAsIGxlbmd0aERlbGV0aW9uczEgPSAwLCBsZW5ndGhJbnNlcnRpb25zMiA9IDAsIGxlbmd0aERlbGV0aW9uczIgPSAwO1xuICBmb3IgKDsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aDsgKSBkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9FUVVBTCA/IChlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgrK10gPSBwb2ludGVyLCBsZW5ndGhJbnNlcnRpb25zMSA9IGxlbmd0aEluc2VydGlvbnMyLCBsZW5ndGhEZWxldGlvbnMxID0gbGVuZ3RoRGVsZXRpb25zMiwgbGVuZ3RoSW5zZXJ0aW9uczIgPSAwLCBsZW5ndGhEZWxldGlvbnMyID0gMCwgbGFzdEVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV0pIDogKGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0lOU0VSVCA/IGxlbmd0aEluc2VydGlvbnMyICs9IGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCA6IGxlbmd0aERlbGV0aW9uczIgKz0gZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoLCBsYXN0RXF1YWxpdHkgJiYgbGFzdEVxdWFsaXR5Lmxlbmd0aCA8PSBNYXRoLm1heChsZW5ndGhJbnNlcnRpb25zMSwgbGVuZ3RoRGVsZXRpb25zMSkgJiYgbGFzdEVxdWFsaXR5Lmxlbmd0aCA8PSBNYXRoLm1heChsZW5ndGhJbnNlcnRpb25zMiwgbGVuZ3RoRGVsZXRpb25zMikgJiYgKGRpZmZzLnNwbGljZShlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSwgMCwgW0RJRkZfREVMRVRFLCBsYXN0RXF1YWxpdHldKSwgZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gKyAxXVswXSA9IERJRkZfSU5TRVJULCBlcXVhbGl0aWVzTGVuZ3RoLS0sIGVxdWFsaXRpZXNMZW5ndGgtLSwgcG9pbnRlciA9IGVxdWFsaXRpZXNMZW5ndGggPiAwID8gZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gOiAtMSwgbGVuZ3RoSW5zZXJ0aW9uczEgPSAwLCBsZW5ndGhEZWxldGlvbnMxID0gMCwgbGVuZ3RoSW5zZXJ0aW9uczIgPSAwLCBsZW5ndGhEZWxldGlvbnMyID0gMCwgbGFzdEVxdWFsaXR5ID0gbnVsbCwgaGFzQ2hhbmdlcyA9ICEwKSksIHBvaW50ZXIrKztcbiAgZm9yIChoYXNDaGFuZ2VzICYmIChkaWZmcyA9IGNsZWFudXBNZXJnZShkaWZmcykpLCBkaWZmcyA9IGNsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKSwgcG9pbnRlciA9IDE7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGg7ICkge1xuICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT09IERJRkZfREVMRVRFICYmIGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0lOU0VSVCkge1xuICAgICAgY29uc3QgZGVsZXRpb24gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0sIGluc2VydGlvbiA9IGRpZmZzW3BvaW50ZXJdWzFdLCBvdmVybGFwTGVuZ3RoMSA9IGdldENvbW1vbk92ZXJsYXAoZGVsZXRpb24sIGluc2VydGlvbiksIG92ZXJsYXBMZW5ndGgyID0gZ2V0Q29tbW9uT3ZlcmxhcChpbnNlcnRpb24sIGRlbGV0aW9uKTtcbiAgICAgIG92ZXJsYXBMZW5ndGgxID49IG92ZXJsYXBMZW5ndGgyID8gKG92ZXJsYXBMZW5ndGgxID49IGRlbGV0aW9uLmxlbmd0aCAvIDIgfHwgb3ZlcmxhcExlbmd0aDEgPj0gaW5zZXJ0aW9uLmxlbmd0aCAvIDIpICYmIChkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RJRkZfRVFVQUwsIGluc2VydGlvbi5zdWJzdHJpbmcoMCwgb3ZlcmxhcExlbmd0aDEpXSksIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9IGRlbGV0aW9uLnN1YnN0cmluZygwLCBkZWxldGlvbi5sZW5ndGggLSBvdmVybGFwTGVuZ3RoMSksIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGluc2VydGlvbi5zdWJzdHJpbmcob3ZlcmxhcExlbmd0aDEpLCBwb2ludGVyKyspIDogKG92ZXJsYXBMZW5ndGgyID49IGRlbGV0aW9uLmxlbmd0aCAvIDIgfHwgb3ZlcmxhcExlbmd0aDIgPj0gaW5zZXJ0aW9uLmxlbmd0aCAvIDIpICYmIChkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RJRkZfRVFVQUwsIGRlbGV0aW9uLnN1YnN0cmluZygwLCBvdmVybGFwTGVuZ3RoMildKSwgZGlmZnNbcG9pbnRlciAtIDFdWzBdID0gRElGRl9JTlNFUlQsIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9IGluc2VydGlvbi5zdWJzdHJpbmcoMCwgaW5zZXJ0aW9uLmxlbmd0aCAtIG92ZXJsYXBMZW5ndGgyKSwgZGlmZnNbcG9pbnRlciArIDFdWzBdID0gRElGRl9ERUxFVEUsIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGRlbGV0aW9uLnN1YnN0cmluZyhvdmVybGFwTGVuZ3RoMiksIHBvaW50ZXIrKyksIHBvaW50ZXIrKztcbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIHJldHVybiBkaWZmcztcbn1cbmNvbnN0IG5vbkFscGhhTnVtZXJpY1JlZ2V4ID0gL1teYS16QS1aMC05XS8sIHdoaXRlc3BhY2VSZWdleCA9IC9cXHMvLCBsaW5lYnJlYWtSZWdleCA9IC9bXFxyXFxuXS8sIGJsYW5rbGluZUVuZFJlZ2V4ID0gL1xcblxccj9cXG4kLywgYmxhbmtsaW5lU3RhcnRSZWdleCA9IC9eXFxyP1xcblxccj9cXG4vO1xuZnVuY3Rpb24gY2xlYW51cFNlbWFudGljTG9zc2xlc3MocmF3RGlmZnMpIHtcbiAgY29uc3QgZGlmZnMgPSByYXdEaWZmcy5tYXAoKGRpZmYyKSA9PiBjbG9uZURpZmYoZGlmZjIpKTtcbiAgZnVuY3Rpb24gZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKG9uZSwgdHdvKSB7XG4gICAgaWYgKCFvbmUgfHwgIXR3bykgcmV0dXJuIDY7XG4gICAgY29uc3QgY2hhcjEgPSBvbmUuY2hhckF0KG9uZS5sZW5ndGggLSAxKSwgY2hhcjIgPSB0d28uY2hhckF0KDApLCBub25BbHBoYU51bWVyaWMxID0gY2hhcjEubWF0Y2gobm9uQWxwaGFOdW1lcmljUmVnZXgpLCBub25BbHBoYU51bWVyaWMyID0gY2hhcjIubWF0Y2gobm9uQWxwaGFOdW1lcmljUmVnZXgpLCB3aGl0ZXNwYWNlMSA9IG5vbkFscGhhTnVtZXJpYzEgJiYgY2hhcjEubWF0Y2god2hpdGVzcGFjZVJlZ2V4KSwgd2hpdGVzcGFjZTIgPSBub25BbHBoYU51bWVyaWMyICYmIGNoYXIyLm1hdGNoKHdoaXRlc3BhY2VSZWdleCksIGxpbmVCcmVhazEgPSB3aGl0ZXNwYWNlMSAmJiBjaGFyMS5tYXRjaChsaW5lYnJlYWtSZWdleCksIGxpbmVCcmVhazIgPSB3aGl0ZXNwYWNlMiAmJiBjaGFyMi5tYXRjaChsaW5lYnJlYWtSZWdleCksIGJsYW5rTGluZTEgPSBsaW5lQnJlYWsxICYmIG9uZS5tYXRjaChibGFua2xpbmVFbmRSZWdleCksIGJsYW5rTGluZTIgPSBsaW5lQnJlYWsyICYmIHR3by5tYXRjaChibGFua2xpbmVTdGFydFJlZ2V4KTtcbiAgICByZXR1cm4gYmxhbmtMaW5lMSB8fCBibGFua0xpbmUyID8gNSA6IGxpbmVCcmVhazEgfHwgbGluZUJyZWFrMiA/IDQgOiBub25BbHBoYU51bWVyaWMxICYmICF3aGl0ZXNwYWNlMSAmJiB3aGl0ZXNwYWNlMiA/IDMgOiB3aGl0ZXNwYWNlMSB8fCB3aGl0ZXNwYWNlMiA/IDIgOiBub25BbHBoYU51bWVyaWMxIHx8IG5vbkFscGhhTnVtZXJpYzIgPyAxIDogMDtcbiAgfVxuICBsZXQgcG9pbnRlciA9IDE7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMTsgKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmc1twb2ludGVyICsgMV1bMF0gPT09IERJRkZfRVFVQUwpIHtcbiAgICAgIGxldCBlcXVhbGl0eTEgPSBkaWZmc1twb2ludGVyIC0gMV1bMV0sIGVkaXQgPSBkaWZmc1twb2ludGVyXVsxXSwgZXF1YWxpdHkyID0gZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgY29uc3QgY29tbW9uT2Zmc2V0ID0gZ2V0Q29tbW9uU3VmZml4KGVxdWFsaXR5MSwgZWRpdCk7XG4gICAgICBpZiAoY29tbW9uT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGNvbW1vblN0cmluZyA9IGVkaXQuc3Vic3RyaW5nKGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZXF1YWxpdHkxID0gZXF1YWxpdHkxLnN1YnN0cmluZygwLCBlcXVhbGl0eTEubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KSwgZWRpdCA9IGNvbW1vblN0cmluZyArIGVkaXQuc3Vic3RyaW5nKDAsIGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KSwgZXF1YWxpdHkyID0gY29tbW9uU3RyaW5nICsgZXF1YWxpdHkyO1xuICAgICAgfVxuICAgICAgbGV0IGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTEsIGJlc3RFZGl0ID0gZWRpdCwgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5MiwgYmVzdFNjb3JlID0gZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKGVxdWFsaXR5MSwgZWRpdCkgKyBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZWRpdCwgZXF1YWxpdHkyKTtcbiAgICAgIGZvciAoOyBlZGl0LmNoYXJBdCgwKSA9PT0gZXF1YWxpdHkyLmNoYXJBdCgwKTsgKSB7XG4gICAgICAgIGVxdWFsaXR5MSArPSBlZGl0LmNoYXJBdCgwKSwgZWRpdCA9IGVkaXQuc3Vic3RyaW5nKDEpICsgZXF1YWxpdHkyLmNoYXJBdCgwKSwgZXF1YWxpdHkyID0gZXF1YWxpdHkyLnN1YnN0cmluZygxKTtcbiAgICAgICAgY29uc3Qgc2NvcmUgPSBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZXF1YWxpdHkxLCBlZGl0KSArIGRpZmZDbGVhbnVwU2VtYW50aWNTY29yZShlZGl0LCBlcXVhbGl0eTIpO1xuICAgICAgICBzY29yZSA+PSBiZXN0U2NvcmUgJiYgKGJlc3RTY29yZSA9IHNjb3JlLCBiZXN0RXF1YWxpdHkxID0gZXF1YWxpdHkxLCBiZXN0RWRpdCA9IGVkaXQsIGJlc3RFcXVhbGl0eTIgPSBlcXVhbGl0eTIpO1xuICAgICAgfVxuICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdICE9PSBiZXN0RXF1YWxpdHkxICYmIChiZXN0RXF1YWxpdHkxID8gZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gYmVzdEVxdWFsaXR5MSA6IChkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpLCBwb2ludGVyLS0pLCBkaWZmc1twb2ludGVyXVsxXSA9IGJlc3RFZGl0LCBiZXN0RXF1YWxpdHkyID8gZGlmZnNbcG9pbnRlciArIDFdWzFdID0gYmVzdEVxdWFsaXR5MiA6IChkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpLCBwb2ludGVyLS0pKTtcbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIHJldHVybiBkaWZmcztcbn1cbmZ1bmN0aW9uIGNsZWFudXBNZXJnZShyYXdEaWZmcykge1xuICBsZXQgZGlmZnMgPSByYXdEaWZmcy5tYXAoKGRpZmYyKSA9PiBjbG9uZURpZmYoZGlmZjIpKTtcbiAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgXCJcIl0pO1xuICBsZXQgcG9pbnRlciA9IDAsIGNvdW50RGVsZXRlID0gMCwgY291bnRJbnNlcnQgPSAwLCB0ZXh0RGVsZXRlID0gXCJcIiwgdGV4dEluc2VydCA9IFwiXCIsIGNvbW1vbmxlbmd0aDtcbiAgZm9yICg7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGg7ICkgc3dpdGNoIChkaWZmc1twb2ludGVyXVswXSkge1xuICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICBjb3VudEluc2VydCsrLCB0ZXh0SW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdLCBwb2ludGVyKys7XG4gICAgICBicmVhaztcbiAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgY291bnREZWxldGUrKywgdGV4dERlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXSwgcG9pbnRlcisrO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgY291bnREZWxldGUgKyBjb3VudEluc2VydCA+IDEgPyAoY291bnREZWxldGUgIT09IDAgJiYgY291bnRJbnNlcnQgIT09IDAgJiYgKGNvbW1vbmxlbmd0aCA9IGdldENvbW1vblByZWZpeCh0ZXh0SW5zZXJ0LCB0ZXh0RGVsZXRlKSwgY29tbW9ubGVuZ3RoICE9PSAwICYmIChwb2ludGVyIC0gY291bnREZWxldGUgLSBjb3VudEluc2VydCA+IDAgJiYgZGlmZnNbcG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQgLSAxXVswXSA9PT0gRElGRl9FUVVBTCA/IGRpZmZzW3BvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0IC0gMV1bMV0gKz0gdGV4dEluc2VydC5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKSA6IChkaWZmcy5zcGxpY2UoMCwgMCwgW0RJRkZfRVFVQUwsIHRleHRJbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCldKSwgcG9pbnRlcisrKSwgdGV4dEluc2VydCA9IHRleHRJbnNlcnQuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCksIHRleHREZWxldGUgPSB0ZXh0RGVsZXRlLnN1YnN0cmluZyhjb21tb25sZW5ndGgpKSwgY29tbW9ubGVuZ3RoID0gZ2V0Q29tbW9uU3VmZml4KHRleHRJbnNlcnQsIHRleHREZWxldGUpLCBjb21tb25sZW5ndGggIT09IDAgJiYgKGRpZmZzW3BvaW50ZXJdWzFdID0gdGV4dEluc2VydC5zdWJzdHJpbmcodGV4dEluc2VydC5sZW5ndGggLSBjb21tb25sZW5ndGgpICsgZGlmZnNbcG9pbnRlcl1bMV0sIHRleHRJbnNlcnQgPSB0ZXh0SW5zZXJ0LnN1YnN0cmluZygwLCB0ZXh0SW5zZXJ0Lmxlbmd0aCAtIGNvbW1vbmxlbmd0aCksIHRleHREZWxldGUgPSB0ZXh0RGVsZXRlLnN1YnN0cmluZygwLCB0ZXh0RGVsZXRlLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCkpKSwgcG9pbnRlciAtPSBjb3VudERlbGV0ZSArIGNvdW50SW5zZXJ0LCBkaWZmcy5zcGxpY2UocG9pbnRlciwgY291bnREZWxldGUgKyBjb3VudEluc2VydCksIHRleHREZWxldGUubGVuZ3RoICYmIChkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RJRkZfREVMRVRFLCB0ZXh0RGVsZXRlXSksIHBvaW50ZXIrKyksIHRleHRJbnNlcnQubGVuZ3RoICYmIChkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RJRkZfSU5TRVJULCB0ZXh0SW5zZXJ0XSksIHBvaW50ZXIrKyksIHBvaW50ZXIrKykgOiBwb2ludGVyICE9PSAwICYmIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9FUVVBTCA/IChkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlcl1bMV0sIGRpZmZzLnNwbGljZShwb2ludGVyLCAxKSkgOiBwb2ludGVyKyssIGNvdW50SW5zZXJ0ID0gMCwgY291bnREZWxldGUgPSAwLCB0ZXh0RGVsZXRlID0gXCJcIiwgdGV4dEluc2VydCA9IFwiXCI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkaWZmIG9wZXJhdGlvblwiKTtcbiAgfVxuICBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXSA9PT0gXCJcIiAmJiBkaWZmcy5wb3AoKTtcbiAgbGV0IGhhc0NoYW5nZXMgPSAhMTtcbiAgZm9yIChwb2ludGVyID0gMTsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aCAtIDE7ICkgZGlmZnNbcG9pbnRlciAtIDFdWzBdID09PSBESUZGX0VRVUFMICYmIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PT0gRElGRl9FUVVBTCAmJiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpID09PSBkaWZmc1twb2ludGVyIC0gMV1bMV0gPyAoZGlmZnNbcG9pbnRlcl1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gKyBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC0gZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCksIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSwgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSAxLCAxKSwgaGFzQ2hhbmdlcyA9ICEwKSA6IGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSA9PT0gZGlmZnNbcG9pbnRlciArIDFdWzFdICYmIChkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlciArIDFdWzFdLCBkaWZmc1twb2ludGVyXVsxXSA9IGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSArIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSwgZGlmZnMuc3BsaWNlKHBvaW50ZXIgKyAxLCAxKSwgaGFzQ2hhbmdlcyA9ICEwKSksIHBvaW50ZXIrKztcbiAgcmV0dXJuIGhhc0NoYW5nZXMgJiYgKGRpZmZzID0gY2xlYW51cE1lcmdlKGRpZmZzKSksIGRpZmZzO1xufVxuZnVuY3Rpb24gdHJ1ZUNvdW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3MucmVkdWNlKChuLCBib29sKSA9PiBuICsgKGJvb2wgPyAxIDogMCksIDApO1xufVxuZnVuY3Rpb24gY2xlYW51cEVmZmljaWVuY3kocmF3RGlmZnMsIGVkaXRDb3N0ID0gNCkge1xuICBsZXQgZGlmZnMgPSByYXdEaWZmcy5tYXAoKGRpZmYyKSA9PiBjbG9uZURpZmYoZGlmZjIpKSwgaGFzQ2hhbmdlcyA9ICExO1xuICBjb25zdCBlcXVhbGl0aWVzID0gW107XG4gIGxldCBlcXVhbGl0aWVzTGVuZ3RoID0gMCwgbGFzdEVxdWFsaXR5ID0gbnVsbCwgcG9pbnRlciA9IDAsIHByZUlucyA9ICExLCBwcmVEZWwgPSAhMSwgcG9zdElucyA9ICExLCBwb3N0RGVsID0gITE7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoOyApIGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0VRVUFMID8gKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCA8IGVkaXRDb3N0ICYmIChwb3N0SW5zIHx8IHBvc3REZWwpID8gKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCsrXSA9IHBvaW50ZXIsIHByZUlucyA9IHBvc3RJbnMsIHByZURlbCA9IHBvc3REZWwsIGxhc3RFcXVhbGl0eSA9IGRpZmZzW3BvaW50ZXJdWzFdKSA6IChlcXVhbGl0aWVzTGVuZ3RoID0gMCwgbGFzdEVxdWFsaXR5ID0gbnVsbCksIHBvc3RJbnMgPSAhMSwgcG9zdERlbCA9ICExKSA6IChkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9ERUxFVEUgPyBwb3N0RGVsID0gITAgOiBwb3N0SW5zID0gITAsIGxhc3RFcXVhbGl0eSAmJiAocHJlSW5zICYmIHByZURlbCAmJiBwb3N0SW5zICYmIHBvc3REZWwgfHwgbGFzdEVxdWFsaXR5Lmxlbmd0aCA8IGVkaXRDb3N0IC8gMiAmJiB0cnVlQ291bnQocHJlSW5zLCBwcmVEZWwsIHBvc3RJbnMsIHBvc3REZWwpID09PSAzKSAmJiAoZGlmZnMuc3BsaWNlKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLCAwLCBbRElGRl9ERUxFVEUsIGxhc3RFcXVhbGl0eV0pLCBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRElGRl9JTlNFUlQsIGVxdWFsaXRpZXNMZW5ndGgtLSwgbGFzdEVxdWFsaXR5ID0gbnVsbCwgcHJlSW5zICYmIHByZURlbCA/IChwb3N0SW5zID0gITAsIHBvc3REZWwgPSAhMCwgZXF1YWxpdGllc0xlbmd0aCA9IDApIDogKGVxdWFsaXRpZXNMZW5ndGgtLSwgcG9pbnRlciA9IGVxdWFsaXRpZXNMZW5ndGggPiAwID8gZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gOiAtMSwgcG9zdElucyA9ICExLCBwb3N0RGVsID0gITEpLCBoYXNDaGFuZ2VzID0gITApKSwgcG9pbnRlcisrO1xuICByZXR1cm4gaGFzQ2hhbmdlcyAmJiAoZGlmZnMgPSBjbGVhbnVwTWVyZ2UoZGlmZnMpKSwgZGlmZnM7XG59XG52YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIF9fZ2V0T3duUHJvcFN5bWJvbHMkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIF9faGFzT3duUHJvcCQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgX19wcm9wSXNFbnVtJDEgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBfX2RlZk5vcm1hbFByb3AkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMShvYmosIGtleSwge1xuICBlbnVtZXJhYmxlOiAhMCxcbiAgY29uZmlndXJhYmxlOiAhMCxcbiAgd3JpdGFibGU6ICEwLFxuICB2YWx1ZVxufSkgOiBvYmpba2V5XSA9IHZhbHVlLCBfX3NwcmVhZFZhbHVlcyQxID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKSBfX2hhc093blByb3AkMS5jYWxsKGIsIHByb3ApICYmIF9fZGVmTm9ybWFsUHJvcCQxKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scyQxKSBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMkMShiKSkgX19wcm9wSXNFbnVtJDEuY2FsbChiLCBwcm9wKSAmJiBfX2RlZk5vcm1hbFByb3AkMShhLCBwcm9wLCBiW3Byb3BdKTtcbiAgcmV0dXJuIGE7XG59O1xuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuICAvKipcbiAgICogQXQgd2hhdCBwb2ludCBpcyBubyBtYXRjaCBkZWNsYXJlZCAoMC4wID0gcGVyZmVjdGlvbiwgMS4wID0gdmVyeSBsb29zZSkuXG4gICAqL1xuICB0aHJlc2hvbGQ6IDAuNSxcbiAgLyoqXG4gICAqIEhvdyBmYXIgdG8gc2VhcmNoIGZvciBhIG1hdGNoICgwID0gZXhhY3QgbG9jYXRpb24sIDEwMDArID0gYnJvYWQgbWF0Y2gpLlxuICAgKiBBIG1hdGNoIHRoaXMgbWFueSBjaGFyYWN0ZXJzIGF3YXkgZnJvbSB0aGUgZXhwZWN0ZWQgbG9jYXRpb24gd2lsbCBhZGRcbiAgICogMS4wIHRvIHRoZSBzY29yZSAoMC4wIGlzIGEgcGVyZmVjdCBtYXRjaCkuXG4gICAqL1xuICBkaXN0YW5jZTogMWUzXG59O1xuZnVuY3Rpb24gYXBwbHlEZWZhdWx0cyhvcHRpb25zKSB7XG4gIHJldHVybiBfX3NwcmVhZFZhbHVlcyQxKF9fc3ByZWFkVmFsdWVzJDEoe30sIERFRkFVTFRfT1BUSU9OUyksIG9wdGlvbnMpO1xufVxuY29uc3QgTUFYX0JJVFMkMSA9IDMyO1xuZnVuY3Rpb24gYml0YXAodGV4dCwgcGF0dGVybiwgbG9jLCBvcHRzID0ge30pIHtcbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gTUFYX0JJVFMkMSkgdGhyb3cgbmV3IEVycm9yKFwiUGF0dGVybiB0b28gbG9uZyBmb3IgdGhpcyBicm93c2VyLlwiKTtcbiAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdHMob3B0cyksIHMgPSBnZXRBbHBoYWJldEZyb21QYXR0ZXJuKHBhdHRlcm4pO1xuICBmdW5jdGlvbiBnZXRCaXRhcFNjb3JlKGUsIHgpIHtcbiAgICBjb25zdCBhY2N1cmFjeSA9IGUgLyBwYXR0ZXJuLmxlbmd0aCwgcHJveGltaXR5ID0gTWF0aC5hYnMobG9jIC0geCk7XG4gICAgcmV0dXJuIG9wdGlvbnMuZGlzdGFuY2UgPyBhY2N1cmFjeSArIHByb3hpbWl0eSAvIG9wdGlvbnMuZGlzdGFuY2UgOiBwcm94aW1pdHkgPyAxIDogYWNjdXJhY3k7XG4gIH1cbiAgbGV0IHNjb3JlVGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGQsIGJlc3RMb2MgPSB0ZXh0LmluZGV4T2YocGF0dGVybiwgbG9jKTtcbiAgYmVzdExvYyAhPT0gLTEgJiYgKHNjb3JlVGhyZXNob2xkID0gTWF0aC5taW4oZ2V0Qml0YXBTY29yZSgwLCBiZXN0TG9jKSwgc2NvcmVUaHJlc2hvbGQpLCBiZXN0TG9jID0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCksIGJlc3RMb2MgIT09IC0xICYmIChzY29yZVRocmVzaG9sZCA9IE1hdGgubWluKGdldEJpdGFwU2NvcmUoMCwgYmVzdExvYyksIHNjb3JlVGhyZXNob2xkKSkpO1xuICBjb25zdCBtYXRjaG1hc2sgPSAxIDw8IHBhdHRlcm4ubGVuZ3RoIC0gMTtcbiAgYmVzdExvYyA9IC0xO1xuICBsZXQgYmluTWluLCBiaW5NaWQsIGJpbk1heCA9IHBhdHRlcm4ubGVuZ3RoICsgdGV4dC5sZW5ndGgsIGxhc3RSZCA9IFtdO1xuICBmb3IgKGxldCBkID0gMDsgZCA8IHBhdHRlcm4ubGVuZ3RoOyBkKyspIHtcbiAgICBmb3IgKGJpbk1pbiA9IDAsIGJpbk1pZCA9IGJpbk1heDsgYmluTWluIDwgYmluTWlkOyApIGdldEJpdGFwU2NvcmUoZCwgbG9jICsgYmluTWlkKSA8PSBzY29yZVRocmVzaG9sZCA/IGJpbk1pbiA9IGJpbk1pZCA6IGJpbk1heCA9IGJpbk1pZCwgYmluTWlkID0gTWF0aC5mbG9vcigoYmluTWF4IC0gYmluTWluKSAvIDIgKyBiaW5NaW4pO1xuICAgIGJpbk1heCA9IGJpbk1pZDtcbiAgICBsZXQgc3RhcnQgPSBNYXRoLm1heCgxLCBsb2MgLSBiaW5NaWQgKyAxKTtcbiAgICBjb25zdCBmaW5pc2ggPSBNYXRoLm1pbihsb2MgKyBiaW5NaWQsIHRleHQubGVuZ3RoKSArIHBhdHRlcm4ubGVuZ3RoLCByZCA9IG5ldyBBcnJheShmaW5pc2ggKyAyKTtcbiAgICByZFtmaW5pc2ggKyAxXSA9ICgxIDw8IGQpIC0gMTtcbiAgICBmb3IgKGxldCBqID0gZmluaXNoOyBqID49IHN0YXJ0OyBqLS0pIHtcbiAgICAgIGNvbnN0IGNoYXJNYXRjaCA9IHNbdGV4dC5jaGFyQXQoaiAtIDEpXTtcbiAgICAgIGlmIChkID09PSAwID8gcmRbal0gPSAocmRbaiArIDFdIDw8IDEgfCAxKSAmIGNoYXJNYXRjaCA6IHJkW2pdID0gKHJkW2ogKyAxXSA8PCAxIHwgMSkgJiBjaGFyTWF0Y2ggfCAoKGxhc3RSZFtqICsgMV0gfCBsYXN0UmRbal0pIDw8IDEgfCAxKSB8IGxhc3RSZFtqICsgMV0sIHJkW2pdICYgbWF0Y2htYXNrKSB7XG4gICAgICAgIGNvbnN0IHNjb3JlID0gZ2V0Qml0YXBTY29yZShkLCBqIC0gMSk7XG4gICAgICAgIGlmIChzY29yZSA8PSBzY29yZVRocmVzaG9sZCkgaWYgKHNjb3JlVGhyZXNob2xkID0gc2NvcmUsIGJlc3RMb2MgPSBqIC0gMSwgYmVzdExvYyA+IGxvYykgc3RhcnQgPSBNYXRoLm1heCgxLCAyICogbG9jIC0gYmVzdExvYyk7XG4gICAgICAgIGVsc2UgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChnZXRCaXRhcFNjb3JlKGQgKyAxLCBsb2MpID4gc2NvcmVUaHJlc2hvbGQpIGJyZWFrO1xuICAgIGxhc3RSZCA9IHJkO1xuICB9XG4gIHJldHVybiBiZXN0TG9jO1xufVxuZnVuY3Rpb24gZ2V0QWxwaGFiZXRGcm9tUGF0dGVybihwYXR0ZXJuKSB7XG4gIGNvbnN0IHMgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSBzW3BhdHRlcm4uY2hhckF0KGkpXSA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykgc1twYXR0ZXJuLmNoYXJBdChpKV0gfD0gMSA8PCBwYXR0ZXJuLmxlbmd0aCAtIGkgLSAxO1xuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIG1hdGNoKHRleHQsIHBhdHRlcm4sIHNlYXJjaExvY2F0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKHRleHQgPT09IG51bGwgfHwgcGF0dGVybiA9PT0gbnVsbCB8fCBzZWFyY2hMb2NhdGlvbiA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiTnVsbCBpbnB1dC4gKG1hdGNoKCkpXCIpO1xuICBjb25zdCBsb2MgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzZWFyY2hMb2NhdGlvbiwgdGV4dC5sZW5ndGgpKTtcbiAgaWYgKHRleHQgPT09IHBhdHRlcm4pIHJldHVybiAwO1xuICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICBpZiAodGV4dC5zdWJzdHJpbmcobG9jLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCkgPT09IHBhdHRlcm4pIHJldHVybiBsb2M7XG4gIH0gZWxzZSByZXR1cm4gLTE7XG4gIHJldHVybiBiaXRhcCh0ZXh0LCBwYXR0ZXJuLCBsb2MsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZGlmZlRleHQxKGRpZmZzKSB7XG4gIGNvbnN0IHRleHQgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykgZGlmZnNbeF1bMF0gIT09IERJRkZfSU5TRVJUICYmICh0ZXh0W3hdID0gZGlmZnNbeF1bMV0pO1xuICByZXR1cm4gdGV4dC5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZGlmZlRleHQyKGRpZmZzKSB7XG4gIGNvbnN0IHRleHQgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykgZGlmZnNbeF1bMF0gIT09IERJRkZfREVMRVRFICYmICh0ZXh0W3hdID0gZGlmZnNbeF1bMV0pO1xuICByZXR1cm4gdGV4dC5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gbGV2ZW5zaHRlaW4oZGlmZnMpIHtcbiAgbGV0IGxldmVuID0gMCwgaW5zZXJ0aW9ucyA9IDAsIGRlbGV0aW9ucyA9IDA7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBvcCA9IGRpZmZzW3hdWzBdLCBkYXRhID0gZGlmZnNbeF1bMV07XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgaW5zZXJ0aW9ucyArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBkZWxldGlvbnMgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBsZXZlbiArPSBNYXRoLm1heChpbnNlcnRpb25zLCBkZWxldGlvbnMpLCBpbnNlcnRpb25zID0gMCwgZGVsZXRpb25zID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRpZmYgb3BlcmF0aW9uLlwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxldmVuICs9IE1hdGgubWF4KGluc2VydGlvbnMsIGRlbGV0aW9ucyksIGxldmVuO1xufVxuZnVuY3Rpb24geEluZGV4KGRpZmZzLCBsb2NhdGlvbikge1xuICBsZXQgY2hhcnMxID0gMCwgY2hhcnMyID0gMCwgbGFzdENoYXJzMSA9IDAsIGxhc3RDaGFyczIgPSAwLCB4O1xuICBmb3IgKHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoICYmIChkaWZmc1t4XVswXSAhPT0gRElGRl9JTlNFUlQgJiYgKGNoYXJzMSArPSBkaWZmc1t4XVsxXS5sZW5ndGgpLCBkaWZmc1t4XVswXSAhPT0gRElGRl9ERUxFVEUgJiYgKGNoYXJzMiArPSBkaWZmc1t4XVsxXS5sZW5ndGgpLCAhKGNoYXJzMSA+IGxvY2F0aW9uKSk7IHgrKykgbGFzdENoYXJzMSA9IGNoYXJzMSwgbGFzdENoYXJzMiA9IGNoYXJzMjtcbiAgcmV0dXJuIGRpZmZzLmxlbmd0aCAhPT0geCAmJiBkaWZmc1t4XVswXSA9PT0gRElGRl9ERUxFVEUgPyBsYXN0Q2hhcnMyIDogbGFzdENoYXJzMiArIChsb2NhdGlvbiAtIGxhc3RDaGFyczEpO1xufVxuZnVuY3Rpb24gY291bnRVdGY4Qnl0ZXMoc3RyKSB7XG4gIGxldCBieXRlcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KGkpO1xuICAgIGlmICh0eXBlb2YgY29kZVBvaW50ID4gXCJ1XCIpIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgY29kZXBvaW50XCIpO1xuICAgIGJ5dGVzICs9IHV0ZjhsZW4oY29kZVBvaW50KTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBhZGp1c3RJbmRpY2llc1RvVWNzMihwYXRjaGVzLCBiYXNlLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IGJ5dGVPZmZzZXQgPSAwLCBpZHggPSAwO1xuICBmdW5jdGlvbiBhZHZhbmNlVG8odGFyZ2V0KSB7XG4gICAgZm9yICg7IGJ5dGVPZmZzZXQgPCB0YXJnZXQ7ICkge1xuICAgICAgY29uc3QgY29kZVBvaW50ID0gYmFzZS5jb2RlUG9pbnRBdChpZHgpO1xuICAgICAgaWYgKHR5cGVvZiBjb2RlUG9pbnQgPiBcInVcIikgcmV0dXJuIGlkeDtcbiAgICAgIGJ5dGVPZmZzZXQgKz0gdXRmOGxlbihjb2RlUG9pbnQpLCBjb2RlUG9pbnQgPiA2NTUzNSA/IGlkeCArPSAyIDogaWR4ICs9IDE7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5hbGxvd0V4Y2VlZGluZ0luZGljZXMgJiYgYnl0ZU9mZnNldCAhPT0gdGFyZ2V0KSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGV0ZXJtaW5lIGJ5dGUgb2Zmc2V0XCIpO1xuICAgIHJldHVybiBpZHg7XG4gIH1cbiAgY29uc3QgYWRqdXN0ZWQgPSBbXTtcbiAgZm9yIChjb25zdCBwYXRjaCBvZiBwYXRjaGVzKSBhZGp1c3RlZC5wdXNoKHtcbiAgICBkaWZmczogcGF0Y2guZGlmZnMubWFwKChkaWZmMikgPT4gY2xvbmVEaWZmKGRpZmYyKSksXG4gICAgc3RhcnQxOiBhZHZhbmNlVG8ocGF0Y2guc3RhcnQxKSxcbiAgICBzdGFydDI6IGFkdmFuY2VUbyhwYXRjaC5zdGFydDIpLFxuICAgIHV0ZjhTdGFydDE6IHBhdGNoLnV0ZjhTdGFydDEsXG4gICAgdXRmOFN0YXJ0MjogcGF0Y2gudXRmOFN0YXJ0MixcbiAgICBsZW5ndGgxOiBwYXRjaC5sZW5ndGgxLFxuICAgIGxlbmd0aDI6IHBhdGNoLmxlbmd0aDIsXG4gICAgdXRmOExlbmd0aDE6IHBhdGNoLnV0ZjhMZW5ndGgxLFxuICAgIHV0ZjhMZW5ndGgyOiBwYXRjaC51dGY4TGVuZ3RoMlxuICB9KTtcbiAgcmV0dXJuIGFkanVzdGVkO1xufVxuZnVuY3Rpb24gdXRmOGxlbihjb2RlUG9pbnQpIHtcbiAgcmV0dXJuIGNvZGVQb2ludCA8PSAxMjcgPyAxIDogY29kZVBvaW50IDw9IDIwNDcgPyAyIDogY29kZVBvaW50IDw9IDY1NTM1ID8gMyA6IDQ7XG59XG5jb25zdCBNQVhfQklUUyA9IDMyLCBERUZBVUxUX01BUkdJTiA9IDQ7XG5mdW5jdGlvbiBhZGRQYWRkaW5nKHBhdGNoZXMsIG1hcmdpbiA9IERFRkFVTFRfTUFSR0lOKSB7XG4gIGNvbnN0IHBhZGRpbmdMZW5ndGggPSBtYXJnaW47XG4gIGxldCBudWxsUGFkZGluZyA9IFwiXCI7XG4gIGZvciAobGV0IHggPSAxOyB4IDw9IHBhZGRpbmdMZW5ndGg7IHgrKykgbnVsbFBhZGRpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh4KTtcbiAgZm9yIChjb25zdCBwIG9mIHBhdGNoZXMpIHAuc3RhcnQxICs9IHBhZGRpbmdMZW5ndGgsIHAuc3RhcnQyICs9IHBhZGRpbmdMZW5ndGgsIHAudXRmOFN0YXJ0MSArPSBwYWRkaW5nTGVuZ3RoLCBwLnV0ZjhTdGFydDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgbGV0IHBhdGNoID0gcGF0Y2hlc1swXSwgZGlmZnMgPSBwYXRjaC5kaWZmcztcbiAgaWYgKGRpZmZzLmxlbmd0aCA9PT0gMCB8fCBkaWZmc1swXVswXSAhPT0gRElGRl9FUVVBTCkgZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgbnVsbFBhZGRpbmddKSwgcGF0Y2guc3RhcnQxIC09IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnN0YXJ0MiAtPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQxIC09IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhTdGFydDIgLT0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gubGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gIGVsc2UgaWYgKHBhZGRpbmdMZW5ndGggPiBkaWZmc1swXVsxXS5sZW5ndGgpIHtcbiAgICBjb25zdCBmaXJzdERpZmZMZW5ndGggPSBkaWZmc1swXVsxXS5sZW5ndGgsIGV4dHJhTGVuZ3RoID0gcGFkZGluZ0xlbmd0aCAtIGZpcnN0RGlmZkxlbmd0aDtcbiAgICBkaWZmc1swXVsxXSA9IG51bGxQYWRkaW5nLnN1YnN0cmluZyhmaXJzdERpZmZMZW5ndGgpICsgZGlmZnNbMF1bMV0sIHBhdGNoLnN0YXJ0MSAtPSBleHRyYUxlbmd0aCwgcGF0Y2guc3RhcnQyIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQxIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQyIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBleHRyYUxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XG4gIH1cbiAgaWYgKHBhdGNoID0gcGF0Y2hlc1twYXRjaGVzLmxlbmd0aCAtIDFdLCBkaWZmcyA9IHBhdGNoLmRpZmZzLCBkaWZmcy5sZW5ndGggPT09IDAgfHwgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMF0gIT09IERJRkZfRVFVQUwpIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIG51bGxQYWRkaW5nXSksIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMiArPSBwYWRkaW5nTGVuZ3RoO1xuICBlbHNlIGlmIChwYWRkaW5nTGVuZ3RoID4gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoKSB7XG4gICAgY29uc3QgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoO1xuICAgIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdICs9IG51bGxQYWRkaW5nLnN1YnN0cmluZygwLCBleHRyYUxlbmd0aCksIHBhdGNoLmxlbmd0aDEgKz0gZXh0cmFMZW5ndGgsIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMiArPSBleHRyYUxlbmd0aDtcbiAgfVxuICByZXR1cm4gbnVsbFBhZGRpbmc7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRjaE9iamVjdChzdGFydDEsIHN0YXJ0Mikge1xuICByZXR1cm4ge1xuICAgIGRpZmZzOiBbXSxcbiAgICBzdGFydDEsXG4gICAgc3RhcnQyLFxuICAgIHV0ZjhTdGFydDE6IHN0YXJ0MSxcbiAgICB1dGY4U3RhcnQyOiBzdGFydDIsXG4gICAgbGVuZ3RoMTogMCxcbiAgICBsZW5ndGgyOiAwLFxuICAgIHV0ZjhMZW5ndGgxOiAwLFxuICAgIHV0ZjhMZW5ndGgyOiAwXG4gIH07XG59XG5mdW5jdGlvbiBzcGxpdE1heChwYXRjaGVzLCBtYXJnaW4gPSBERUZBVUxUX01BUkdJTikge1xuICBjb25zdCBwYXRjaFNpemUgPSBNQVhfQklUUztcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgaWYgKHBhdGNoZXNbeF0ubGVuZ3RoMSA8PSBwYXRjaFNpemUpIGNvbnRpbnVlO1xuICAgIGNvbnN0IGJpZ3BhdGNoID0gcGF0Y2hlc1t4XTtcbiAgICBwYXRjaGVzLnNwbGljZSh4LS0sIDEpO1xuICAgIGxldCBzdGFydDEgPSBiaWdwYXRjaC5zdGFydDEsIHN0YXJ0MiA9IGJpZ3BhdGNoLnN0YXJ0MiwgcHJlQ29udGV4dCA9IFwiXCI7XG4gICAgZm9yICg7IGJpZ3BhdGNoLmRpZmZzLmxlbmd0aCAhPT0gMDsgKSB7XG4gICAgICBjb25zdCBwYXRjaCA9IGNyZWF0ZVBhdGNoT2JqZWN0KHN0YXJ0MSAtIHByZUNvbnRleHQubGVuZ3RoLCBzdGFydDIgLSBwcmVDb250ZXh0Lmxlbmd0aCk7XG4gICAgICBsZXQgZW1wdHkgPSAhMDtcbiAgICAgIGlmIChwcmVDb250ZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgIGNvbnN0IHByZWNvbnRleHRCeXRlQ291bnQgPSBjb3VudFV0ZjhCeXRlcyhwcmVDb250ZXh0KTtcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSA9IHByZUNvbnRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSA9IHByZWNvbnRleHRCeXRlQ291bnQsIHBhdGNoLmxlbmd0aDIgPSBwcmVDb250ZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgPSBwcmVjb250ZXh0Qnl0ZUNvdW50LCBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBwcmVDb250ZXh0XSk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmIHBhdGNoLmxlbmd0aDEgPCBwYXRjaFNpemUgLSBtYXJnaW47ICkge1xuICAgICAgICBjb25zdCBkaWZmVHlwZSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzBdO1xuICAgICAgICBsZXQgZGlmZlRleHQgPSBiaWdwYXRjaC5kaWZmc1swXVsxXSwgZGlmZlRleHRCeXRlQ291bnQgPSBjb3VudFV0ZjhCeXRlcyhkaWZmVGV4dCk7XG4gICAgICAgIGlmIChkaWZmVHlwZSA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZUZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZGlmZlRleHRCeXRlQ291bnQsIHN0YXJ0MiArPSBkaWZmVGV4dC5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgZGlmZjIgPSBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xuICAgICAgICAgIGRpZmYyICYmIHBhdGNoLmRpZmZzLnB1c2goZGlmZjIpLCBlbXB0eSA9ICExO1xuICAgICAgICB9IGVsc2UgZGlmZlR5cGUgPT09IERJRkZfREVMRVRFICYmIHBhdGNoLmRpZmZzLmxlbmd0aCA9PT0gMSAmJiBwYXRjaC5kaWZmc1swXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmVGV4dC5sZW5ndGggPiAyICogcGF0Y2hTaXplID8gKHBhdGNoLmxlbmd0aDEgKz0gZGlmZlRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBkaWZmVGV4dEJ5dGVDb3VudCwgc3RhcnQxICs9IGRpZmZUZXh0Lmxlbmd0aCwgZW1wdHkgPSAhMSwgcGF0Y2guZGlmZnMucHVzaChbZGlmZlR5cGUsIGRpZmZUZXh0XSksIGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCkpIDogKGRpZmZUZXh0ID0gZGlmZlRleHQuc3Vic3RyaW5nKDAsIHBhdGNoU2l6ZSAtIHBhdGNoLmxlbmd0aDEgLSBtYXJnaW4pLCBkaWZmVGV4dEJ5dGVDb3VudCA9IGNvdW50VXRmOEJ5dGVzKGRpZmZUZXh0KSwgcGF0Y2gubGVuZ3RoMSArPSBkaWZmVGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IGRpZmZUZXh0Qnl0ZUNvdW50LCBzdGFydDEgKz0gZGlmZlRleHQubGVuZ3RoLCBkaWZmVHlwZSA9PT0gRElGRl9FUVVBTCA/IChwYXRjaC5sZW5ndGgyICs9IGRpZmZUZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZGlmZlRleHRCeXRlQ291bnQsIHN0YXJ0MiArPSBkaWZmVGV4dC5sZW5ndGgpIDogZW1wdHkgPSAhMSwgcGF0Y2guZGlmZnMucHVzaChbZGlmZlR5cGUsIGRpZmZUZXh0XSksIGRpZmZUZXh0ID09PSBiaWdwYXRjaC5kaWZmc1swXVsxXSA/IGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCkgOiBiaWdwYXRjaC5kaWZmc1swXVsxXSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzFdLnN1YnN0cmluZyhkaWZmVGV4dC5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIHByZUNvbnRleHQgPSBkaWZmVGV4dDIocGF0Y2guZGlmZnMpLCBwcmVDb250ZXh0ID0gcHJlQ29udGV4dC5zdWJzdHJpbmcocHJlQ29udGV4dC5sZW5ndGggLSBtYXJnaW4pO1xuICAgICAgY29uc3QgcG9zdENvbnRleHQgPSBkaWZmVGV4dDEoYmlncGF0Y2guZGlmZnMpLnN1YnN0cmluZygwLCBtYXJnaW4pLCBwb3N0Q29udGV4dEJ5dGVDb3VudCA9IGNvdW50VXRmOEJ5dGVzKHBvc3RDb250ZXh0KTtcbiAgICAgIHBvc3RDb250ZXh0ICE9PSBcIlwiICYmIChwYXRjaC5sZW5ndGgxICs9IHBvc3RDb250ZXh0Lmxlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBwb3N0Q29udGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IHBvc3RDb250ZXh0Qnl0ZUNvdW50LCBwYXRjaC51dGY4TGVuZ3RoMiArPSBwb3N0Q29udGV4dEJ5dGVDb3VudCwgcGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzBdID09PSBESUZGX0VRVUFMID8gcGF0Y2guZGlmZnNbcGF0Y2guZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gcG9zdENvbnRleHQgOiBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBwb3N0Q29udGV4dF0pKSwgZW1wdHkgfHwgcGF0Y2hlcy5zcGxpY2UoKyt4LCAwLCBwYXRjaCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhcHBseShwYXRjaGVzLCBvcmlnaW5hbFRleHQsIG9wdHMgPSB7fSkge1xuICBpZiAodHlwZW9mIHBhdGNoZXMgPT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IEVycm9yKFwiUGF0Y2hlcyBtdXN0IGJlIGFuIGFycmF5IC0gcGFzcyB0aGUgcGF0Y2ggdG8gYHBhcnNlUGF0Y2goKWAgZmlyc3RcIik7XG4gIGxldCB0ZXh0ID0gb3JpZ2luYWxUZXh0O1xuICBpZiAocGF0Y2hlcy5sZW5ndGggPT09IDApIHJldHVybiBbdGV4dCwgW11dO1xuICBjb25zdCBwYXJzZWQgPSBhZGp1c3RJbmRpY2llc1RvVWNzMihwYXRjaGVzLCB0ZXh0LCB7XG4gICAgYWxsb3dFeGNlZWRpbmdJbmRpY2VzOiBvcHRzLmFsbG93RXhjZWVkaW5nSW5kaWNlc1xuICB9KSwgbWFyZ2luID0gb3B0cy5tYXJnaW4gfHwgREVGQVVMVF9NQVJHSU4sIGRlbGV0ZVRocmVzaG9sZCA9IG9wdHMuZGVsZXRlVGhyZXNob2xkIHx8IDAuNCwgbnVsbFBhZGRpbmcgPSBhZGRQYWRkaW5nKHBhcnNlZCwgbWFyZ2luKTtcbiAgdGV4dCA9IG51bGxQYWRkaW5nICsgdGV4dCArIG51bGxQYWRkaW5nLCBzcGxpdE1heChwYXJzZWQsIG1hcmdpbik7XG4gIGxldCBkZWx0YSA9IDA7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBwYXJzZWQubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBleHBlY3RlZExvYyA9IHBhcnNlZFt4XS5zdGFydDIgKyBkZWx0YSwgdGV4dDEgPSBkaWZmVGV4dDEocGFyc2VkW3hdLmRpZmZzKTtcbiAgICBsZXQgc3RhcnRMb2MsIGVuZExvYyA9IC0xO1xuICAgIGlmICh0ZXh0MS5sZW5ndGggPiBNQVhfQklUUyA/IChzdGFydExvYyA9IG1hdGNoKHRleHQsIHRleHQxLnN1YnN0cmluZygwLCBNQVhfQklUUyksIGV4cGVjdGVkTG9jKSwgc3RhcnRMb2MgIT09IC0xICYmIChlbmRMb2MgPSBtYXRjaCh0ZXh0LCB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gTUFYX0JJVFMpLCBleHBlY3RlZExvYyArIHRleHQxLmxlbmd0aCAtIE1BWF9CSVRTKSwgKGVuZExvYyA9PT0gLTEgfHwgc3RhcnRMb2MgPj0gZW5kTG9jKSAmJiAoc3RhcnRMb2MgPSAtMSkpKSA6IHN0YXJ0TG9jID0gbWF0Y2godGV4dCwgdGV4dDEsIGV4cGVjdGVkTG9jKSwgc3RhcnRMb2MgPT09IC0xKSByZXN1bHRzW3hdID0gITEsIGRlbHRhIC09IHBhcnNlZFt4XS5sZW5ndGgyIC0gcGFyc2VkW3hdLmxlbmd0aDE7XG4gICAgZWxzZSB7XG4gICAgICByZXN1bHRzW3hdID0gITAsIGRlbHRhID0gc3RhcnRMb2MgLSBleHBlY3RlZExvYztcbiAgICAgIGxldCB0ZXh0MjtcbiAgICAgIGlmIChlbmRMb2MgPT09IC0xID8gdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydExvYywgc3RhcnRMb2MgKyB0ZXh0MS5sZW5ndGgpIDogdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydExvYywgZW5kTG9jICsgTUFYX0JJVFMpLCB0ZXh0MSA9PT0gdGV4dDIpIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydExvYykgKyBkaWZmVGV4dDIocGFyc2VkW3hdLmRpZmZzKSArIHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jICsgdGV4dDEubGVuZ3RoKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgZGlmZnMgPSBkaWZmKHRleHQxLCB0ZXh0Miwge1xuICAgICAgICAgIGNoZWNrTGluZXM6ICExXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGV4dDEubGVuZ3RoID4gTUFYX0JJVFMgJiYgbGV2ZW5zaHRlaW4oZGlmZnMpIC8gdGV4dDEubGVuZ3RoID4gZGVsZXRlVGhyZXNob2xkKSByZXN1bHRzW3hdID0gITE7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRpZmZzID0gY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xuICAgICAgICAgIGxldCBpbmRleDEgPSAwLCBpbmRleDIgPSAwO1xuICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgcGFyc2VkW3hdLmRpZmZzLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICBjb25zdCBtb2QgPSBwYXJzZWRbeF0uZGlmZnNbeV07XG4gICAgICAgICAgICBtb2RbMF0gIT09IERJRkZfRVFVQUwgJiYgKGluZGV4MiA9IHhJbmRleChkaWZmcywgaW5kZXgxKSksIG1vZFswXSA9PT0gRElGRl9JTlNFUlQgPyB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRMb2MgKyBpbmRleDIpICsgbW9kWzFdICsgdGV4dC5zdWJzdHJpbmcoc3RhcnRMb2MgKyBpbmRleDIpIDogbW9kWzBdID09PSBESUZGX0RFTEVURSAmJiAodGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0TG9jICsgaW5kZXgyKSArIHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jICsgeEluZGV4KGRpZmZzLCBpbmRleDEgKyBtb2RbMV0ubGVuZ3RoKSkpLCBtb2RbMF0gIT09IERJRkZfREVMRVRFICYmIChpbmRleDEgKz0gbW9kWzFdLmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcobnVsbFBhZGRpbmcubGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIG51bGxQYWRkaW5nLmxlbmd0aCksIFt0ZXh0LCByZXN1bHRzXTtcbn1cbmNvbnN0IHBhdGNoSGVhZGVyID0gL15AQCAtKFxcZCspLD8oXFxkKikgXFwrKFxcZCspLD8oXFxkKikgQEAkLztcbmZ1bmN0aW9uIHBhcnNlKHRleHRsaW5lKSB7XG4gIGlmICghdGV4dGxpbmUpIHJldHVybiBbXTtcbiAgY29uc3QgcGF0Y2hlcyA9IFtdLCBsaW5lcyA9IHRleHRsaW5lLnNwbGl0KGBcbmApO1xuICBsZXQgdGV4dFBvaW50ZXIgPSAwO1xuICBmb3IgKDsgdGV4dFBvaW50ZXIgPCBsaW5lcy5sZW5ndGg7ICkge1xuICAgIGNvbnN0IG0gPSBsaW5lc1t0ZXh0UG9pbnRlcl0ubWF0Y2gocGF0Y2hIZWFkZXIpO1xuICAgIGlmICghbSkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhdGNoIHN0cmluZzogJHtsaW5lc1t0ZXh0UG9pbnRlcl19YCk7XG4gICAgY29uc3QgcGF0Y2ggPSBjcmVhdGVQYXRjaE9iamVjdCh0b0ludChtWzFdKSwgdG9JbnQobVszXSkpO1xuICAgIGZvciAocGF0Y2hlcy5wdXNoKHBhdGNoKSwgbVsyXSA9PT0gXCJcIiA/IChwYXRjaC5zdGFydDEtLSwgcGF0Y2gudXRmOFN0YXJ0MS0tLCBwYXRjaC5sZW5ndGgxID0gMSwgcGF0Y2gudXRmOExlbmd0aDEgPSAxKSA6IG1bMl0gPT09IFwiMFwiID8gKHBhdGNoLmxlbmd0aDEgPSAwLCBwYXRjaC51dGY4TGVuZ3RoMSA9IDApIDogKHBhdGNoLnN0YXJ0MS0tLCBwYXRjaC51dGY4U3RhcnQxLS0sIHBhdGNoLnV0ZjhMZW5ndGgxID0gdG9JbnQobVsyXSksIHBhdGNoLmxlbmd0aDEgPSBwYXRjaC51dGY4TGVuZ3RoMSksIG1bNF0gPT09IFwiXCIgPyAocGF0Y2guc3RhcnQyLS0sIHBhdGNoLnV0ZjhTdGFydDItLSwgcGF0Y2gubGVuZ3RoMiA9IDEsIHBhdGNoLnV0ZjhMZW5ndGgyID0gMSkgOiBtWzRdID09PSBcIjBcIiA/IChwYXRjaC5sZW5ndGgyID0gMCwgcGF0Y2gudXRmOExlbmd0aDIgPSAwKSA6IChwYXRjaC5zdGFydDItLSwgcGF0Y2gudXRmOFN0YXJ0Mi0tLCBwYXRjaC51dGY4TGVuZ3RoMiA9IHRvSW50KG1bNF0pLCBwYXRjaC5sZW5ndGgyID0gcGF0Y2gudXRmOExlbmd0aDIpLCB0ZXh0UG9pbnRlcisrOyB0ZXh0UG9pbnRlciA8IGxpbmVzLmxlbmd0aDsgKSB7XG4gICAgICBjb25zdCBjdXJyZW50TGluZSA9IGxpbmVzW3RleHRQb2ludGVyXSwgc2lnbiA9IGN1cnJlbnRMaW5lLmNoYXJBdCgwKTtcbiAgICAgIGlmIChzaWduID09PSBcIkBcIikgYnJlYWs7XG4gICAgICBpZiAoc2lnbiA9PT0gXCJcIikge1xuICAgICAgICB0ZXh0UG9pbnRlcisrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBsaW5lO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGluZSA9IGRlY29kZVVSSShjdXJyZW50TGluZS5zbGljZSgxKSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIGVzY2FwZSBpbiBwYXJzZTogJHtjdXJyZW50TGluZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHV0ZjhEaWZmID0gY291bnRVdGY4Qnl0ZXMobGluZSkgLSBsaW5lLmxlbmd0aDtcbiAgICAgIGlmIChzaWduID09PSBcIi1cIikgcGF0Y2guZGlmZnMucHVzaChbRElGRl9ERUxFVEUsIGxpbmVdKSwgcGF0Y2gubGVuZ3RoMSAtPSB1dGY4RGlmZjtcbiAgICAgIGVsc2UgaWYgKHNpZ24gPT09IFwiK1wiKSBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0lOU0VSVCwgbGluZV0pLCBwYXRjaC5sZW5ndGgyIC09IHV0ZjhEaWZmO1xuICAgICAgZWxzZSBpZiAoc2lnbiA9PT0gXCIgXCIpIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIGxpbmVdKSwgcGF0Y2gubGVuZ3RoMSAtPSB1dGY4RGlmZiwgcGF0Y2gubGVuZ3RoMiAtPSB1dGY4RGlmZjtcbiAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhdGNoIG1vZGUgXCIke3NpZ259XCIgaW46ICR7bGluZX1gKTtcbiAgICAgIHRleHRQb2ludGVyKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRjaGVzO1xufVxuZnVuY3Rpb24gdG9JbnQobnVtKSB7XG4gIHJldHVybiBwYXJzZUludChudW0sIDEwKTtcbn1cbmNvbnN0IElTX1VET0lORyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBJU19SRURPSU5HID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB3aXRoVW5kb2luZyhlZGl0b3IsIGZuKSB7XG4gIGNvbnN0IHByZXYgPSBpc1VuZG9pbmcoZWRpdG9yKTtcbiAgSVNfVURPSU5HLnNldChlZGl0b3IsICEwKSwgZm4oKSwgSVNfVURPSU5HLnNldChlZGl0b3IsIHByZXYpO1xufVxuZnVuY3Rpb24gaXNVbmRvaW5nKGVkaXRvcikge1xuICByZXR1cm4gSVNfVURPSU5HLmdldChlZGl0b3IpID8/ICExO1xufVxuZnVuY3Rpb24gc2V0SXNVbmRvaW5nKGVkaXRvciwgaXNVbmRvaW5nMikge1xuICBJU19VRE9JTkcuc2V0KGVkaXRvciwgaXNVbmRvaW5nMik7XG59XG5mdW5jdGlvbiB3aXRoUmVkb2luZyhlZGl0b3IsIGZuKSB7XG4gIGNvbnN0IHByZXYgPSBpc1JlZG9pbmcoZWRpdG9yKTtcbiAgSVNfUkVET0lORy5zZXQoZWRpdG9yLCAhMCksIGZuKCksIElTX1JFRE9JTkcuc2V0KGVkaXRvciwgcHJldik7XG59XG5mdW5jdGlvbiBpc1JlZG9pbmcoZWRpdG9yKSB7XG4gIHJldHVybiBJU19SRURPSU5HLmdldChlZGl0b3IpID8/ICExO1xufVxuZnVuY3Rpb24gc2V0SXNSZWRvaW5nKGVkaXRvciwgaXNSZWRvaW5nMikge1xuICBJU19SRURPSU5HLnNldChlZGl0b3IsIGlzUmVkb2luZzIpO1xufVxuY29uc3QgZGVmYXVsdEtleUdlbmVyYXRvciA9ICgpID0+IHJhbmRvbUtleSgxMiksIGdldEJ5dGVIZXhUYWJsZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICBsZXQgdGFibGU7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKHRhYmxlKVxuICAgICAgcmV0dXJuIHRhYmxlO1xuICAgIHRhYmxlID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSlcbiAgICAgIHRhYmxlW2ldID0gKGkgKyAyNTYpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgICByZXR1cm4gdGFibGU7XG4gIH07XG59KSgpO1xuZnVuY3Rpb24gd2hhdHdnUk5HKGxlbmd0aCA9IDE2KSB7XG4gIGNvbnN0IHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCksIHJuZHM4O1xufVxuZnVuY3Rpb24gcmFuZG9tS2V5KGxlbmd0aCkge1xuICBjb25zdCB0YWJsZSA9IGdldEJ5dGVIZXhUYWJsZSgpO1xuICByZXR1cm4gd2hhdHdnUk5HKGxlbmd0aCkucmVkdWNlKChzdHIsIG4pID0+IHN0ciArIHRhYmxlW25dLCBcIlwiKS5zbGljZSgwLCBsZW5ndGgpO1xufVxuY29uc3QgQ1VSUkVOVF9BQ1RJT05fSUQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHdpdGhBcHBseWluZ0JlaGF2aW9yQWN0aW9ucyhlZGl0b3IsIGZuKSB7XG4gIENVUlJFTlRfQUNUSU9OX0lELnNldChlZGl0b3IsIGRlZmF1bHRLZXlHZW5lcmF0b3IoKSksIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmbiksIENVUlJFTlRfQUNUSU9OX0lELnNldChlZGl0b3IsIHZvaWQgMCk7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50QWN0aW9uSWQoZWRpdG9yKSB7XG4gIHJldHVybiBDVVJSRU5UX0FDVElPTl9JRC5nZXQoZWRpdG9yKTtcbn1cbmZ1bmN0aW9uIGlzQXBwbHlpbmdCZWhhdmlvckFjdGlvbnMoZWRpdG9yKSB7XG4gIHJldHVybiBnZXRDdXJyZW50QWN0aW9uSWQoZWRpdG9yKSAhPT0gdm9pZCAwO1xufVxuY29uc3QgQ1VSUkVOVF9CRUhBVklPUl9BQ1RJT05fSU5URU5EX1NFVCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gd2l0aEFwcGx5aW5nQmVoYXZpb3JBY3Rpb25JbnRlbmRTZXQoZWRpdG9yLCBmbikge1xuICBjb25zdCBjdXJyZW50ID0gQ1VSUkVOVF9CRUhBVklPUl9BQ1RJT05fSU5URU5EX1NFVC5nZXQoZWRpdG9yKTtcbiAgQ1VSUkVOVF9CRUhBVklPUl9BQ1RJT05fSU5URU5EX1NFVC5zZXQoZWRpdG9yLCB7XG4gICAgYWN0aW9uU2V0SWQ6IGRlZmF1bHRLZXlHZW5lcmF0b3IoKVxuICB9KSwgd2l0aEFwcGx5aW5nQmVoYXZpb3JBY3Rpb25zKGVkaXRvciwgZm4pLCBDVVJSRU5UX0JFSEFWSU9SX0FDVElPTl9JTlRFTkRfU0VULnNldChlZGl0b3IsIGN1cnJlbnQpO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudEJlaGF2aW9yQWN0aW9uU2V0SWQoZWRpdG9yKSB7XG4gIHJldHVybiBDVVJSRU5UX0JFSEFWSU9SX0FDVElPTl9JTlRFTkRfU0VULmdldChlZGl0b3IpPy5hY3Rpb25TZXRJZDtcbn1cbmNvbnN0IGRlYnVnJGQgPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhVbmRvUmVkb1wiKSwgU0FWSU5HID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFJFTU9URV9QQVRDSEVTID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFVORE9fU1RFUF9MSU1JVCA9IDFlMywgaXNTYXZpbmcgPSAoZWRpdG9yKSA9PiB7XG4gIGNvbnN0IHN0YXRlID0gU0FWSU5HLmdldChlZGl0b3IpO1xuICByZXR1cm4gc3RhdGUgPT09IHZvaWQgMCA/ICEwIDogc3RhdGU7XG59LCBnZXRSZW1vdGVQYXRjaGVzID0gKGVkaXRvcikgPT4gKFJFTU9URV9QQVRDSEVTLmdldChlZGl0b3IpIHx8IFJFTU9URV9QQVRDSEVTLnNldChlZGl0b3IsIFtdKSwgUkVNT1RFX1BBVENIRVMuZ2V0KGVkaXRvcikgfHwgW10pO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFVuZG9SZWRvKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGVkaXRvckFjdG9yLFxuICAgIGJsb2NrU2NoZW1hVHlwZVxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIChlZGl0b3IpID0+IHtcbiAgICBsZXQgcHJldmlvdXNTbmFwc2hvdCA9IGZyb21TbGF0ZVZhbHVlKGVkaXRvci5jaGlsZHJlbiwgYmxvY2tTY2hlbWFUeXBlLm5hbWUpO1xuICAgIGNvbnN0IHJlbW90ZVBhdGNoZXMgPSBnZXRSZW1vdGVQYXRjaGVzKGVkaXRvcik7XG4gICAgbGV0IHByZXZpb3VzQmVoYXZpb3JBY3Rpb25JbnRlbmRTZXRJZCA9IGdldEN1cnJlbnRCZWhhdmlvckFjdGlvblNldElkKGVkaXRvcik7XG4gICAgb3B0aW9ucy5zdWJzY3JpcHRpb25zLnB1c2goKCkgPT4ge1xuICAgICAgZGVidWckZChcIlN1YnNjcmliaW5nIHRvIHBhdGNoZXNcIik7XG4gICAgICBjb25zdCBzdWIgPSBlZGl0b3JBY3Rvci5vbihcInBhdGNoZXNcIiwgKHtcbiAgICAgICAgcGF0Y2hlcyxcbiAgICAgICAgc25hcHNob3RcbiAgICAgIH0pID0+IHtcbiAgICAgICAgbGV0IHJlc2V0ID0gITE7XG4gICAgICAgIHBhdGNoZXMuZm9yRWFjaCgocGF0Y2gpID0+IHtcbiAgICAgICAgICBpZiAoIXJlc2V0ICYmIHBhdGNoLm9yaWdpbiAhPT0gXCJsb2NhbFwiICYmIHJlbW90ZVBhdGNoZXMpIHtcbiAgICAgICAgICAgIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgZGVidWckZChcIlNvbWVvbmUgZWxzZSBjbGVhcmVkIHRoZSBjb250ZW50LCByZXNldHRpbmcgdW5kby9yZWRvIGhpc3RvcnlcIiksIGVkaXRvci5oaXN0b3J5ID0ge1xuICAgICAgICAgICAgICAgIHVuZG9zOiBbXSxcbiAgICAgICAgICAgICAgICByZWRvczogW11cbiAgICAgICAgICAgICAgfSwgcmVtb3RlUGF0Y2hlcy5zcGxpY2UoMCwgcmVtb3RlUGF0Y2hlcy5sZW5ndGgpLCBTQVZJTkcuc2V0KGVkaXRvciwgITApLCByZXNldCA9ICEwO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdGVQYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICBwYXRjaCxcbiAgICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgIHNuYXBzaG90LFxuICAgICAgICAgICAgICBwcmV2aW91c1NuYXBzaG90XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBwcmV2aW91c1NuYXBzaG90ID0gc25hcHNob3Q7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRlYnVnJGQoXCJVbnN1YnNjcmliaW5nIHRvIHBhdGNoZXNcIiksIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgfTtcbiAgICB9KSwgZWRpdG9yLmhpc3RvcnkgPSB7XG4gICAgICB1bmRvczogW10sXG4gICAgICByZWRvczogW11cbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIGFwcGx5OiBhcHBseTJcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3IuYXBwbHkgPSAob3ApID0+IHtcbiAgICAgIGlmIChlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLm1hdGNoZXMoe1xuICAgICAgICBcImVkaXQgbW9kZVwiOiBcInJlYWQgb25seVwiXG4gICAgICB9KSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNDaGFuZ2luZ1JlbW90ZWx5KGVkaXRvcikpIHtcbiAgICAgICAgYXBwbHkyKG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzVW5kb2luZyhlZGl0b3IpIHx8IGlzUmVkb2luZyhlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3BlcmF0aW9ucyxcbiAgICAgICAgaGlzdG9yeVxuICAgICAgfSA9IGVkaXRvciwge1xuICAgICAgICB1bmRvc1xuICAgICAgfSA9IGhpc3RvcnksIHN0ZXAgPSB1bmRvc1t1bmRvcy5sZW5ndGggLSAxXSwgbGFzdE9wID0gc3RlcCAmJiBzdGVwLm9wZXJhdGlvbnMgJiYgc3RlcC5vcGVyYXRpb25zW3N0ZXAub3BlcmF0aW9ucy5sZW5ndGggLSAxXSwgb3ZlcndyaXRlID0gc2hvdWxkT3ZlcndyaXRlKG9wLCBsYXN0T3ApLCBzYXZlID0gaXNTYXZpbmcoZWRpdG9yKSwgY3VycmVudEJlaGF2aW9yQWN0aW9uSW50ZW5kU2V0SWQgPSBnZXRDdXJyZW50QmVoYXZpb3JBY3Rpb25TZXRJZChlZGl0b3IpO1xuICAgICAgbGV0IG1lcmdlID0gY3VycmVudEJlaGF2aW9yQWN0aW9uSW50ZW5kU2V0SWQgIT09IHZvaWQgMCAmJiBwcmV2aW91c0JlaGF2aW9yQWN0aW9uSW50ZW5kU2V0SWQgPT09IHZvaWQgMCA/ICExIDogY3VycmVudEJlaGF2aW9yQWN0aW9uSW50ZW5kU2V0SWQgIT09IHZvaWQgMCAmJiBwcmV2aW91c0JlaGF2aW9yQWN0aW9uSW50ZW5kU2V0SWQgIT09IHZvaWQgMCA/IGN1cnJlbnRCZWhhdmlvckFjdGlvbkludGVuZFNldElkID09PSBwcmV2aW91c0JlaGF2aW9yQWN0aW9uSW50ZW5kU2V0SWQgOiAhMDtcbiAgICAgIGlmIChzYXZlKSB7XG4gICAgICAgIGlmIChzdGVwID8gb3BlcmF0aW9ucy5sZW5ndGggPT09IDAgJiYgKG1lcmdlID0gY3VycmVudEJlaGF2aW9yQWN0aW9uSW50ZW5kU2V0SWQgPT09IHZvaWQgMCAmJiBwcmV2aW91c0JlaGF2aW9yQWN0aW9uSW50ZW5kU2V0SWQgPT09IHZvaWQgMCA/IHNob3VsZE1lcmdlKG9wLCBsYXN0T3ApIHx8IG92ZXJ3cml0ZSA6IG1lcmdlKSA6IG1lcmdlID0gITEsIHN0ZXAgJiYgbWVyZ2UpXG4gICAgICAgICAgc3RlcC5vcGVyYXRpb25zLnB1c2gob3ApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBuZXdTdGVwID0ge1xuICAgICAgICAgICAgb3BlcmF0aW9uczogWy4uLmVkaXRvci5zZWxlY3Rpb24gPT09IG51bGwgPyBbXSA6IFtjcmVhdGVTZWxlY3RPcGVyYXRpb24oZWRpdG9yKV0sIG9wXSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIHVuZG9zLnB1c2gobmV3U3RlcCksIGRlYnVnJGQoXCJDcmVhdGVkIG5ldyB1bmRvIHN0ZXBcIiwgc3RlcCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHVuZG9zLmxlbmd0aCA+IFVORE9fU1RFUF9MSU1JVDsgKVxuICAgICAgICAgIHVuZG9zLnNoaWZ0KCk7XG4gICAgICAgIHNob3VsZENsZWFyKG9wKSAmJiAoaGlzdG9yeS5yZWRvcyA9IFtdKTtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzQmVoYXZpb3JBY3Rpb25JbnRlbmRTZXRJZCA9IGN1cnJlbnRCZWhhdmlvckFjdGlvbkludGVuZFNldElkLCBhcHBseTIob3ApO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IGhpc3RvcnlVbmRvQWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBhY3Rpb25cbn0pID0+IHtcbiAgY29uc3QgZWRpdG9yID0gYWN0aW9uLmVkaXRvciwge1xuICAgIHVuZG9zXG4gIH0gPSBlZGl0b3IuaGlzdG9yeSwgcmVtb3RlUGF0Y2hlcyA9IGdldFJlbW90ZVBhdGNoZXMoZWRpdG9yKTtcbiAgaWYgKHVuZG9zLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBzdGVwID0gdW5kb3NbdW5kb3MubGVuZ3RoIC0gMV07XG4gICAgaWYgKGRlYnVnJGQoXCJVbmRvaW5nXCIsIHN0ZXApLCBzdGVwLm9wZXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgb3RoZXJQYXRjaGVzID0gcmVtb3RlUGF0Y2hlcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0udGltZSA+PSBzdGVwLnRpbWVzdGFtcCk7XG4gICAgICBsZXQgdHJhbnNmb3JtZWRPcGVyYXRpb25zID0gc3RlcC5vcGVyYXRpb25zO1xuICAgICAgb3RoZXJQYXRjaGVzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgdHJhbnNmb3JtZWRPcGVyYXRpb25zID0gZmxhdHRlbih0cmFuc2Zvcm1lZE9wZXJhdGlvbnMubWFwKChvcCkgPT4gdHJhbnNmb3JtT3BlcmF0aW9uKGVkaXRvciwgaXRlbS5wYXRjaCwgb3AsIGl0ZW0uc25hcHNob3QsIGl0ZW0ucHJldmlvdXNTbmFwc2hvdCkpKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmV2ZXJzZWRPcGVyYXRpb25zID0gdHJhbnNmb3JtZWRPcGVyYXRpb25zLm1hcChPcGVyYXRpb24uaW52ZXJzZSkucmV2ZXJzZSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICB3aXRoVW5kb2luZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgIHdpdGhvdXRTYXZpbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHJldmVyc2VkT3BlcmF0aW9ucy5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGVkaXRvci5hcHBseShvcCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGRlYnVnJGQoXCJDb3VsZCBub3QgcGVyZm9ybSB1bmRvIHN0ZXBcIiwgZXJyKSwgcmVtb3RlUGF0Y2hlcy5zcGxpY2UoMCwgcmVtb3RlUGF0Y2hlcy5sZW5ndGgpLCBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvciksIGVkaXRvci5oaXN0b3J5ID0ge1xuICAgICAgICAgIHVuZG9zOiBbXSxcbiAgICAgICAgICByZWRvczogW11cbiAgICAgICAgfSwgU0FWSU5HLnNldChlZGl0b3IsICEwKSwgc2V0SXNVbmRvaW5nKGVkaXRvciwgITEpLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWRpdG9yLmhpc3RvcnkucmVkb3MucHVzaChzdGVwKSwgZWRpdG9yLmhpc3RvcnkudW5kb3MucG9wKCk7XG4gICAgfVxuICB9XG59LCBoaXN0b3J5UmVkb0FjdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgYWN0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGVkaXRvciA9IGFjdGlvbi5lZGl0b3IsIHtcbiAgICByZWRvc1xuICB9ID0gZWRpdG9yLmhpc3RvcnksIHJlbW90ZVBhdGNoZXMgPSBnZXRSZW1vdGVQYXRjaGVzKGVkaXRvcik7XG4gIGlmIChyZWRvcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgc3RlcCA9IHJlZG9zW3JlZG9zLmxlbmd0aCAtIDFdO1xuICAgIGlmIChkZWJ1ZyRkKFwiUmVkb2luZ1wiLCBzdGVwKSwgc3RlcC5vcGVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG90aGVyUGF0Y2hlcyA9IHJlbW90ZVBhdGNoZXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnRpbWUgPj0gc3RlcC50aW1lc3RhbXApO1xuICAgICAgbGV0IHRyYW5zZm9ybWVkT3BlcmF0aW9ucyA9IHN0ZXAub3BlcmF0aW9ucztcbiAgICAgIG90aGVyUGF0Y2hlcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIHRyYW5zZm9ybWVkT3BlcmF0aW9ucyA9IGZsYXR0ZW4odHJhbnNmb3JtZWRPcGVyYXRpb25zLm1hcCgob3ApID0+IHRyYW5zZm9ybU9wZXJhdGlvbihlZGl0b3IsIGl0ZW0ucGF0Y2gsIG9wLCBpdGVtLnNuYXBzaG90LCBpdGVtLnByZXZpb3VzU25hcHNob3QpKSk7XG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgd2l0aFJlZG9pbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICB3aXRob3V0U2F2aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm1lZE9wZXJhdGlvbnMuZm9yRWFjaCgob3ApID0+IHtcbiAgICAgICAgICAgICAgICBlZGl0b3IuYXBwbHkob3ApO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBkZWJ1ZyRkKFwiQ291bGQgbm90IHBlcmZvcm0gcmVkbyBzdGVwXCIsIGVyciksIHJlbW90ZVBhdGNoZXMuc3BsaWNlKDAsIHJlbW90ZVBhdGNoZXMubGVuZ3RoKSwgVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpLCBlZGl0b3IuaGlzdG9yeSA9IHtcbiAgICAgICAgICB1bmRvczogW10sXG4gICAgICAgICAgcmVkb3M6IFtdXG4gICAgICAgIH0sIFNBVklORy5zZXQoZWRpdG9yLCAhMCksIHNldElzUmVkb2luZyhlZGl0b3IsICExKSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVkaXRvci5oaXN0b3J5LnVuZG9zLnB1c2goc3RlcCksIGVkaXRvci5oaXN0b3J5LnJlZG9zLnBvcCgpO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHRyYW5zZm9ybU9wZXJhdGlvbihlZGl0b3IsIHBhdGNoLCBvcGVyYXRpb24sIHNuYXBzaG90LCBwcmV2aW91c1NuYXBzaG90KSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVkT3BlcmF0aW9uID0ge1xuICAgIC4uLm9wZXJhdGlvblxuICB9O1xuICBpZiAocGF0Y2gudHlwZSA9PT0gXCJpbnNlcnRcIiAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IGluc2VydEJsb2NrSW5kZXggPSAoc25hcHNob3QgfHwgW10pLmZpbmRJbmRleCgoYmxrKSA9PiBpc0VxdWFsKHtcbiAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgfSwgcGF0Y2gucGF0aFswXSkpO1xuICAgIHJldHVybiBkZWJ1ZyRkKGBBZGp1c3RpbmcgYmxvY2sgcGF0aCAoKyR7cGF0Y2guaXRlbXMubGVuZ3RofSkgZm9yICcke3RyYW5zZm9ybWVkT3BlcmF0aW9uLnR5cGV9JyBvcGVyYXRpb24gYW5kIHBhdGNoICcke3BhdGNoLnR5cGV9J2ApLCBbYWRqdXN0QmxvY2tQYXRoKHRyYW5zZm9ybWVkT3BlcmF0aW9uLCBwYXRjaC5pdGVtcy5sZW5ndGgsIGluc2VydEJsb2NrSW5kZXgpXTtcbiAgfVxuICBpZiAocGF0Y2gudHlwZSA9PT0gXCJ1bnNldFwiICYmIHBhdGNoLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgdW5zZXRCbG9ja0luZGV4ID0gKHByZXZpb3VzU25hcHNob3QgfHwgW10pLmZpbmRJbmRleCgoYmxrKSA9PiBpc0VxdWFsKHtcbiAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgfSwgcGF0Y2gucGF0aFswXSkpO1xuICAgIHJldHVybiBcInBhdGhcIiBpbiB0cmFuc2Zvcm1lZE9wZXJhdGlvbiAmJiBBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkT3BlcmF0aW9uLnBhdGgpICYmIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnBhdGhbMF0gPT09IHVuc2V0QmxvY2tJbmRleCA/IChkZWJ1ZyRkKFwiU2tpcHBpbmcgdHJhbnNmb3JtYXRpb24gdGhhdCB0YXJnZXRlZCByZW1vdmVkIGJsb2NrXCIpLCBbXSkgOiBbYWRqdXN0QmxvY2tQYXRoKHRyYW5zZm9ybWVkT3BlcmF0aW9uLCAtMSwgdW5zZXRCbG9ja0luZGV4KV07XG4gIH1cbiAgaWYgKHBhdGNoLnR5cGUgPT09IFwidW5zZXRcIiAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gZGVidWckZChgQWRqdXN0aW5nIHNlbGVjdGlvbiBmb3IgdW5zZXQgZXZlcnl0aGluZyBwYXRjaCBhbmQgJHtvcGVyYXRpb24udHlwZX0gb3BlcmF0aW9uYCksIFtdO1xuICBpZiAocGF0Y2gudHlwZSA9PT0gXCJkaWZmTWF0Y2hQYXRjaFwiKSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uVGFyZ2V0QmxvY2sgPSBmaW5kT3BlcmF0aW9uVGFyZ2V0QmxvY2soZWRpdG9yLCB0cmFuc2Zvcm1lZE9wZXJhdGlvbik7XG4gICAgcmV0dXJuICFvcGVyYXRpb25UYXJnZXRCbG9jayB8fCAhaXNFcXVhbCh7XG4gICAgICBfa2V5OiBvcGVyYXRpb25UYXJnZXRCbG9jay5fa2V5XG4gICAgfSwgcGF0Y2gucGF0aFswXSkgPyBbdHJhbnNmb3JtZWRPcGVyYXRpb25dIDogKHBhcnNlKHBhdGNoLnZhbHVlKS5mb3JFYWNoKChkaWZmUGF0Y2gpID0+IHtcbiAgICAgIGxldCBhZGp1c3RPZmZzZXRCeSA9IDAsIGNoYW5nZWRPZmZzZXQgPSBkaWZmUGF0Y2gudXRmOFN0YXJ0MTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGlmZnNcbiAgICAgIH0gPSBkaWZmUGF0Y2g7XG4gICAgICBpZiAoZGlmZnMuZm9yRWFjaCgoZGlmZjIsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IFtkaWZmVHlwZSwgdGV4dF0gPSBkaWZmMjtcbiAgICAgICAgZGlmZlR5cGUgPT09IERJRkZfSU5TRVJUID8gKGFkanVzdE9mZnNldEJ5ICs9IHRleHQubGVuZ3RoLCBjaGFuZ2VkT2Zmc2V0ICs9IHRleHQubGVuZ3RoKSA6IGRpZmZUeXBlID09PSBESUZGX0RFTEVURSA/IChhZGp1c3RPZmZzZXRCeSAtPSB0ZXh0Lmxlbmd0aCwgY2hhbmdlZE9mZnNldCAtPSB0ZXh0Lmxlbmd0aCkgOiBkaWZmVHlwZSA9PT0gRElGRl9FUVVBTCAmJiAoZGlmZnMuc2xpY2UoaW5kZXgpLmV2ZXJ5KChbZFR5cGVdKSA9PiBkVHlwZSA9PT0gRElGRl9FUVVBTCkgfHwgKGNoYW5nZWRPZmZzZXQgKz0gdGV4dC5sZW5ndGgpKTtcbiAgICAgIH0pLCB0cmFuc2Zvcm1lZE9wZXJhdGlvbi50eXBlID09PSBcImluc2VydF90ZXh0XCIgJiYgY2hhbmdlZE9mZnNldCA8IHRyYW5zZm9ybWVkT3BlcmF0aW9uLm9mZnNldCAmJiAodHJhbnNmb3JtZWRPcGVyYXRpb24ub2Zmc2V0ICs9IGFkanVzdE9mZnNldEJ5KSwgdHJhbnNmb3JtZWRPcGVyYXRpb24udHlwZSA9PT0gXCJyZW1vdmVfdGV4dFwiICYmIGNoYW5nZWRPZmZzZXQgPD0gdHJhbnNmb3JtZWRPcGVyYXRpb24ub2Zmc2V0IC0gdHJhbnNmb3JtZWRPcGVyYXRpb24udGV4dC5sZW5ndGggJiYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLm9mZnNldCArPSBhZGp1c3RPZmZzZXRCeSksIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRGb2N1cyA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXM/LmZvY3VzID8ge1xuICAgICAgICAgIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMuZm9jdXNcbiAgICAgICAgfSA6IHZvaWQgMCwgY3VycmVudEFuY2hvciA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uPy5wcm9wZXJ0aWVzPy5hbmNob3IgPyB7XG4gICAgICAgICAgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ucHJvcGVydGllcy5hbmNob3JcbiAgICAgICAgfSA6IHZvaWQgMCwgbmV3Rm9jdXMgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbj8ubmV3UHJvcGVydGllcz8uZm9jdXMgPyB7XG4gICAgICAgICAgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcy5mb2N1c1xuICAgICAgICB9IDogdm9pZCAwLCBuZXdBbmNob3IgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbj8ubmV3UHJvcGVydGllcz8uYW5jaG9yID8ge1xuICAgICAgICAgIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMuYW5jaG9yXG4gICAgICAgIH0gOiB2b2lkIDA7XG4gICAgICAgIChjdXJyZW50Rm9jdXMgJiYgY3VycmVudEFuY2hvciB8fCBuZXdGb2N1cyAmJiBuZXdBbmNob3IpICYmIChbY3VycmVudEZvY3VzLCBjdXJyZW50QW5jaG9yLCBuZXdGb2N1cywgbmV3QW5jaG9yXS5mb3JFYWNoKChwb2ludCkgPT4ge1xuICAgICAgICAgIHBvaW50ICYmIGNoYW5nZWRPZmZzZXQgPCBwb2ludC5vZmZzZXQgJiYgKHBvaW50Lm9mZnNldCArPSBhZGp1c3RPZmZzZXRCeSk7XG4gICAgICAgIH0pLCBjdXJyZW50Rm9jdXMgJiYgY3VycmVudEFuY2hvciAmJiAodHJhbnNmb3JtZWRPcGVyYXRpb24ucHJvcGVydGllcyA9IHtcbiAgICAgICAgICBmb2N1czogY3VycmVudEZvY3VzLFxuICAgICAgICAgIGFuY2hvcjogY3VycmVudEFuY2hvclxuICAgICAgICB9KSwgbmV3Rm9jdXMgJiYgbmV3QW5jaG9yICYmICh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgIGZvY3VzOiBuZXdGb2N1cyxcbiAgICAgICAgICBhbmNob3I6IG5ld0FuY2hvclxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSksIFt0cmFuc2Zvcm1lZE9wZXJhdGlvbl0pO1xuICB9XG4gIHJldHVybiBbdHJhbnNmb3JtZWRPcGVyYXRpb25dO1xufVxuZnVuY3Rpb24gYWRqdXN0QmxvY2tQYXRoKG9wZXJhdGlvbiwgbGV2ZWwsIGJsb2NrSW5kZXgpIHtcbiAgY29uc3QgdHJhbnNmb3JtZWRPcGVyYXRpb24gPSB7XG4gICAgLi4ub3BlcmF0aW9uXG4gIH07XG4gIGlmIChibG9ja0luZGV4ID49IDAgJiYgdHJhbnNmb3JtZWRPcGVyYXRpb24udHlwZSAhPT0gXCJzZXRfc2VsZWN0aW9uXCIgJiYgQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoKSAmJiB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoWzBdID49IGJsb2NrSW5kZXggKyBsZXZlbCAmJiB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoWzBdICsgbGV2ZWwgPiAtMSkge1xuICAgIGNvbnN0IG5ld1BhdGggPSBbdHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aFswXSArIGxldmVsLCAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoLnNsaWNlKDEpXTtcbiAgICB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoID0gbmV3UGF0aDtcbiAgfVxuICBpZiAodHJhbnNmb3JtZWRPcGVyYXRpb24udHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIpIHtcbiAgICBjb25zdCBjdXJyZW50Rm9jdXMgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzPy5mb2N1cyA/IHtcbiAgICAgIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMuZm9jdXNcbiAgICB9IDogdm9pZCAwLCBjdXJyZW50QW5jaG9yID0gdHJhbnNmb3JtZWRPcGVyYXRpb24/LnByb3BlcnRpZXM/LmFuY2hvciA/IHtcbiAgICAgIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMuYW5jaG9yXG4gICAgfSA6IHZvaWQgMCwgbmV3Rm9jdXMgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbj8ubmV3UHJvcGVydGllcz8uZm9jdXMgPyB7XG4gICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzLmZvY3VzXG4gICAgfSA6IHZvaWQgMCwgbmV3QW5jaG9yID0gdHJhbnNmb3JtZWRPcGVyYXRpb24/Lm5ld1Byb3BlcnRpZXM/LmFuY2hvciA/IHtcbiAgICAgIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMuYW5jaG9yXG4gICAgfSA6IHZvaWQgMDtcbiAgICAoY3VycmVudEZvY3VzICYmIGN1cnJlbnRBbmNob3IgfHwgbmV3Rm9jdXMgJiYgbmV3QW5jaG9yKSAmJiAoW2N1cnJlbnRGb2N1cywgY3VycmVudEFuY2hvciwgbmV3Rm9jdXMsIG5ld0FuY2hvcl0uZm9yRWFjaCgocG9pbnQpID0+IHtcbiAgICAgIHBvaW50ICYmIHBvaW50LnBhdGhbMF0gPj0gYmxvY2tJbmRleCArIGxldmVsICYmIHBvaW50LnBhdGhbMF0gKyBsZXZlbCA+IC0xICYmIChwb2ludC5wYXRoID0gW3BvaW50LnBhdGhbMF0gKyBsZXZlbCwgLi4ucG9pbnQucGF0aC5zbGljZSgxKV0pO1xuICAgIH0pLCBjdXJyZW50Rm9jdXMgJiYgY3VycmVudEFuY2hvciAmJiAodHJhbnNmb3JtZWRPcGVyYXRpb24ucHJvcGVydGllcyA9IHtcbiAgICAgIGZvY3VzOiBjdXJyZW50Rm9jdXMsXG4gICAgICBhbmNob3I6IGN1cnJlbnRBbmNob3JcbiAgICB9KSwgbmV3Rm9jdXMgJiYgbmV3QW5jaG9yICYmICh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzID0ge1xuICAgICAgZm9jdXM6IG5ld0ZvY3VzLFxuICAgICAgYW5jaG9yOiBuZXdBbmNob3JcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybWVkT3BlcmF0aW9uO1xufVxuY29uc3Qgc2hvdWxkTWVyZ2UgPSAob3AsIHByZXYpID0+ICEhKG9wLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiIHx8IHByZXYgJiYgb3AudHlwZSA9PT0gXCJpbnNlcnRfdGV4dFwiICYmIHByZXYudHlwZSA9PT0gXCJpbnNlcnRfdGV4dFwiICYmIG9wLm9mZnNldCA9PT0gcHJldi5vZmZzZXQgKyBwcmV2LnRleHQubGVuZ3RoICYmIFBhdGguZXF1YWxzKG9wLnBhdGgsIHByZXYucGF0aCkgJiYgb3AudGV4dCAhPT0gXCIgXCIgfHwgcHJldiAmJiBvcC50eXBlID09PSBcInJlbW92ZV90ZXh0XCIgJiYgcHJldi50eXBlID09PSBcInJlbW92ZV90ZXh0XCIgJiYgb3Aub2Zmc2V0ICsgb3AudGV4dC5sZW5ndGggPT09IHByZXYub2Zmc2V0ICYmIFBhdGguZXF1YWxzKG9wLnBhdGgsIHByZXYucGF0aCkpLCBzaG91bGRPdmVyd3JpdGUgPSAob3AsIHByZXYpID0+ICEhKHByZXYgJiYgb3AudHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIgJiYgcHJldi50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIiksIHNob3VsZENsZWFyID0gKG9wKSA9PiBvcC50eXBlICE9PSBcInNldF9zZWxlY3Rpb25cIjtcbmZ1bmN0aW9uIHdpdGhvdXRTYXZpbmcoZWRpdG9yLCBmbikge1xuICBjb25zdCBwcmV2ID0gaXNTYXZpbmcoZWRpdG9yKTtcbiAgU0FWSU5HLnNldChlZGl0b3IsICExKSwgZm4oKSwgU0FWSU5HLnNldChlZGl0b3IsIHByZXYpO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VsZWN0T3BlcmF0aW9uKGVkaXRvcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic2V0X3NlbGVjdGlvblwiLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIC4uLmVkaXRvci5zZWxlY3Rpb25cbiAgICB9LFxuICAgIG5ld1Byb3BlcnRpZXM6IHtcbiAgICAgIC4uLmVkaXRvci5zZWxlY3Rpb25cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBmaW5kT3BlcmF0aW9uVGFyZ2V0QmxvY2soZWRpdG9yLCBvcGVyYXRpb24pIHtcbiAgbGV0IGJsb2NrO1xuICByZXR1cm4gb3BlcmF0aW9uLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiICYmIGVkaXRvci5zZWxlY3Rpb24gPyBibG9jayA9IGVkaXRvci5jaGlsZHJlbltlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF1dIDogXCJwYXRoXCIgaW4gb3BlcmF0aW9uICYmIChibG9jayA9IGVkaXRvci5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXV0pLCBibG9jaztcbn1cbmNvbnN0IGRlYnVnJGMgPSBkZWJ1Z1dpdGhOYW1lKFwic3luYyBtYWNoaW5lXCIpLCBzeW5jVmFsdWVDYWxsYmFjayA9ICh7XG4gIHNlbmRCYWNrLFxuICBpbnB1dFxufSkgPT4ge1xuICB1cGRhdGVWYWx1ZSh7XG4gICAgY29udGV4dDogaW5wdXQuY29udGV4dCxcbiAgICBzZW5kQmFjayxcbiAgICBzbGF0ZUVkaXRvcjogaW5wdXQuc2xhdGVFZGl0b3IsXG4gICAgdmFsdWU6IGlucHV0LnZhbHVlLFxuICAgIHN0cmVhbUJsb2NrczogaW5wdXQuc3RyZWFtQmxvY2tzXG4gIH0pO1xufSwgc3luY1ZhbHVlTG9naWMgPSBmcm9tQ2FsbGJhY2soc3luY1ZhbHVlQ2FsbGJhY2spLCBzeW5jTWFjaGluZSA9IHNldHVwKHtcbiAgdHlwZXM6IHtcbiAgICBjb250ZXh0OiB7fSxcbiAgICBpbnB1dDoge30sXG4gICAgZXZlbnRzOiB7fSxcbiAgICBlbWl0dGVkOiB7fVxuICB9LFxuICBhY3Rpb25zOiB7XG4gICAgXCJhc3NpZ24gaW5pdGlhbCB2YWx1ZSBzeW5jZWRcIjogYXNzaWduKHtcbiAgICAgIGluaXRpYWxWYWx1ZVN5bmNlZDogITBcbiAgICB9KSxcbiAgICBcImFzc2lnbiByZWFkT25seVwiOiBhc3NpZ24oe1xuICAgICAgcmVhZE9ubHk6ICh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwidXBkYXRlIHJlYWRPbmx5XCIpLCBldmVudC5yZWFkT25seSlcbiAgICB9KSxcbiAgICBcImFzc2lnbiBwZW5kaW5nIHZhbHVlXCI6IGFzc2lnbih7XG4gICAgICBwZW5kaW5nVmFsdWU6ICh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwidXBkYXRlIHZhbHVlXCIpLCBldmVudC52YWx1ZSlcbiAgICB9KSxcbiAgICBcImNsZWFyIHBlbmRpbmcgdmFsdWVcIjogYXNzaWduKHtcbiAgICAgIHBlbmRpbmdWYWx1ZTogdm9pZCAwXG4gICAgfSksXG4gICAgXCJhc3NpZ24gcHJldmlvdXMgdmFsdWVcIjogYXNzaWduKHtcbiAgICAgIHByZXZpb3VzVmFsdWU6ICh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwiZG9uZSBzeW5jaW5nXCIpLCBldmVudC52YWx1ZSlcbiAgICB9KSxcbiAgICBcImVtaXQgZG9uZSBzeW5jaW5nIGluaXRpYWwgdmFsdWVcIjogZW1pdCh7XG4gICAgICB0eXBlOiBcImRvbmUgc3luY2luZyBpbml0aWFsIHZhbHVlXCJcbiAgICB9KVxuICB9LFxuICBndWFyZHM6IHtcbiAgICBcImluaXRpYWwgdmFsdWUgc3luY2VkXCI6ICh7XG4gICAgICBjb250ZXh0XG4gICAgfSkgPT4gY29udGV4dC5pbml0aWFsVmFsdWVTeW5jZWQsXG4gICAgXCJpcyBidXN5XCI6ICh7XG4gICAgICBjb250ZXh0XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgZWRpdGFibGUgPSAhY29udGV4dC5yZWFkT25seSwgaXNQcm9jZXNzaW5nTG9jYWxDaGFuZ2VzID0gY29udGV4dC5pc1Byb2Nlc3NpbmdMb2NhbENoYW5nZXMsIGlzQ2hhbmdpbmcgPSBpc0NoYW5naW5nUmVtb3RlbHkoY29udGV4dC5zbGF0ZUVkaXRvcikgPz8gITEsIGlzQnVzeSA9IGVkaXRhYmxlICYmIChpc1Byb2Nlc3NpbmdMb2NhbENoYW5nZXMgfHwgaXNDaGFuZ2luZyk7XG4gICAgICByZXR1cm4gZGVidWckYyhcImlzQnVzeVwiLCB7XG4gICAgICAgIGlzQnVzeSxcbiAgICAgICAgZWRpdGFibGUsXG4gICAgICAgIGlzUHJvY2Vzc2luZ0xvY2FsQ2hhbmdlcyxcbiAgICAgICAgaXNDaGFuZ2luZ1xuICAgICAgfSksIGlzQnVzeTtcbiAgICB9LFxuICAgIFwidmFsdWUgY2hhbmdlZCB3aGlsZSBzeW5jaW5nXCI6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwiZG9uZSBzeW5jaW5nXCIpLCBjb250ZXh0LnBlbmRpbmdWYWx1ZSAhPT0gZXZlbnQudmFsdWUpLFxuICAgIFwicGVuZGluZyB2YWx1ZSBlcXVhbHMgcHJldmlvdXMgdmFsdWVcIjogKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSA9PiBpc0VxdWFsKGNvbnRleHQucGVuZGluZ1ZhbHVlLCBjb250ZXh0LnByZXZpb3VzVmFsdWUpXG4gIH0sXG4gIGFjdG9yczoge1xuICAgIFwic3luYyB2YWx1ZVwiOiBzeW5jVmFsdWVMb2dpY1xuICB9XG59KS5jcmVhdGVNYWNoaW5lKHtcbiAgaWQ6IFwic3luY1wiLFxuICBjb250ZXh0OiAoe1xuICAgIGlucHV0XG4gIH0pID0+ICh7XG4gICAgaW5pdGlhbFZhbHVlU3luY2VkOiAhMSxcbiAgICBpc1Byb2Nlc3NpbmdMb2NhbENoYW5nZXM6ICExLFxuICAgIGtleUdlbmVyYXRvcjogaW5wdXQua2V5R2VuZXJhdG9yLFxuICAgIHNjaGVtYTogaW5wdXQuc2NoZW1hLFxuICAgIHJlYWRPbmx5OiBpbnB1dC5yZWFkT25seSxcbiAgICBzbGF0ZUVkaXRvcjogaW5wdXQuc2xhdGVFZGl0b3IsXG4gICAgcGVuZGluZ1ZhbHVlOiB2b2lkIDAsXG4gICAgcHJldmlvdXNWYWx1ZTogdm9pZCAwXG4gIH0pLFxuICBvbjoge1xuICAgIFwiaGFzIHBlbmRpbmcgcGF0Y2hlc1wiOiB7XG4gICAgICBhY3Rpb25zOiBhc3NpZ24oe1xuICAgICAgICBpc1Byb2Nlc3NpbmdMb2NhbENoYW5nZXM6ICEwXG4gICAgICB9KVxuICAgIH0sXG4gICAgbXV0YXRpb246IHtcbiAgICAgIGFjdGlvbnM6IGFzc2lnbih7XG4gICAgICAgIGlzUHJvY2Vzc2luZ0xvY2FsQ2hhbmdlczogITFcbiAgICAgIH0pXG4gICAgfSxcbiAgICBcInVwZGF0ZSByZWFkT25seVwiOiB7XG4gICAgICBhY3Rpb25zOiBbXCJhc3NpZ24gcmVhZE9ubHlcIl1cbiAgICB9XG4gIH0sXG4gIHR5cGU6IFwicGFyYWxsZWxcIixcbiAgc3RhdGVzOiB7XG4gICAgXCJzZXR0aW5nIHVwXCI6IHtcbiAgICAgIGluaXRpYWw6IFwic3luY2luZyBpbml0aWFsIHZhbHVlXCIsXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgXCJzeW5jaW5nIGluaXRpYWwgdmFsdWVcIjoge1xuICAgICAgICAgIGVudHJ5OiBbKCkgPT4ge1xuICAgICAgICAgICAgZGVidWckYyhcImVudHJ5OiBzeW5jaW5nIGluaXRpYWwgdmFsdWVcIik7XG4gICAgICAgICAgfV0sXG4gICAgICAgICAgZXhpdDogWygpID0+IHtcbiAgICAgICAgICAgIGRlYnVnJGMoXCJleGl0OiBzeW5jaW5nIGluaXRpYWwgdmFsdWVcIik7XG4gICAgICAgICAgfV0sXG4gICAgICAgICAgYWx3YXlzOiB7XG4gICAgICAgICAgICBndWFyZDogXCJpbml0aWFsIHZhbHVlIHN5bmNlZFwiLFxuICAgICAgICAgICAgdGFyZ2V0OiBcImRvbmUgc3luY2luZyBpbml0aWFsIHZhbHVlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiZG9uZSBzeW5jaW5nIGluaXRpYWwgdmFsdWVcIjoge1xuICAgICAgICAgIGVudHJ5OiBbXCJlbWl0IGRvbmUgc3luY2luZyBpbml0aWFsIHZhbHVlXCIsICgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnJGMoXCJlbnRyeTogZG9uZSBzeW5jaW5nIGluaXRpYWwgdmFsdWVcIik7XG4gICAgICAgICAgfV0sXG4gICAgICAgICAgZXhpdDogWygpID0+IHtcbiAgICAgICAgICAgIGRlYnVnJGMoXCJleGl0OiBkb25lIHN5bmNpbmcgaW5pdGlhbCB2YWx1ZVwiKTtcbiAgICAgICAgICB9XSxcbiAgICAgICAgICB0eXBlOiBcImZpbmFsXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc3luY2luZzoge1xuICAgICAgaW5pdGlhbDogXCJpZGxlXCIsXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgaWRsZToge1xuICAgICAgICAgIGVudHJ5OiBbKCkgPT4ge1xuICAgICAgICAgICAgZGVidWckYyhcImVudHJ5OiBzeW5jaW5nLT5pZGxlXCIpO1xuICAgICAgICAgIH1dLFxuICAgICAgICAgIGV4aXQ6IFsoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyRjKFwiZXhpdDogc3luY2luZy0+aWRsZVwiKTtcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgXCJ1cGRhdGUgdmFsdWVcIjogW3tcbiAgICAgICAgICAgICAgZ3VhcmQ6IFwiaXMgYnVzeVwiLFxuICAgICAgICAgICAgICB0YXJnZXQ6IFwiYnVzeVwiLFxuICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJhc3NpZ24gcGVuZGluZyB2YWx1ZVwiXVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICB0YXJnZXQ6IFwic3luY2luZ1wiLFxuICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJhc3NpZ24gcGVuZGluZyB2YWx1ZVwiXVxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGJ1c3k6IHtcbiAgICAgICAgICBlbnRyeTogWygpID0+IHtcbiAgICAgICAgICAgIGRlYnVnJGMoXCJlbnRyeTogc3luY2luZy0+YnVzeVwiKTtcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBleGl0OiBbKCkgPT4ge1xuICAgICAgICAgICAgZGVidWckYyhcImV4aXQ6IHN5bmNpbmctPmJ1c3lcIik7XG4gICAgICAgICAgfV0sXG4gICAgICAgICAgYWZ0ZXI6IHtcbiAgICAgICAgICAgIDFlMzogW3tcbiAgICAgICAgICAgICAgZ3VhcmQ6IFwiaXMgYnVzeVwiLFxuICAgICAgICAgICAgICB0YXJnZXQ6IFwiLlwiLFxuICAgICAgICAgICAgICByZWVudGVyOiAhMCxcbiAgICAgICAgICAgICAgYWN0aW9uczogWygpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyRjKFwicmVlbnRlcjogc3luY2luZy0+YnVzeVwiKTtcbiAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcInN5bmNpbmdcIlxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBcInVwZGF0ZSB2YWx1ZVwiOiBbe1xuICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJhc3NpZ24gcGVuZGluZyB2YWx1ZVwiXVxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN5bmNpbmc6IHtcbiAgICAgICAgICBlbnRyeTogWygpID0+IHtcbiAgICAgICAgICAgIGRlYnVnJGMoXCJlbnRyeTogc3luY2luZy0+c3luY2luZ1wiKTtcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBleGl0OiBbKCkgPT4ge1xuICAgICAgICAgICAgZGVidWckYyhcImV4aXQ6IHN5bmNpbmctPnN5bmNpbmdcIik7XG4gICAgICAgICAgfV0sXG4gICAgICAgICAgYWx3YXlzOiB7XG4gICAgICAgICAgICBndWFyZDogXCJwZW5kaW5nIHZhbHVlIGVxdWFscyBwcmV2aW91cyB2YWx1ZVwiLFxuICAgICAgICAgICAgdGFyZ2V0OiBcImlkbGVcIixcbiAgICAgICAgICAgIGFjdGlvbnM6IFtcImNsZWFyIHBlbmRpbmcgdmFsdWVcIiwgXCJhc3NpZ24gaW5pdGlhbCB2YWx1ZSBzeW5jZWRcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGludm9rZToge1xuICAgICAgICAgICAgc3JjOiBcInN5bmMgdmFsdWVcIixcbiAgICAgICAgICAgIGlkOiBcInN5bmMgdmFsdWVcIixcbiAgICAgICAgICAgIGlucHV0OiAoe1xuICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICB9KSA9PiAoe1xuICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAga2V5R2VuZXJhdG9yOiBjb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlOiBjb250ZXh0LnByZXZpb3VzVmFsdWUsXG4gICAgICAgICAgICAgICAgcmVhZE9ubHk6IGNvbnRleHQucmVhZE9ubHksXG4gICAgICAgICAgICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzbGF0ZUVkaXRvcjogY29udGV4dC5zbGF0ZUVkaXRvcixcbiAgICAgICAgICAgICAgc3RyZWFtQmxvY2tzOiAhY29udGV4dC5pbml0aWFsVmFsdWVTeW5jZWQsXG4gICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0LnBlbmRpbmdWYWx1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBcInVwZGF0ZSB2YWx1ZVwiOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFtcImFzc2lnbiBwZW5kaW5nIHZhbHVlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0Y2g6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogW2VtaXQoKHtcbiAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICB9KSA9PiBldmVudCldXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJpbnZhbGlkIHZhbHVlXCI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogW2VtaXQoKHtcbiAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICB9KSA9PiBldmVudCldXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ2YWx1ZSBjaGFuZ2VkXCI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogW2VtaXQoKHtcbiAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICB9KSA9PiBldmVudCldXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJkb25lIHN5bmNpbmdcIjogW3tcbiAgICAgICAgICAgICAgZ3VhcmQ6IFwidmFsdWUgY2hhbmdlZCB3aGlsZSBzeW5jaW5nXCIsXG4gICAgICAgICAgICAgIGFjdGlvbnM6IFtcImFzc2lnbiBwcmV2aW91cyB2YWx1ZVwiLCBcImFzc2lnbiBpbml0aWFsIHZhbHVlIHN5bmNlZFwiXSxcbiAgICAgICAgICAgICAgcmVlbnRlcjogITBcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcImlkbGVcIixcbiAgICAgICAgICAgICAgYWN0aW9uczogW1wiY2xlYXIgcGVuZGluZyB2YWx1ZVwiLCBcImFzc2lnbiBwcmV2aW91cyB2YWx1ZVwiLCBcImFzc2lnbiBpbml0aWFsIHZhbHVlIHN5bmNlZFwiXVxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuYXN5bmMgZnVuY3Rpb24gdXBkYXRlVmFsdWUoe1xuICBjb250ZXh0LFxuICBzZW5kQmFjayxcbiAgc2xhdGVFZGl0b3IsXG4gIHN0cmVhbUJsb2NrcyxcbiAgdmFsdWVcbn0pIHtcbiAgbGV0IGlzQ2hhbmdlZCA9ICExLCBpc1ZhbGlkID0gITA7XG4gIGNvbnN0IGhhZFNlbGVjdGlvbiA9ICEhc2xhdGVFZGl0b3Iuc2VsZWN0aW9uO1xuICBpZiAoKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPT09IDApICYmIChkZWJ1ZyRjKFwiVmFsdWUgaXMgZW1wdHlcIiksIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICB3aXRob3V0U2F2aW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICB3aXRob3V0UGF0Y2hpbmcoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgICAgaGFkU2VsZWN0aW9uICYmIFRyYW5zZm9ybXMuZGVzZWxlY3Qoc2xhdGVFZGl0b3IpO1xuICAgICAgICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IHNsYXRlRWRpdG9yLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgc2xhdGVFZGl0b3IuY2hpbGRyZW4uZm9yRWFjaCgoXywgaW5kZXgpID0+IHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKHNsYXRlRWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogW2NoaWxkcmVuTGVuZ3RoIC0gMSAtIGluZGV4XVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KSwgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhzbGF0ZUVkaXRvciwgc2xhdGVFZGl0b3IucHRlQ3JlYXRlVGV4dEJsb2NrKHtcbiAgICAgICAgICBkZWNvcmF0b3JzOiBbXVxuICAgICAgICB9KSwge1xuICAgICAgICAgIGF0OiBbMF1cbiAgICAgICAgfSksIGhhZFNlbGVjdGlvbiAmJiBUcmFuc2Zvcm1zLnNlbGVjdChzbGF0ZUVkaXRvciwgWzAsIDBdKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KSwgaXNDaGFuZ2VkID0gITApLCB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgc2xhdGVWYWx1ZUZyb21Qcm9wcyA9IHRvU2xhdGVWYWx1ZSh2YWx1ZSwge1xuICAgICAgc2NoZW1hVHlwZXM6IGNvbnRleHQuc2NoZW1hXG4gICAgfSk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgICAgd2l0aFJlbW90ZUNoYW5nZXMoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgICAgICB3aXRob3V0UGF0Y2hpbmcoc2xhdGVFZGl0b3IsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuTGVuZ3RoID0gc2xhdGVFZGl0b3IuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHNsYXRlVmFsdWVGcm9tUHJvcHMubGVuZ3RoIDwgY2hpbGRyZW5MZW5ndGgpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuTGVuZ3RoIC0gMTsgaSA+IHNsYXRlVmFsdWVGcm9tUHJvcHMubGVuZ3RoIC0gMTsgaS0tKVxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgIGF0OiBbaV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaXNDaGFuZ2VkID0gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IFtjdXJyZW50QmxvY2ssIGN1cnJlbnRCbG9ja0luZGV4XSBvZiBnZXRCbG9ja3Moe1xuICAgICAgICAgICAgICBzbGF0ZVZhbHVlOiBzbGF0ZVZhbHVlRnJvbVByb3BzLFxuICAgICAgICAgICAgICBzdHJlYW1CbG9ja3NcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBibG9ja0NoYW5nZWQsXG4gICAgICAgICAgICAgICAgYmxvY2tWYWxpZFxuICAgICAgICAgICAgICB9ID0gc3luY0Jsb2NrKHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgIHNlbmRCYWNrLFxuICAgICAgICAgICAgICAgIGJsb2NrOiBjdXJyZW50QmxvY2ssXG4gICAgICAgICAgICAgICAgaW5kZXg6IGN1cnJlbnRCbG9ja0luZGV4LFxuICAgICAgICAgICAgICAgIHNsYXRlRWRpdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpc0NoYW5nZWQgPSBibG9ja0NoYW5nZWQgfHwgaXNDaGFuZ2VkLCBpc1ZhbGlkID0gaXNWYWxpZCAmJiBibG9ja1ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGlmICghaXNWYWxpZCkge1xuICAgIGRlYnVnJGMoXCJJbnZhbGlkIHZhbHVlLCByZXR1cm5pbmdcIiksIHNlbmRCYWNrKHtcbiAgICAgIHR5cGU6IFwiZG9uZSBzeW5jaW5nXCIsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNDaGFuZ2VkKSB7XG4gICAgZGVidWckYyhcIlNlcnZlciB2YWx1ZSBjaGFuZ2VkLCBzeW5jaW5nIGVkaXRvclwiKTtcbiAgICB0cnkge1xuICAgICAgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKSwgc2VuZEJhY2soe1xuICAgICAgICB0eXBlOiBcImludmFsaWQgdmFsdWVcIixcbiAgICAgICAgcmVzb2x1dGlvbjogbnVsbCxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pLCBzZW5kQmFjayh7XG4gICAgICAgIHR5cGU6IFwiZG9uZSBzeW5jaW5nXCIsXG4gICAgICAgIHZhbHVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGFkU2VsZWN0aW9uICYmICFzbGF0ZUVkaXRvci5zZWxlY3Rpb24gJiYgKFRyYW5zZm9ybXMuc2VsZWN0KHNsYXRlRWRpdG9yLCB7XG4gICAgICBhbmNob3I6IHtcbiAgICAgICAgcGF0aDogWzAsIDBdLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czoge1xuICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfVxuICAgIH0pLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpKSwgc2VuZEJhY2soe1xuICAgICAgdHlwZTogXCJ2YWx1ZSBjaGFuZ2VkXCIsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9IGVsc2VcbiAgICBkZWJ1ZyRjKFwiU2VydmVyIHZhbHVlIGFuZCBlZGl0b3IgdmFsdWUgaXMgZXF1YWwsIG5vIG5lZWQgdG8gc3luYy5cIik7XG4gIHNlbmRCYWNrKHtcbiAgICB0eXBlOiBcImRvbmUgc3luY2luZ1wiLFxuICAgIHZhbHVlXG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24qIGdldEJsb2Nrcyh7XG4gIHNsYXRlVmFsdWUsXG4gIHN0cmVhbUJsb2Nrc1xufSkge1xuICBsZXQgaW5kZXggPSAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IGJsb2NrIG9mIHNsYXRlVmFsdWUpXG4gICAgc3RyZWFtQmxvY2tzICYmIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDApKSwgeWllbGQgW2Jsb2NrLCBpbmRleF0sIGluZGV4Kys7XG59XG5mdW5jdGlvbiBzeW5jQmxvY2soe1xuICBjb250ZXh0LFxuICBzZW5kQmFjayxcbiAgYmxvY2ssXG4gIGluZGV4LFxuICBzbGF0ZUVkaXRvcixcbiAgdmFsdWVcbn0pIHtcbiAgbGV0IGJsb2NrQ2hhbmdlZCA9ICExLCBibG9ja1ZhbGlkID0gITA7XG4gIGNvbnN0IGN1cnJlbnRCbG9jayA9IGJsb2NrLCBjdXJyZW50QmxvY2tJbmRleCA9IGluZGV4LCBvbGRCbG9jayA9IHNsYXRlRWRpdG9yLmNoaWxkcmVuW2N1cnJlbnRCbG9ja0luZGV4XSwgaGFzQ2hhbmdlcyA9IG9sZEJsb2NrICYmICFpc0VxdWFsKGN1cnJlbnRCbG9jaywgb2xkQmxvY2spO1xuICByZXR1cm4gRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgIHdpdGhSZW1vdGVDaGFuZ2VzKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICB3aXRob3V0UGF0Y2hpbmcoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgICAgaWYgKGhhc0NoYW5nZXMgJiYgYmxvY2tWYWxpZCkge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25WYWx1ZSA9IFt2YWx1ZVtjdXJyZW50QmxvY2tJbmRleF1dLCB2YWxpZGF0aW9uID0gdmFsaWRhdGVWYWx1ZSh2YWxpZGF0aW9uVmFsdWUsIGNvbnRleHQuc2NoZW1hLCBjb250ZXh0LmtleUdlbmVyYXRvcik7XG4gICAgICAgICAgIXZhbGlkYXRpb24udmFsaWQgJiYgdmFsaWRhdGlvbi5yZXNvbHV0aW9uPy5hdXRvUmVzb2x2ZSAmJiB2YWxpZGF0aW9uLnJlc29sdXRpb24/LnBhdGNoZXMubGVuZ3RoID4gMCAmJiAhY29udGV4dC5yZWFkT25seSAmJiBjb250ZXh0LnByZXZpb3VzVmFsdWUgJiYgY29udGV4dC5wcmV2aW91c1ZhbHVlICE9PSB2YWx1ZSAmJiAoY29uc29sZS53YXJuKGAke3ZhbGlkYXRpb24ucmVzb2x1dGlvbi5hY3Rpb259IGZvciBibG9jayB3aXRoIF9rZXkgJyR7dmFsaWRhdGlvblZhbHVlWzBdLl9rZXl9Jy4gJHt2YWxpZGF0aW9uLnJlc29sdXRpb24/LmRlc2NyaXB0aW9ufWApLCB2YWxpZGF0aW9uLnJlc29sdXRpb24ucGF0Y2hlcy5mb3JFYWNoKChwYXRjaCkgPT4ge1xuICAgICAgICAgICAgc2VuZEJhY2soe1xuICAgICAgICAgICAgICB0eXBlOiBcInBhdGNoXCIsXG4gICAgICAgICAgICAgIHBhdGNoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSksIHZhbGlkYXRpb24udmFsaWQgfHwgdmFsaWRhdGlvbi5yZXNvbHV0aW9uPy5hdXRvUmVzb2x2ZSA/IChvbGRCbG9jay5fa2V5ID09PSBjdXJyZW50QmxvY2suX2tleSA/IChkZWJ1ZyRjLmVuYWJsZWQgJiYgZGVidWckYyhcIlVwZGF0aW5nIGJsb2NrXCIsIG9sZEJsb2NrLCBjdXJyZW50QmxvY2spLCBfdXBkYXRlQmxvY2soc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9jaywgb2xkQmxvY2ssIGN1cnJlbnRCbG9ja0luZGV4KSkgOiAoZGVidWckYy5lbmFibGVkICYmIGRlYnVnJGMoXCJSZXBsYWNpbmcgYmxvY2tcIiwgb2xkQmxvY2ssIGN1cnJlbnRCbG9jayksIF9yZXBsYWNlQmxvY2soc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9jaywgY3VycmVudEJsb2NrSW5kZXgpKSwgYmxvY2tDaGFuZ2VkID0gITApIDogKHNlbmRCYWNrKHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZCB2YWx1ZVwiLFxuICAgICAgICAgICAgcmVzb2x1dGlvbjogdmFsaWRhdGlvbi5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9KSwgYmxvY2tWYWxpZCA9ICExKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9sZEJsb2NrICYmIGJsb2NrVmFsaWQpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uVmFsdWUgPSBbdmFsdWVbY3VycmVudEJsb2NrSW5kZXhdXSwgdmFsaWRhdGlvbiA9IHZhbGlkYXRlVmFsdWUodmFsaWRhdGlvblZhbHVlLCBjb250ZXh0LnNjaGVtYSwgY29udGV4dC5rZXlHZW5lcmF0b3IpO1xuICAgICAgICAgIGRlYnVnJGMuZW5hYmxlZCAmJiBkZWJ1ZyRjKFwiVmFsaWRhdGluZyBhbmQgaW5zZXJ0aW5nIG5ldyBibG9jayBpbiB0aGUgZW5kIG9mIHRoZSB2YWx1ZVwiLCBjdXJyZW50QmxvY2spLCB2YWxpZGF0aW9uLnZhbGlkIHx8IHZhbGlkYXRpb24ucmVzb2x1dGlvbj8uYXV0b1Jlc29sdmUgPyBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2ssIHtcbiAgICAgICAgICAgIGF0OiBbY3VycmVudEJsb2NrSW5kZXhdXG4gICAgICAgICAgfSkgOiAoZGVidWckYyhcIkludmFsaWRcIiwgdmFsaWRhdGlvbiksIHNlbmRCYWNrKHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZCB2YWx1ZVwiLFxuICAgICAgICAgICAgcmVzb2x1dGlvbjogdmFsaWRhdGlvbi5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9KSwgYmxvY2tWYWxpZCA9ICExKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pLCB7XG4gICAgYmxvY2tDaGFuZ2VkLFxuICAgIGJsb2NrVmFsaWRcbiAgfTtcbn1cbmZ1bmN0aW9uIF9yZXBsYWNlQmxvY2soc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9jaywgY3VycmVudEJsb2NrSW5kZXgpIHtcbiAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IHNsYXRlRWRpdG9yLnNlbGVjdGlvbiwgc2VsZWN0aW9uRm9jdXNPbkJsb2NrID0gY3VycmVudFNlbGVjdGlvbiAmJiBjdXJyZW50U2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0gPT09IGN1cnJlbnRCbG9ja0luZGV4O1xuICBzZWxlY3Rpb25Gb2N1c09uQmxvY2sgJiYgVHJhbnNmb3Jtcy5kZXNlbGVjdChzbGF0ZUVkaXRvciksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoc2xhdGVFZGl0b3IsIHtcbiAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4XVxuICB9KSwgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCB7XG4gICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleF1cbiAgfSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCksIHNlbGVjdGlvbkZvY3VzT25CbG9jayAmJiBUcmFuc2Zvcm1zLnNlbGVjdChzbGF0ZUVkaXRvciwgY3VycmVudFNlbGVjdGlvbik7XG59XG5mdW5jdGlvbiBfdXBkYXRlQmxvY2soc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9jaywgb2xkQmxvY2ssIGN1cnJlbnRCbG9ja0luZGV4KSB7XG4gIGlmIChUcmFuc2Zvcm1zLnNldE5vZGVzKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2ssIHtcbiAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4XVxuICB9KSwgc2xhdGVFZGl0b3IuaXNUZXh0QmxvY2soY3VycmVudEJsb2NrKSAmJiBzbGF0ZUVkaXRvci5pc1RleHRCbG9jayhvbGRCbG9jaykpIHtcbiAgICBjb25zdCBvbGRCbG9ja0NoaWxkcmVuTGVuZ3RoID0gb2xkQmxvY2suY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGN1cnJlbnRCbG9jay5jaGlsZHJlbi5sZW5ndGggPCBvbGRCbG9ja0NoaWxkcmVuTGVuZ3RoICYmIEFycmF5LmZyb20oQXJyYXkob2xkQmxvY2tDaGlsZHJlbkxlbmd0aCAtIGN1cnJlbnRCbG9jay5jaGlsZHJlbi5sZW5ndGgpKS5mb3JFYWNoKChfLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGRJbmRleCA9IG9sZEJsb2NrQ2hpbGRyZW5MZW5ndGggLSAxIC0gaW5kZXg7XG4gICAgICBjaGlsZEluZGV4ID4gMCAmJiAoZGVidWckYyhcIlJlbW92aW5nIGNoaWxkXCIpLCBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKHNsYXRlRWRpdG9yLCB7XG4gICAgICAgIGF0OiBbY3VycmVudEJsb2NrSW5kZXgsIGNoaWxkSW5kZXhdXG4gICAgICB9KSk7XG4gICAgfSksIGN1cnJlbnRCbG9jay5jaGlsZHJlbi5mb3JFYWNoKChjdXJyZW50QmxvY2tDaGlsZCwgY3VycmVudEJsb2NrQ2hpbGRJbmRleCkgPT4ge1xuICAgICAgY29uc3Qgb2xkQmxvY2tDaGlsZCA9IG9sZEJsb2NrLmNoaWxkcmVuW2N1cnJlbnRCbG9ja0NoaWxkSW5kZXhdLCBpc0NoaWxkQ2hhbmdlZCA9ICFpc0VxdWFsKGN1cnJlbnRCbG9ja0NoaWxkLCBvbGRCbG9ja0NoaWxkKSwgaXNUZXh0Q2hhbmdlZCA9ICFpc0VxdWFsKGN1cnJlbnRCbG9ja0NoaWxkLnRleHQsIG9sZEJsb2NrQ2hpbGQ/LnRleHQpLCBwYXRoID0gW2N1cnJlbnRCbG9ja0luZGV4LCBjdXJyZW50QmxvY2tDaGlsZEluZGV4XTtcbiAgICAgIGlmIChpc0NoaWxkQ2hhbmdlZClcbiAgICAgICAgaWYgKGN1cnJlbnRCbG9ja0NoaWxkLl9rZXkgPT09IG9sZEJsb2NrQ2hpbGQ/Ll9rZXkpIHtcbiAgICAgICAgICBkZWJ1ZyRjKFwiVXBkYXRpbmcgY2hhbmdlZCBjaGlsZFwiLCBjdXJyZW50QmxvY2tDaGlsZCwgb2xkQmxvY2tDaGlsZCksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9ja0NoaWxkLCB7XG4gICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGlzU3Bhbk5vZGUgPSBUZXh0LmlzVGV4dChjdXJyZW50QmxvY2tDaGlsZCkgJiYgY3VycmVudEJsb2NrQ2hpbGQuX3R5cGUgPT09IFwic3BhblwiICYmIFRleHQuaXNUZXh0KG9sZEJsb2NrQ2hpbGQpICYmIG9sZEJsb2NrQ2hpbGQuX3R5cGUgPT09IFwic3BhblwiO1xuICAgICAgICAgIGlzU3Bhbk5vZGUgJiYgaXNUZXh0Q2hhbmdlZCA/IChUcmFuc2Zvcm1zLmRlbGV0ZShzbGF0ZUVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHtcbiAgICAgICAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIG9mZnNldDogb2xkQmxvY2tDaGlsZC50ZXh0Lmxlbmd0aFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIFRyYW5zZm9ybXMuaW5zZXJ0VGV4dChzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrQ2hpbGQudGV4dCwge1xuICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICB9KSwgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKSkgOiBpc1NwYW5Ob2RlIHx8IChkZWJ1ZyRjKFwiVXBkYXRpbmcgY2hhbmdlZCBpbmxpbmUgb2JqZWN0IGNoaWxkXCIsIGN1cnJlbnRCbG9ja0NoaWxkKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhzbGF0ZUVkaXRvciwge1xuICAgICAgICAgICAgX2tleTogVk9JRF9DSElMRF9LRVlcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogWy4uLnBhdGgsIDBdLFxuICAgICAgICAgICAgdm9pZHM6ICEwXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2Ugb2xkQmxvY2tDaGlsZCA/IChkZWJ1ZyRjKFwiUmVwbGFjaW5nIGNoaWxkXCIsIGN1cnJlbnRCbG9ja0NoaWxkKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhzbGF0ZUVkaXRvciwge1xuICAgICAgICAgIGF0OiBbY3VycmVudEJsb2NrSW5kZXgsIGN1cnJlbnRCbG9ja0NoaWxkSW5kZXhdXG4gICAgICAgIH0pLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2tDaGlsZCwge1xuICAgICAgICAgIGF0OiBbY3VycmVudEJsb2NrSW5kZXgsIGN1cnJlbnRCbG9ja0NoaWxkSW5kZXhdXG4gICAgICAgIH0pLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpKSA6IG9sZEJsb2NrQ2hpbGQgfHwgKGRlYnVnJGMoXCJJbnNlcnRpbmcgbmV3IGNoaWxkXCIsIGN1cnJlbnRCbG9ja0NoaWxkKSwgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrQ2hpbGQsIHtcbiAgICAgICAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4LCBjdXJyZW50QmxvY2tDaGlsZEluZGV4XVxuICAgICAgICB9KSwgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKSk7XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IGRlYnVnJGIgPSBkZWJ1Z1dpdGhOYW1lKFwiY29tcG9uZW50OlBvcnRhYmxlVGV4dEVkaXRvcjpTeW5jaHJvbml6ZXJcIik7XG5mdW5jdGlvbiBTeW5jaHJvbml6ZXIocHJvcHMpIHtcbiAgY29uc3QgJCA9IGMoNDEpLCB7XG4gICAgZWRpdG9yQWN0b3IsXG4gICAgc2xhdGVFZGl0b3JcbiAgfSA9IHByb3BzLCB2YWx1ZSA9IHVzZVNlbGVjdG9yKHByb3BzLmVkaXRvckFjdG9yLCBfdGVtcCksIHJlYWRPbmx5ID0gdXNlU2VsZWN0b3IocHJvcHMuZWRpdG9yQWN0b3IsIF90ZW1wMik7XG4gIGxldCB0MDtcbiAgJFswXSAhPT0gcHJvcHMuZWRpdG9yQWN0b3IgPyAodDAgPSBwcm9wcy5lZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLCAkWzBdID0gcHJvcHMuZWRpdG9yQWN0b3IsICRbMV0gPSB0MCkgOiB0MCA9ICRbMV07XG4gIGNvbnN0IHQxID0gdDAuY29udGV4dC5rZXlHZW5lcmF0b3I7XG4gIGxldCB0MjtcbiAgJFsyXSAhPT0gcHJvcHMuZWRpdG9yQWN0b3IgPyAodDIgPSBwcm9wcy5lZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLm1hdGNoZXMoe1xuICAgIFwiZWRpdCBtb2RlXCI6IFwicmVhZCBvbmx5XCJcbiAgfSksICRbMl0gPSBwcm9wcy5lZGl0b3JBY3RvciwgJFszXSA9IHQyKSA6IHQyID0gJFszXTtcbiAgbGV0IHQzO1xuICAkWzRdICE9PSBwcm9wcy5lZGl0b3JBY3RvciA/ICh0MyA9IHByb3BzLmVkaXRvckFjdG9yLmdldFNuYXBzaG90KCksICRbNF0gPSBwcm9wcy5lZGl0b3JBY3RvciwgJFs1XSA9IHQzKSA6IHQzID0gJFs1XTtcbiAgbGV0IHQ0O1xuICAkWzZdICE9PSBzbGF0ZUVkaXRvciB8fCAkWzddICE9PSB0MC5jb250ZXh0LmtleUdlbmVyYXRvciB8fCAkWzhdICE9PSB0MiB8fCAkWzldICE9PSB0My5jb250ZXh0LnNjaGVtYSA/ICh0NCA9IHtcbiAgICBpbnB1dDoge1xuICAgICAga2V5R2VuZXJhdG9yOiB0MSxcbiAgICAgIHJlYWRPbmx5OiB0MixcbiAgICAgIHNjaGVtYTogdDMuY29udGV4dC5zY2hlbWEsXG4gICAgICBzbGF0ZUVkaXRvclxuICAgIH1cbiAgfSwgJFs2XSA9IHNsYXRlRWRpdG9yLCAkWzddID0gdDAuY29udGV4dC5rZXlHZW5lcmF0b3IsICRbOF0gPSB0MiwgJFs5XSA9IHQzLmNvbnRleHQuc2NoZW1hLCAkWzEwXSA9IHQ0KSA6IHQ0ID0gJFsxMF07XG4gIGNvbnN0IHN5bmNBY3RvclJlZiA9IHVzZUFjdG9yUmVmKHN5bmNNYWNoaW5lLCB0NCk7XG4gIGxldCB0NTtcbiAgJFsxMV0gIT09IGVkaXRvckFjdG9yID8gKHQ1ID0gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKSwgJFsxMV0gPSBlZGl0b3JBY3RvciwgJFsxMl0gPSB0NSkgOiB0NSA9ICRbMTJdO1xuICBsZXQgdDY7XG4gICRbMTNdICE9PSBzbGF0ZUVkaXRvciB8fCAkWzE0XSAhPT0gdDUuY29udGV4dC5zY2hlbWEgPyAodDYgPSB7XG4gICAgaW5wdXQ6IHtcbiAgICAgIHNjaGVtYTogdDUuY29udGV4dC5zY2hlbWEsXG4gICAgICBzbGF0ZUVkaXRvclxuICAgIH1cbiAgfSwgJFsxM10gPSBzbGF0ZUVkaXRvciwgJFsxNF0gPSB0NS5jb250ZXh0LnNjaGVtYSwgJFsxNV0gPSB0NikgOiB0NiA9ICRbMTVdO1xuICBjb25zdCBtdXRhdGlvbkFjdG9yUmVmID0gdXNlQWN0b3JSZWYobXV0YXRpb25NYWNoaW5lLCB0Nik7XG4gIGxldCB0NywgdDg7XG4gICRbMTZdICE9PSBlZGl0b3JBY3RvciB8fCAkWzE3XSAhPT0gbXV0YXRpb25BY3RvclJlZiB8fCAkWzE4XSAhPT0gc3luY0FjdG9yUmVmID8gKHQ3ID0gKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG11dGF0aW9uQWN0b3JSZWYub24oXCIqXCIsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQudHlwZSA9PT0gXCJoYXMgcGVuZGluZyBwYXRjaGVzXCIgJiYgc3luY0FjdG9yUmVmLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImhhcyBwZW5kaW5nIHBhdGNoZXNcIlxuICAgICAgfSksIGV2ZW50LnR5cGUgPT09IFwibXV0YXRpb25cIiAmJiAoc3luY0FjdG9yUmVmLnNlbmQoe1xuICAgICAgICB0eXBlOiBcIm11dGF0aW9uXCJcbiAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJtdXRhdGlvblwiLFxuICAgICAgICBwYXRjaGVzOiBldmVudC5wYXRjaGVzLFxuICAgICAgICBzbmFwc2hvdDogZXZlbnQuc25hcHNob3QsXG4gICAgICAgIHZhbHVlOiBldmVudC5zbmFwc2hvdFxuICAgICAgfSkpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCB0OCA9IFttdXRhdGlvbkFjdG9yUmVmLCBzeW5jQWN0b3JSZWYsIGVkaXRvckFjdG9yXSwgJFsxNl0gPSBlZGl0b3JBY3RvciwgJFsxN10gPSBtdXRhdGlvbkFjdG9yUmVmLCAkWzE4XSA9IHN5bmNBY3RvclJlZiwgJFsxOV0gPSB0NywgJFsyMF0gPSB0OCkgOiAodDcgPSAkWzE5XSwgdDggPSAkWzIwXSksIHVzZUVmZmVjdCh0NywgdDgpO1xuICBsZXQgdDEwLCB0OTtcbiAgJFsyMV0gIT09IHByb3BzLmVkaXRvckFjdG9yIHx8ICRbMjJdICE9PSBzbGF0ZUVkaXRvciB8fCAkWzIzXSAhPT0gc3luY0FjdG9yUmVmID8gKHQ5ID0gKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbl8wID0gc3luY0FjdG9yUmVmLm9uKFwiKlwiLCAoZXZlbnRfMCkgPT4ge1xuICAgICAgYmIxNTogc3dpdGNoIChldmVudF8wLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImludmFsaWQgdmFsdWVcIjoge1xuICAgICAgICAgIHByb3BzLmVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgLi4uZXZlbnRfMCxcbiAgICAgICAgICAgIHR5cGU6IFwibm90aWZ5LmludmFsaWQgdmFsdWVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrIGJiMTU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInZhbHVlIGNoYW5nZWRcIjoge1xuICAgICAgICAgIHByb3BzLmVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgLi4uZXZlbnRfMCxcbiAgICAgICAgICAgIHR5cGU6IFwibm90aWZ5LnZhbHVlIGNoYW5nZWRcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrIGJiMTU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInBhdGNoXCI6IHtcbiAgICAgICAgICBwcm9wcy5lZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIC4uLmV2ZW50XzAsXG4gICAgICAgICAgICB0eXBlOiBcImludGVybmFsLnBhdGNoXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnJvbVNsYXRlVmFsdWUoc2xhdGVFZGl0b3IuY2hpbGRyZW4sIHByb3BzLmVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KHNsYXRlRWRpdG9yKSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhayBiYjE1O1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHJvcHMuZWRpdG9yQWN0b3Iuc2VuZChldmVudF8wKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uXzAudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCB0MTAgPSBbcHJvcHMuZWRpdG9yQWN0b3IsIHNsYXRlRWRpdG9yLCBzeW5jQWN0b3JSZWZdLCAkWzIxXSA9IHByb3BzLmVkaXRvckFjdG9yLCAkWzIyXSA9IHNsYXRlRWRpdG9yLCAkWzIzXSA9IHN5bmNBY3RvclJlZiwgJFsyNF0gPSB0MTAsICRbMjVdID0gdDkpIDogKHQxMCA9ICRbMjRdLCB0OSA9ICRbMjVdKSwgdXNlRWZmZWN0KHQ5LCB0MTApO1xuICBsZXQgdDExLCB0MTI7XG4gICRbMjZdICE9PSByZWFkT25seSB8fCAkWzI3XSAhPT0gc3luY0FjdG9yUmVmID8gKHQxMSA9ICgpID0+IHtcbiAgICBzeW5jQWN0b3JSZWYuc2VuZCh7XG4gICAgICB0eXBlOiBcInVwZGF0ZSByZWFkT25seVwiLFxuICAgICAgcmVhZE9ubHlcbiAgICB9KTtcbiAgfSwgdDEyID0gW3N5bmNBY3RvclJlZiwgcmVhZE9ubHldLCAkWzI2XSA9IHJlYWRPbmx5LCAkWzI3XSA9IHN5bmNBY3RvclJlZiwgJFsyOF0gPSB0MTEsICRbMjldID0gdDEyKSA6ICh0MTEgPSAkWzI4XSwgdDEyID0gJFsyOV0pLCB1c2VFZmZlY3QodDExLCB0MTIpO1xuICBsZXQgdDEzLCB0MTQ7XG4gICRbMzBdICE9PSBzeW5jQWN0b3JSZWYgfHwgJFszMV0gIT09IHZhbHVlID8gKHQxMyA9ICgpID0+IHtcbiAgICBkZWJ1ZyRiKFwiVmFsdWUgZnJvbSBwcm9wcyBjaGFuZ2VkLCBzeW5jaW5nIG5ldyB2YWx1ZVwiKSwgc3luY0FjdG9yUmVmLnNlbmQoe1xuICAgICAgdHlwZTogXCJ1cGRhdGUgdmFsdWVcIixcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH0sIHQxNCA9IFtzeW5jQWN0b3JSZWYsIHZhbHVlXSwgJFszMF0gPSBzeW5jQWN0b3JSZWYsICRbMzFdID0gdmFsdWUsICRbMzJdID0gdDEzLCAkWzMzXSA9IHQxNCkgOiAodDEzID0gJFszMl0sIHQxNCA9ICRbMzNdKSwgdXNlRWZmZWN0KHQxMywgdDE0KTtcbiAgbGV0IHQxNTtcbiAgJFszNF0gIT09IGVkaXRvckFjdG9yIHx8ICRbMzVdICE9PSBtdXRhdGlvbkFjdG9yUmVmID8gKHQxNSA9ICgpID0+IHtcbiAgICBkZWJ1ZyRiKFwiU3Vic2NyaWJpbmcgdG8gcGF0Y2ggZXZlbnRzXCIpO1xuICAgIGNvbnN0IHN1YiA9IGVkaXRvckFjdG9yLm9uKFwiaW50ZXJuYWwucGF0Y2hcIiwgKGV2ZW50XzEpID0+IHtcbiAgICAgIG11dGF0aW9uQWN0b3JSZWYuc2VuZCh7XG4gICAgICAgIC4uLmV2ZW50XzEsXG4gICAgICAgIHR5cGU6IFwicGF0Y2hcIlxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRlYnVnJGIoXCJVbnN1YnNjcmliaW5nIHRvIHBhdGNoIGV2ZW50c1wiKSwgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgJFszNF0gPSBlZGl0b3JBY3RvciwgJFszNV0gPSBtdXRhdGlvbkFjdG9yUmVmLCAkWzM2XSA9IHQxNSkgOiB0MTUgPSAkWzM2XTtcbiAgbGV0IHQxNjtcbiAgcmV0dXJuICRbMzddICE9PSBlZGl0b3JBY3RvciB8fCAkWzM4XSAhPT0gbXV0YXRpb25BY3RvclJlZiB8fCAkWzM5XSAhPT0gc2xhdGVFZGl0b3IgPyAodDE2ID0gW2VkaXRvckFjdG9yLCBtdXRhdGlvbkFjdG9yUmVmLCBzbGF0ZUVkaXRvcl0sICRbMzddID0gZWRpdG9yQWN0b3IsICRbMzhdID0gbXV0YXRpb25BY3RvclJlZiwgJFszOV0gPSBzbGF0ZUVkaXRvciwgJFs0MF0gPSB0MTYpIDogdDE2ID0gJFs0MF0sIHVzZUVmZmVjdCh0MTUsIHQxNiksIG51bGw7XG59XG5mdW5jdGlvbiBfdGVtcDIoc18wKSB7XG4gIHJldHVybiBzXzAubWF0Y2hlcyh7XG4gICAgXCJlZGl0IG1vZGVcIjogXCJyZWFkIG9ubHlcIlxuICB9KTtcbn1cbmZ1bmN0aW9uIF90ZW1wKHMpIHtcbiAgcmV0dXJuIHMuY29udGV4dC52YWx1ZTtcbn1cblN5bmNocm9uaXplci5kaXNwbGF5TmFtZSA9IFwiU3luY2hyb25pemVyXCI7XG5jb25zdCBjb252ZXJ0ZXJKc29uID0ge1xuICBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gIHNlcmlhbGl6ZTogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgY29uc3QgcG9ydGFibGVUZXh0Q29udmVydGVyID0gc25hcHNob3QuY29udGV4dC5jb252ZXJ0ZXJzLmZpbmQoKGNvbnZlcnRlcikgPT4gY29udmVydGVyLm1pbWVUeXBlID09PSBcImFwcGxpY2F0aW9uL3gtcG9ydGFibGUtdGV4dFwiKTtcbiAgICByZXR1cm4gcG9ydGFibGVUZXh0Q29udmVydGVyID8ge1xuICAgICAgLi4ucG9ydGFibGVUZXh0Q29udmVydGVyLnNlcmlhbGl6ZSh7XG4gICAgICAgIHNuYXBzaG90LFxuICAgICAgICBldmVudFxuICAgICAgfSksXG4gICAgICBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBvcmlnaW5FdmVudDogZXZlbnQub3JpZ2luRXZlbnRcbiAgICB9IDoge1xuICAgICAgdHlwZTogXCJzZXJpYWxpemF0aW9uLmZhaWx1cmVcIixcbiAgICAgIG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIG9yaWdpbkV2ZW50OiBldmVudC5vcmlnaW5FdmVudCxcbiAgICAgIHJlYXNvbjogXCJObyBhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHQgQ29udmVydGVyIGZvdW5kXCJcbiAgICB9O1xuICB9LFxuICBkZXNlcmlhbGl6ZTogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgY29uc3QgcG9ydGFibGVUZXh0Q29udmVydGVyID0gc25hcHNob3QuY29udGV4dC5jb252ZXJ0ZXJzLmZpbmQoKGNvbnZlcnRlcikgPT4gY29udmVydGVyLm1pbWVUeXBlID09PSBcImFwcGxpY2F0aW9uL3gtcG9ydGFibGUtdGV4dFwiKTtcbiAgICByZXR1cm4gcG9ydGFibGVUZXh0Q29udmVydGVyID8ge1xuICAgICAgLi4ucG9ydGFibGVUZXh0Q29udmVydGVyLmRlc2VyaWFsaXplKHtcbiAgICAgICAgc25hcHNob3QsXG4gICAgICAgIGV2ZW50XG4gICAgICB9KSxcbiAgICAgIG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0gOiB7XG4gICAgICB0eXBlOiBcImRlc2VyaWFsaXphdGlvbi5mYWlsdXJlXCIsXG4gICAgICBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICByZWFzb246IFwiTm8gYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0IENvbnZlcnRlciBmb3VuZFwiXG4gICAgfTtcbiAgfVxufSwgY29udmVydGVyUG9ydGFibGVUZXh0ID0ge1xuICBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHRcIixcbiAgc2VyaWFsaXplOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzZXJpYWxpemF0aW9uLmZhaWx1cmVcIixcbiAgICAgICAgbWltZVR5cGU6IFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0XCIsXG4gICAgICAgIG9yaWdpbkV2ZW50OiBldmVudC5vcmlnaW5FdmVudCxcbiAgICAgICAgcmVhc29uOiBcIk5vIHNlbGVjdGlvblwiXG4gICAgICB9O1xuICAgIGNvbnN0IGJsb2NrcyA9IHNsaWNlQmxvY2tzKHtcbiAgICAgIGJsb2Nrczogc25hcHNob3QuY29udGV4dC52YWx1ZSxcbiAgICAgIHNlbGVjdGlvbjogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb25cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzZXJpYWxpemF0aW9uLnN1Y2Nlc3NcIixcbiAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KGJsb2NrcyksXG4gICAgICBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHRcIixcbiAgICAgIG9yaWdpbkV2ZW50OiBldmVudC5vcmlnaW5FdmVudFxuICAgIH07XG4gIH0sXG4gIGRlc2VyaWFsaXplOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBjb25zdCBibG9ja3MgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShibG9ja3MpKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJkZXNlcmlhbGl6YXRpb24uZmFpbHVyZVwiLFxuICAgICAgICBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHRcIixcbiAgICAgICAgcmVhc29uOiBcIkRhdGEgaXMgbm90IGFuIGFycmF5XCJcbiAgICAgIH07XG4gICAgY29uc3QgcGFyc2VkQmxvY2tzID0gYmxvY2tzLmZsYXRNYXAoKGJsb2NrKSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWRCbG9jayA9IHBhcnNlQmxvY2soe1xuICAgICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICBibG9jayxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIElmIHdlIGFyZSBkcmFnZ2luZyBpbnRlcm5hbGx5IHRoZW4gd2Ugd291bGQgbGlrZSB0byBrZWVwIHRoZVxuICAgICAgICAgICAqIGRyb3BwZWQgcG9ydGFibGUgdGV4dCBhcyBpcy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICByZWZyZXNoS2V5czogIXNuYXBzaG90LmJldGEuaGFzVGFnPy4oXCJkcmFnZ2luZyBpbnRlcm5hbGx5XCIpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBhcnNlZEJsb2NrID8gW3BhcnNlZEJsb2NrXSA6IFtdO1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJzZWRCbG9ja3MubGVuZ3RoID09PSAwICYmIGJsb2Nrcy5sZW5ndGggPiAwID8ge1xuICAgICAgdHlwZTogXCJkZXNlcmlhbGl6YXRpb24uZmFpbHVyZVwiLFxuICAgICAgbWltZVR5cGU6IFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0XCIsXG4gICAgICByZWFzb246IFwiTm8gYmxvY2tzIHdlcmUgcGFyc2VkXCJcbiAgICB9IDoge1xuICAgICAgdHlwZTogXCJkZXNlcmlhbGl6YXRpb24uc3VjY2Vzc1wiLFxuICAgICAgZGF0YTogcGFyc2VkQmxvY2tzLFxuICAgICAgbWltZVR5cGU6IFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0XCJcbiAgICB9O1xuICB9XG59LCBjb252ZXJ0ZXJUZXh0SHRtbCA9IHtcbiAgbWltZVR5cGU6IFwidGV4dC9odG1sXCIsXG4gIHNlcmlhbGl6ZTogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic2VyaWFsaXphdGlvbi5mYWlsdXJlXCIsXG4gICAgICAgIG1pbWVUeXBlOiBcInRleHQvaHRtbFwiLFxuICAgICAgICBvcmlnaW5FdmVudDogZXZlbnQub3JpZ2luRXZlbnQsXG4gICAgICAgIHJlYXNvbjogXCJObyBzZWxlY3Rpb25cIlxuICAgICAgfTtcbiAgICBjb25zdCBibG9ja3MgPSBzbGljZUJsb2Nrcyh7XG4gICAgICBibG9ja3M6IHNuYXBzaG90LmNvbnRleHQudmFsdWUsXG4gICAgICBzZWxlY3Rpb246IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uXG4gICAgfSksIGh0bWwgPSB0b0hUTUwoYmxvY2tzLCB7XG4gICAgICBvbk1pc3NpbmdDb21wb25lbnQ6ICExLFxuICAgICAgY29tcG9uZW50czoge1xuICAgICAgICB1bmtub3duVHlwZTogKHtcbiAgICAgICAgICBjaGlsZHJlblxuICAgICAgICB9KSA9PiBjaGlsZHJlbiAhPT0gdm9pZCAwID8gYCR7Y2hpbGRyZW59YCA6IFwiXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaHRtbCA9PT0gXCJcIiA/IHtcbiAgICAgIHR5cGU6IFwic2VyaWFsaXphdGlvbi5mYWlsdXJlXCIsXG4gICAgICBtaW1lVHlwZTogXCJ0ZXh0L2h0bWxcIixcbiAgICAgIG9yaWdpbkV2ZW50OiBldmVudC5vcmlnaW5FdmVudCxcbiAgICAgIHJlYXNvbjogXCJTZXJpYWxpemVkIEhUTUwgaXMgZW1wdHlcIlxuICAgIH0gOiB7XG4gICAgICB0eXBlOiBcInNlcmlhbGl6YXRpb24uc3VjY2Vzc1wiLFxuICAgICAgZGF0YTogaHRtbCxcbiAgICAgIG1pbWVUeXBlOiBcInRleHQvaHRtbFwiLFxuICAgICAgb3JpZ2luRXZlbnQ6IGV2ZW50Lm9yaWdpbkV2ZW50XG4gICAgfTtcbiAgfSxcbiAgZGVzZXJpYWxpemU6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4gKHtcbiAgICB0eXBlOiBcImRlc2VyaWFsaXphdGlvbi5zdWNjZXNzXCIsXG4gICAgZGF0YTogaHRtbFRvQmxvY2tzKGV2ZW50LmRhdGEsIHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLnBvcnRhYmxlVGV4dCwge1xuICAgICAga2V5R2VuZXJhdG9yOiBzbmFwc2hvdC5jb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgIHVuc3RhYmxlX3doaXRlc3BhY2VPblBhc3RlTW9kZTogc25hcHNob3QuY29udGV4dC5zY2hlbWEuYmxvY2sub3B0aW9ucy51bnN0YWJsZV93aGl0ZXNwYWNlT25QYXN0ZU1vZGVcbiAgICB9KSxcbiAgICBtaW1lVHlwZTogXCJ0ZXh0L2h0bWxcIlxuICB9KVxufSwgY29udmVydGVyVGV4dFBsYWluID0ge1xuICBtaW1lVHlwZTogXCJ0ZXh0L3BsYWluXCIsXG4gIHNlcmlhbGl6ZTogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiA/IHtcbiAgICB0eXBlOiBcInNlcmlhbGl6YXRpb24uc3VjY2Vzc1wiLFxuICAgIGRhdGE6IHNsaWNlQmxvY2tzKHtcbiAgICAgIGJsb2Nrczogc25hcHNob3QuY29udGV4dC52YWx1ZSxcbiAgICAgIHNlbGVjdGlvbjogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb25cbiAgICB9KS5tYXAoKGJsb2NrKSA9PiBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhibG9jaykgPyBibG9jay5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC5fdHlwZSA9PT0gc25hcHNob3QuY29udGV4dC5zY2hlbWEuc3Bhbi5uYW1lID8gY2hpbGQudGV4dCA6IGBbJHtzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5pbmxpbmVPYmplY3RzLmZpbmQoKGlubGluZU9iamVjdFR5cGUpID0+IGlubGluZU9iamVjdFR5cGUubmFtZSA9PT0gY2hpbGQuX3R5cGUpPy50aXRsZSA/PyBcIk9iamVjdFwifV1gKS5qb2luKFwiXCIpIDogYFske3NuYXBzaG90LmNvbnRleHQuc2NoZW1hLmJsb2NrT2JqZWN0cy5maW5kKChibG9ja09iamVjdFR5cGUpID0+IGJsb2NrT2JqZWN0VHlwZS5uYW1lID09PSBibG9jay5fdHlwZSk/LnRpdGxlID8/IFwiT2JqZWN0XCJ9XWApLmpvaW4oYFxuXG5gKSxcbiAgICBtaW1lVHlwZTogXCJ0ZXh0L3BsYWluXCIsXG4gICAgb3JpZ2luRXZlbnQ6IGV2ZW50Lm9yaWdpbkV2ZW50XG4gIH0gOiB7XG4gICAgdHlwZTogXCJzZXJpYWxpemF0aW9uLmZhaWx1cmVcIixcbiAgICBtaW1lVHlwZTogXCJ0ZXh0L3BsYWluXCIsXG4gICAgb3JpZ2luRXZlbnQ6IGV2ZW50Lm9yaWdpbkV2ZW50LFxuICAgIHJlYXNvbjogXCJObyBzZWxlY3Rpb25cIlxuICB9LFxuICBkZXNlcmlhbGl6ZTogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgY29uc3QgdGV4dFRvSHRtbCA9IGA8aHRtbD48Ym9keT4ke2VzY2FwZUh0bWwoZXZlbnQuZGF0YSkuc3BsaXQoL1xcbnsyLH0vKS5tYXAoKGxpbmUpID0+IGxpbmUgPyBgPHA+JHtsaW5lLnJlcGxhY2UoLyg/OlxcclxcbnxcXHJ8XFxuKS9nLCBcIjxici8+XCIpfTwvcD5gIDogXCI8cD48L3A+XCIpLmpvaW4oXCJcIil9PC9ib2R5PjwvaHRtbD5gO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImRlc2VyaWFsaXphdGlvbi5zdWNjZXNzXCIsXG4gICAgICBkYXRhOiBodG1sVG9CbG9ja3ModGV4dFRvSHRtbCwgc25hcHNob3QuY29udGV4dC5zY2hlbWEucG9ydGFibGVUZXh0LCB7XG4gICAgICAgIGtleUdlbmVyYXRvcjogc25hcHNob3QuY29udGV4dC5rZXlHZW5lcmF0b3JcbiAgICAgIH0pLFxuICAgICAgbWltZVR5cGU6IFwidGV4dC9wbGFpblwiXG4gICAgfTtcbiAgfVxufSwgZW50aXR5TWFwID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIjxcIjogXCImbHQ7XCIsXG4gIFwiPlwiOiBcIiZndDtcIixcbiAgJ1wiJzogXCImcXVvdDtcIixcbiAgXCInXCI6IFwiJiMzOTtcIixcbiAgXCIvXCI6IFwiJiN4MkY7XCIsXG4gIFwiYFwiOiBcIiYjeDYwO1wiLFxuICBcIj1cIjogXCImI3gzRDtcIlxufTtcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKC9bJjw+XCInYD0vXS9nLCAocykgPT4gZW50aXR5TWFwW3NdKTtcbn1cbmNvbnN0IGNvcmVDb252ZXJ0ZXJzID0gW2NvbnZlcnRlckpzb24sIGNvbnZlcnRlclBvcnRhYmxlVGV4dCwgY29udmVydGVyVGV4dEh0bWwsIGNvbnZlcnRlclRleHRQbGFpbl0sIGRlYnVnJGEgPSBkZWJ1Z1dpdGhOYW1lKFwib3BlcmF0aW9uVG9QYXRjaGVzXCIpO1xuZnVuY3Rpb24gY3JlYXRlT3BlcmF0aW9uVG9QYXRjaGVzKHR5cGVzKSB7XG4gIGNvbnN0IHRleHRCbG9ja05hbWUgPSB0eXBlcy5ibG9jay5uYW1lO1xuICBmdW5jdGlvbiBpbnNlcnRUZXh0UGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIGJlZm9yZVZhbHVlKSB7XG4gICAgZGVidWckYS5lbmFibGVkICYmIGRlYnVnJGEoXCJPcGVyYXRpb25cIiwgSlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLCBudWxsLCAyKSk7XG4gICAgY29uc3QgYmxvY2sgPSBlZGl0b3IuaXNUZXh0QmxvY2soZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXSkgJiYgZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICBpZiAoIWJsb2NrKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYmxvY2tcIik7XG4gICAgY29uc3QgdGV4dENoaWxkID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBlZGl0b3IuaXNUZXh0U3BhbihibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0pICYmIGJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXTtcbiAgICBpZiAoIXRleHRDaGlsZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGNoaWxkXCIpO1xuICAgIGNvbnN0IHBhdGggPSBbe1xuICAgICAgX2tleTogYmxvY2suX2tleVxuICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgX2tleTogdGV4dENoaWxkLl9rZXlcbiAgICB9LCBcInRleHRcIl0sIHByZXZCbG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXSwgcHJldkNoaWxkID0gZWRpdG9yLmlzVGV4dEJsb2NrKHByZXZCbG9jaykgJiYgcHJldkJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSwgcHJldlRleHQgPSBlZGl0b3IuaXNUZXh0U3BhbihwcmV2Q2hpbGQpID8gcHJldkNoaWxkLnRleHQgOiBcIlwiLCBwYXRjaCA9IGRpZmZNYXRjaFBhdGNoJDEocHJldlRleHQsIHRleHRDaGlsZC50ZXh0LCBwYXRoKTtcbiAgICByZXR1cm4gcGF0Y2gudmFsdWUubGVuZ3RoID8gW3BhdGNoXSA6IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZVRleHRQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBibG9jayA9IGVkaXRvciAmJiBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgIGlmICghYmxvY2spXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBibG9ja1wiKTtcbiAgICBjb25zdCBjaGlsZCA9IGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dIHx8IHZvaWQgMCwgdGV4dENoaWxkID0gZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpID8gY2hpbGQgOiB2b2lkIDA7XG4gICAgaWYgKGNoaWxkICYmICF0ZXh0Q2hpbGQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzcGFuXCIpO1xuICAgIGlmICghdGV4dENoaWxkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgY2hpbGRcIik7XG4gICAgY29uc3QgcGF0aCA9IFt7XG4gICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICBfa2V5OiB0ZXh0Q2hpbGQuX2tleVxuICAgIH0sIFwidGV4dFwiXSwgYmVmb3JlQmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXV0sIHByZXZUZXh0Q2hpbGQgPSBlZGl0b3IuaXNUZXh0QmxvY2soYmVmb3JlQmxvY2spICYmIGJlZm9yZUJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSwgcHJldlRleHQgPSBlZGl0b3IuaXNUZXh0U3BhbihwcmV2VGV4dENoaWxkKSAmJiBwcmV2VGV4dENoaWxkLnRleHQsIHBhdGNoID0gZGlmZk1hdGNoUGF0Y2gkMShwcmV2VGV4dCB8fCBcIlwiLCB0ZXh0Q2hpbGQudGV4dCwgcGF0aCk7XG4gICAgcmV0dXJuIHBhdGNoLnZhbHVlID8gW3BhdGNoXSA6IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHNldE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbikge1xuICAgIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGJsb2NrID0gZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICAgIGlmICh0eXBlb2YgYmxvY2suX2tleSAhPSBcInN0cmluZ1wiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBibG9jayB0byBoYXZlIGEgX2tleVwiKTtcbiAgICAgIGNvbnN0IHNldE5vZGUgPSBvbWl0Qnkoe1xuICAgICAgICAuLi5lZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dLFxuICAgICAgICAuLi5vcGVyYXRpb24ubmV3UHJvcGVydGllc1xuICAgICAgfSwgaXNVbmRlZmluZWQpO1xuICAgICAgcmV0dXJuIFtzZXQoZnJvbVNsYXRlVmFsdWUoW3NldE5vZGVdLCB0ZXh0QmxvY2tOYW1lKVswXSwgW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfV0pXTtcbiAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgYmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhibG9jaykpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV07XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgIGNvbnN0IGJsb2NrS2V5ID0gYmxvY2suX2tleSwgY2hpbGRLZXkgPSBjaGlsZC5fa2V5LCBwYXRjaGVzID0gW10sIGtleXMgPSBPYmplY3Qua2V5cyhvcGVyYXRpb24ubmV3UHJvcGVydGllcyk7XG4gICAgICAgICAgcmV0dXJuIGtleXMuZm9yRWFjaCgoa2V5TmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxICYmIGtleU5hbWUgPT09IFwiX2tleVwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGdldChvcGVyYXRpb24ubmV3UHJvcGVydGllcywga2V5TmFtZSk7XG4gICAgICAgICAgICAgIHBhdGNoZXMucHVzaChzZXQodmFsLCBbe1xuICAgICAgICAgICAgICAgIF9rZXk6IGJsb2NrS2V5XG4gICAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwgYmxvY2suY2hpbGRyZW4uaW5kZXhPZihjaGlsZCksIGtleU5hbWVdKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCB2YWwgPSBnZXQob3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMsIGtleU5hbWUpO1xuICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goc2V0KHZhbCwgW3tcbiAgICAgICAgICAgICAgICBfa2V5OiBibG9ja0tleVxuICAgICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgICAgICBfa2V5OiBjaGlsZEtleVxuICAgICAgICAgICAgICB9LCBrZXlOYW1lXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBwYXRjaGVzO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgdmFsaWQgY2hpbGRcIik7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBhIHZhbGlkIGJsb2NrXCIpO1xuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHBhdGggZW5jb3VudGVyZWQ6ICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLnBhdGgpfWApO1xuICB9XG4gIGZ1bmN0aW9uIGluc2VydE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBibG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXSwgaXNUZXh0QmxvY2syID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKTtcbiAgICBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IG9wZXJhdGlvbi5wYXRoWzBdID09PSAwID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIiwgYmVmb3JlQmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXSAtIDFdLCB0YXJnZXRLZXkgPSBvcGVyYXRpb24ucGF0aFswXSA9PT0gMCA/IGJsb2NrPy5fa2V5IDogYmVmb3JlQmxvY2s/Ll9rZXk7XG4gICAgICByZXR1cm4gdGFyZ2V0S2V5ID8gW2luc2VydChbZnJvbVNsYXRlVmFsdWUoW29wZXJhdGlvbi5ub2RlXSwgdGV4dEJsb2NrTmFtZSlbMF1dLCBwb3NpdGlvbiwgW3tcbiAgICAgICAgX2tleTogdGFyZ2V0S2V5XG4gICAgICB9XSldIDogW3NldElmTWlzc2luZyhiZWZvcmVWYWx1ZSwgW10pLCBpbnNlcnQoW2Zyb21TbGF0ZVZhbHVlKFtvcGVyYXRpb24ubm9kZV0sIHRleHRCbG9ja05hbWUpWzBdXSwgXCJiZWZvcmVcIiwgW29wZXJhdGlvbi5wYXRoWzBdXSldO1xuICAgIH0gZWxzZSBpZiAoaXNUZXh0QmxvY2syICYmIG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMiAmJiBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGJsb2NrLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCAhYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV0gLSAxXSA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCIsIG5vZGUgPSB7XG4gICAgICAgIC4uLm9wZXJhdGlvbi5ub2RlXG4gICAgICB9O1xuICAgICAgIW5vZGUuX3R5cGUgJiYgVGV4dC5pc1RleHQobm9kZSkgJiYgKG5vZGUuX3R5cGUgPSBcInNwYW5cIiwgbm9kZS5tYXJrcyA9IFtdKTtcbiAgICAgIGNvbnN0IGNoaWxkID0gZnJvbVNsYXRlVmFsdWUoW3tcbiAgICAgICAgX2tleTogXCJib2d1c1wiLFxuICAgICAgICBfdHlwZTogdGV4dEJsb2NrTmFtZSxcbiAgICAgICAgY2hpbGRyZW46IFtub2RlXVxuICAgICAgfV0sIHRleHRCbG9ja05hbWUpWzBdLmNoaWxkcmVuWzBdO1xuICAgICAgcmV0dXJuIFtpbnNlcnQoW2NoaWxkXSwgcG9zaXRpb24sIFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwgYmxvY2suY2hpbGRyZW4ubGVuZ3RoIDw9IDEgfHwgIWJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0gPyAwIDoge1xuICAgICAgICBfa2V5OiBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXSAtIDFdLl9rZXlcbiAgICAgIH1dKV07XG4gICAgfVxuICAgIHJldHVybiBkZWJ1ZyRhKFwiU29tZXRoaW5nIHdhcyBpbnNlcnRlZCBpbnRvIGEgdm9pZCBibG9jay4gTm90IHByb2R1Y2luZyBlZGl0b3IgcGF0Y2hlcy5cIiksIFtdO1xuICB9XG4gIGZ1bmN0aW9uIHNwbGl0Tm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBiZWZvcmVWYWx1ZSkge1xuICAgIGNvbnN0IHBhdGNoZXMgPSBbXSwgc3BsaXRCbG9jayA9IGVkaXRvci5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXV07XG4gICAgaWYgKCFlZGl0b3IuaXNUZXh0QmxvY2soc3BsaXRCbG9jaykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJsb2NrIHdpdGggcGF0aCAke0pTT04uc3RyaW5naWZ5KG9wZXJhdGlvbi5wYXRoWzBdKX0gaXMgbm90IGEgdGV4dCBibG9jayBhbmQgY2FuJ3QgYmUgc3BsaXRgKTtcbiAgICBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBvbGRCbG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2sob2xkQmxvY2spKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gZnJvbVNsYXRlVmFsdWUoW2VkaXRvci5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXSArIDFdXSwgdGV4dEJsb2NrTmFtZSlbMF07XG4gICAgICAgIHRhcmdldFZhbHVlICYmIChwYXRjaGVzLnB1c2goaW5zZXJ0KFt0YXJnZXRWYWx1ZV0sIFwiYWZ0ZXJcIiwgW3tcbiAgICAgICAgICBfa2V5OiBzcGxpdEJsb2NrLl9rZXlcbiAgICAgICAgfV0pKSwgb2xkQmxvY2suY2hpbGRyZW4uc2xpY2Uob3BlcmF0aW9uLnBvc2l0aW9uKS5mb3JFYWNoKChzcGFuKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGF0aCA9IFt7XG4gICAgICAgICAgICBfa2V5OiBvbGRCbG9jay5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICBfa2V5OiBzcGFuLl9rZXlcbiAgICAgICAgICB9XTtcbiAgICAgICAgICBwYXRjaGVzLnB1c2godW5zZXQocGF0aCkpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0Y2hlcztcbiAgICB9XG4gICAgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3Qgc3BsaXRTcGFuID0gc3BsaXRCbG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV07XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oc3BsaXRTcGFuKSkge1xuICAgICAgICBjb25zdCB0YXJnZXRTcGFucyA9IGZyb21TbGF0ZVZhbHVlKFt7XG4gICAgICAgICAgLi4uc3BsaXRCbG9jayxcbiAgICAgICAgICBjaGlsZHJlbjogc3BsaXRCbG9jay5jaGlsZHJlbi5zbGljZShvcGVyYXRpb24ucGF0aFsxXSArIDEsIG9wZXJhdGlvbi5wYXRoWzFdICsgMilcbiAgICAgICAgfV0sIHRleHRCbG9ja05hbWUpWzBdLmNoaWxkcmVuO1xuICAgICAgICBwYXRjaGVzLnB1c2goaW5zZXJ0KHRhcmdldFNwYW5zLCBcImFmdGVyXCIsIFt7XG4gICAgICAgICAgX2tleTogc3BsaXRCbG9jay5fa2V5XG4gICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgIF9rZXk6IHNwbGl0U3Bhbi5fa2V5XG4gICAgICAgIH1dKSksIHBhdGNoZXMucHVzaChzZXQoc3BsaXRTcGFuLnRleHQsIFt7XG4gICAgICAgICAgX2tleTogc3BsaXRCbG9jay5fa2V5XG4gICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgIF9rZXk6IHNwbGl0U3Bhbi5fa2V5XG4gICAgICAgIH0sIFwidGV4dFwiXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGNoZXM7XG4gICAgfVxuICAgIHJldHVybiBwYXRjaGVzO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBibG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoYmxvY2sgJiYgYmxvY2suX2tleSlcbiAgICAgICAgcmV0dXJuIFt1bnNldChbe1xuICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgfV0pXTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJsb2NrIG5vdCBmb3VuZFwiKTtcbiAgICB9IGVsc2UgaWYgKGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgb3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBzcGFuVG9SZW1vdmUgPSBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV07XG4gICAgICByZXR1cm4gc3BhblRvUmVtb3ZlID8gYmxvY2suY2hpbGRyZW4uZmlsdGVyKChzcGFuKSA9PiBzcGFuLl9rZXkgPT09IG9wZXJhdGlvbi5ub2RlLl9rZXkpLmxlbmd0aCA+IDEgPyAoY29uc29sZS53YXJuKGBNdWx0aXBsZSBzcGFucyBoYXZlIFxcYF9rZXlcXGAgJHtvcGVyYXRpb24ubm9kZS5fa2V5fS4gSXQncyBhbWJpZ3VvdXMgd2hpY2ggb25lIHRvIHJlbW92ZS5gLCBKU09OLnN0cmluZ2lmeShibG9jaywgbnVsbCwgMikpLCBbXSkgOiBbdW5zZXQoW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgIF9rZXk6IHNwYW5Ub1JlbW92ZS5fa2V5XG4gICAgICB9XSldIDogKGRlYnVnJGEoXCJTcGFuIG5vdCBmb3VuZCBpbiBlZGl0b3IgdHJ5aW5nIHRvIHJlbW92ZSBub2RlXCIpLCBbXSk7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gZGVidWckYShcIk5vdCBjcmVhdGluZyBwYXRjaCBpbnNpZGUgb2JqZWN0IGJsb2NrXCIpLCBbXTtcbiAgfVxuICBmdW5jdGlvbiBtZXJnZU5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBwYXRjaGVzID0gW10sIGJsb2NrID0gYmVmb3JlVmFsdWVbb3BlcmF0aW9uLnBhdGhbMF1dLCB1cGRhdGVkQmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDEpXG4gICAgICBpZiAoYmxvY2s/Ll9rZXkpIHtcbiAgICAgICAgY29uc3QgbmV3QmxvY2sgPSBmcm9tU2xhdGVWYWx1ZShbZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdIC0gMV1dLCB0ZXh0QmxvY2tOYW1lKVswXTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHNldChuZXdCbG9jaywgW3tcbiAgICAgICAgICBfa2V5OiBuZXdCbG9jay5fa2V5XG4gICAgICAgIH1dKSksIHBhdGNoZXMucHVzaCh1bnNldChbe1xuICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgfV0pKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUYXJnZXQga2V5IG5vdCBmb3VuZCFcIik7XG4gICAgZWxzZSBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBlZGl0b3IuaXNUZXh0QmxvY2sodXBkYXRlZEJsb2NrKSAmJiBvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRTcGFuID0gdXBkYXRlZEJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0gJiYgZWRpdG9yLmlzVGV4dFNwYW4odXBkYXRlZEJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0pID8gdXBkYXRlZEJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0gOiB2b2lkIDAsIHJlbW92ZWRTcGFuID0gYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dICYmIGVkaXRvci5pc1RleHRTcGFuKGJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSkgPyBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0gOiB2b2lkIDA7XG4gICAgICB1cGRhdGVkU3BhbiAmJiAoYmxvY2suY2hpbGRyZW4uZmlsdGVyKChzcGFuKSA9PiBzcGFuLl9rZXkgPT09IHVwZGF0ZWRTcGFuLl9rZXkpLmxlbmd0aCA9PT0gMSA/IHBhdGNoZXMucHVzaChzZXQodXBkYXRlZFNwYW4udGV4dCwgW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgIF9rZXk6IHVwZGF0ZWRTcGFuLl9rZXlcbiAgICAgIH0sIFwidGV4dFwiXSkpIDogY29uc29sZS53YXJuKGBNdWx0aXBsZSBzcGFucyBoYXZlIFxcYF9rZXlcXGAgJHt1cGRhdGVkU3Bhbi5fa2V5fS4gSXQncyBhbWJpZ3VvdXMgd2hpY2ggb25lIHRvIHVwZGF0ZS5gLCBKU09OLnN0cmluZ2lmeShibG9jaywgbnVsbCwgMikpKSwgcmVtb3ZlZFNwYW4gJiYgKGJsb2NrLmNoaWxkcmVuLmZpbHRlcigoc3BhbikgPT4gc3Bhbi5fa2V5ID09PSByZW1vdmVkU3Bhbi5fa2V5KS5sZW5ndGggPT09IDEgPyBwYXRjaGVzLnB1c2godW5zZXQoW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgIF9rZXk6IHJlbW92ZWRTcGFuLl9rZXlcbiAgICAgIH1dKSkgOiBjb25zb2xlLndhcm4oYE11bHRpcGxlIHNwYW5zIGhhdmUgXFxgX2tleVxcYCAke3JlbW92ZWRTcGFuLl9rZXl9LiBJdCdzIGFtYmlndW91cyB3aGljaCBvbmUgdG8gcmVtb3ZlLmAsIEpTT04uc3RyaW5naWZ5KGJsb2NrLCBudWxsLCAyKSkpO1xuICAgIH0gZWxzZVxuICAgICAgZGVidWckYShcIlZvaWQgbm9kZXMgY2FuJ3QgYmUgbWVyZ2VkLCBub3QgY3JlYXRpbmcgYW55IHBhdGNoZXNcIik7XG4gICAgcmV0dXJuIHBhdGNoZXM7XG4gIH1cbiAgZnVuY3Rpb24gbW92ZU5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBwYXRjaGVzID0gW10sIGJsb2NrID0gYmVmb3JlVmFsdWVbb3BlcmF0aW9uLnBhdGhbMF1dLCB0YXJnZXRCbG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5uZXdQYXRoWzBdXTtcbiAgICBpZiAoIXRhcmdldEJsb2NrKVxuICAgICAgcmV0dXJuIHBhdGNoZXM7XG4gICAgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBvcGVyYXRpb24ucGF0aFswXSA+IG9wZXJhdGlvbi5uZXdQYXRoWzBdID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIjtcbiAgICAgIHBhdGNoZXMucHVzaCh1bnNldChbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9XSkpLCBwYXRjaGVzLnB1c2goaW5zZXJ0KFtmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCB0ZXh0QmxvY2tOYW1lKVswXV0sIHBvc2l0aW9uLCBbe1xuICAgICAgICBfa2V5OiB0YXJnZXRCbG9jay5fa2V5XG4gICAgICB9XSkpO1xuICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAyICYmIGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgZWRpdG9yLmlzVGV4dEJsb2NrKHRhcmdldEJsb2NrKSkge1xuICAgICAgY29uc3QgY2hpbGQgPSBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0sIHRhcmdldENoaWxkID0gdGFyZ2V0QmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLm5ld1BhdGhbMV1dLCBwb3NpdGlvbiA9IG9wZXJhdGlvbi5uZXdQYXRoWzFdID09PSB0YXJnZXRCbG9jay5jaGlsZHJlbi5sZW5ndGggPyBcImFmdGVyXCIgOiBcImJlZm9yZVwiLCBjaGlsZFRvSW5zZXJ0ID0gZnJvbVNsYXRlVmFsdWUoW2Jsb2NrXSwgdGV4dEJsb2NrTmFtZSlbMF0uY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dO1xuICAgICAgcGF0Y2hlcy5wdXNoKHVuc2V0KFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICB9XSkpLCBwYXRjaGVzLnB1c2goaW5zZXJ0KFtjaGlsZFRvSW5zZXJ0XSwgcG9zaXRpb24sIFt7XG4gICAgICAgIF9rZXk6IHRhcmdldEJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBfa2V5OiB0YXJnZXRDaGlsZC5fa2V5XG4gICAgICB9XSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICByZXR1cm4ge1xuICAgIGluc2VydE5vZGVQYXRjaCxcbiAgICBpbnNlcnRUZXh0UGF0Y2gsXG4gICAgbWVyZ2VOb2RlUGF0Y2gsXG4gICAgbW92ZU5vZGVQYXRjaCxcbiAgICByZW1vdmVOb2RlUGF0Y2gsXG4gICAgcmVtb3ZlVGV4dFBhdGNoLFxuICAgIHNldE5vZGVQYXRjaCxcbiAgICBzcGxpdE5vZGVQYXRjaFxuICB9O1xufVxuY29uc3QgaW5zZXJ0QnJlYWtBY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBjb25zdCBrZXlHZW5lcmF0b3IgPSBjb250ZXh0LmtleUdlbmVyYXRvciwgc2NoZW1hID0gY29udGV4dC5zY2hlbWEsIGVkaXRvciA9IGFjdGlvbi5lZGl0b3I7XG4gIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICByZXR1cm47XG4gIGNvbnN0IGFuY2hvckJsb2NrUGF0aCA9IGVkaXRvci5zZWxlY3Rpb24uYW5jaG9yLnBhdGguc2xpY2UoMCwgMSksIGZvY3VzQmxvY2tQYXRoID0gZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpLCBmb2N1c0Jsb2NrID0gTm9kZS5kZXNjZW5kYW50KGVkaXRvciwgZm9jdXNCbG9ja1BhdGgpO1xuICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKGZvY3VzQmxvY2spICYmIGFuY2hvckJsb2NrUGF0aFswXSA9PT0gZm9jdXNCbG9ja1BhdGhbMF0pIHtcbiAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogZWRpdG9yLnNlbGVjdGlvblxuICAgIH0pO1xuICAgIGNvbnN0IFtuZXh0QmxvY2ssIG5leHRCbG9ja1BhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBQYXRoLm5leHQoZm9jdXNCbG9ja1BhdGgpLCB7XG4gICAgICBkZXB0aDogMVxuICAgIH0pLCBuZXh0Q2hpbGQgPSBOb2RlLmNoaWxkKG5leHRCbG9jaywgMCk7XG4gICAgaWYgKCFlZGl0b3IuaXNUZXh0U3BhbihuZXh0Q2hpbGQpICYmIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICBfa2V5OiBjb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgX3R5cGU6IFwic3BhblwiLFxuICAgICAgdGV4dDogXCJcIixcbiAgICAgIG1hcmtzOiBbXVxuICAgIH0sIHtcbiAgICAgIGF0OiBbbmV4dEJsb2NrUGF0aFswXSwgMF1cbiAgICB9KSwgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB7XG4gICAgICBhbmNob3I6IHtcbiAgICAgICAgcGF0aDogWy4uLm5leHRCbG9ja1BhdGgsIDBdLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czoge1xuICAgICAgICBwYXRoOiBbLi4ubmV4dEJsb2NrUGF0aCwgMF0sXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfVxuICAgIH0pLCBlZGl0b3IuaXNUZXh0QmxvY2sobmV4dEJsb2NrKSAmJiBuZXh0QmxvY2subWFya0RlZnMgJiYgbmV4dEJsb2NrLm1hcmtEZWZzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG5ld01hcmtEZWZLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgcHJldk5vZGVTcGFucyA9IEFycmF5LmZyb20oTm9kZS5jaGlsZHJlbihlZGl0b3IsIGZvY3VzQmxvY2tQYXRoKSkubWFwKChlbnRyeSkgPT4gZW50cnlbMF0pLmZpbHRlcigobm9kZSkgPT4gZWRpdG9yLmlzVGV4dFNwYW4obm9kZSkpLCBjaGlsZHJlbiA9IE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBuZXh0QmxvY2tQYXRoKTtcbiAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmICghZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBtYXJrcyA9IGNoaWxkLm1hcmtzID8/IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG1hcmsgb2YgbWFya3MpXG4gICAgICAgICAgc2NoZW1hLmRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IudmFsdWUgPT09IG1hcmspIHx8IHByZXZOb2RlU3BhbnMuc29tZSgocHJldk5vZGVTcGFuKSA9PiBwcmV2Tm9kZVNwYW4ubWFya3M/LmluY2x1ZGVzKG1hcmspKSAmJiAhbmV3TWFya0RlZktleXMuaGFzKG1hcmspICYmIG5ld01hcmtEZWZLZXlzLnNldChtYXJrLCBrZXlHZW5lcmF0b3IoKSk7XG4gICAgICAgIGNvbnN0IG5ld01hcmtzID0gbWFya3MubWFwKChtYXJrKSA9PiBuZXdNYXJrRGVmS2V5cy5nZXQobWFyaykgPz8gbWFyayk7XG4gICAgICAgIGlzRXF1YWwobWFya3MsIG5ld01hcmtzKSB8fCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtzOiBuZXdNYXJrc1xuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IGNoaWxkUGF0aFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld01hcmtEZWZzID0gbmV4dEJsb2NrLm1hcmtEZWZzLm1hcCgobWFya0RlZikgPT4gKHtcbiAgICAgICAgLi4ubWFya0RlZixcbiAgICAgICAgX2tleTogbmV3TWFya0RlZktleXMuZ2V0KG1hcmtEZWYuX2tleSkgPz8gbWFya0RlZi5fa2V5XG4gICAgICB9KSk7XG4gICAgICBpc0VxdWFsKG5leHRCbG9jay5tYXJrRGVmcywgbmV3TWFya0RlZnMpIHx8IFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIG1hcmtEZWZzOiBuZXdNYXJrRGVmc1xuICAgICAgfSwge1xuICAgICAgICBhdDogbmV4dEJsb2NrUGF0aCxcbiAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgIGFsd2F5czogITBcbiAgfSk7XG59LCBpbnNlcnRTb2Z0QnJlYWtBY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGFjdGlvblxufSkgPT4ge1xuICBpbnNlcnRUZXh0KGFjdGlvbi5lZGl0b3IsIGBcbmApO1xufSwgdG9nZ2xlTGlzdEl0ZW1BY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBpc0xpc3RJdGVtQWN0aXZlKHtcbiAgICBlZGl0b3I6IGFjdGlvbi5lZGl0b3IsXG4gICAgbGlzdEl0ZW06IGFjdGlvbi5saXN0SXRlbVxuICB9KSA/IHJlbW92ZUxpc3RJdGVtQWN0aW9uSW1wbGVtZW50YXRpb24oe1xuICAgIGNvbnRleHQsXG4gICAgYWN0aW9uOiB7XG4gICAgICAuLi5hY3Rpb24sXG4gICAgICB0eXBlOiBcImxpc3QgaXRlbS5yZW1vdmVcIlxuICAgIH1cbiAgfSkgOiBhZGRMaXN0SXRlbUFjdGlvbkltcGxlbWVudGF0aW9uKHtcbiAgICBjb250ZXh0LFxuICAgIGFjdGlvbjoge1xuICAgICAgLi4uYWN0aW9uLFxuICAgICAgdHlwZTogXCJsaXN0IGl0ZW0uYWRkXCJcbiAgICB9XG4gIH0pO1xufSwgcmVtb3ZlTGlzdEl0ZW1BY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBpZiAoIWFjdGlvbi5lZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybjtcbiAgY29uc3QgZ3VhcmRzID0gY3JlYXRlR3VhcmRzKGNvbnRleHQpLCBzZWxlY3RlZEJsb2NrcyA9IFsuLi5FZGl0b3Iubm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgIGF0OiBhY3Rpb24uZWRpdG9yLnNlbGVjdGlvbixcbiAgICBtYXRjaDogKG5vZGUpID0+IGd1YXJkcy5pc0xpc3RCbG9jayhub2RlKVxuICB9KV07XG4gIGZvciAoY29uc3QgWywgYXRdIG9mIHNlbGVjdGVkQmxvY2tzKVxuICAgIFRyYW5zZm9ybXMudW5zZXROb2RlcyhhY3Rpb24uZWRpdG9yLCBbXCJsaXN0SXRlbVwiLCBcImxldmVsXCJdLCB7XG4gICAgICBhdFxuICAgIH0pO1xufSwgYWRkTGlzdEl0ZW1BY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBpZiAoIWFjdGlvbi5lZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybjtcbiAgY29uc3QgZ3VhcmRzID0gY3JlYXRlR3VhcmRzKGNvbnRleHQpLCBzZWxlY3RlZEJsb2NrcyA9IFsuLi5FZGl0b3Iubm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgIGF0OiBhY3Rpb24uZWRpdG9yLnNlbGVjdGlvbixcbiAgICBtYXRjaDogKG5vZGUpID0+IGd1YXJkcy5pc1RleHRCbG9jayhub2RlKVxuICB9KV07XG4gIGZvciAoY29uc3QgWywgYXRdIG9mIHNlbGVjdGVkQmxvY2tzKVxuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgICAgbGV2ZWw6IDEsXG4gICAgICBsaXN0SXRlbTogYWN0aW9uLmxpc3RJdGVtXG4gICAgfSwge1xuICAgICAgYXRcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBpc0xpc3RJdGVtQWN0aXZlKHtcbiAgZWRpdG9yLFxuICBsaXN0SXRlbVxufSkge1xuICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IFsuLi5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSlcbiAgfSldO1xuICByZXR1cm4gc2VsZWN0ZWRCbG9ja3MubGVuZ3RoID4gMCA/IHNlbGVjdGVkQmxvY2tzLmV2ZXJ5KChbbm9kZV0pID0+IGVkaXRvci5pc0xpc3RCbG9jayhub2RlKSAmJiBub2RlLmxpc3RJdGVtID09PSBsaXN0SXRlbSkgOiAhMTtcbn1cbmNvbnN0IHRvZ2dsZVN0eWxlQWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBhY3Rpb25cbn0pID0+IHtcbiAgaXNTdHlsZUFjdGl2ZSh7XG4gICAgZWRpdG9yOiBhY3Rpb24uZWRpdG9yLFxuICAgIHN0eWxlOiBhY3Rpb24uc3R5bGVcbiAgfSkgPyByZW1vdmVTdHlsZUFjdGlvbkltcGxlbWVudGF0aW9uKHtcbiAgICBjb250ZXh0LFxuICAgIGFjdGlvbjoge1xuICAgICAgLi4uYWN0aW9uLFxuICAgICAgdHlwZTogXCJzdHlsZS5yZW1vdmVcIlxuICAgIH1cbiAgfSkgOiBhZGRTdHlsZUFjdGlvbkltcGxlbWVudGF0aW9uKHtcbiAgICBjb250ZXh0LFxuICAgIGFjdGlvbjoge1xuICAgICAgLi4uYWN0aW9uLFxuICAgICAgdHlwZTogXCJzdHlsZS5hZGRcIlxuICAgIH1cbiAgfSk7XG59LCByZW1vdmVTdHlsZUFjdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgY29udGV4dCxcbiAgYWN0aW9uXG59KSA9PiB7XG4gIGlmICghYWN0aW9uLmVkaXRvci5zZWxlY3Rpb24pXG4gICAgcmV0dXJuO1xuICBjb25zdCBkZWZhdWx0U3R5bGUgPSBjb250ZXh0LnNjaGVtYS5zdHlsZXNbMF0udmFsdWUsIGd1YXJkcyA9IGNyZWF0ZUd1YXJkcyhjb250ZXh0KSwgc2VsZWN0ZWRCbG9ja3MgPSBbLi4uRWRpdG9yLm5vZGVzKGFjdGlvbi5lZGl0b3IsIHtcbiAgICBhdDogYWN0aW9uLmVkaXRvci5zZWxlY3Rpb24sXG4gICAgbWF0Y2g6IChub2RlKSA9PiBndWFyZHMuaXNUZXh0QmxvY2sobm9kZSlcbiAgfSldO1xuICBmb3IgKGNvbnN0IFssIGF0XSBvZiBzZWxlY3RlZEJsb2NrcylcbiAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGFjdGlvbi5lZGl0b3IsIHtcbiAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICB9LCB7XG4gICAgICBhdFxuICAgIH0pO1xufSwgYWRkU3R5bGVBY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBpZiAoIWFjdGlvbi5lZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybjtcbiAgY29uc3QgZ3VhcmRzID0gY3JlYXRlR3VhcmRzKGNvbnRleHQpLCBzZWxlY3RlZEJsb2NrcyA9IFsuLi5FZGl0b3Iubm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgIGF0OiBhY3Rpb24uZWRpdG9yLnNlbGVjdGlvbixcbiAgICBtYXRjaDogKG5vZGUpID0+IGd1YXJkcy5pc1RleHRCbG9jayhub2RlKVxuICB9KV07XG4gIGZvciAoY29uc3QgWywgYXRdIG9mIHNlbGVjdGVkQmxvY2tzKVxuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgICAgc3R5bGU6IGFjdGlvbi5zdHlsZVxuICAgIH0sIHtcbiAgICAgIGF0XG4gICAgfSk7XG59O1xuZnVuY3Rpb24gaXNTdHlsZUFjdGl2ZSh7XG4gIGVkaXRvcixcbiAgc3R5bGVcbn0pIHtcbiAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3Qgc2VsZWN0ZWRCbG9ja3MgPSBbLi4uRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpXG4gIH0pXTtcbiAgcmV0dXJuIHNlbGVjdGVkQmxvY2tzLmxlbmd0aCA+IDAgPyBzZWxlY3RlZEJsb2Nrcy5ldmVyeSgoW25vZGVdKSA9PiBub2RlLnN0eWxlID09PSBzdHlsZSkgOiAhMTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0U3Bhbihub2RlKSB7XG4gIHJldHVybiBub2RlLl90eXBlID09PSBcInNwYW5cIiAmJiBcInRleHRcIiBpbiBub2RlICYmIHR5cGVvZiBub2RlLnRleHQgPT0gXCJzdHJpbmdcIiAmJiAodHlwZW9mIG5vZGUubWFya3MgPiBcInVcIiB8fCBBcnJheS5pc0FycmF5KG5vZGUubWFya3MpICYmIG5vZGUubWFya3MuZXZlcnkoKG1hcmspID0+IHR5cGVvZiBtYXJrID09IFwic3RyaW5nXCIpKTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0QmxvY2sobm9kZSkge1xuICByZXR1cm4gKFxuICAgIC8vIEEgYmxvY2sgZG9lc24ndCBfaGF2ZV8gdG8gYmUgbmFtZWQgJ2Jsb2NrJyAtIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlblxuICAgIC8vIGFsbG93ZWQgY2hpbGQgdHlwZXMgYW5kIG1hcmtzLCBvbmUgbWlnaHQgbmFtZSB0aGVtIGRpZmZlcmVudGx5XG4gICAgdHlwZW9mIG5vZGUuX3R5cGUgPT0gXCJzdHJpbmdcIiAmJiAvLyBUb29sa2l0LXR5cGVzIGxpa2UgbmVzdGVkIHNwYW5zIGFyZSBALXByZWZpeGVkXG4gICAgbm9kZS5fdHlwZVswXSAhPT0gXCJAXCIgJiYgLy8gYG1hcmtEZWZzYCBpc24ndCBfcmVxdWlyZWRfIHBlciBzYXksIGJ1dCBpZiBpdCdzIHRoZXJlLCBpdCBuZWVkcyB0byBiZSBhbiBhcnJheVxuICAgICghKFwibWFya0RlZnNcIiBpbiBub2RlKSB8fCAhbm9kZS5tYXJrRGVmcyB8fCBBcnJheS5pc0FycmF5KG5vZGUubWFya0RlZnMpICYmIC8vIEV2ZXJ5IG1hcmsgZGVmaW5pdGlvbiBuZWVkcyB0byBoYXZlIGFuIGBfa2V5YCB0byBiZSBtYXBwYWJsZSBpbiBjaGlsZCBzcGFuc1xuICAgIG5vZGUubWFya0RlZnMuZXZlcnkoKGRlZikgPT4gdHlwZW9mIGRlZi5fa2V5ID09IFwic3RyaW5nXCIpKSAmJiAvLyBgY2hpbGRyZW5gIGlzIHJlcXVpcmVkIGFuZCBuZWVkcyB0byBiZSBhbiBhcnJheVxuICAgIFwiY2hpbGRyZW5cIiBpbiBub2RlICYmIEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikgJiYgLy8gQWxsIGNoaWxkcmVuIGFyZSBvYmplY3RzIHdpdGggYF90eXBlYCAodXN1YWxseSBzcGFucywgYnV0IGNhbiBjb250YWluIG90aGVyIHN0dWZmKVxuICAgIG5vZGUuY2hpbGRyZW4uZXZlcnkoKGNoaWxkKSA9PiB0eXBlb2YgY2hpbGQgPT0gXCJvYmplY3RcIiAmJiBcIl90eXBlXCIgaW4gY2hpbGQpXG4gICk7XG59XG5jb25zdCBkZWNvcmF0b3JBZGRBY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSBhY3Rpb24uZWRpdG9yLCBtYXJrID0gYWN0aW9uLmRlY29yYXRvciwgdmFsdWUgPSBmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIGNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKSwgbWFudWFsQW5jaG9yID0gYWN0aW9uLm9mZnNldHM/LmFuY2hvciA/IGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQoe1xuICAgIHZhbHVlLFxuICAgIGJsb2NrT2Zmc2V0OiBhY3Rpb24ub2Zmc2V0cy5hbmNob3IsXG4gICAgZGlyZWN0aW9uOiBcImJhY2t3YXJkXCJcbiAgfSkgOiB2b2lkIDAsIG1hbnVhbEZvY3VzID0gYWN0aW9uLm9mZnNldHM/LmZvY3VzID8gYmxvY2tPZmZzZXRUb1NwYW5TZWxlY3Rpb25Qb2ludCh7XG4gICAgdmFsdWUsXG4gICAgYmxvY2tPZmZzZXQ6IGFjdGlvbi5vZmZzZXRzLmZvY3VzLFxuICAgIGRpcmVjdGlvbjogXCJmb3J3YXJkXCJcbiAgfSkgOiB2b2lkIDAsIG1hbnVhbFNlbGVjdGlvbiA9IG1hbnVhbEFuY2hvciAmJiBtYW51YWxGb2N1cyA/IHtcbiAgICBhbmNob3I6IG1hbnVhbEFuY2hvcixcbiAgICBmb2N1czogbWFudWFsRm9jdXNcbiAgfSA6IHZvaWQgMCwgc2VsZWN0aW9uID0gbWFudWFsU2VsZWN0aW9uID8gdG9TbGF0ZVJhbmdlKG1hbnVhbFNlbGVjdGlvbiwgYWN0aW9uLmVkaXRvcikgPz8gZWRpdG9yLnNlbGVjdGlvbiA6IGVkaXRvci5zZWxlY3Rpb247XG4gIGlmICghc2VsZWN0aW9uKVxuICAgIHJldHVybjtcbiAgY29uc3QgZWRpdG9yU2VsZWN0aW9uID0gdG9Qb3J0YWJsZVRleHRSYW5nZSh2YWx1ZSwgc2VsZWN0aW9uLCBjb250ZXh0LnNjaGVtYSksIGFuY2hvck9mZnNldCA9IGVkaXRvclNlbGVjdGlvbiA/IHNwYW5TZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQoe1xuICAgIHZhbHVlLFxuICAgIHNlbGVjdGlvblBvaW50OiBlZGl0b3JTZWxlY3Rpb24uYW5jaG9yXG4gIH0pIDogdm9pZCAwLCBmb2N1c09mZnNldCA9IGVkaXRvclNlbGVjdGlvbiA/IHNwYW5TZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQoe1xuICAgIHZhbHVlLFxuICAgIHNlbGVjdGlvblBvaW50OiBlZGl0b3JTZWxlY3Rpb24uZm9jdXNcbiAgfSkgOiB2b2lkIDA7XG4gIGlmICghYW5jaG9yT2Zmc2V0IHx8ICFmb2N1c09mZnNldClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBhbmNob3Igb3IgZm9jdXMgb2Zmc2V0XCIpO1xuICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHt9LCB7XG4gICAgICBhdDogc2VsZWN0aW9uLFxuICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgc3BsaXQ6ICEwLFxuICAgICAgaGFuZ2luZzogITBcbiAgICB9KTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IGZyb21TbGF0ZVZhbHVlKGVkaXRvci5jaGlsZHJlbiwgY29udGV4dC5zY2hlbWEuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpLCBuZXdTZWxlY3Rpb24gPSBibG9ja09mZnNldHNUb1NlbGVjdGlvbih7XG4gICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICBvZmZzZXRzOiB7XG4gICAgICAgIGFuY2hvcjogYW5jaG9yT2Zmc2V0LFxuICAgICAgICBmb2N1czogZm9jdXNPZmZzZXRcbiAgICAgIH0sXG4gICAgICBiYWNrd2FyZDogZWRpdG9yU2VsZWN0aW9uPy5iYWNrd2FyZFxuICAgIH0pLCB0cmltbWVkU2VsZWN0aW9uID0gZ2V0VHJpbW1lZFNlbGVjdGlvbih7XG4gICAgICBiZXRhOiB7XG4gICAgICAgIGhhc1RhZzogKCkgPT4gITFcbiAgICAgIH0sXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIGFjdGl2ZURlY29yYXRvcnM6IFtdLFxuICAgICAgICBjb252ZXJ0ZXJzOiBbXSxcbiAgICAgICAga2V5R2VuZXJhdG9yOiBjb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYSxcbiAgICAgICAgc2VsZWN0aW9uOiBuZXdTZWxlY3Rpb24sXG4gICAgICAgIHZhbHVlOiBuZXdWYWx1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghdHJpbW1lZFNlbGVjdGlvbilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHRyaW1tZWQgc2VsZWN0aW9uXCIpO1xuICAgIGNvbnN0IG5ld1JhbmdlID0gdG9TbGF0ZVJhbmdlKHRyaW1tZWRTZWxlY3Rpb24sIGVkaXRvcik7XG4gICAgaWYgKCFuZXdSYW5nZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIG5ldyBzZWxlY3Rpb25cIik7XG4gICAgY29uc3Qgc3BsaXRUZXh0Tm9kZXMgPSBSYW5nZS5pc1JhbmdlKG5ld1JhbmdlKSA/IFsuLi5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogbmV3UmFuZ2UsXG4gICAgICBtYXRjaDogKG5vZGUpID0+IFRleHQuaXNUZXh0KG5vZGUpXG4gICAgfSldIDogW107XG4gICAgZm9yIChjb25zdCBbbm9kZSwgcGF0aF0gb2Ygc3BsaXRUZXh0Tm9kZXMpIHtcbiAgICAgIGNvbnN0IG1hcmtzID0gWy4uLihBcnJheS5pc0FycmF5KG5vZGUubWFya3MpID8gbm9kZS5tYXJrcyA6IFtdKS5maWx0ZXIoKGVNYXJrKSA9PiBlTWFyayAhPT0gbWFyayksIG1hcmtdO1xuICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgbWFya3NcbiAgICAgIH0sIHtcbiAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgICAgc3BsaXQ6ICEwLFxuICAgICAgICBoYW5naW5nOiAhMFxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uLCB7XG4gICAgICBkZXB0aDogMVxuICAgIH0pLCBsb25lbHlFbXB0eVNwYW4gPSBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIGJsb2NrLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBlZGl0b3IuaXNUZXh0U3BhbihibG9jay5jaGlsZHJlblswXSkgJiYgYmxvY2suY2hpbGRyZW5bMF0udGV4dCA9PT0gXCJcIiA/IGJsb2NrLmNoaWxkcmVuWzBdIDogdm9pZCAwO1xuICAgIGlmIChsb25lbHlFbXB0eVNwYW4pIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nTWFya3MgPSBsb25lbHlFbXB0eVNwYW4ubWFya3MgPz8gW10sIGV4aXN0aW5nTWFya3NXaXRob3V0RGVjb3JhdG9yID0gZXhpc3RpbmdNYXJrcy5maWx0ZXIoKGV4aXN0aW5nTWFyaykgPT4gZXhpc3RpbmdNYXJrICE9PSBtYXJrKTtcbiAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIG1hcmtzOiBleGlzdGluZ01hcmtzLmxlbmd0aCA9PT0gZXhpc3RpbmdNYXJrc1dpdGhvdXREZWNvcmF0b3IubGVuZ3RoID8gWy4uLmV4aXN0aW5nTWFya3MsIG1hcmtdIDogZXhpc3RpbmdNYXJrc1dpdGhvdXREZWNvcmF0b3JcbiAgICAgIH0sIHtcbiAgICAgICAgYXQ6IGJsb2NrUGF0aCxcbiAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0U3Bhbihub2RlKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nTWFya3MgPSB7XG4gICAgICAgIC4uLkVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9XG4gICAgICB9Lm1hcmtzIHx8IFtdLCBtYXJrcyA9IHtcbiAgICAgICAgLi4uRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge30sXG4gICAgICAgIG1hcmtzOiBbLi4uZXhpc3RpbmdNYXJrcywgbWFya11cbiAgICAgIH07XG4gICAgICBlZGl0b3IubWFya3MgPSBtYXJrcztcbiAgICB9XG4gIH1cbiAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICBjb25zdCBzZWxlY3Rpb24yID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICBlZGl0b3Iuc2VsZWN0aW9uID0ge1xuICAgICAgLi4uc2VsZWN0aW9uMlxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRQcmV2aW91c1NwYW4oe1xuICBlZGl0b3IsXG4gIGJsb2NrUGF0aCxcbiAgc3BhblBhdGhcbn0pIHtcbiAgbGV0IHByZXZpb3VzU3BhbjtcbiAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgTm9kZS5jaGlsZHJlbihlZGl0b3IsIGJsb2NrUGF0aCwge1xuICAgIHJldmVyc2U6ICEwXG4gIH0pKVxuICAgIGlmIChlZGl0b3IuaXNUZXh0U3BhbihjaGlsZCkgJiYgUGF0aC5pc0JlZm9yZShjaGlsZFBhdGgsIHNwYW5QYXRoKSkge1xuICAgICAgcHJldmlvdXNTcGFuID0gY2hpbGQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBwcmV2aW91c1NwYW47XG59XG5mdW5jdGlvbiBnZXROZXh0U3Bhbih7XG4gIGVkaXRvcixcbiAgYmxvY2tQYXRoLFxuICBzcGFuUGF0aFxufSkge1xuICBsZXQgbmV4dFNwYW47XG4gIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBibG9ja1BhdGgpKVxuICAgIGlmIChlZGl0b3IuaXNUZXh0U3BhbihjaGlsZCkgJiYgUGF0aC5pc0FmdGVyKGNoaWxkUGF0aCwgc3BhblBhdGgpKSB7XG4gICAgICBuZXh0U3BhbiA9IGNoaWxkO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gbmV4dFNwYW47XG59XG5jb25zdCBkZWJ1ZyQ5ID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoUG9ydGFibGVUZXh0TWFya01vZGVsXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dE1hcmtNb2RlbChlZGl0b3JBY3RvciwgdHlwZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGFwcGx5OiBhcHBseTIsXG4gICAgICBub3JtYWxpemVOb2RlXG4gICAgfSA9IGVkaXRvciwgZGVjb3JhdG9ycyA9IHR5cGVzLmRlY29yYXRvcnMubWFwKCh0KSA9PiB0LnZhbHVlKTtcbiAgICByZXR1cm4gZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSAobm9kZUVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBbbm9kZSwgcGF0aF0gPSBub2RlRW50cnk7XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gTm9kZS5jaGlsZHJlbihlZGl0b3IsIHBhdGgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBjaGlsZHJlbikge1xuICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gbm9kZS5jaGlsZHJlbltjaGlsZFBhdGhbMV0gKyAxXTtcbiAgICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpICYmIGVkaXRvci5pc1RleHRTcGFuKG5leHROb2RlKSAmJiBjaGlsZC5tYXJrcz8uZXZlcnkoKG1hcmspID0+IG5leHROb2RlLm1hcmtzPy5pbmNsdWRlcyhtYXJrKSkgJiYgbmV4dE5vZGUubWFya3M/LmV2ZXJ5KChtYXJrKSA9PiBjaGlsZC5tYXJrcz8uaW5jbHVkZXMobWFyaykpKSB7XG4gICAgICAgICAgICBkZWJ1ZyQ5KFwiTWVyZ2luZyBzcGFuc1wiLCBKU09OLnN0cmluZ2lmeShjaGlsZCwgbnVsbCwgMiksIEpTT04uc3RyaW5naWZ5KG5leHROb2RlLCBudWxsLCAyKSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLm1lcmdlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBbY2hpbGRQYXRoWzBdLCBjaGlsZFBhdGhbMV0gKyAxXSxcbiAgICAgICAgICAgICAgdm9pZHM6ICEwXG4gICAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkgJiYgIUFycmF5LmlzQXJyYXkobm9kZS5tYXJrRGVmcykpIHtcbiAgICAgICAgZGVidWckOShcIkFkZGluZyAubWFya0RlZnMgdG8gYmxvY2sgbm9kZVwiKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtEZWZzOiBbXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4obm9kZSkgJiYgIUFycmF5LmlzQXJyYXkobm9kZS5tYXJrcykpIHtcbiAgICAgICAgZGVidWckOShcIkFkZGluZyAubWFya3MgdG8gc3BhbiBub2RlXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWFya3M6IFtdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0U3Bhbihub2RlKSkge1xuICAgICAgICBjb25zdCBibG9ja1BhdGggPSBQYXRoLnBhcmVudChwYXRoKSwgW2Jsb2NrXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgYmxvY2tQYXRoKSwgZGVjb3JhdG9yczIgPSB0eXBlcy5kZWNvcmF0b3JzLm1hcCgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IudmFsdWUpLCBhbm5vdGF0aW9ucyA9IG5vZGUubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWRlY29yYXRvcnMyLmluY2x1ZGVzKG1hcmspKTtcbiAgICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgbm9kZS50ZXh0ID09PSBcIlwiICYmIGFubm90YXRpb25zICYmIGFubm90YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkZWJ1ZyQ5KFwiUmVtb3ZpbmcgYW5ub3RhdGlvbnMgZnJvbSBlbXB0eSBzcGFuIG5vZGVcIiksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBtYXJrczogbm9kZS5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiBkZWNvcmF0b3JzMi5pbmNsdWRlcyhtYXJrKSlcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGRlY29yYXRvcnMyID0gdHlwZXMuZGVjb3JhdG9ycy5tYXAoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLnZhbHVlKTtcbiAgICAgICAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgTm9kZS5jaGlsZHJlbihlZGl0b3IsIHBhdGgpKVxuICAgICAgICAgIGlmIChlZGl0b3IuaXNUZXh0U3BhbihjaGlsZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtzID0gY2hpbGQubWFya3MgPz8gW10sIG9ycGhhbmVkQW5ub3RhdGlvbnMgPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzMi5pbmNsdWRlcyhtYXJrKSAmJiAhbm9kZS5tYXJrRGVmcz8uZmluZCgoZGVmKSA9PiBkZWYuX2tleSA9PT0gbWFyaykpO1xuICAgICAgICAgICAgaWYgKG9ycGhhbmVkQW5ub3RhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBkZWJ1ZyQ5KFwiUmVtb3Zpbmcgb3JwaGFuZWQgYW5ub3RhdGlvbnMgZnJvbSBzcGFuIG5vZGVcIiksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBtYXJrczogbWFya3MuZmlsdGVyKChtYXJrKSA9PiAhb3JwaGFuZWRBbm5vdGF0aW9ucy5pbmNsdWRlcyhtYXJrKSlcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrUGF0aCA9IFBhdGgucGFyZW50KHBhdGgpLCBbYmxvY2tdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBibG9ja1BhdGgpO1xuICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSkge1xuICAgICAgICAgIGNvbnN0IGRlY29yYXRvcnMyID0gdHlwZXMuZGVjb3JhdG9ycy5tYXAoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLnZhbHVlKSwgbWFya3MgPSBub2RlLm1hcmtzID8/IFtdLCBvcnBoYW5lZEFubm90YXRpb25zID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiAhZGVjb3JhdG9yczIuaW5jbHVkZXMobWFyaykgJiYgIWJsb2NrLm1hcmtEZWZzPy5maW5kKChkZWYpID0+IGRlZi5fa2V5ID09PSBtYXJrKSk7XG4gICAgICAgICAgaWYgKG9ycGhhbmVkQW5ub3RhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGVidWckOShcIlJlbW92aW5nIG9ycGhhbmVkIGFubm90YXRpb25zIGZyb20gc3BhbiBub2RlXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgbWFya3M6IG1hcmtzLmZpbHRlcigobWFyaykgPT4gIW9ycGhhbmVkQW5ub3RhdGlvbnMuaW5jbHVkZXMobWFyaykpXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkpIHtcbiAgICAgICAgY29uc3QgbWFya0RlZnMgPSBub2RlLm1hcmtEZWZzID8/IFtdLCBtYXJrRGVmS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIG5ld01hcmtEZWZzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbWFya0RlZiBvZiBtYXJrRGVmcylcbiAgICAgICAgICBtYXJrRGVmS2V5cy5oYXMobWFya0RlZi5fa2V5KSB8fCAobWFya0RlZktleXMuYWRkKG1hcmtEZWYuX2tleSksIG5ld01hcmtEZWZzLnB1c2gobWFya0RlZikpO1xuICAgICAgICBpZiAobWFya0RlZnMubGVuZ3RoICE9PSBuZXdNYXJrRGVmcy5sZW5ndGgpIHtcbiAgICAgICAgICBkZWJ1ZyQ5KFwiUmVtb3ZpbmcgZHVwbGljYXRlIG1hcmtEZWZzXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbWFya0RlZnM6IG5ld01hcmtEZWZzXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhub2RlKSAmJiAhZWRpdG9yLm9wZXJhdGlvbnMuc29tZSgob3ApID0+IG9wLnR5cGUgPT09IFwibWVyZ2Vfbm9kZVwiICYmIFwibWFya0RlZnNcIiBpbiBvcC5wcm9wZXJ0aWVzICYmIG9wLnBhdGgubGVuZ3RoID09PSAxKSkge1xuICAgICAgICBjb25zdCBuZXdNYXJrRGVmcyA9IChub2RlLm1hcmtEZWZzIHx8IFtdKS5maWx0ZXIoKGRlZikgPT4gbm9kZS5jaGlsZHJlbi5maW5kKChjaGlsZCkgPT4gVGV4dC5pc1RleHQoY2hpbGQpICYmIEFycmF5LmlzQXJyYXkoY2hpbGQubWFya3MpICYmIGNoaWxkLm1hcmtzLmluY2x1ZGVzKGRlZi5fa2V5KSkpO1xuICAgICAgICBpZiAobm9kZS5tYXJrRGVmcyAmJiAhaXNFcXVhbChuZXdNYXJrRGVmcywgbm9kZS5tYXJrRGVmcykpIHtcbiAgICAgICAgICBkZWJ1ZyQ5KFwiUmVtb3ZpbmcgbWFya0RlZiBub3QgaW4gdXNlXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbWFya0RlZnM6IG5ld01hcmtEZWZzXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9ybWFsaXplTm9kZShub2RlRW50cnkpO1xuICAgIH0sIGVkaXRvci5hcHBseSA9IChvcCkgPT4ge1xuICAgICAgaWYgKGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZG9pbmcoZWRpdG9yKSB8fCBpc1JlZG9pbmcoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIgJiYgRWRpdG9yLm1hcmtzKGVkaXRvcikgJiYgb3AucHJvcGVydGllcyAmJiBvcC5uZXdQcm9wZXJ0aWVzICYmIG9wLnByb3BlcnRpZXMuYW5jaG9yICYmIG9wLnByb3BlcnRpZXMuZm9jdXMgJiYgb3AubmV3UHJvcGVydGllcy5hbmNob3IgJiYgb3AubmV3UHJvcGVydGllcy5mb2N1cykge1xuICAgICAgICBjb25zdCBwcmV2aW91c1NlbGVjdGlvbklzQ29sbGFwc2VkID0gUmFuZ2UuaXNDb2xsYXBzZWQoe1xuICAgICAgICAgIGFuY2hvcjogb3AucHJvcGVydGllcy5hbmNob3IsXG4gICAgICAgICAgZm9jdXM6IG9wLnByb3BlcnRpZXMuZm9jdXNcbiAgICAgICAgfSksIG5ld1NlbGVjdGlvbklzQ29sbGFwc2VkID0gUmFuZ2UuaXNDb2xsYXBzZWQoe1xuICAgICAgICAgIGFuY2hvcjogb3AubmV3UHJvcGVydGllcy5hbmNob3IsXG4gICAgICAgICAgZm9jdXM6IG9wLm5ld1Byb3BlcnRpZXMuZm9jdXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcmV2aW91c1NlbGVjdGlvbklzQ29sbGFwc2VkICYmIG5ld1NlbGVjdGlvbklzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgY29uc3QgZm9jdXNTcGFuID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBtb2RlOiBcImxvd2VzdFwiLFxuICAgICAgICAgICAgYXQ6IG9wLnByb3BlcnRpZXMuZm9jdXMsXG4gICAgICAgICAgICBtYXRjaDogKG4pID0+IGVkaXRvci5pc1RleHRTcGFuKG4pLFxuICAgICAgICAgICAgdm9pZHM6ICExXG4gICAgICAgICAgfSkpWzBdPy5bMF0sIG5ld0ZvY3VzU3BhbiA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbW9kZTogXCJsb3dlc3RcIixcbiAgICAgICAgICAgIGF0OiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLFxuICAgICAgICAgICAgbWF0Y2g6IChuKSA9PiBlZGl0b3IuaXNUZXh0U3BhbihuKSxcbiAgICAgICAgICAgIHZvaWRzOiAhMVxuICAgICAgICAgIH0pKVswXT8uWzBdLCBtb3ZlZFRvTmV4dFNwYW4gPSBmb2N1c1NwYW4gJiYgbmV3Rm9jdXNTcGFuICYmIG9wLm5ld1Byb3BlcnRpZXMuZm9jdXMucGF0aFswXSA9PT0gb3AucHJvcGVydGllcy5mb2N1cy5wYXRoWzBdICYmIG9wLm5ld1Byb3BlcnRpZXMuZm9jdXMucGF0aFsxXSA9PT0gb3AucHJvcGVydGllcy5mb2N1cy5wYXRoWzFdICsgMSAmJiBmb2N1c1NwYW4udGV4dC5sZW5ndGggPT09IG9wLnByb3BlcnRpZXMuZm9jdXMub2Zmc2V0ICYmIG9wLm5ld1Byb3BlcnRpZXMuZm9jdXMub2Zmc2V0ID09PSAwLCBtb3ZlZFRvUHJldmlvdXNTcGFuID0gZm9jdXNTcGFuICYmIG5ld0ZvY3VzU3BhbiAmJiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMF0gPT09IG9wLnByb3BlcnRpZXMuZm9jdXMucGF0aFswXSAmJiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMV0gPT09IG9wLnByb3BlcnRpZXMuZm9jdXMucGF0aFsxXSAtIDEgJiYgb3AucHJvcGVydGllcy5mb2N1cy5vZmZzZXQgPT09IDAgJiYgbmV3Rm9jdXNTcGFuLnRleHQubGVuZ3RoID09PSBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLm9mZnNldDtcbiAgICAgICAgICBpZiAobW92ZWRUb05leHRTcGFuIHx8IG1vdmVkVG9QcmV2aW91c1NwYW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcC50eXBlID09PSBcImluc2VydF9ub2RlXCIpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNlbGVjdGlvblxuICAgICAgICB9ID0gZWRpdG9yO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgY29uc3QgW19ibG9jaywgYmxvY2tQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uLCB7XG4gICAgICAgICAgICBkZXB0aDogMVxuICAgICAgICAgIH0pLCBwcmV2aW91c1NwYW4gPSBnZXRQcmV2aW91c1NwYW4oe1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgYmxvY2tQYXRoLFxuICAgICAgICAgICAgc3BhblBhdGg6IG9wLnBhdGhcbiAgICAgICAgICB9KSwgcHJldmlvdXNTcGFuQW5ub3RhdGlvbnMgPSBwcmV2aW91c1NwYW4gPyBwcmV2aW91c1NwYW4ubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpIDogW10sIG5leHRTcGFuID0gZ2V0TmV4dFNwYW4oe1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgYmxvY2tQYXRoLFxuICAgICAgICAgICAgc3BhblBhdGg6IFtvcC5wYXRoWzBdLCBvcC5wYXRoWzFdIC0gMV1cbiAgICAgICAgICB9KSwgbmV4dFNwYW5Bbm5vdGF0aW9ucyA9IG5leHRTcGFuID8gbmV4dFNwYW4ubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpIDogW10sIGFubm90YXRpb25zRW5kaW5nID0gcHJldmlvdXNTcGFuQW5ub3RhdGlvbnM/LmZpbHRlcigoYW5ub3RhdGlvbikgPT4gIW5leHRTcGFuQW5ub3RhdGlvbnM/LmluY2x1ZGVzKGFubm90YXRpb24pKSA/PyBbXSwgYXRUaGVFbmRPZkFubm90YXRpb24gPSBhbm5vdGF0aW9uc0VuZGluZy5sZW5ndGggPiAwO1xuICAgICAgICAgIGlmIChhdFRoZUVuZE9mQW5ub3RhdGlvbiAmJiBpc1BvcnRhYmxlVGV4dFNwYW4ob3Aubm9kZSkgJiYgb3Aubm9kZS5tYXJrcz8uc29tZSgobWFyaykgPT4gYW5ub3RhdGlvbnNFbmRpbmcuaW5jbHVkZXMobWFyaykpKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAuLi5vcC5ub2RlLFxuICAgICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgICAgIG1hcmtzOiBvcC5ub2RlLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+ICFhbm5vdGF0aW9uc0VuZGluZy5pbmNsdWRlcyhtYXJrKSkgPz8gW11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhbm5vdGF0aW9uc1N0YXJ0aW5nID0gbmV4dFNwYW5Bbm5vdGF0aW9ucz8uZmlsdGVyKChhbm5vdGF0aW9uKSA9PiAhcHJldmlvdXNTcGFuQW5ub3RhdGlvbnM/LmluY2x1ZGVzKGFubm90YXRpb24pKSA/PyBbXSwgYXRUaGVTdGFydE9mQW5ub3RhdGlvbiA9IGFubm90YXRpb25zU3RhcnRpbmcubGVuZ3RoID4gMDtcbiAgICAgICAgICBpZiAoYXRUaGVTdGFydE9mQW5ub3RhdGlvbiAmJiBpc1BvcnRhYmxlVGV4dFNwYW4ob3Aubm9kZSkgJiYgb3Aubm9kZS5tYXJrcz8uc29tZSgobWFyaykgPT4gYW5ub3RhdGlvbnNTdGFydGluZy5pbmNsdWRlcyhtYXJrKSkpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIC4uLm9wLm5vZGUsXG4gICAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICAgICAgbWFya3M6IG9wLm5vZGUubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWFubm90YXRpb25zU3RhcnRpbmcuaW5jbHVkZXMobWFyaykpID8/IFtdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbmV4dFNwYW5EZWNvcmF0b3JzID0gbmV4dFNwYW4/Lm1hcmtzPy5maWx0ZXIoKG1hcmspID0+IGRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpID8/IFtdO1xuICAgICAgICAgIGlmIChuZXh0U3BhbkRlY29yYXRvcnMubGVuZ3RoID4gMCAmJiBhdFRoZUVuZE9mQW5ub3RhdGlvbiAmJiAhYXRUaGVTdGFydE9mQW5ub3RhdGlvbiAmJiBpc1BvcnRhYmxlVGV4dFNwYW4ob3Aubm9kZSkgJiYgb3Aubm9kZS5tYXJrcz8ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAuLi5vcC5ub2RlLFxuICAgICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgICAgIG1hcmtzOiBuZXh0U3BhbkRlY29yYXRvcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wLnR5cGUgPT09IFwiaW5zZXJ0X3RleHRcIikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2VsZWN0aW9uXG4gICAgICAgIH0gPSBlZGl0b3IsIGNvbGxhcHNlZFNlbGVjdGlvbiA9IHNlbGVjdGlvbiA/IFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikgOiAhMTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBjb2xsYXBzZWRTZWxlY3Rpb24pIHtcbiAgICAgICAgICBjb25zdCBbX2Jsb2NrLCBibG9ja1BhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24sIHtcbiAgICAgICAgICAgIGRlcHRoOiAxXG4gICAgICAgICAgfSksIFtzcGFuLCBzcGFuUGF0aF0gPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1vZGU6IFwibG93ZXN0XCIsXG4gICAgICAgICAgICBhdDogc2VsZWN0aW9uLmZvY3VzLFxuICAgICAgICAgICAgbWF0Y2g6IChuKSA9PiBlZGl0b3IuaXNUZXh0U3BhbihuKSxcbiAgICAgICAgICAgIHZvaWRzOiAhMVxuICAgICAgICAgIH0pKVswXSA/PyBbdm9pZCAwLCB2b2lkIDBdLCBtYXJrcyA9IHNwYW4ubWFya3MgPz8gW10sIG1hcmtzV2l0aG91dEFubm90YXRpb25zID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiBkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSwgc3Bhbkhhc0Fubm90YXRpb25zID0gbWFya3MubGVuZ3RoID4gbWFya3NXaXRob3V0QW5ub3RhdGlvbnMubGVuZ3RoLCBzcGFuSXNFbXB0eSA9IHNwYW4udGV4dC5sZW5ndGggPT09IDAsIGF0VGhlQmVnaW5uaW5nT2ZTcGFuID0gc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IDAsIGF0VGhlRW5kT2ZTcGFuID0gc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IHNwYW4udGV4dC5sZW5ndGgsIHByZXZpb3VzU3BhbiA9IGdldFByZXZpb3VzU3Bhbih7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBibG9ja1BhdGgsXG4gICAgICAgICAgICBzcGFuUGF0aFxuICAgICAgICAgIH0pLCBuZXh0U3BhbiA9IGdldE5leHRTcGFuKHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGJsb2NrUGF0aCxcbiAgICAgICAgICAgIHNwYW5QYXRoXG4gICAgICAgICAgfSksIG5leHRTcGFuQW5ub3RhdGlvbnMgPSBuZXh0U3Bhbj8ubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpID8/IFtdLCBzcGFuQW5ub3RhdGlvbnMgPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSwgcHJldmlvdXNTcGFuSGFzQW5ub3RhdGlvbnMgPSBwcmV2aW91c1NwYW4gPyBwcmV2aW91c1NwYW4ubWFya3M/LnNvbWUoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSA6ICExLCBwcmV2aW91c1NwYW5IYXNTYW1lQW5ub3RhdGlvbnMgPSBwcmV2aW91c1NwYW4gPyBwcmV2aW91c1NwYW4ubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpLmV2ZXJ5KChtYXJrKSA9PiBtYXJrcy5pbmNsdWRlcyhtYXJrKSkgOiAhMSwgcHJldmlvdXNTcGFuSGFzU2FtZUFubm90YXRpb24gPSBwcmV2aW91c1NwYW4gPyBwcmV2aW91c1NwYW4ubWFya3M/LnNvbWUoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspICYmIG1hcmtzLmluY2x1ZGVzKG1hcmspKSA6ICExLCBwcmV2aW91c1NwYW5IYXNTYW1lTWFya3MgPSBwcmV2aW91c1NwYW4gPyBwcmV2aW91c1NwYW4ubWFya3M/LmV2ZXJ5KChtYXJrKSA9PiBtYXJrcy5pbmNsdWRlcyhtYXJrKSkgOiAhMSwgbmV4dFNwYW5TaGFyZXNTb21lQW5ub3RhdGlvbnMgPSBzcGFuQW5ub3RhdGlvbnMuc29tZSgobWFyaykgPT4gbmV4dFNwYW5Bbm5vdGF0aW9ucz8uaW5jbHVkZXMobWFyaykpO1xuICAgICAgICAgIGlmIChzcGFuSGFzQW5ub3RhdGlvbnMgJiYgIXNwYW5Jc0VtcHR5KSB7XG4gICAgICAgICAgICBpZiAoYXRUaGVCZWdpbm5pbmdPZlNwYW4pIHtcbiAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU3Bhbkhhc1NhbWVNYXJrcykge1xuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBvcC50ZXh0LFxuICAgICAgICAgICAgICAgICAgbWFya3M6IHByZXZpb3VzU3Bhbj8ubWFya3MgPz8gW11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNTcGFuSGFzU2FtZUFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IG9wLnRleHQsXG4gICAgICAgICAgICAgICAgICBtYXJrczogcHJldmlvdXNTcGFuPy5tYXJrcyA/PyBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c1NwYW5IYXNTYW1lQW5ub3RhdGlvbikge1xuICAgICAgICAgICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFwcmV2aW91c1NwYW4pIHtcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgX3R5cGU6IFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICAgICAgICAgICAgdGV4dDogb3AudGV4dCxcbiAgICAgICAgICAgICAgICAgIG1hcmtzOiBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF0VGhlRW5kT2ZTcGFuKSB7XG4gICAgICAgICAgICAgIGlmIChuZXh0U3BhbiAmJiBuZXh0U3BhblNoYXJlc1NvbWVBbm5vdGF0aW9ucyAmJiBuZXh0U3BhbkFubm90YXRpb25zLmxlbmd0aCA8IHNwYW5Bbm5vdGF0aW9ucy5sZW5ndGggfHwgIW5leHRTcGFuU2hhcmVzU29tZUFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IG9wLnRleHQsXG4gICAgICAgICAgICAgICAgICBtYXJrczogbmV4dFNwYW4/Lm1hcmtzID8/IFtdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghbmV4dFNwYW4pIHtcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgX3R5cGU6IFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICAgICAgICAgICAgdGV4dDogb3AudGV4dCxcbiAgICAgICAgICAgICAgICAgIG1hcmtzOiBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXRUaGVCZWdpbm5pbmdPZlNwYW4gJiYgIXNwYW5Jc0VtcHR5ICYmIHByZXZpb3VzU3Bhbikge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgX3R5cGU6IFwic3BhblwiLFxuICAgICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgICAgIHRleHQ6IG9wLnRleHQsXG4gICAgICAgICAgICAgIG1hcmtzOiBwcmV2aW91c1NwYW5IYXNBbm5vdGF0aW9ucyA/IFtdIDogKHByZXZpb3VzU3Bhbi5tYXJrcyA/PyBbXSkuZmlsdGVyKChtYXJrKSA9PiBkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJyZW1vdmVfdGV4dFwiKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgfSA9IGVkaXRvcjtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICBjb25zdCBbYmxvY2ssIGJsb2NrUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbiwge1xuICAgICAgICAgICAgZGVwdGg6IDFcbiAgICAgICAgICB9KSwgW3NwYW4sIHNwYW5QYXRoXSA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbW9kZTogXCJsb3dlc3RcIixcbiAgICAgICAgICAgIGF0OiB7XG4gICAgICAgICAgICAgIHBhdGg6IG9wLnBhdGgsXG4gICAgICAgICAgICAgIG9mZnNldDogb3Aub2Zmc2V0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF0Y2g6IChuKSA9PiBlZGl0b3IuaXNUZXh0U3BhbihuKSxcbiAgICAgICAgICAgIHZvaWRzOiAhMVxuICAgICAgICAgIH0pKVswXSA/PyBbdm9pZCAwLCB2b2lkIDBdO1xuICAgICAgICAgIGlmIChzcGFuICYmIGJsb2NrICYmIGlzUG9ydGFibGVUZXh0QmxvY2soYmxvY2spKSB7XG4gICAgICAgICAgICBjb25zdCBtYXJrRGVmcyA9IGJsb2NrLm1hcmtEZWZzID8/IFtdLCBtYXJrcyA9IHNwYW4ubWFya3MgPz8gW10sIHNwYW5IYXNBbm5vdGF0aW9ucyA9IG1hcmtzLnNvbWUoKG1hcmspID0+IG1hcmtEZWZzLmZpbmQoKG1hcmtEZWYpID0+IG1hcmtEZWYuX2tleSA9PT0gbWFyaykpLCBkZWxldGluZ0Zyb21UaGVFbmQgPSBvcC5vZmZzZXQgKyBvcC50ZXh0Lmxlbmd0aCA9PT0gc3Bhbi50ZXh0Lmxlbmd0aCwgZGVsZXRpbmdBbGxUZXh0ID0gb3Aub2Zmc2V0ID09PSAwICYmIGRlbGV0aW5nRnJvbVRoZUVuZCwgcHJldmlvdXNTcGFuID0gZ2V0UHJldmlvdXNTcGFuKHtcbiAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICBibG9ja1BhdGgsXG4gICAgICAgICAgICAgIHNwYW5QYXRoXG4gICAgICAgICAgICB9KSwgbmV4dFNwYW4gPSBnZXROZXh0U3Bhbih7XG4gICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgYmxvY2tQYXRoLFxuICAgICAgICAgICAgICBzcGFuUGF0aFxuICAgICAgICAgICAgfSksIHByZXZpb3VzU3Bhbkhhc1NhbWVBbm5vdGF0aW9uID0gcHJldmlvdXNTcGFuID8gcHJldmlvdXNTcGFuLm1hcmtzPy5zb21lKChtYXJrKSA9PiAhZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSAmJiBtYXJrcy5pbmNsdWRlcyhtYXJrKSkgOiAhMSwgbmV4dFNwYW5IYXNTYW1lQW5ub3RhdGlvbiA9IG5leHRTcGFuID8gbmV4dFNwYW4ubWFya3M/LnNvbWUoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspICYmIG1hcmtzLmluY2x1ZGVzKG1hcmspKSA6ICExO1xuICAgICAgICAgICAgaWYgKHNwYW5IYXNBbm5vdGF0aW9ucyAmJiBkZWxldGluZ0FsbFRleHQgJiYgIXByZXZpb3VzU3Bhbkhhc1NhbWVBbm5vdGF0aW9uICYmICFuZXh0U3Bhbkhhc1NhbWVBbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1hcmtzV2l0aG91dEFubm90YXRpb25NYXJrcyA9ICh7XG4gICAgICAgICAgICAgICAgLi4uRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge31cbiAgICAgICAgICAgICAgfS5tYXJrcyB8fCBbXSkuZmlsdGVyKChtYXJrKSA9PiBkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKTtcbiAgICAgICAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgICBhcHBseTIob3ApLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgbWFya3M6IG1hcmtzV2l0aG91dEFubm90YXRpb25NYXJrc1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIGF0OiBvcC5wYXRoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wLnR5cGUgPT09IFwibWVyZ2Vfbm9kZVwiICYmIG9wLnBhdGgubGVuZ3RoID09PSAxICYmIFwibWFya0RlZnNcIiBpbiBvcC5wcm9wZXJ0aWVzICYmIG9wLnByb3BlcnRpZXMuX3R5cGUgPT09IHR5cGVzLmJsb2NrLm5hbWUgJiYgQXJyYXkuaXNBcnJheShvcC5wcm9wZXJ0aWVzLm1hcmtEZWZzKSAmJiBvcC5wcm9wZXJ0aWVzLm1hcmtEZWZzLmxlbmd0aCA+IDAgJiYgb3AucGF0aFswXSAtIDEgPj0gMCkge1xuICAgICAgICBjb25zdCBbdGFyZ2V0QmxvY2ssIHRhcmdldFBhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBbb3AucGF0aFswXSAtIDFdKTtcbiAgICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayh0YXJnZXRCbG9jaykpIHtcbiAgICAgICAgICBjb25zdCBvbGREZWZzID0gQXJyYXkuaXNBcnJheSh0YXJnZXRCbG9jay5tYXJrRGVmcykgJiYgdGFyZ2V0QmxvY2subWFya0RlZnMgfHwgW10sIG5ld01hcmtEZWZzID0gdW5pcShbLi4ub2xkRGVmcywgLi4ub3AucHJvcGVydGllcy5tYXJrRGVmc10pO1xuICAgICAgICAgIGRlYnVnJDkoXCJDb3B5aW5nIG1hcmtEZWZzIG92ZXIgdG8gbWVyZ2VkIGJsb2NrXCIsIG9wKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hcmtEZWZzOiBuZXdNYXJrRGVmc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRQYXRoLFxuICAgICAgICAgICAgdm9pZHM6ICExXG4gICAgICAgICAgfSksIGFwcGx5MihvcCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcHBseTIob3ApO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IHJlbW92ZURlY29yYXRvckFjdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgYWN0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGVkaXRvciA9IGFjdGlvbi5lZGl0b3IsIG1hcmsgPSBhY3Rpb24uZGVjb3JhdG9yLCB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKVxuICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHt9LCB7XG4gICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgICAgc3BsaXQ6ICEwLFxuICAgICAgICBoYW5naW5nOiAhMFxuICAgICAgfSksIGVkaXRvci5zZWxlY3Rpb24gJiYgWy4uLkVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dFxuICAgICAgfSldLmZvckVhY2goKFtub2RlLCBwYXRoXSkgPT4ge1xuICAgICAgICBjb25zdCBibG9jayA9IGVkaXRvci5jaGlsZHJlbltwYXRoWzBdXTtcbiAgICAgICAgRWxlbWVudC5pc0VsZW1lbnQoYmxvY2spICYmIGJsb2NrLmNoaWxkcmVuLmluY2x1ZGVzKG5vZGUpICYmIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWFya3M6IChBcnJheS5pc0FycmF5KG5vZGUubWFya3MpID8gbm9kZS5tYXJrcyA6IFtdKS5maWx0ZXIoKGVNYXJrKSA9PiBlTWFyayAhPT0gbWFyayksXG4gICAgICAgICAgX3R5cGU6IFwic3BhblwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24sIHtcbiAgICAgICAgZGVwdGg6IDFcbiAgICAgIH0pLCBsb25lbHlFbXB0eVNwYW4gPSBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIGJsb2NrLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBlZGl0b3IuaXNUZXh0U3BhbihibG9jay5jaGlsZHJlblswXSkgJiYgYmxvY2suY2hpbGRyZW5bMF0udGV4dCA9PT0gXCJcIiA/IGJsb2NrLmNoaWxkcmVuWzBdIDogdm9pZCAwO1xuICAgICAgaWYgKGxvbmVseUVtcHR5U3Bhbikge1xuICAgICAgICBjb25zdCBleGlzdGluZ01hcmtzV2l0aG91dERlY29yYXRvciA9IChsb25lbHlFbXB0eVNwYW4ubWFya3MgPz8gW10pLmZpbHRlcigoZXhpc3RpbmdNYXJrKSA9PiBleGlzdGluZ01hcmsgIT09IG1hcmspO1xuICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtzOiBleGlzdGluZ01hcmtzV2l0aG91dERlY29yYXRvclxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IGJsb2NrUGF0aCxcbiAgICAgICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRTcGFuKG5vZGUpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdNYXJrcyA9IHtcbiAgICAgICAgICAuLi5FZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fVxuICAgICAgICB9Lm1hcmtzIHx8IFtdLCBtYXJrcyA9IHtcbiAgICAgICAgICAuLi5FZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSxcbiAgICAgICAgICBtYXJrczogZXhpc3RpbmdNYXJrcy5maWx0ZXIoKGVNYXJrKSA9PiBlTWFyayAhPT0gbWFyaylcbiAgICAgICAgfTtcbiAgICAgICAgZWRpdG9yLm1hcmtzID0ge1xuICAgICAgICAgIG1hcmtzOiBtYXJrcy5tYXJrcyxcbiAgICAgICAgICBfdHlwZTogXCJzcGFuXCJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbjIgPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IHtcbiAgICAgICAgLi4uc2VsZWN0aW9uMlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBpc0RlY29yYXRvckFjdGl2ZSh7XG4gIGVkaXRvcixcbiAgZGVjb3JhdG9yXG59KSB7XG4gIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IHNlbGVjdGVkVGV4dE5vZGVzID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uXG4gIH0pKTtcbiAgcmV0dXJuIHNlbGVjdGVkVGV4dE5vZGVzLmxlbmd0aCA9PT0gMCA/ICExIDogUmFuZ2UuaXNFeHBhbmRlZChlZGl0b3Iuc2VsZWN0aW9uKSA/IHNlbGVjdGVkVGV4dE5vZGVzLmV2ZXJ5KChuKSA9PiB7XG4gICAgY29uc3QgW25vZGVdID0gbjtcbiAgICByZXR1cm4gbm9kZS5tYXJrcz8uaW5jbHVkZXMoZGVjb3JhdG9yKTtcbiAgfSkgOiAoe1xuICAgIC4uLkVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9XG4gIH0ubWFya3MgfHwgW10pLmluY2x1ZGVzKGRlY29yYXRvcik7XG59XG5jb25zdCB0b2dnbGVEZWNvcmF0b3JBY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBpc0RlY29yYXRvckFjdGl2ZSh7XG4gICAgZWRpdG9yOiBhY3Rpb24uZWRpdG9yLFxuICAgIGRlY29yYXRvcjogYWN0aW9uLmRlY29yYXRvclxuICB9KSA/IHJlbW92ZURlY29yYXRvckFjdGlvbkltcGxlbWVudGF0aW9uKHtcbiAgICBjb250ZXh0LFxuICAgIGFjdGlvbjoge1xuICAgICAgdHlwZTogXCJkZWNvcmF0b3IucmVtb3ZlXCIsXG4gICAgICBlZGl0b3I6IGFjdGlvbi5lZGl0b3IsXG4gICAgICBkZWNvcmF0b3I6IGFjdGlvbi5kZWNvcmF0b3JcbiAgICB9XG4gIH0pIDogZGVjb3JhdG9yQWRkQWN0aW9uSW1wbGVtZW50YXRpb24oe1xuICAgIGNvbnRleHQsXG4gICAgYWN0aW9uOiB7XG4gICAgICB0eXBlOiBcImRlY29yYXRvci5hZGRcIixcbiAgICAgIGVkaXRvcjogYWN0aW9uLmVkaXRvcixcbiAgICAgIGRlY29yYXRvcjogYWN0aW9uLmRlY29yYXRvclxuICAgIH1cbiAgfSk7XG59LCBkZWJ1ZyQ4ID0gZGVidWdXaXRoTmFtZShcIkFQSTplZGl0YWJsZVwiKTtcbmZ1bmN0aW9uIGNyZWF0ZUVkaXRhYmxlQVBJKGVkaXRvciwgZWRpdG9yQWN0b3IpIHtcbiAgY29uc3QgdHlwZXMgPSBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hO1xuICByZXR1cm4ge1xuICAgIGZvY3VzOiAoKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJmb2N1c1wiXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSxcbiAgICBibHVyOiAoKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJibHVyXCJcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHRvZ2dsZU1hcms6IChtYXJrKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJkZWNvcmF0b3IudG9nZ2xlXCIsXG4gICAgICAgICAgZGVjb3JhdG9yOiBtYXJrXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSxcbiAgICB0b2dnbGVMaXN0OiAobGlzdEl0ZW0pID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImxpc3QgaXRlbS50b2dnbGVcIixcbiAgICAgICAgICBsaXN0SXRlbVxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdG9nZ2xlQmxvY2tTdHlsZTogKHN0eWxlKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJzdHlsZS50b2dnbGVcIixcbiAgICAgICAgICBzdHlsZVxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaXNNYXJrQWN0aXZlOiAobWFyaykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGlzRGVjb3JhdG9yQWN0aXZlKHtcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgZGVjb3JhdG9yOiBtYXJrXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oZXJyKSwgITE7XG4gICAgICB9XG4gICAgfSxcbiAgICBtYXJrczogKCkgPT4gKHtcbiAgICAgIC4uLkVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9XG4gICAgfSkubWFya3MgfHwgW10sXG4gICAgdW5kbzogKCkgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiaGlzdG9yeS51bmRvXCJcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHJlZG86ICgpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImhpc3RvcnkucmVkb1wiXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSxcbiAgICBzZWxlY3Q6IChzZWxlY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IHNsYXRlU2VsZWN0aW9uID0gdG9TbGF0ZVJhbmdlKHNlbGVjdGlvbiwgZWRpdG9yKTtcbiAgICAgIHNsYXRlU2VsZWN0aW9uID8gVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzbGF0ZVNlbGVjdGlvbikgOiBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvciksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgIH0sXG4gICAgZm9jdXNCbG9jazogKCkgPT4ge1xuICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBOb2RlLmRlc2NlbmRhbnQoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSkpO1xuICAgICAgICBpZiAoYmxvY2spXG4gICAgICAgICAgcmV0dXJuIGZyb21TbGF0ZVZhbHVlKFtibG9ja10sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKVswXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZvY3VzQ2hpbGQ6ICgpID0+IHtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gTm9kZS5kZXNjZW5kYW50KGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpKTtcbiAgICAgICAgaWYgKGJsb2NrICYmIGVkaXRvci5pc1RleHRCbG9jayhibG9jaykpXG4gICAgICAgICAgcmV0dXJuIGZyb21TbGF0ZVZhbHVlKFtibG9ja10sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKVswXS5jaGlsZHJlbltlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMV1dO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW5zZXJ0Q2hpbGQ6ICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHR5cGUubmFtZSAhPT0gdHlwZXMuc3Bhbi5uYW1lKVxuICAgICAgICByZXR1cm4gZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW5zZXJ0LmlubGluZSBvYmplY3RcIixcbiAgICAgICAgICAgIGlubGluZU9iamVjdDoge1xuICAgICAgICAgICAgICBuYW1lOiB0eXBlLm5hbWUsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlZGl0b3JcbiAgICAgICAgfSksIHRvUG9ydGFibGVUZXh0UmFuZ2UoZnJvbVNsYXRlVmFsdWUoZWRpdG9yLmNoaWxkcmVuLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSksIGVkaXRvci5zZWxlY3Rpb24sIHR5cGVzKT8uZm9jdXMucGF0aCA/PyBbXTtcbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGVkaXRvciBoYXMgbm8gc2VsZWN0aW9uXCIpO1xuICAgICAgY29uc3QgW2ZvY3VzQmxvY2tdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSksXG4gICAgICAgIG1hdGNoOiAobikgPT4gbi5fdHlwZSA9PT0gdHlwZXMuYmxvY2submFtZVxuICAgICAgfSkpWzBdIHx8IFt2b2lkIDBdO1xuICAgICAgaWYgKCFmb2N1c0Jsb2NrKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmb2N1c2VkIHRleHQgYmxvY2tcIik7XG4gICAgICBpZiAodHlwZS5uYW1lICE9PSB0eXBlcy5zcGFuLm5hbWUgJiYgIXR5cGVzLmlubGluZU9iamVjdHMuc29tZSgodCkgPT4gdC5uYW1lID09PSB0eXBlLm5hbWUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHR5cGUgY2Fubm90IGJlIGluc2VydGVkIGFzIGEgY2hpbGQgdG8gYSB0ZXh0IGJsb2NrXCIpO1xuICAgICAgY29uc3QgY2hpbGQgPSB0b1NsYXRlVmFsdWUoW3tcbiAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICBfdHlwZTogdHlwZXMuYmxvY2submFtZSxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICAgIF90eXBlOiB0eXBlLm5hbWUsXG4gICAgICAgICAgLi4udmFsdWUgfHwge31cbiAgICAgICAgfV1cbiAgICAgIH1dLCB7XG4gICAgICAgIHNjaGVtYVR5cGVzOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hXG4gICAgICB9KVswXS5jaGlsZHJlblswXSwgZm9jdXNDaGlsZFBhdGggPSBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMiksIGlzU3Bhbk5vZGUgPSBjaGlsZC5fdHlwZSA9PT0gdHlwZXMuc3Bhbi5uYW1lLCBmb2N1c05vZGUgPSBOb2RlLmdldChlZGl0b3IsIGZvY3VzQ2hpbGRQYXRoKTtcbiAgICAgIHJldHVybiBpc1NwYW5Ob2RlICYmIGZvY3VzTm9kZS5fdHlwZSAhPT0gdHlwZXMuc3Bhbi5uYW1lICYmIChkZWJ1ZyQ4KFwiSW5zZXJ0aW5nIHNwYW4gY2hpbGQgbmV4dCB0byBpbmxpbmUgb2JqZWN0IGNoaWxkLCBtb3Zpbmcgc2VsZWN0aW9uICsgMVwiKSwgZWRpdG9yLm1vdmUoe1xuICAgICAgICBkaXN0YW5jZTogMSxcbiAgICAgICAgdW5pdDogXCJjaGFyYWN0ZXJcIlxuICAgICAgfSkpLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgY2hpbGQsIHtcbiAgICAgICAgc2VsZWN0OiAhMCxcbiAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKSwgdG9Qb3J0YWJsZVRleHRSYW5nZShmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKSwgZWRpdG9yLnNlbGVjdGlvbiwgdHlwZXMpPy5mb2N1cy5wYXRoIHx8IFtdO1xuICAgIH0sXG4gICAgaW5zZXJ0QmxvY2s6ICh0eXBlLCB2YWx1ZSkgPT4gKGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICB0eXBlOiBcImluc2VydC5ibG9jayBvYmplY3RcIixcbiAgICAgICAgYmxvY2tPYmplY3Q6IHtcbiAgICAgICAgICBuYW1lOiB0eXBlLm5hbWUsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSxcbiAgICAgICAgcGxhY2VtZW50OiBcImF1dG9cIlxuICAgICAgfSxcbiAgICAgIGVkaXRvclxuICAgIH0pLCB0b1BvcnRhYmxlVGV4dFJhbmdlKGZyb21TbGF0ZVZhbHVlKGVkaXRvci5jaGlsZHJlbiwgdHlwZXMuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpLCBlZGl0b3Iuc2VsZWN0aW9uLCB0eXBlcyk/LmZvY3VzLnBhdGggPz8gW10pLFxuICAgIGhhc0Jsb2NrU3R5bGU6IChzdHlsZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGlzU3R5bGVBY3RpdmUoe1xuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICBzdHlsZVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgfSxcbiAgICBoYXNMaXN0U3R5bGU6IChsaXN0SXRlbSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGlzTGlzdEl0ZW1BY3RpdmUoe1xuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICBsaXN0SXRlbVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc1ZvaWQ6IChlbGVtZW50KSA9PiAhW3R5cGVzLmJsb2NrLm5hbWUsIHR5cGVzLnNwYW4ubmFtZV0uaW5jbHVkZXMoZWxlbWVudC5fdHlwZSksXG4gICAgZmluZEJ5UGF0aDogKHBhdGgpID0+IHtcbiAgICAgIGNvbnN0IHNsYXRlUGF0aCA9IHRvU2xhdGVSYW5nZSh7XG4gICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfVxuICAgICAgfSwgZWRpdG9yKTtcbiAgICAgIGlmIChzbGF0ZVBhdGgpIHtcbiAgICAgICAgY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzbGF0ZVBhdGguZm9jdXMucGF0aC5zbGljZSgwLCAxKSk7XG4gICAgICAgIGlmIChibG9jayAmJiBibG9ja1BhdGggJiYgdHlwZW9mIGJsb2NrLl9rZXkgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSAmJiBzbGF0ZVBhdGguZm9jdXMucGF0aC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gW2Zyb21TbGF0ZVZhbHVlKFtibG9ja10sIHR5cGVzLmJsb2NrLm5hbWUpWzBdLCBbe1xuICAgICAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgICAgICB9XV07XG4gICAgICAgICAgY29uc3QgcHRCbG9jayA9IGZyb21TbGF0ZVZhbHVlKFtibG9ja10sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKVswXTtcbiAgICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKHB0QmxvY2spKSB7XG4gICAgICAgICAgICBjb25zdCBwdENoaWxkID0gcHRCbG9jay5jaGlsZHJlbltzbGF0ZVBhdGguZm9jdXMucGF0aFsxXV07XG4gICAgICAgICAgICBpZiAocHRDaGlsZClcbiAgICAgICAgICAgICAgcmV0dXJuIFtwdENoaWxkLCBbe1xuICAgICAgICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgICAgX2tleTogcHRDaGlsZC5fa2V5XG4gICAgICAgICAgICAgIH1dXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbdm9pZCAwLCB2b2lkIDBdO1xuICAgIH0sXG4gICAgZmluZERPTU5vZGU6IChlbGVtZW50KSA9PiB7XG4gICAgICBsZXQgbm9kZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFtpdGVtXSA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBbXSxcbiAgICAgICAgICBtYXRjaDogKG4pID0+IG4uX2tleSA9PT0gZWxlbWVudC5fa2V5XG4gICAgICAgIH0pIHx8IFtdKVswXSB8fCBbdm9pZCAwXTtcbiAgICAgICAgbm9kZSA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGl0ZW0pO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIGFjdGl2ZUFubm90YXRpb25zOiAoKSA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24gfHwgZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLmxlbmd0aCA8IDIpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUFubm90YXRpb25zID0gW10sIHNwYW5zID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICAgIG1hdGNoOiAobm9kZSkgPT4gVGV4dC5pc1RleHQobm9kZSkgJiYgbm9kZS5tYXJrcyAhPT0gdm9pZCAwICYmIEFycmF5LmlzQXJyYXkobm9kZS5tYXJrcykgJiYgbm9kZS5tYXJrcy5sZW5ndGggPiAwXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IFtzcGFuLCBwYXRoXSBvZiBzcGFucykge1xuICAgICAgICAgIGNvbnN0IFtibG9ja10gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgsIHtcbiAgICAgICAgICAgIGRlcHRoOiAxXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBibG9jay5tYXJrRGVmcz8uZm9yRWFjaCgoZGVmKSA9PiB7XG4gICAgICAgICAgICBUZXh0LmlzVGV4dChzcGFuKSAmJiBzcGFuLm1hcmtzICYmIEFycmF5LmlzQXJyYXkoc3Bhbi5tYXJrcykgJiYgc3Bhbi5tYXJrcy5pbmNsdWRlcyhkZWYuX2tleSkgJiYgYWN0aXZlQW5ub3RhdGlvbnMucHVzaChkZWYpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3RpdmVBbm5vdGF0aW9ucztcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcbiAgICBpc0Fubm90YXRpb25BY3RpdmU6IChhbm5vdGF0aW9uVHlwZSkgPT4gaXNBbm5vdGF0aW9uQWN0aXZlKHtcbiAgICAgIGVkaXRvcixcbiAgICAgIGFubm90YXRpb246IHtcbiAgICAgICAgbmFtZTogYW5ub3RhdGlvblR5cGVcbiAgICAgIH1cbiAgICB9KSxcbiAgICBhZGRBbm5vdGF0aW9uOiAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgIGxldCBwYXRocztcbiAgICAgIHJldHVybiBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICBwYXRocyA9IGFkZEFubm90YXRpb25BY3Rpb25JbXBsZW1lbnRhdGlvbih7XG4gICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAga2V5R2VuZXJhdG9yOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yLFxuICAgICAgICAgICAgc2NoZW1hOiB0eXBlc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiBcImFubm90YXRpb24uYWRkXCIsXG4gICAgICAgICAgICBhbm5vdGF0aW9uOiB7XG4gICAgICAgICAgICAgIG5hbWU6IHR5cGUubmFtZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlID8/IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKSwgcGF0aHM7XG4gICAgfSxcbiAgICBkZWxldGU6IChzZWxlY3Rpb24sIG9wdGlvbnMpID0+IHtcbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0b1NsYXRlUmFuZ2Uoc2VsZWN0aW9uLCBlZGl0b3IpO1xuICAgICAgICBpZiAoIShyYW5nZSAmJiByYW5nZS5hbmNob3IucGF0aC5sZW5ndGggPiAwICYmIHJhbmdlLmZvY3VzLnBhdGgubGVuZ3RoID4gMCkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByYW5nZVwiKTtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zPy5tb2RlIHx8IG9wdGlvbnM/Lm1vZGUgPT09IFwic2VsZWN0ZWRcIikge1xuICAgICAgICAgICAgZGVidWckOChcIkRlbGV0aW5nIGNvbnRlbnQgaW4gc2VsZWN0aW9uXCIpLCBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgICBoYW5naW5nOiAhMCxcbiAgICAgICAgICAgICAgdm9pZHM6ICEwXG4gICAgICAgICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wdGlvbnM/Lm1vZGUgPT09IFwiYmxvY2tzXCIgJiYgKGRlYnVnJDgoXCJEZWxldGluZyBibG9ja3MgdG91Y2hlZCBieSBzZWxlY3Rpb25cIiksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcmFuZ2UsXG4gICAgICAgICAgICB2b2lkczogITAsXG4gICAgICAgICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRCbG9jayhub2RlKSB8fCAhZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpICYmIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpXG4gICAgICAgICAgfSkpLCBvcHRpb25zPy5tb2RlID09PSBcImNoaWxkcmVuXCIgJiYgKGRlYnVnJDgoXCJEZWxldGluZyBjaGlsZHJlbiB0b3VjaGVkIGJ5IHNlbGVjdGlvblwiKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgICAgIHZvaWRzOiAhMCxcbiAgICAgICAgICAgIG1hdGNoOiAobm9kZSkgPT4gbm9kZS5fdHlwZSA9PT0gdHlwZXMuc3Bhbi5uYW1lIHx8IC8vIFRleHQgY2hpbGRyZW5cbiAgICAgICAgICAgICFlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkgJiYgRWxlbWVudC5pc0VsZW1lbnQobm9kZSlcbiAgICAgICAgICB9KSksIGVkaXRvci5jaGlsZHJlbi5sZW5ndGggPT09IDAgJiYgKGVkaXRvci5jaGlsZHJlbiA9IFtlZGl0b3IucHRlQ3JlYXRlVGV4dEJsb2NrKHtcbiAgICAgICAgICAgIGRlY29yYXRvcnM6IFtdXG4gICAgICAgICAgfSldKSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZUFubm90YXRpb246ICh0eXBlKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJhbm5vdGF0aW9uLnJlbW92ZVwiLFxuICAgICAgICAgIGFubm90YXRpb246IHtcbiAgICAgICAgICAgIG5hbWU6IHR5cGUubmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldFNlbGVjdGlvbjogKCkgPT4ge1xuICAgICAgbGV0IHB0UmFuZ2UgPSBudWxsO1xuICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBTTEFURV9UT19QT1JUQUJMRV9URVhUX1JBTkdFLmdldChlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKVxuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgcHRSYW5nZSA9IHRvUG9ydGFibGVUZXh0UmFuZ2UoZnJvbVNsYXRlVmFsdWUoZWRpdG9yLmNoaWxkcmVuLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSksIGVkaXRvci5zZWxlY3Rpb24sIHR5cGVzKSwgU0xBVEVfVE9fUE9SVEFCTEVfVEVYVF9SQU5HRS5zZXQoZWRpdG9yLnNlbGVjdGlvbiwgcHRSYW5nZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHRSYW5nZTtcbiAgICB9LFxuICAgIGdldFZhbHVlOiAoKSA9PiBmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKSxcbiAgICBpc0NvbGxhcHNlZFNlbGVjdGlvbjogKCkgPT4gISFlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pLFxuICAgIGlzRXhwYW5kZWRTZWxlY3Rpb246ICgpID0+ICEhZWRpdG9yLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKGVkaXRvci5zZWxlY3Rpb24pLFxuICAgIGluc2VydEJyZWFrOiAoKSA9PiB7XG4gICAgICBlZGl0b3IuaW5zZXJ0QnJlYWsoKSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgfSxcbiAgICBnZXRGcmFnbWVudDogKCkgPT4gZnJvbVNsYXRlVmFsdWUoZWRpdG9yLmdldEZyYWdtZW50KCksIHR5cGVzLmJsb2NrLm5hbWUpLFxuICAgIGlzU2VsZWN0aW9uc092ZXJsYXBwaW5nOiAoc2VsZWN0aW9uQSwgc2VsZWN0aW9uQikgPT4ge1xuICAgICAgY29uc3QgcmFuZ2VBID0gdG9TbGF0ZVJhbmdlKHNlbGVjdGlvbkEsIGVkaXRvciksIHJhbmdlQiA9IHRvU2xhdGVSYW5nZShzZWxlY3Rpb25CLCBlZGl0b3IpO1xuICAgICAgcmV0dXJuIFJhbmdlLmlzUmFuZ2UocmFuZ2VBKSAmJiBSYW5nZS5pc1JhbmdlKHJhbmdlQikgJiYgUmFuZ2UuaW5jbHVkZXMocmFuZ2VBLCByYW5nZUIpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQW5ub3RhdGlvbkFjdGl2ZSh7XG4gIGVkaXRvcixcbiAgYW5ub3RhdGlvblxufSkge1xuICBpZiAoIWVkaXRvci5zZWxlY3Rpb24gfHwgZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLmxlbmd0aCA8IDIpXG4gICAgcmV0dXJuICExO1xuICB0cnkge1xuICAgIGNvbnN0IHNwYW5zID0gWy4uLkVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgbWF0Y2g6IChub2RlKSA9PiBUZXh0LmlzVGV4dChub2RlKVxuICAgIH0pXTtcbiAgICBpZiAoc3BhbnMubGVuZ3RoID09PSAwIHx8IHNwYW5zLnNvbWUoKFtzcGFuXSkgPT4gIWlzUG9ydGFibGVUZXh0U3BhbiQxKHNwYW4pIHx8ICFzcGFuLm1hcmtzIHx8IHNwYW4ubWFya3M/Lmxlbmd0aCA9PT0gMCkpIHJldHVybiAhMTtcbiAgICBjb25zdCBzZWxlY3Rpb25NYXJrRGVmcyA9IHNwYW5zLnJlZHVjZSgoYWNjTWFya0RlZnMsIFssIHBhdGhdKSA9PiB7XG4gICAgICBjb25zdCBbYmxvY2tdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoLCB7XG4gICAgICAgIGRlcHRoOiAxXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIGJsb2NrLm1hcmtEZWZzID8gWy4uLmFjY01hcmtEZWZzLCAuLi5ibG9jay5tYXJrRGVmc10gOiBhY2NNYXJrRGVmcztcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHNwYW5zLmV2ZXJ5KChbc3Bhbl0pID0+IGlzUG9ydGFibGVUZXh0U3BhbiQxKHNwYW4pID8gc3Bhbi5tYXJrcz8ubWFwKChtYXJrS2V5KSA9PiBzZWxlY3Rpb25NYXJrRGVmcy5maW5kKChkZWYpID0+IGRlZj8uX2tleSA9PT0gbWFya0tleSk/Ll90eXBlKT8uaW5jbHVkZXMoYW5ub3RhdGlvbi5uYW1lKSA6ICExKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5jb25zdCBhZGRBbm5vdGF0aW9uQWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBhY3Rpb25cbn0pID0+IHtcbiAgY29uc3QgZWRpdG9yID0gYWN0aW9uLmVkaXRvcjtcbiAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8IFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKVxuICAgIHJldHVybjtcbiAgbGV0IHBhdGhzLCBzcGFuUGF0aCwgbWFya0RlZlBhdGg7XG4gIGNvbnN0IG1hcmtEZWZQYXRocyA9IFtdLCBzZWxlY3RlZEJsb2NrcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRCbG9jayhub2RlKSxcbiAgICByZXZlcnNlOiBSYW5nZS5pc0JhY2t3YXJkKGVkaXRvci5zZWxlY3Rpb24pXG4gIH0pO1xuICBmb3IgKGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSBvZiBzZWxlY3RlZEJsb2Nrcykge1xuICAgIGlmIChibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgYmxvY2suY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGJsb2NrLmNoaWxkcmVuWzBdLnRleHQgPT09IFwiXCIpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBhbm5vdGF0aW9uS2V5ID0gY29udGV4dC5rZXlHZW5lcmF0b3IoKSwgbWFya0RlZnMgPSBibG9jay5tYXJrRGVmcyA/PyBbXTtcbiAgICBtYXJrRGVmcy5maW5kKChtYXJrRGVmKSA9PiBtYXJrRGVmLl90eXBlID09PSBhY3Rpb24uYW5ub3RhdGlvbi5uYW1lICYmIG1hcmtEZWYuX2tleSA9PT0gYW5ub3RhdGlvbktleSkgPT09IHZvaWQgMCAmJiAoVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgIG1hcmtEZWZzOiBbLi4ubWFya0RlZnMsIHtcbiAgICAgICAgX3R5cGU6IGFjdGlvbi5hbm5vdGF0aW9uLm5hbWUsXG4gICAgICAgIF9rZXk6IGFubm90YXRpb25LZXksXG4gICAgICAgIC4uLmFjdGlvbi5hbm5vdGF0aW9uLnZhbHVlXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIGF0OiBibG9ja1BhdGhcbiAgICB9KSwgbWFya0RlZlBhdGggPSBbe1xuICAgICAgX2tleTogYmxvY2suX2tleVxuICAgIH0sIFwibWFya0RlZnNcIiwge1xuICAgICAgX2tleTogYW5ub3RhdGlvbktleVxuICAgIH1dLCBSYW5nZS5pc0JhY2t3YXJkKGVkaXRvci5zZWxlY3Rpb24pID8gbWFya0RlZlBhdGhzLnVuc2hpZnQobWFya0RlZlBhdGgpIDogbWFya0RlZlBhdGhzLnB1c2gobWFya0RlZlBhdGgpKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHt9LCB7XG4gICAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgICBzcGxpdDogITBcbiAgICB9KTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBibG9ja1BhdGgpO1xuICAgIGZvciAoY29uc3QgW3NwYW4sIHBhdGhdIG9mIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoIWVkaXRvci5pc1RleHRTcGFuKHNwYW4pIHx8ICFSYW5nZS5pbmNsdWRlcyhlZGl0b3Iuc2VsZWN0aW9uLCBwYXRoKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBtYXJrcyA9IHNwYW4ubWFya3MgPz8gW10sIGV4aXN0aW5nU2FtZVR5cGVBbm5vdGF0aW9ucyA9IG1hcmtzLmZpbHRlcigobWFyaykgPT4gbWFya0RlZnMuc29tZSgobWFya0RlZikgPT4gbWFya0RlZi5fa2V5ID09PSBtYXJrICYmIG1hcmtEZWYuX3R5cGUgPT09IGFjdGlvbi5hbm5vdGF0aW9uLm5hbWUpKTtcbiAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIG1hcmtzOiBbLi4ubWFya3MuZmlsdGVyKChtYXJrKSA9PiAhZXhpc3RpbmdTYW1lVHlwZUFubm90YXRpb25zLmluY2x1ZGVzKG1hcmspKSwgYW5ub3RhdGlvbktleV1cbiAgICAgIH0sIHtcbiAgICAgICAgYXQ6IHBhdGhcbiAgICAgIH0pLCBzcGFuUGF0aCA9IFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBfa2V5OiBzcGFuLl9rZXlcbiAgICAgIH1dO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWFya0RlZlBhdGggJiYgc3BhblBhdGggJiYgKHBhdGhzID0ge1xuICAgIG1hcmtEZWZQYXRoLFxuICAgIG1hcmtEZWZQYXRocyxcbiAgICBzcGFuUGF0aFxuICB9KSwgcGF0aHM7XG59LCByZW1vdmVBbm5vdGF0aW9uQWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBhY3Rpb25cbn0pID0+IHtcbiAgY29uc3QgZWRpdG9yID0gYWN0aW9uLmVkaXRvcjtcbiAgaWYgKGRlYnVnJDgoXCJSZW1vdmluZyBhbm5vdGF0aW9uXCIsIGFjdGlvbi5hbm5vdGF0aW9uLm5hbWUpLCAhIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBbYmxvY2ssIGJsb2NrUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24sIHtcbiAgICAgICAgZGVwdGg6IDFcbiAgICAgIH0pO1xuICAgICAgaWYgKCFlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBwb3RlbnRpYWxBbm5vdGF0aW9ucyA9IChibG9jay5tYXJrRGVmcyA/PyBbXSkuZmlsdGVyKChtYXJrRGVmKSA9PiBtYXJrRGVmLl90eXBlID09PSBhY3Rpb24uYW5ub3RhdGlvbi5uYW1lKSwgW3NlbGVjdGVkQ2hpbGQsIHNlbGVjdGVkQ2hpbGRQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbiwge1xuICAgICAgICBkZXB0aDogMlxuICAgICAgfSk7XG4gICAgICBpZiAoIWVkaXRvci5pc1RleHRTcGFuKHNlbGVjdGVkQ2hpbGQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBhbm5vdGF0aW9uVG9SZW1vdmUgPSBzZWxlY3RlZENoaWxkLm1hcmtzPy5maW5kKChtYXJrKSA9PiBwb3RlbnRpYWxBbm5vdGF0aW9ucy5zb21lKChtYXJrRGVmKSA9PiBtYXJrRGVmLl9rZXkgPT09IG1hcmspKTtcbiAgICAgIGlmICghYW5ub3RhdGlvblRvUmVtb3ZlKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBwcmV2aW91c1NwYW5zV2l0aFNhbWVBbm5vdGF0aW9uID0gW107XG4gICAgICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBOb2RlLmNoaWxkcmVuKGVkaXRvciwgYmxvY2tQYXRoLCB7XG4gICAgICAgIHJldmVyc2U6ICEwXG4gICAgICB9KSlcbiAgICAgICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKGNoaWxkKSAmJiBQYXRoLmlzQmVmb3JlKGNoaWxkUGF0aCwgc2VsZWN0ZWRDaGlsZFBhdGgpKVxuICAgICAgICAgIGlmIChjaGlsZC5tYXJrcz8uaW5jbHVkZXMoYW5ub3RhdGlvblRvUmVtb3ZlKSlcbiAgICAgICAgICAgIHByZXZpb3VzU3BhbnNXaXRoU2FtZUFubm90YXRpb24ucHVzaChbY2hpbGQsIGNoaWxkUGF0aF0pO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgY29uc3QgbmV4dFNwYW5zV2l0aFNhbWVBbm5vdGF0aW9uID0gW107XG4gICAgICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBOb2RlLmNoaWxkcmVuKGVkaXRvciwgYmxvY2tQYXRoKSlcbiAgICAgICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKGNoaWxkKSAmJiBQYXRoLmlzQWZ0ZXIoY2hpbGRQYXRoLCBzZWxlY3RlZENoaWxkUGF0aCkpXG4gICAgICAgICAgaWYgKGNoaWxkLm1hcmtzPy5pbmNsdWRlcyhhbm5vdGF0aW9uVG9SZW1vdmUpKVxuICAgICAgICAgICAgbmV4dFNwYW5zV2l0aFNhbWVBbm5vdGF0aW9uLnB1c2goW2NoaWxkLCBjaGlsZFBhdGhdKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIFsuLi5wcmV2aW91c1NwYW5zV2l0aFNhbWVBbm5vdGF0aW9uLCBbc2VsZWN0ZWRDaGlsZCwgc2VsZWN0ZWRDaGlsZFBhdGhdLCAuLi5uZXh0U3BhbnNXaXRoU2FtZUFubm90YXRpb25dKVxuICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtzOiBjaGlsZC5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiBtYXJrICE9PSBhbm5vdGF0aW9uVG9SZW1vdmUpXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge30sIHtcbiAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0U3Bhbihub2RlKSxcbiAgICAgICAgc3BsaXQ6ICEwLFxuICAgICAgICBoYW5naW5nOiAhMFxuICAgICAgfSk7XG4gICAgICBjb25zdCBibG9ja3MgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRCbG9jayhub2RlKVxuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSBvZiBibG9ja3MpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBOb2RlLmNoaWxkcmVuKGVkaXRvciwgYmxvY2tQYXRoKTtcbiAgICAgICAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoIWVkaXRvci5pc1RleHRTcGFuKGNoaWxkKSB8fCAhUmFuZ2UuaW5jbHVkZXMoZWRpdG9yLnNlbGVjdGlvbiwgY2hpbGRQYXRoKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IG1hcmtEZWZzID0gYmxvY2subWFya0RlZnMgPz8gW10sIG1hcmtzID0gY2hpbGQubWFya3MgPz8gW10sIG1hcmtzV2l0aG91dEFubm90YXRpb24gPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+IG1hcmtEZWZzLmZpbmQoKG1hcmtEZWYyKSA9PiBtYXJrRGVmMi5fa2V5ID09PSBtYXJrKT8uX3R5cGUgIT09IGFjdGlvbi5hbm5vdGF0aW9uLm5hbWUpO1xuICAgICAgICAgIG1hcmtzV2l0aG91dEFubm90YXRpb24ubGVuZ3RoICE9PSBtYXJrcy5sZW5ndGggJiYgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hcmtzOiBtYXJrc1dpdGhvdXRBbm5vdGF0aW9uXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IGNoaWxkUGF0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxufSwgdG9nZ2xlQW5ub3RhdGlvbkFjdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgY29udGV4dCxcbiAgYWN0aW9uXG59KSA9PiB7XG4gIGlmIChpc0Fubm90YXRpb25BY3RpdmUoe1xuICAgIGVkaXRvcjogYWN0aW9uLmVkaXRvcixcbiAgICBhbm5vdGF0aW9uOiB7XG4gICAgICBuYW1lOiBhY3Rpb24uYW5ub3RhdGlvbi5uYW1lXG4gICAgfVxuICB9KSlcbiAgICByZW1vdmVBbm5vdGF0aW9uQWN0aW9uSW1wbGVtZW50YXRpb24oe1xuICAgICAgY29udGV4dCxcbiAgICAgIGFjdGlvbjoge1xuICAgICAgICB0eXBlOiBcImFubm90YXRpb24ucmVtb3ZlXCIsXG4gICAgICAgIGFubm90YXRpb246IGFjdGlvbi5hbm5vdGF0aW9uLFxuICAgICAgICBlZGl0b3I6IGFjdGlvbi5lZGl0b3JcbiAgICAgIH1cbiAgICB9KTtcbiAgZWxzZVxuICAgIHJldHVybiBhZGRBbm5vdGF0aW9uQWN0aW9uSW1wbGVtZW50YXRpb24oe1xuICAgICAgY29udGV4dCxcbiAgICAgIGFjdGlvbjoge1xuICAgICAgICB0eXBlOiBcImFubm90YXRpb24uYWRkXCIsXG4gICAgICAgIGFubm90YXRpb246IGFjdGlvbi5hbm5vdGF0aW9uLFxuICAgICAgICBlZGl0b3I6IGFjdGlvbi5lZGl0b3JcbiAgICAgIH1cbiAgICB9KTtcbn07XG5mdW5jdGlvbiBpbnNlcnRCbG9jayh7XG4gIGJsb2NrLFxuICBwbGFjZW1lbnQsXG4gIGVkaXRvcixcbiAgc2NoZW1hXG59KSB7XG4gIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgY29uc3QgW2ZvY3VzQmxvY2ssIGZvY3VzQmxvY2tQYXRoXSA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKSxcbiAgICAgIG1hdGNoOiAobikgPT4gIUVkaXRvci5pc0VkaXRvcihuKVxuICAgIH0pKVswXSA/PyBbdm9pZCAwLCB2b2lkIDBdO1xuICAgIGlmIChwbGFjZW1lbnQgPT09IFwiYWZ0ZXJcIikge1xuICAgICAgY29uc3QgbmV4dFBhdGggPSBbZm9jdXNCbG9ja1BhdGhbMF0gKyAxXTtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBibG9jaywge1xuICAgICAgICBhdDogbmV4dFBhdGhcbiAgICAgIH0pLCBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHtcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgcGF0aDogW25leHRQYXRoWzBdLCAwXSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBbbmV4dFBhdGhbMF0sIDBdLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgcGxhY2VtZW50ID09PSBcImJlZm9yZVwiID8gVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGJsb2NrLCB7XG4gICAgICBhdDogZm9jdXNCbG9ja1BhdGhcbiAgICB9KSA6IChFZGl0b3IuaW5zZXJ0Tm9kZShlZGl0b3IsIGJsb2NrKSwgZm9jdXNCbG9jayAmJiBpc0VxdWFsVG9FbXB0eUVkaXRvcihbZm9jdXNCbG9ja10sIHNjaGVtYSkgJiYgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBmb2N1c0Jsb2NrUGF0aFxuICAgIH0pKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsYXN0QmxvY2sgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiAobikgPT4gIUVkaXRvci5pc0VkaXRvcihuKSxcbiAgICAgIGF0OiBbXSxcbiAgICAgIHJldmVyc2U6ICEwXG4gICAgfSkpWzBdO1xuICAgIEVkaXRvci5pbnNlcnROb2RlKGVkaXRvciwgYmxvY2spLCBsYXN0QmxvY2sgJiYgaXNFcXVhbFRvRW1wdHlFZGl0b3IoW2xhc3RCbG9ja1swXV0sIHNjaGVtYSkgJiYgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBsYXN0QmxvY2tbMV1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgYmxvY2tTZXRCZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgY29udGV4dCxcbiAgYWN0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGxvY2F0aW9uID0gdG9TbGF0ZVJhbmdlKHtcbiAgICBhbmNob3I6IHtcbiAgICAgIHBhdGg6IGFjdGlvbi5hdCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgZm9jdXM6IHtcbiAgICAgIHBhdGg6IGFjdGlvbi5hdCxcbiAgICAgIG9mZnNldDogMFxuICAgIH1cbiAgfSwgYWN0aW9uLmVkaXRvcik7XG4gIGlmICghbG9jYXRpb24pXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY29udmVydCAke0pTT04uc3RyaW5naWZ5KGFjdGlvbi5hdCl9IGludG8gYSBTbGF0ZSBSYW5nZWApO1xuICBjb25zdCBibG9jayA9IEVkaXRvci5ub2RlKGFjdGlvbi5lZGl0b3IsIGxvY2F0aW9uLCB7XG4gICAgZGVwdGg6IDFcbiAgfSk/LlswXTtcbiAgaWYgKCFibG9jaylcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGJsb2NrIGF0ICR7SlNPTi5zdHJpbmdpZnkoYWN0aW9uLmF0KX1gKTtcbiAgY29uc3QgcGFyc2VkQmxvY2sgPSBmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCBjb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoYWN0aW9uLmVkaXRvcikpLmF0KDApO1xuICBpZiAoIXBhcnNlZEJsb2NrKVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIGJsb2NrIGF0ICR7SlNPTi5zdHJpbmdpZnkoYWN0aW9uLmF0KX1gKTtcbiAgY29uc3Qge1xuICAgIF90eXBlLFxuICAgIC4uLmZpbHRlcmVkUHJvcHNcbiAgfSA9IGFjdGlvbi5wcm9wcywgdXBkYXRlZEJsb2NrID0gcGFyc2VCbG9jayh7XG4gICAgY29udGV4dCxcbiAgICBibG9jazoge1xuICAgICAgLi4ucGFyc2VkQmxvY2ssXG4gICAgICAuLi5maWx0ZXJlZFByb3BzXG4gICAgfSxcbiAgICBvcHRpb25zOiB7XG4gICAgICByZWZyZXNoS2V5czogITFcbiAgICB9XG4gIH0pO1xuICBpZiAoIXVwZGF0ZWRCbG9jaylcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byB1cGRhdGUgYmxvY2sgYXQgJHtKU09OLnN0cmluZ2lmeShhY3Rpb24uYXQpfWApO1xuICBjb25zdCBzbGF0ZUJsb2NrID0gdG9TbGF0ZVZhbHVlKFt1cGRhdGVkQmxvY2tdLCB7XG4gICAgc2NoZW1hVHlwZXM6IGNvbnRleHQuc2NoZW1hXG4gIH0pPy5hdCgwKTtcbiAgaWYgKCFzbGF0ZUJsb2NrKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjb252ZXJ0IGJsb2NrIHRvIFNsYXRlIHZhbHVlXCIpO1xuICBUcmFuc2Zvcm1zLnNldE5vZGVzKGFjdGlvbi5lZGl0b3IsIHNsYXRlQmxvY2ssIHtcbiAgICBhdDogbG9jYXRpb25cbiAgfSk7XG59LCBibG9ja1Vuc2V0QmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBjb25zdCBsb2NhdGlvbiA9IHRvU2xhdGVSYW5nZSh7XG4gICAgYW5jaG9yOiB7XG4gICAgICBwYXRoOiBhY3Rpb24uYXQsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGZvY3VzOiB7XG4gICAgICBwYXRoOiBhY3Rpb24uYXQsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9XG4gIH0sIGFjdGlvbi5lZGl0b3IpO1xuICBpZiAoIWxvY2F0aW9uKVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNvbnZlcnQgJHtKU09OLnN0cmluZ2lmeShhY3Rpb24uYXQpfSBpbnRvIGEgU2xhdGUgUmFuZ2VgKTtcbiAgY29uc3QgYmxvY2sgPSBFZGl0b3Iubm9kZShhY3Rpb24uZWRpdG9yLCBsb2NhdGlvbiwge1xuICAgIGRlcHRoOiAxXG4gIH0pPy5bMF07XG4gIGlmICghYmxvY2spXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBibG9jayBhdCAke0pTT04uc3RyaW5naWZ5KGFjdGlvbi5hdCl9YCk7XG4gIGNvbnN0IHBhcnNlZEJsb2NrID0gZnJvbVNsYXRlVmFsdWUoW2Jsb2NrXSwgY29udGV4dC5zY2hlbWEuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGFjdGlvbi5lZGl0b3IpKS5hdCgwKTtcbiAgaWYgKCFwYXJzZWRCbG9jaylcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSBibG9jayBhdCAke0pTT04uc3RyaW5naWZ5KGFjdGlvbi5hdCl9YCk7XG4gIGlmIChpc1RleHRCbG9jayhjb250ZXh0LnNjaGVtYSwgcGFyc2VkQmxvY2spKSB7XG4gICAgY29uc3QgcHJvcHNUb1JlbW92ZSA9IGFjdGlvbi5wcm9wcy5maWx0ZXIoKHByb3ApID0+IHByb3AgIT09IFwiX3R5cGVcIiksIHVwZGF0ZWRUZXh0QmxvY2sgPSBwYXJzZUJsb2NrKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBibG9jazogb21pdChwYXJzZWRCbG9jaywgcHJvcHNUb1JlbW92ZSksXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHJlZnJlc2hLZXlzOiAhMVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghdXBkYXRlZFRleHRCbG9jaylcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHVwZGF0ZSBibG9jayBhdCAke0pTT04uc3RyaW5naWZ5KGFjdGlvbi5hdCl9YCk7XG4gICAgY29uc3QgcHJvcHNUb1NldCA9IHt9O1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wc1RvUmVtb3ZlKVxuICAgICAgcHJvcCBpbiB1cGRhdGVkVGV4dEJsb2NrID8gcHJvcHNUb1NldFtwcm9wXSA9IHVwZGF0ZWRUZXh0QmxvY2tbcHJvcF0gOiBwcm9wc1RvU2V0W3Byb3BdID0gdm9pZCAwO1xuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoYWN0aW9uLmVkaXRvciwgcHJvcHNUb1NldCwge1xuICAgICAgYXQ6IGxvY2F0aW9uXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWRCbG9ja09iamVjdCA9IHBhcnNlQmxvY2soe1xuICAgIGNvbnRleHQsXG4gICAgYmxvY2s6IG9taXQocGFyc2VkQmxvY2ssIGFjdGlvbi5wcm9wcy5maWx0ZXIoKHByb3ApID0+IHByb3AgIT09IFwiX3R5cGVcIikpLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHJlZnJlc2hLZXlzOiAhMVxuICAgIH1cbiAgfSk7XG4gIGlmICghdXBkYXRlZEJsb2NrT2JqZWN0KVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHVwZGF0ZSBibG9jayBhdCAke0pTT04uc3RyaW5naWZ5KGFjdGlvbi5hdCl9YCk7XG4gIGNvbnN0IHtcbiAgICBfdHlwZSxcbiAgICBfa2V5LFxuICAgIC4uLnByb3BzXG4gIH0gPSB1cGRhdGVkQmxvY2tPYmplY3Q7XG4gIFRyYW5zZm9ybXMuc2V0Tm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgIF90eXBlLFxuICAgIF9rZXksXG4gICAgdmFsdWU6IHByb3BzXG4gIH0sIHtcbiAgICBhdDogbG9jYXRpb25cbiAgfSk7XG59LCBkYXRhVHJhbnNmZXJTZXRBY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGFjdGlvblxufSkgPT4ge1xuICBhY3Rpb24uZGF0YVRyYW5zZmVyLnNldERhdGEoYWN0aW9uLm1pbWVUeXBlLCBhY3Rpb24uZGF0YSk7XG59LCBkZWxldGVBY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGFjdGlvblxufSkgPT4ge1xuICBjb25zdCByYW5nZSA9IHRvU2xhdGVSYW5nZShhY3Rpb24uc2VsZWN0aW9uLCBhY3Rpb24uZWRpdG9yKTtcbiAgaWYgKCFyYW5nZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgU2xhdGUgUmFuZ2UgZm9yIHNlbGVjdGlvbiAke0pTT04uc3RyaW5naWZ5KGFjdGlvbi5zZWxlY3Rpb24pfWApO1xuICBzZWxlY3QoYWN0aW9uLmVkaXRvciwgcmFuZ2UpLCBkZWxldGVGcmFnbWVudChhY3Rpb24uZWRpdG9yKTtcbn0sIGRlbGV0ZVRleHRBY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBjb25zdCB2YWx1ZSA9IGZyb21TbGF0ZVZhbHVlKGFjdGlvbi5lZGl0b3IuY2hpbGRyZW4sIGNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChhY3Rpb24uZWRpdG9yKSksIHNlbGVjdGlvbiA9IGJsb2NrT2Zmc2V0c1RvU2VsZWN0aW9uKHtcbiAgICB2YWx1ZSxcbiAgICBvZmZzZXRzOiB7XG4gICAgICBhbmNob3I6IGFjdGlvbi5hbmNob3IsXG4gICAgICBmb2N1czogYWN0aW9uLmZvY3VzXG4gICAgfVxuICB9KTtcbiAgaWYgKCFzZWxlY3Rpb24pXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgc2VsZWN0aW9uIGZyb20gYmxvY2sgb2Zmc2V0c1wiKTtcbiAgY29uc3QgdHJpbW1lZFNlbGVjdGlvbiA9IGdldFRyaW1tZWRTZWxlY3Rpb24oe1xuICAgIGJldGE6IHtcbiAgICAgIGhhc1RhZzogKCkgPT4gITFcbiAgICB9LFxuICAgIGNvbnRleHQ6IHtcbiAgICAgIGNvbnZlcnRlcnM6IFtdLFxuICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYSxcbiAgICAgIGtleUdlbmVyYXRvcjogY29udGV4dC5rZXlHZW5lcmF0b3IsXG4gICAgICBhY3RpdmVEZWNvcmF0b3JzOiBbXSxcbiAgICAgIHZhbHVlLFxuICAgICAgc2VsZWN0aW9uXG4gICAgfVxuICB9KTtcbiAgaWYgKCF0cmltbWVkU2VsZWN0aW9uKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHRyaW1tZWQgc2VsZWN0aW9uXCIpO1xuICBjb25zdCByYW5nZSA9IHRvU2xhdGVSYW5nZSh0cmltbWVkU2VsZWN0aW9uLCBhY3Rpb24uZWRpdG9yKTtcbiAgaWYgKCFyYW5nZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBTbGF0ZSByYW5nZSBmcm9tIHRyaW1tZWQgc2VsZWN0aW9uXCIpO1xuICBUcmFuc2Zvcm1zLmRlbGV0ZShhY3Rpb24uZWRpdG9yLCB7XG4gICAgYXQ6IHJhbmdlXG4gIH0pO1xufSwgaW5zZXJ0QmxvY2tPYmplY3RBY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBjb25zdCBibG9jayA9IHRvU2xhdGVWYWx1ZShbe1xuICAgIF9rZXk6IGNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgX3R5cGU6IGFjdGlvbi5ibG9ja09iamVjdC5uYW1lLFxuICAgIC4uLmFjdGlvbi5ibG9ja09iamVjdC52YWx1ZSA/IGFjdGlvbi5ibG9ja09iamVjdC52YWx1ZSA6IHt9XG4gIH1dLCB7XG4gICAgc2NoZW1hVHlwZXM6IGNvbnRleHQuc2NoZW1hXG4gIH0pWzBdO1xuICBpbnNlcnRCbG9jayh7XG4gICAgYmxvY2ssXG4gICAgcGxhY2VtZW50OiBhY3Rpb24ucGxhY2VtZW50LFxuICAgIGVkaXRvcjogYWN0aW9uLmVkaXRvcixcbiAgICBzY2hlbWE6IGNvbnRleHQuc2NoZW1hXG4gIH0pO1xufSwgaW5zZXJ0QmxvY2tzQWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBhY3Rpb25cbn0pID0+IHtcbiAgY29uc3QgZnJhZ21lbnQgPSB0b1NsYXRlVmFsdWUoYWN0aW9uLmJsb2Nrcywge1xuICAgIHNjaGVtYVR5cGVzOiBjb250ZXh0LnNjaGVtYVxuICB9KTtcbiAgaWYgKCFhY3Rpb24uZWRpdG9yLnNlbGVjdGlvbilcbiAgICByZXR1cm47XG4gIGNvbnN0IFtmb2N1c0Jsb2NrLCBmb2N1c1BhdGhdID0gRWRpdG9yLm5vZGUoYWN0aW9uLmVkaXRvciwgYWN0aW9uLmVkaXRvci5zZWxlY3Rpb24sIHtcbiAgICBkZXB0aDogMVxuICB9KTtcbiAgaWYgKGFjdGlvbi5lZGl0b3IuaXNUZXh0QmxvY2soZm9jdXNCbG9jaykgJiYgYWN0aW9uLmVkaXRvci5pc1RleHRCbG9jayhmcmFnbWVudFswXSkpIHtcbiAgICBjb25zdCB7XG4gICAgICBtYXJrRGVmc1xuICAgIH0gPSBmb2N1c0Jsb2NrO1xuICAgIGlzRXF1YWwobWFya0RlZnMsIGZyYWdtZW50WzBdLm1hcmtEZWZzKSB8fCBUcmFuc2Zvcm1zLnNldE5vZGVzKGFjdGlvbi5lZGl0b3IsIHtcbiAgICAgIG1hcmtEZWZzOiB1bmlxKFsuLi5mcmFnbWVudFswXS5tYXJrRGVmcyB8fCBbXSwgLi4ubWFya0RlZnMgfHwgW11dKVxuICAgIH0sIHtcbiAgICAgIGF0OiBmb2N1c1BhdGgsXG4gICAgICBtb2RlOiBcImxvd2VzdFwiLFxuICAgICAgdm9pZHM6ICExXG4gICAgfSk7XG4gIH1cbiAgaXNFcXVhbFRvRW1wdHlFZGl0b3IoYWN0aW9uLmVkaXRvci5jaGlsZHJlbiwgY29udGV4dC5zY2hlbWEpID8gKFRyYW5zZm9ybXMuc3BsaXROb2RlcyhhY3Rpb24uZWRpdG9yLCB7XG4gICAgYXQ6IFswLCAwXVxuICB9KSwgYWN0aW9uLmVkaXRvci5pbnNlcnRGcmFnbWVudChmcmFnbWVudCksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgIGF0OiBbMF1cbiAgfSkpIDogYWN0aW9uLmVkaXRvci5pbnNlcnRGcmFnbWVudChmcmFnbWVudCk7XG59LCBpbnNlcnRJbmxpbmVPYmplY3RBY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBpZiAoIWNvbnRleHQuc2NoZW1hLmlubGluZU9iamVjdHMuc29tZSgoaW5saW5lT2JqZWN0KSA9PiBpbmxpbmVPYmplY3QubmFtZSA9PT0gYWN0aW9uLmlubGluZU9iamVjdC5uYW1lKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gaW5zZXJ0IHVua25vd24gaW5saW5lIG9iamVjdFwiKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFhY3Rpb24uZWRpdG9yLnNlbGVjdGlvbikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gaW5zZXJ0IGlubGluZSBvYmplY3Qgd2l0aG91dCBzZWxlY3Rpb25cIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IFtmb2N1c1RleHRCbG9ja10gPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhhY3Rpb24uZWRpdG9yLCB7XG4gICAgYXQ6IGFjdGlvbi5lZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGgsXG4gICAgbWF0Y2g6IChub2RlKSA9PiBhY3Rpb24uZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpXG4gIH0pKS5hdCgwKSA/PyBbdm9pZCAwLCB2b2lkIDBdO1xuICBpZiAoIWZvY3VzVGV4dEJsb2NrKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBwZXJmb3JtIGFjdGlvbiB3aXRob3V0IGZvY3VzIHRleHQgYmxvY2tcIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNoaWxkID0gdG9TbGF0ZVZhbHVlKFt7XG4gICAgX3R5cGU6IGNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsXG4gICAgX2tleTogY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICBjaGlsZHJlbjogW3tcbiAgICAgIF90eXBlOiBhY3Rpb24uaW5saW5lT2JqZWN0Lm5hbWUsXG4gICAgICBfa2V5OiBjb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgLi4uYWN0aW9uLmlubGluZU9iamVjdC52YWx1ZSA/PyB7fVxuICAgIH1dXG4gIH1dLCB7XG4gICAgc2NoZW1hVHlwZXM6IGNvbnRleHQuc2NoZW1hXG4gIH0pLmF0KDApPy5jaGlsZHJlbi5hdCgwKTtcbiAgaWYgKCFjaGlsZCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gaW5zZXJ0IGlubGluZSBvYmplY3RcIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoYWN0aW9uLmVkaXRvciwgY2hpbGQpO1xufSwgaW5zZXJ0U3BhbkFjdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgY29udGV4dCxcbiAgYWN0aW9uXG59KSA9PiB7XG4gIGlmICghYWN0aW9uLmVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIHBlcmZvcm0gYWN0aW9uIHdpdGhvdXQgc2VsZWN0aW9uXCIsIGFjdGlvbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IFtmb2N1c0Jsb2NrLCBmb2N1c0Jsb2NrUGF0aF0gPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhhY3Rpb24uZWRpdG9yLCB7XG4gICAgYXQ6IGFjdGlvbi5lZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGgsXG4gICAgbWF0Y2g6IChub2RlKSA9PiBhY3Rpb24uZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpXG4gIH0pKVswXSA/PyBbdm9pZCAwLCB2b2lkIDBdO1xuICBpZiAoIWZvY3VzQmxvY2sgfHwgIWZvY3VzQmxvY2tQYXRoKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBwZXJmb3JtIGFjdGlvbiB3aXRob3V0IGZvY3VzIGJsb2NrXCIsIGFjdGlvbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG1hcmtEZWZzID0gZm9jdXNCbG9jay5tYXJrRGVmcyA/PyBbXSwgYW5ub3RhdGlvbnMgPSBhY3Rpb24uYW5ub3RhdGlvbnMgPyBhY3Rpb24uYW5ub3RhdGlvbnMubWFwKChhbm5vdGF0aW9uKSA9PiAoe1xuICAgIF90eXBlOiBhbm5vdGF0aW9uLm5hbWUsXG4gICAgX2tleTogY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAuLi5hbm5vdGF0aW9uLnZhbHVlXG4gIH0pKSA6IHZvaWQgMDtcbiAgYW5ub3RhdGlvbnMgJiYgYW5ub3RhdGlvbnMubGVuZ3RoID4gMCAmJiBUcmFuc2Zvcm1zLnNldE5vZGVzKGFjdGlvbi5lZGl0b3IsIHtcbiAgICBtYXJrRGVmczogWy4uLm1hcmtEZWZzLCAuLi5hbm5vdGF0aW9uc11cbiAgfSksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgIF90eXBlOiBcInNwYW5cIixcbiAgICBfa2V5OiBjb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgIHRleHQ6IGFjdGlvbi50ZXh0LFxuICAgIG1hcmtzOiBbLi4uYW5ub3RhdGlvbnM/Lm1hcCgoYW5ub3RhdGlvbikgPT4gYW5ub3RhdGlvbi5fa2V5KSA/PyBbXSwgLi4uYWN0aW9uLmRlY29yYXRvcnMgPz8gW11dXG4gIH0pO1xufSwgaW5zZXJ0QmxvY2tBY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBjb25zdCBwYXJzZWRCbG9jayA9IHBhcnNlQmxvY2soe1xuICAgIGJsb2NrOiBhY3Rpb24uYmxvY2ssXG4gICAgY29udGV4dCxcbiAgICBvcHRpb25zOiB7XG4gICAgICByZWZyZXNoS2V5czogITFcbiAgICB9XG4gIH0pO1xuICBpZiAoIXBhcnNlZEJsb2NrKVxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIGJsb2NrICR7SlNPTi5zdHJpbmdpZnkoYWN0aW9uLmJsb2NrKX1gKTtcbiAgY29uc3QgZnJhZ21lbnQgPSB0b1NsYXRlVmFsdWUoW3BhcnNlZEJsb2NrXSwge1xuICAgIHNjaGVtYVR5cGVzOiBjb250ZXh0LnNjaGVtYVxuICB9KVswXTtcbiAgaWYgKCFmcmFnbWVudClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjb252ZXJ0IGJsb2NrIHRvIFNsYXRlIGZyYWdtZW50ICR7SlNPTi5zdHJpbmdpZnkocGFyc2VkQmxvY2spfWApO1xuICBpbnNlcnRCbG9jayh7XG4gICAgYmxvY2s6IGZyYWdtZW50LFxuICAgIHBsYWNlbWVudDogYWN0aW9uLnBsYWNlbWVudCxcbiAgICBlZGl0b3I6IGFjdGlvbi5lZGl0b3IsXG4gICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYVxuICB9KTtcbn0sIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zID0ge1xuICBcImFubm90YXRpb24uYWRkXCI6IGFkZEFubm90YXRpb25BY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJhbm5vdGF0aW9uLnJlbW92ZVwiOiByZW1vdmVBbm5vdGF0aW9uQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiYW5ub3RhdGlvbi50b2dnbGVcIjogdG9nZ2xlQW5ub3RhdGlvbkFjdGlvbkltcGxlbWVudGF0aW9uLFxuICBcImJsb2NrLnNldFwiOiBibG9ja1NldEJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiYmxvY2sudW5zZXRcIjogYmxvY2tVbnNldEJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIGJsdXI6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBSZWFjdEVkaXRvci5ibHVyKGFjdGlvbi5lZGl0b3IpO1xuICB9LFxuICBcImRhdGEgdHJhbnNmZXIuc2V0XCI6IGRhdGFUcmFuc2ZlclNldEFjdGlvbkltcGxlbWVudGF0aW9uLFxuICBcImRlY29yYXRvci5hZGRcIjogZGVjb3JhdG9yQWRkQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiZGVjb3JhdG9yLnJlbW92ZVwiOiByZW1vdmVEZWNvcmF0b3JBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJkZWNvcmF0b3IudG9nZ2xlXCI6IHRvZ2dsZURlY29yYXRvckFjdGlvbkltcGxlbWVudGF0aW9uLFxuICBmb2N1czogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIFJlYWN0RWRpdG9yLmZvY3VzKGFjdGlvbi5lZGl0b3IpO1xuICB9LFxuICBkZWxldGU6IGRlbGV0ZUFjdGlvbkltcGxlbWVudGF0aW9uLFxuICBcImRlbGV0ZS5iYWNrd2FyZFwiOiAoe1xuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgYWN0aW9uLmVkaXRvci5kZWxldGVCYWNrd2FyZChhY3Rpb24udW5pdCk7XG4gIH0sXG4gIFwiZGVsZXRlLmZvcndhcmRcIjogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGRlbGV0ZUZvcndhcmQoYWN0aW9uLmVkaXRvciwgYWN0aW9uLnVuaXQpO1xuICB9LFxuICBcImRlbGV0ZS5ibG9ja1wiOiAoe1xuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgY29uc3QgcmFuZ2UgPSB0b1NsYXRlUmFuZ2Uoe1xuICAgICAgYW5jaG9yOiB7XG4gICAgICAgIHBhdGg6IGFjdGlvbi5ibG9ja1BhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IGFjdGlvbi5ibG9ja1BhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfVxuICAgIH0sIGFjdGlvbi5lZGl0b3IpO1xuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gZmluZCBTbGF0ZSByYW5nZSBmcm9tIHNlbGVjdGlvbiBwb2ludHNcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgICAgYXQ6IHJhbmdlXG4gICAgfSk7XG4gIH0sXG4gIFwiZGVsZXRlLnRleHRcIjogZGVsZXRlVGV4dEFjdGlvbkltcGxlbWVudGF0aW9uLFxuICBcImRlc2VyaWFsaXphdGlvbi5mYWlsdXJlXCI6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBjb25zb2xlLmVycm9yKGBEZXNlcmlhbGl6YXRpb24gb2YgJHthY3Rpb24ubWltZVR5cGV9IGZhaWxlZCB3aXRoIHJlYXNvbiAke2FjdGlvbi5yZWFzb259YCk7XG4gIH0sXG4gIFwiZGVzZXJpYWxpemF0aW9uLnN1Y2Nlc3NcIjogKHtcbiAgICBjb250ZXh0LFxuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgaW5zZXJ0QmxvY2tzQWN0aW9uSW1wbGVtZW50YXRpb24oe1xuICAgICAgY29udGV4dCxcbiAgICAgIGFjdGlvbjoge1xuICAgICAgICB0eXBlOiBcImluc2VydC5ibG9ja3NcIixcbiAgICAgICAgYmxvY2tzOiBhY3Rpb24uZGF0YSxcbiAgICAgICAgZWRpdG9yOiBhY3Rpb24uZWRpdG9yXG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIFwiaGlzdG9yeS5yZWRvXCI6IGhpc3RvcnlSZWRvQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiaGlzdG9yeS51bmRvXCI6IGhpc3RvcnlVbmRvQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiaW5zZXJ0LmJsb2NrXCI6IGluc2VydEJsb2NrQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiaW5zZXJ0LmJsb2Nrc1wiOiBpbnNlcnRCbG9ja3NBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJpbnNlcnQuYmxvY2sgb2JqZWN0XCI6IGluc2VydEJsb2NrT2JqZWN0QWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiaW5zZXJ0LmJyZWFrXCI6IGluc2VydEJyZWFrQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiaW5zZXJ0LmlubGluZSBvYmplY3RcIjogaW5zZXJ0SW5saW5lT2JqZWN0QWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiaW5zZXJ0LnNvZnQgYnJlYWtcIjogaW5zZXJ0U29mdEJyZWFrQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiaW5zZXJ0LnNwYW5cIjogaW5zZXJ0U3BhbkFjdGlvbkltcGxlbWVudGF0aW9uLFxuICBcImluc2VydC50ZXh0XCI6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBpbnNlcnRUZXh0KGFjdGlvbi5lZGl0b3IsIGFjdGlvbi50ZXh0KTtcbiAgfSxcbiAgXCJpbnNlcnQudGV4dCBibG9ja1wiOiAoe1xuICAgIGNvbnRleHQsXG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBjb25zdCBibG9jayA9IHRvU2xhdGVWYWx1ZShbe1xuICAgICAgX2tleTogY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgIF90eXBlOiBjb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lLFxuICAgICAgc3R5bGU6IGNvbnRleHQuc2NoZW1hLnN0eWxlc1swXS52YWx1ZSA/PyBcIm5vcm1hbFwiLFxuICAgICAgbWFya0RlZnM6IFtdLFxuICAgICAgY2hpbGRyZW46IGFjdGlvbi50ZXh0QmxvY2s/LmNoaWxkcmVuPy5tYXAoKGNoaWxkKSA9PiAoe1xuICAgICAgICAuLi5jaGlsZCxcbiAgICAgICAgX2tleTogY29udGV4dC5rZXlHZW5lcmF0b3IoKVxuICAgICAgfSkpID8/IFt7XG4gICAgICAgIF90eXBlOiBjb250ZXh0LnNjaGVtYS5zcGFuLm5hbWUsXG4gICAgICAgIF9rZXk6IGNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICAgIHRleHQ6IFwiXCJcbiAgICAgIH1dXG4gICAgfV0sIHtcbiAgICAgIHNjaGVtYVR5cGVzOiBjb250ZXh0LnNjaGVtYVxuICAgIH0pWzBdO1xuICAgIGluc2VydEJsb2NrKHtcbiAgICAgIGJsb2NrLFxuICAgICAgZWRpdG9yOiBhY3Rpb24uZWRpdG9yLFxuICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYSxcbiAgICAgIHBsYWNlbWVudDogYWN0aW9uLnBsYWNlbWVudFxuICAgIH0pO1xuICB9LFxuICBlZmZlY3Q6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBhY3Rpb24uZWZmZWN0KCk7XG4gIH0sXG4gIFwibGlzdCBpdGVtLmFkZFwiOiBhZGRMaXN0SXRlbUFjdGlvbkltcGxlbWVudGF0aW9uLFxuICBcImxpc3QgaXRlbS5yZW1vdmVcIjogcmVtb3ZlTGlzdEl0ZW1BY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJsaXN0IGl0ZW0udG9nZ2xlXCI6IHRvZ2dsZUxpc3RJdGVtQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwibW92ZS5ibG9ja1wiOiAoe1xuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgY29uc3QgYXQgPSBbdG9TbGF0ZVBhdGgoYWN0aW9uLmF0LCBhY3Rpb24uZWRpdG9yKVswXV0sIHRvID0gW3RvU2xhdGVQYXRoKGFjdGlvbi50bywgYWN0aW9uLmVkaXRvcilbMF1dO1xuICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGFjdGlvbi5lZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgdG8sXG4gICAgICBtb2RlOiBcImhpZ2hlc3RcIlxuICAgIH0pO1xuICB9LFxuICBcIm1vdmUuYmxvY2sgZG93blwiOiAoe1xuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgY29uc3QgYXQgPSBbdG9TbGF0ZVBhdGgoYWN0aW9uLmF0LCBhY3Rpb24uZWRpdG9yKVswXV0sIHRvID0gW1BhdGgubmV4dChhdClbMF1dO1xuICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGFjdGlvbi5lZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgdG8sXG4gICAgICBtb2RlOiBcImhpZ2hlc3RcIlxuICAgIH0pO1xuICB9LFxuICBcIm1vdmUuYmxvY2sgdXBcIjogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGNvbnN0IGF0ID0gW3RvU2xhdGVQYXRoKGFjdGlvbi5hdCwgYWN0aW9uLmVkaXRvcilbMF1dO1xuICAgIGlmICghUGF0aC5oYXNQcmV2aW91cyhhdCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdG8gPSBbUGF0aC5wcmV2aW91cyhhdClbMF1dO1xuICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGFjdGlvbi5lZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgdG8sXG4gICAgICBtb2RlOiBcImhpZ2hlc3RcIlxuICAgIH0pO1xuICB9LFxuICBub29wOiAoKSA9PiB7XG4gIH0sXG4gIHNlbGVjdDogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IHRvU2xhdGVSYW5nZShhY3Rpb24uc2VsZWN0aW9uLCBhY3Rpb24uZWRpdG9yKTtcbiAgICBuZXdTZWxlY3Rpb24gPyBUcmFuc2Zvcm1zLnNlbGVjdChhY3Rpb24uZWRpdG9yLCBuZXdTZWxlY3Rpb24pIDogVHJhbnNmb3Jtcy5kZXNlbGVjdChhY3Rpb24uZWRpdG9yKTtcbiAgfSxcbiAgXCJzZWxlY3QucHJldmlvdXMgYmxvY2tcIjogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGlmICghYWN0aW9uLmVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gc2VsZWN0IHByZXZpb3VzIGJsb2NrIHdpdGhvdXQgYSBzZWxlY3Rpb25cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrUGF0aCA9IGFjdGlvbi5lZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSk7XG4gICAgaWYgKCFQYXRoLmhhc1ByZXZpb3VzKGJsb2NrUGF0aCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGVyZSdzIG5vIHByZXZpb3VzIGJsb2NrIHRvIHNlbGVjdFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNCbG9ja1BhdGggPSBQYXRoLnByZXZpb3VzKGJsb2NrUGF0aCk7XG4gICAgVHJhbnNmb3Jtcy5zZWxlY3QoYWN0aW9uLmVkaXRvciwgcHJldmlvdXNCbG9ja1BhdGgpO1xuICB9LFxuICBcInNlbGVjdC5uZXh0IGJsb2NrXCI6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBpZiAoIWFjdGlvbi5lZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIHNlbGVjdCBuZXh0IGJsb2NrIHdpdGhvdXQgYSBzZWxlY3Rpb25cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5leHRCbG9ja1BhdGggPSBbYWN0aW9uLmVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKVswXSArIDFdO1xuICAgIFRyYW5zZm9ybXMuc2VsZWN0KGFjdGlvbi5lZGl0b3IsIG5leHRCbG9ja1BhdGgpO1xuICB9LFxuICBcInNlcmlhbGl6YXRpb24uZmFpbHVyZVwiOiAoe1xuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgY29uc29sZS5lcnJvcihgU2VyaWFsaXphdGlvbiBvZiAke2FjdGlvbi5taW1lVHlwZX0gZmFpbGVkIHdpdGggcmVhc29uICR7YWN0aW9uLnJlYXNvbn1gKTtcbiAgfSxcbiAgXCJzZXJpYWxpemF0aW9uLnN1Y2Nlc3NcIjogKHtcbiAgICBjb250ZXh0LFxuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgZGF0YVRyYW5zZmVyU2V0QWN0aW9uSW1wbGVtZW50YXRpb24oe1xuICAgICAgY29udGV4dCxcbiAgICAgIGFjdGlvbjoge1xuICAgICAgICAuLi5hY3Rpb24sXG4gICAgICAgIHR5cGU6IFwiZGF0YSB0cmFuc2Zlci5zZXRcIlxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBcInN0eWxlLnRvZ2dsZVwiOiB0b2dnbGVTdHlsZUFjdGlvbkltcGxlbWVudGF0aW9uLFxuICBcInN0eWxlLmFkZFwiOiBhZGRTdHlsZUFjdGlvbkltcGxlbWVudGF0aW9uLFxuICBcInN0eWxlLnJlbW92ZVwiOiByZW1vdmVTdHlsZUFjdGlvbkltcGxlbWVudGF0aW9uXG59O1xuZnVuY3Rpb24gcGVyZm9ybUFjdGlvbih7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBcIm5vb3BcIjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJlZmZlY3RcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnMuZWZmZWN0KHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcGVyZm9ybURlZmF1bHRBY3Rpb24oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwZXJmb3JtRGVmYXVsdEFjdGlvbih7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBcImFubm90YXRpb24uYWRkXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiYW5ub3RhdGlvbi5hZGRcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJhbm5vdGF0aW9uLnJlbW92ZVwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImFubm90YXRpb24ucmVtb3ZlXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiYW5ub3RhdGlvbi50b2dnbGVcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJhbm5vdGF0aW9uLnRvZ2dsZVwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImJsb2NrLnNldFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImJsb2NrLnNldFwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImJsb2NrLnVuc2V0XCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiYmxvY2sudW5zZXRcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJibHVyXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zLmJsdXIoe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJkYXRhIHRyYW5zZmVyLnNldFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImRhdGEgdHJhbnNmZXIuc2V0XCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZGVjb3JhdG9yLmFkZFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImRlY29yYXRvci5hZGRcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJkZWNvcmF0b3IucmVtb3ZlXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiZGVjb3JhdG9yLnJlbW92ZVwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImRlY29yYXRvci50b2dnbGVcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJkZWNvcmF0b3IudG9nZ2xlXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZGVsZXRlXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zLmRlbGV0ZSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImRlbGV0ZS5iYWNrd2FyZFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImRlbGV0ZS5iYWNrd2FyZFwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImRlbGV0ZS5ibG9ja1wiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImRlbGV0ZS5ibG9ja1wiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImRlbGV0ZS5mb3J3YXJkXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiZGVsZXRlLmZvcndhcmRcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJkZWxldGUudGV4dFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImRlbGV0ZS50ZXh0XCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZGVzZXJpYWxpemF0aW9uLmZhaWx1cmVcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJkZXNlcmlhbGl6YXRpb24uZmFpbHVyZVwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImRlc2VyaWFsaXphdGlvbi5zdWNjZXNzXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiZGVzZXJpYWxpemF0aW9uLnN1Y2Nlc3NcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJmb2N1c1wiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9ucy5mb2N1cyh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImhpc3RvcnkucmVkb1wiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImhpc3RvcnkucmVkb1wiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImhpc3RvcnkudW5kb1wiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImhpc3RvcnkudW5kb1wiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImluc2VydC5ibG9ja1wiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImluc2VydC5ibG9ja1wiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImluc2VydC5ibG9ja3NcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJpbnNlcnQuYmxvY2tzXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaW5zZXJ0LmJsb2NrIG9iamVjdFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImluc2VydC5ibG9jayBvYmplY3RcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJpbnNlcnQuaW5saW5lIG9iamVjdFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImluc2VydC5pbmxpbmUgb2JqZWN0XCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaW5zZXJ0LmJyZWFrXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiaW5zZXJ0LmJyZWFrXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaW5zZXJ0LnNvZnQgYnJlYWtcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJpbnNlcnQuc29mdCBicmVha1wiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImluc2VydC5zcGFuXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiaW5zZXJ0LnNwYW5cIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJpbnNlcnQudGV4dFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImluc2VydC50ZXh0XCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaW5zZXJ0LnRleHQgYmxvY2tcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJpbnNlcnQudGV4dCBibG9ja1wiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImxpc3QgaXRlbS5hZGRcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJsaXN0IGl0ZW0uYWRkXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwibGlzdCBpdGVtLnJlbW92ZVwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImxpc3QgaXRlbS5yZW1vdmVcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJsaXN0IGl0ZW0udG9nZ2xlXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wibGlzdCBpdGVtLnRvZ2dsZVwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIm1vdmUuYmxvY2tcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJtb3ZlLmJsb2NrXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwibW92ZS5ibG9jayBkb3duXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wibW92ZS5ibG9jayBkb3duXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwibW92ZS5ibG9jayB1cFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcIm1vdmUuYmxvY2sgdXBcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJzZWxlY3RcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnMuc2VsZWN0KHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwic2VsZWN0LnByZXZpb3VzIGJsb2NrXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wic2VsZWN0LnByZXZpb3VzIGJsb2NrXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwic2VsZWN0Lm5leHQgYmxvY2tcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJzZWxlY3QubmV4dCBibG9ja1wiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInNlcmlhbGl6YXRpb24uZmFpbHVyZVwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcInNlcmlhbGl6YXRpb24uZmFpbHVyZVwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInNlcmlhbGl6YXRpb24uc3VjY2Vzc1wiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcInNlcmlhbGl6YXRpb24uc3VjY2Vzc1wiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInN0eWxlLmFkZFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcInN0eWxlLmFkZFwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInN0eWxlLnJlbW92ZVwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcInN0eWxlLnJlbW92ZVwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJzdHlsZS50b2dnbGVcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVXaXRoRXZlbnRMaXN0ZW5lcnMoZWRpdG9yQWN0b3IsIHN1YnNjcmlwdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQubWF4QmxvY2tzICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gZWRpdG9yO1xuICAgIHN1YnNjcmlwdGlvbnMucHVzaCgoKSA9PiB7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBlZGl0b3JBY3Rvci5vbihcIipcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgIC8vIFRoZXNlIGV2ZW50cyBhcmUgbm90IHJlbGV2YW50IGZvciBCZWhhdmlvcnNcbiAgICAgICAgICBjYXNlIFwiYmx1cnJlZFwiOlxuICAgICAgICAgIGNhc2UgXCJkb25lIGxvYWRpbmdcIjpcbiAgICAgICAgICBjYXNlIFwiZWRpdGFibGVcIjpcbiAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICBjYXNlIFwiZm9jdXNlZFwiOlxuICAgICAgICAgIGNhc2UgXCJpbnZhbGlkIHZhbHVlXCI6XG4gICAgICAgICAgY2FzZSBcImxvYWRpbmdcIjpcbiAgICAgICAgICBjYXNlIFwibXV0YXRpb25cIjpcbiAgICAgICAgICBjYXNlIFwicGF0Y2hcIjpcbiAgICAgICAgICBjYXNlIFwiaW50ZXJuYWwucGF0Y2hcIjpcbiAgICAgICAgICBjYXNlIFwicGF0Y2hlc1wiOlxuICAgICAgICAgIGNhc2UgXCJyZWFkIG9ubHlcIjpcbiAgICAgICAgICBjYXNlIFwicmVhZHlcIjpcbiAgICAgICAgICBjYXNlIFwic2VsZWN0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcInZhbHVlIGNoYW5nZWRcIjpcbiAgICAgICAgICBjYXNlIFwidW5zZXRcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjdXN0b20uKlwiOlxuICAgICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiY3VzdG9tIGJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgICAgICAgIGJlaGF2aW9yRXZlbnQ6IGV2ZW50LmV2ZW50LFxuICAgICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgICAgICAgIGJlaGF2aW9yRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGRlbGV0ZUJhY2t3YXJkLFxuICAgICAgZGVsZXRlRm9yd2FyZDogZGVsZXRlRm9yd2FyZDIsXG4gICAgICBpbnNlcnRCcmVhayxcbiAgICAgIGluc2VydERhdGEsXG4gICAgICBpbnNlcnRUZXh0OiBpbnNlcnRUZXh0MixcbiAgICAgIHNlbGVjdDogc2VsZWN0MixcbiAgICAgIHNldEZyYWdtZW50RGF0YVxuICAgIH0gPSBlZGl0b3I7XG4gICAgcmV0dXJuIGVkaXRvci5kZWxldGVCYWNrd2FyZCA9ICh1bml0KSA9PiB7XG4gICAgICBpZiAoaXNBcHBseWluZ0JlaGF2aW9yQWN0aW9ucyhlZGl0b3IpKSB7XG4gICAgICAgIGRlbGV0ZUJhY2t3YXJkKHVuaXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJkZWxldGUuYmFja3dhcmRcIixcbiAgICAgICAgICB1bml0XG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLmRlbGV0ZUZvcndhcmQgPSAodW5pdCkgPT4ge1xuICAgICAgaWYgKGlzQXBwbHlpbmdCZWhhdmlvckFjdGlvbnMoZWRpdG9yKSkge1xuICAgICAgICBkZWxldGVGb3J3YXJkMih1bml0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiZGVsZXRlLmZvcndhcmRcIixcbiAgICAgICAgICB1bml0XG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLmluc2VydEJyZWFrID0gKCkgPT4ge1xuICAgICAgaWYgKGlzQXBwbHlpbmdCZWhhdmlvckFjdGlvbnMoZWRpdG9yKSkge1xuICAgICAgICBpbnNlcnRCcmVhaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJpbnNlcnQuYnJlYWtcIlxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sIGVkaXRvci5pbnNlcnREYXRhID0gKGRhdGFUcmFuc2ZlcikgPT4ge1xuICAgICAgaWYgKGlzQXBwbHlpbmdCZWhhdmlvckFjdGlvbnMoZWRpdG9yKSkge1xuICAgICAgICBpbnNlcnREYXRhKGRhdGFUcmFuc2Zlcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImRlc2VyaWFsaXplXCIsXG4gICAgICAgICAgZGF0YVRyYW5zZmVyXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLmluc2VydFNvZnRCcmVhayA9ICgpID0+IHtcbiAgICAgIGlmIChpc0FwcGx5aW5nQmVoYXZpb3JBY3Rpb25zKGVkaXRvcikpIHtcbiAgICAgICAgaW5zZXJ0U29mdEJyZWFrQWN0aW9uSW1wbGVtZW50YXRpb24oe1xuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIGtleUdlbmVyYXRvcjogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgICAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiBcImluc2VydC5zb2Z0IGJyZWFrXCIsXG4gICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJpbnNlcnQuc29mdCBicmVha1wiXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLmluc2VydFRleHQgPSAodGV4dCwgb3B0aW9ucykgPT4ge1xuICAgICAgaWYgKGlzQXBwbHlpbmdCZWhhdmlvckFjdGlvbnMoZWRpdG9yKSkge1xuICAgICAgICBpbnNlcnRUZXh0Mih0ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiaW5zZXJ0LnRleHRcIixcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICBkZWZhdWx0QWN0aW9uQ2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICBpbnNlcnRUZXh0Mih0ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLnJlZG8gPSAoKSA9PiB7XG4gICAgICBpZiAoaXNBcHBseWluZ0JlaGF2aW9yQWN0aW9ucyhlZGl0b3IpKSB7XG4gICAgICAgIHBlcmZvcm1BY3Rpb24oe1xuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIGtleUdlbmVyYXRvcjogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgICAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiBcImhpc3RvcnkucmVkb1wiLFxuICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiaGlzdG9yeS5yZWRvXCJcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LCBlZGl0b3Iuc2VsZWN0ID0gKGxvY2F0aW9uKSA9PiB7XG4gICAgICBpZiAoaXNBcHBseWluZ0JlaGF2aW9yQWN0aW9ucyhlZGl0b3IpKSB7XG4gICAgICAgIHNlbGVjdDIobG9jYXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGxvY2F0aW9uKTtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcInNlbGVjdFwiLFxuICAgICAgICAgIHNlbGVjdGlvbjogdG9Qb3J0YWJsZVRleHRSYW5nZShmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpLCByYW5nZSwgZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSlcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICBkZWZhdWx0QWN0aW9uQ2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICBzZWxlY3QyKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLnNldEZyYWdtZW50RGF0YSA9IChkYXRhVHJhbnNmZXIsIG9yaWdpbkV2ZW50KSA9PiB7XG4gICAgICBpZiAoaXNBcHBseWluZ0JlaGF2aW9yQWN0aW9ucyhlZGl0b3IpKSB7XG4gICAgICAgIHNldEZyYWdtZW50RGF0YShkYXRhVHJhbnNmZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkYXRhVHJhbnNmZXIuY2xlYXJEYXRhKCksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcInNlcmlhbGl6ZVwiLFxuICAgICAgICAgIGRhdGFUcmFuc2ZlcixcbiAgICAgICAgICBvcmlnaW5FdmVudDogb3JpZ2luRXZlbnQgPz8gXCJ1bmtub3duXCJcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LCBlZGl0b3IudW5kbyA9ICgpID0+IHtcbiAgICAgIGlmIChpc0FwcGx5aW5nQmVoYXZpb3JBY3Rpb25zKGVkaXRvcikpIHtcbiAgICAgICAgcGVyZm9ybUFjdGlvbih7XG4gICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAga2V5R2VuZXJhdG9yOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yLFxuICAgICAgICAgICAgc2NoZW1hOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhY3Rpb246IHtcbiAgICAgICAgICAgIHR5cGU6IFwiaGlzdG9yeS51bmRvXCIsXG4gICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJoaXN0b3J5LnVuZG9cIlxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdpdGhNYXhCbG9ja3MoZWRpdG9yQWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGFwcGx5OiBhcHBseTJcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3IuYXBwbHkgPSAob3BlcmF0aW9uKSA9PiB7XG4gICAgICBpZiAoZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5tYXRjaGVzKHtcbiAgICAgICAgXCJlZGl0IG1vZGVcIjogXCJyZWFkIG9ubHlcIlxuICAgICAgfSkpIHtcbiAgICAgICAgYXBwbHkyKG9wZXJhdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc0NoYW5naW5nUmVtb3RlbHkoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzVW5kb2luZyhlZGl0b3IpIHx8IGlzUmVkb2luZyhlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcGVyYXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByb3dzID0gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0Lm1heEJsb2NrcyA/PyAtMTtcbiAgICAgIHJvd3MgPiAwICYmIGVkaXRvci5jaGlsZHJlbi5sZW5ndGggPj0gcm93cyAmJiAob3BlcmF0aW9uLnR5cGUgPT09IFwiaW5zZXJ0X25vZGVcIiB8fCBvcGVyYXRpb24udHlwZSA9PT0gXCJzcGxpdF9ub2RlXCIpICYmIG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMSB8fCBhcHBseTIob3BlcmF0aW9uKTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVXaXRoT2JqZWN0S2V5cyhlZGl0b3JBY3Rvciwgc2NoZW1hVHlwZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGFwcGx5OiBhcHBseTIsXG4gICAgICBub3JtYWxpemVOb2RlXG4gICAgfSA9IGVkaXRvcjtcbiAgICByZXR1cm4gZWRpdG9yLmFwcGx5ID0gKG9wZXJhdGlvbikgPT4ge1xuICAgICAgaWYgKGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcGVyYXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNVbmRvaW5nKGVkaXRvcikgfHwgaXNSZWRvaW5nKGVkaXRvcikpIHtcbiAgICAgICAgYXBwbHkyKG9wZXJhdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gXCJzcGxpdF9ub2RlXCIpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdLZXlzID0gWy4uLk5vZGUuZGVzY2VuZGFudHMoZWRpdG9yKV0ubWFwKChbbm9kZV0pID0+IG5vZGUuX2tleSk7XG4gICAgICAgIGFwcGx5Mih7XG4gICAgICAgICAgLi4ub3BlcmF0aW9uLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIC4uLm9wZXJhdGlvbi5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgX2tleTogb3BlcmF0aW9uLnByb3BlcnRpZXMuX2tleSA9PT0gdm9pZCAwIHx8IGV4aXN0aW5nS2V5cy5pbmNsdWRlcyhvcGVyYXRpb24ucHJvcGVydGllcy5fa2V5KSA/IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSA6IG9wZXJhdGlvbi5wcm9wZXJ0aWVzLl9rZXlcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09IFwiaW5zZXJ0X25vZGVcIiAmJiAhRWRpdG9yLmlzRWRpdG9yKG9wZXJhdGlvbi5ub2RlKSkge1xuICAgICAgICBjb25zdCBleGlzdGluZ0tleXMgPSBbLi4uTm9kZS5kZXNjZW5kYW50cyhlZGl0b3IpXS5tYXAoKFtub2RlXSkgPT4gbm9kZS5fa2V5KTtcbiAgICAgICAgYXBwbHkyKHtcbiAgICAgICAgICAuLi5vcGVyYXRpb24sXG4gICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgLi4ub3BlcmF0aW9uLm5vZGUsXG4gICAgICAgICAgICBfa2V5OiBvcGVyYXRpb24ubm9kZS5fa2V5ID09PSB2b2lkIDAgfHwgZXhpc3RpbmdLZXlzLmluY2x1ZGVzKG9wZXJhdGlvbi5ub2RlLl9rZXkpID8gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpIDogb3BlcmF0aW9uLm5vZGUuX2tleVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFwcGx5MihvcGVyYXRpb24pO1xuICAgIH0sIGVkaXRvci5ub3JtYWxpemVOb2RlID0gKGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBbbm9kZSwgcGF0aF0gPSBlbnRyeTtcbiAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLl90eXBlID09PSBzY2hlbWFUeXBlcy5ibG9jay5uYW1lKSB7XG4gICAgICAgIGlmICghbm9kZS5fa2V5KSB7XG4gICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgTm9kZS5jaGlsZHJlbihlZGl0b3IsIHBhdGgpKVxuICAgICAgICAgIGlmICghY2hpbGQuX2tleSkge1xuICAgICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBub3JtYWxpemVOb2RlKGVudHJ5KTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBkZWJ1ZyQ3ID0gZGVidWdXaXRoTmFtZShcImFwcGx5UGF0Y2hlc1wiKSwgZGVidWdWZXJib3NlID0gZGVidWckNy5lbmFibGVkICYmICEwO1xuZnVuY3Rpb24gY3JlYXRlQXBwbHlQYXRjaChzY2hlbWFUeXBlcykge1xuICByZXR1cm4gKGVkaXRvciwgcGF0Y2gpID0+IHtcbiAgICBsZXQgY2hhbmdlZCA9ICExO1xuICAgIGRlYnVnVmVyYm9zZSAmJiAoZGVidWckNyhgXG5cbk5FVyBQQVRDSCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09YCksIGRlYnVnJDcoSlNPTi5zdHJpbmdpZnkocGF0Y2gsIG51bGwsIDIpKSk7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAocGF0Y2gudHlwZSkge1xuICAgICAgICBjYXNlIFwiaW5zZXJ0XCI6XG4gICAgICAgICAgY2hhbmdlZCA9IGluc2VydFBhdGNoKGVkaXRvciwgcGF0Y2gsIHNjaGVtYVR5cGVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInVuc2V0XCI6XG4gICAgICAgICAgY2hhbmdlZCA9IHVuc2V0UGF0Y2goZWRpdG9yLCBwYXRjaCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZXRcIjpcbiAgICAgICAgICBjaGFuZ2VkID0gc2V0UGF0Y2goZWRpdG9yLCBwYXRjaCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkaWZmTWF0Y2hQYXRjaFwiOlxuICAgICAgICAgIGNoYW5nZWQgPSBkaWZmTWF0Y2hQYXRjaChlZGl0b3IsIHBhdGNoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkZWJ1ZyQ3KFwiVW5oYW5kbGVkIHBhdGNoXCIsIHBhdGNoLnR5cGUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRpZmZNYXRjaFBhdGNoKGVkaXRvciwgcGF0Y2gpIHtcbiAgY29uc3Qge1xuICAgIGJsb2NrLFxuICAgIGNoaWxkLFxuICAgIGNoaWxkUGF0aFxuICB9ID0gZmluZEJsb2NrQW5kQ2hpbGRGcm9tUGF0aChlZGl0b3IsIHBhdGNoLnBhdGgpO1xuICBpZiAoIWJsb2NrKVxuICAgIHJldHVybiBkZWJ1ZyQ3KFwiQmxvY2sgbm90IGZvdW5kXCIpLCAhMTtcbiAgaWYgKCFjaGlsZCB8fCAhY2hpbGRQYXRoKVxuICAgIHJldHVybiBkZWJ1ZyQ3KFwiQ2hpbGQgbm90IGZvdW5kXCIpLCAhMTtcbiAgaWYgKCEoYmxvY2sgJiYgZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gNCAmJiBwYXRjaC5wYXRoWzFdID09PSBcImNoaWxkcmVuXCIgJiYgcGF0Y2gucGF0aFszXSA9PT0gXCJ0ZXh0XCIpIHx8ICFUZXh0LmlzVGV4dChjaGlsZCkpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBwYXRjaGVzID0gcGFyc2UocGF0Y2gudmFsdWUpLCBbbmV3VmFsdWVdID0gYXBwbHkocGF0Y2hlcywgY2hpbGQudGV4dCwge1xuICAgIGFsbG93RXhjZWVkaW5nSW5kaWNlczogITBcbiAgfSksIGRpZmYkMSA9IGNsZWFudXBFZmZpY2llbmN5KGRpZmYoY2hpbGQudGV4dCwgbmV3VmFsdWUpLCA1KTtcbiAgZGVidWdTdGF0ZShlZGl0b3IsIFwiYmVmb3JlXCIpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBbb3AsIHRleHRdIG9mIGRpZmYkMSlcbiAgICBvcCA9PT0gRElGRl9JTlNFUlQgPyAoZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6IFwiaW5zZXJ0X3RleHRcIixcbiAgICAgIHBhdGg6IGNoaWxkUGF0aCxcbiAgICAgIG9mZnNldCxcbiAgICAgIHRleHRcbiAgICB9KSwgb2Zmc2V0ICs9IHRleHQubGVuZ3RoKSA6IG9wID09PSBESUZGX0RFTEVURSA/IGVkaXRvci5hcHBseSh7XG4gICAgICB0eXBlOiBcInJlbW92ZV90ZXh0XCIsXG4gICAgICBwYXRoOiBjaGlsZFBhdGgsXG4gICAgICBvZmZzZXQsXG4gICAgICB0ZXh0XG4gICAgfSkgOiBvcCA9PT0gRElGRl9FUVVBTCAmJiAob2Zmc2V0ICs9IHRleHQubGVuZ3RoKTtcbiAgcmV0dXJuIGRlYnVnU3RhdGUoZWRpdG9yLCBcImFmdGVyXCIpLCAhMDtcbn1cbmZ1bmN0aW9uIGluc2VydFBhdGNoKGVkaXRvciwgcGF0Y2gsIHNjaGVtYVR5cGVzKSB7XG4gIGNvbnN0IHtcbiAgICBibG9jazogdGFyZ2V0QmxvY2ssXG4gICAgY2hpbGQ6IHRhcmdldENoaWxkLFxuICAgIGJsb2NrUGF0aDogdGFyZ2V0QmxvY2tQYXRoLFxuICAgIGNoaWxkUGF0aDogdGFyZ2V0Q2hpbGRQYXRoXG4gIH0gPSBmaW5kQmxvY2tBbmRDaGlsZEZyb21QYXRoKGVkaXRvciwgcGF0Y2gucGF0aCk7XG4gIGlmICghdGFyZ2V0QmxvY2sgfHwgIXRhcmdldEJsb2NrUGF0aClcbiAgICByZXR1cm4gZGVidWckNyhcIkJsb2NrIG5vdCBmb3VuZFwiKSwgITE7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA+IDEgJiYgcGF0Y2gucGF0aFsxXSAhPT0gXCJjaGlsZHJlblwiKVxuICAgIHJldHVybiBkZWJ1ZyQ3KFwiSWdub3JpbmcgcGF0Y2ggdGFyZ2V0aW5nIHZvaWQgdmFsdWVcIiksICExO1xuICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCB7XG4gICAgICBpdGVtczogaXRlbXMyLFxuICAgICAgcG9zaXRpb246IHBvc2l0aW9uMlxuICAgIH0gPSBwYXRjaCwgYmxvY2tzVG9JbnNlcnQgPSB0b1NsYXRlVmFsdWUoaXRlbXMyLCB7XG4gICAgICBzY2hlbWFUeXBlc1xuICAgIH0sIEtFWV9UT19TTEFURV9FTEVNRU5ULmdldChlZGl0b3IpKSwgdGFyZ2V0QmxvY2tJbmRleCA9IHRhcmdldEJsb2NrUGF0aFswXSwgbm9ybWFsaXplZElkeDIgPSBwb3NpdGlvbjIgPT09IFwiYWZ0ZXJcIiA/IHRhcmdldEJsb2NrSW5kZXggKyAxIDogdGFyZ2V0QmxvY2tJbmRleDtcbiAgICByZXR1cm4gZGVidWckNyhgSW5zZXJ0aW5nIGJsb2NrcyBhdCBwYXRoIFske25vcm1hbGl6ZWRJZHgyfV1gKSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYmVmb3JlXCIpLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgYmxvY2tzVG9JbnNlcnQsIHtcbiAgICAgIGF0OiBbbm9ybWFsaXplZElkeDJdXG4gICAgfSksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImFmdGVyXCIpLCAhMDtcbiAgfVxuICBjb25zdCB7XG4gICAgaXRlbXMsXG4gICAgcG9zaXRpb25cbiAgfSA9IHBhdGNoO1xuICBpZiAoIXRhcmdldENoaWxkIHx8ICF0YXJnZXRDaGlsZFBhdGgpXG4gICAgcmV0dXJuIGRlYnVnJDcoXCJDaGlsZCBub3QgZm91bmRcIiksICExO1xuICBjb25zdCBjaGlsZHJlblRvSW5zZXJ0ID0gdGFyZ2V0QmxvY2sgJiYgdG9TbGF0ZVZhbHVlKFt7XG4gICAgLi4udGFyZ2V0QmxvY2ssXG4gICAgY2hpbGRyZW46IGl0ZW1zXG4gIH1dLCB7XG4gICAgc2NoZW1hVHlwZXNcbiAgfSwgS0VZX1RPX1NMQVRFX0VMRU1FTlQuZ2V0KGVkaXRvcikpLCB0YXJnZXRDaGlsZEluZGV4ID0gdGFyZ2V0Q2hpbGRQYXRoWzFdLCBub3JtYWxpemVkSWR4ID0gcG9zaXRpb24gPT09IFwiYWZ0ZXJcIiA/IHRhcmdldENoaWxkSW5kZXggKyAxIDogdGFyZ2V0Q2hpbGRJbmRleCwgY2hpbGRJbnNlcnRQYXRoID0gW3RhcmdldENoaWxkUGF0aFswXSwgbm9ybWFsaXplZElkeF07XG4gIHJldHVybiBkZWJ1ZyQ3KGBJbnNlcnRpbmcgY2hpbGRyZW4gYXQgcGF0aCAke2NoaWxkSW5zZXJ0UGF0aH1gKSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYmVmb3JlXCIpLCBjaGlsZHJlblRvSW5zZXJ0ICYmIEVsZW1lbnQuaXNFbGVtZW50KGNoaWxkcmVuVG9JbnNlcnRbMF0pICYmIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBjaGlsZHJlblRvSW5zZXJ0WzBdLmNoaWxkcmVuLCB7XG4gICAgYXQ6IGNoaWxkSW5zZXJ0UGF0aFxuICB9KSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwO1xufVxuZnVuY3Rpb24gc2V0UGF0Y2goZWRpdG9yLCBwYXRjaCkge1xuICBsZXQgdmFsdWUgPSBwYXRjaC52YWx1ZTtcbiAgdHlwZW9mIHBhdGNoLnBhdGhbM10gPT0gXCJzdHJpbmdcIiAmJiAodmFsdWUgPSB7fSwgdmFsdWVbcGF0Y2gucGF0aFszXV0gPSBwYXRjaC52YWx1ZSk7XG4gIGNvbnN0IHtcbiAgICBibG9jayxcbiAgICBibG9ja1BhdGgsXG4gICAgY2hpbGQsXG4gICAgY2hpbGRQYXRoXG4gIH0gPSBmaW5kQmxvY2tBbmRDaGlsZEZyb21QYXRoKGVkaXRvciwgcGF0Y2gucGF0aCk7XG4gIGlmICghYmxvY2spXG4gICAgcmV0dXJuIGRlYnVnJDcoXCJCbG9jayBub3QgZm91bmRcIiksICExO1xuICBjb25zdCBpc1RleHRCbG9jazIgPSBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spO1xuICBpZiAoaXNUZXh0QmxvY2syICYmIHBhdGNoLnBhdGgubGVuZ3RoID4gMSAmJiBwYXRjaC5wYXRoWzFdICE9PSBcImNoaWxkcmVuXCIpXG4gICAgcmV0dXJuIGRlYnVnJDcoXCJJZ25vcmluZyBzZXR0aW5nIHZvaWQgdmFsdWVcIiksICExO1xuICBpZiAoZGVidWdTdGF0ZShlZGl0b3IsIFwiYmVmb3JlXCIpLCBpc1RleHRCbG9jazIgJiYgY2hpbGQgJiYgY2hpbGRQYXRoKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KHZhbHVlKSAmJiBUZXh0LmlzVGV4dChjaGlsZCkpIHtcbiAgICAgIGNvbnN0IG5ld1RleHQgPSBjaGlsZC50ZXh0O1xuICAgICAgdmFsdWUudGV4dCAhPT0gbmV3VGV4dCAmJiAoZGVidWckNyhcIlNldHRpbmcgdGV4dCBwcm9wZXJ0eVwiKSwgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogXCJyZW1vdmVfdGV4dFwiLFxuICAgICAgICBwYXRoOiBjaGlsZFBhdGgsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgdGV4dDogbmV3VGV4dFxuICAgICAgfSksIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6IFwiaW5zZXJ0X3RleHRcIixcbiAgICAgICAgcGF0aDogY2hpbGRQYXRoLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIHRleHQ6IHZhbHVlLnRleHRcbiAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKSk7XG4gICAgfSBlbHNlXG4gICAgICBkZWJ1ZyQ3KFwiU2V0dGluZyBub24tdGV4dCBwcm9wZXJ0eVwiKSwgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogXCJzZXRfbm9kZVwiLFxuICAgICAgICBwYXRoOiBjaGlsZFBhdGgsXG4gICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICBuZXdQcm9wZXJ0aWVzOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgcmV0dXJuICEwO1xuICB9IGVsc2UgaWYgKEVsZW1lbnQuaXNFbGVtZW50KGJsb2NrKSAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMSAmJiBibG9ja1BhdGgpIHtcbiAgICBkZWJ1ZyQ3KFwiU2V0dGluZyBibG9jayBwcm9wZXJ0eVwiKTtcbiAgICBjb25zdCB7XG4gICAgICBjaGlsZHJlbixcbiAgICAgIC4uLm5leHRSZXN0XG4gICAgfSA9IHZhbHVlLCB7XG4gICAgICBjaGlsZHJlbjogcHJldkNoaWxkcmVuLFxuICAgICAgLi4ucHJldlJlc3RcbiAgICB9ID0gYmxvY2sgfHwge1xuICAgICAgY2hpbGRyZW46IHZvaWQgMFxuICAgIH07XG4gICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6IFwic2V0X25vZGVcIixcbiAgICAgIHBhdGg6IGJsb2NrUGF0aCxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLi4ucHJldlJlc3RcbiAgICAgIH0sXG4gICAgICBuZXdQcm9wZXJ0aWVzOiBuZXh0UmVzdFxuICAgIH0pLCBkZWJ1ZyQ3KFwiU2V0dGluZyBjaGlsZHJlblwiKSwgYmxvY2suY2hpbGRyZW4uZm9yRWFjaCgoYzIsIGNJbmRleCkgPT4ge1xuICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogXCJyZW1vdmVfbm9kZVwiLFxuICAgICAgICBwYXRoOiBibG9ja1BhdGguY29uY2F0KGJsb2NrLmNoaWxkcmVuLmxlbmd0aCAtIDEgLSBjSW5kZXgpLFxuICAgICAgICBub2RlOiBjMlxuICAgICAgfSk7XG4gICAgfSksIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmZvckVhY2goKGMyLCBjSW5kZXgpID0+IHtcbiAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6IFwiaW5zZXJ0X25vZGVcIixcbiAgICAgICAgcGF0aDogYmxvY2tQYXRoLmNvbmNhdChjSW5kZXgpLFxuICAgICAgICBub2RlOiBjMlxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoYmxvY2sgJiYgXCJ2YWx1ZVwiIGluIGJsb2NrKVxuICAgIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA+IDEgJiYgcGF0Y2gucGF0aFsxXSAhPT0gXCJjaGlsZHJlblwiKSB7XG4gICAgICBjb25zdCBuZXdWYWwgPSBhcHBseUFsbChibG9jay52YWx1ZSwgW3tcbiAgICAgICAgLi4ucGF0Y2gsXG4gICAgICAgIHBhdGg6IHBhdGNoLnBhdGguc2xpY2UoMSlcbiAgICAgIH1dKTtcbiAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIC4uLmJsb2NrLFxuICAgICAgICB2YWx1ZTogbmV3VmFsXG4gICAgICB9LCB7XG4gICAgICAgIGF0OiBibG9ja1BhdGhcbiAgICAgIH0pO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwO1xufVxuZnVuY3Rpb24gdW5zZXRQYXRjaChlZGl0b3IsIHBhdGNoKSB7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIGRlYnVnJDcoXCJSZW1vdmluZyBldmVyeXRoaW5nXCIpLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJiZWZvcmVcIik7XG4gICAgY29uc3QgcHJldmlvdXNTZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgIHJldHVybiBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvciksIGVkaXRvci5jaGlsZHJlbi5mb3JFYWNoKChfY2hpbGQsIGkpID0+IHtcbiAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBbaV1cbiAgICAgIH0pO1xuICAgIH0pLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgZWRpdG9yLnB0ZUNyZWF0ZVRleHRCbG9jayh7XG4gICAgICBkZWNvcmF0b3JzOiBbXVxuICAgIH0pKSwgcHJldmlvdXNTZWxlY3Rpb24gJiYgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCB7XG4gICAgICBhbmNob3I6IHtcbiAgICAgICAgcGF0aDogWzAsIDBdLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czoge1xuICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfVxuICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwO1xuICB9XG4gIGNvbnN0IHtcbiAgICBibG9jayxcbiAgICBibG9ja1BhdGgsXG4gICAgY2hpbGQsXG4gICAgY2hpbGRQYXRoXG4gIH0gPSBmaW5kQmxvY2tBbmRDaGlsZEZyb21QYXRoKGVkaXRvciwgcGF0Y2gucGF0aCk7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmICghYmxvY2sgfHwgIWJsb2NrUGF0aClcbiAgICAgIHJldHVybiBkZWJ1ZyQ3KFwiQmxvY2sgbm90IGZvdW5kXCIpLCAhMTtcbiAgICBjb25zdCBibG9ja0luZGV4ID0gYmxvY2tQYXRoWzBdO1xuICAgIHJldHVybiBkZWJ1ZyQ3KGBSZW1vdmluZyBibG9jayBhdCBwYXRoIFske2Jsb2NrSW5kZXh9XWApLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJiZWZvcmVcIiksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogW2Jsb2NrSW5kZXhdXG4gICAgfSksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImFmdGVyXCIpLCAhMDtcbiAgfVxuICByZXR1cm4gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBwYXRjaC5wYXRoWzFdID09PSBcImNoaWxkcmVuXCIgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDMgPyAhY2hpbGQgfHwgIWNoaWxkUGF0aCA/IChkZWJ1ZyQ3KFwiQ2hpbGQgbm90IGZvdW5kXCIpLCAhMSkgOiAoZGVidWckNyhgVW5zZXR0aW5nIGNoaWxkIGF0IHBhdGggJHtKU09OLnN0cmluZ2lmeShjaGlsZFBhdGgpfWApLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJiZWZvcmVcIiksIGRlYnVnVmVyYm9zZSAmJiBkZWJ1ZyQ3KGBSZW1vdmluZyBjaGlsZCBhdCBwYXRoICR7SlNPTi5zdHJpbmdpZnkoY2hpbGRQYXRoKX1gKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICBhdDogY2hpbGRQYXRoXG4gIH0pLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJhZnRlclwiKSwgITApIDogITE7XG59XG5mdW5jdGlvbiBpc0tleWVkU2VnbWVudChzZWdtZW50KSB7XG4gIHJldHVybiB0eXBlb2Ygc2VnbWVudCA9PSBcIm9iamVjdFwiICYmIFwiX2tleVwiIGluIHNlZ21lbnQ7XG59XG5mdW5jdGlvbiBkZWJ1Z1N0YXRlKGVkaXRvciwgc3RhdGVOYW1lKSB7XG4gIGRlYnVnVmVyYm9zZSAmJiAoZGVidWckNyhgQ2hpbGRyZW4gJHtzdGF0ZU5hbWV9OmAsIEpTT04uc3RyaW5naWZ5KGVkaXRvci5jaGlsZHJlbiwgbnVsbCwgMikpLCBkZWJ1ZyQ3KGBTZWxlY3Rpb24gJHtzdGF0ZU5hbWV9OiBgLCBKU09OLnN0cmluZ2lmeShlZGl0b3Iuc2VsZWN0aW9uLCBudWxsLCAyKSkpO1xufVxuZnVuY3Rpb24gZmluZEJsb2NrRnJvbVBhdGgoZWRpdG9yLCBwYXRoKSB7XG4gIGxldCBibG9ja0luZGV4ID0gLTE7XG4gIGNvbnN0IGJsb2NrID0gZWRpdG9yLmNoaWxkcmVuLmZpbmQoKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgaXNNYXRjaCA9IGlzS2V5ZWRTZWdtZW50KHBhdGhbMF0pID8gbm9kZS5fa2V5ID09PSBwYXRoWzBdLl9rZXkgOiBpbmRleCA9PT0gcGF0aFswXTtcbiAgICByZXR1cm4gaXNNYXRjaCAmJiAoYmxvY2tJbmRleCA9IGluZGV4KSwgaXNNYXRjaDtcbiAgfSk7XG4gIHJldHVybiBibG9jayA/IHtcbiAgICBibG9jayxcbiAgICBwYXRoOiBbYmxvY2tJbmRleF1cbiAgfSA6IHt9O1xufVxuZnVuY3Rpb24gZmluZEJsb2NrQW5kQ2hpbGRGcm9tUGF0aChlZGl0b3IsIHBhdGgpIHtcbiAgY29uc3Qge1xuICAgIGJsb2NrLFxuICAgIHBhdGg6IGJsb2NrUGF0aFxuICB9ID0gZmluZEJsb2NrRnJvbVBhdGgoZWRpdG9yLCBwYXRoKTtcbiAgaWYgKCEoRWxlbWVudC5pc0VsZW1lbnQoYmxvY2spICYmIHBhdGhbMV0gPT09IFwiY2hpbGRyZW5cIikpXG4gICAgcmV0dXJuIHtcbiAgICAgIGJsb2NrLFxuICAgICAgYmxvY2tQYXRoLFxuICAgICAgY2hpbGQ6IHZvaWQgMCxcbiAgICAgIGNoaWxkUGF0aDogdm9pZCAwXG4gICAgfTtcbiAgbGV0IGNoaWxkSW5kZXggPSAtMTtcbiAgY29uc3QgY2hpbGQgPSBibG9jay5jaGlsZHJlbi5maW5kKChub2RlLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSBpc0tleWVkU2VnbWVudChwYXRoWzJdKSA/IG5vZGUuX2tleSA9PT0gcGF0aFsyXS5fa2V5IDogaW5kZXggPT09IHBhdGhbMl07XG4gICAgcmV0dXJuIGlzTWF0Y2ggJiYgKGNoaWxkSW5kZXggPSBpbmRleCksIGlzTWF0Y2g7XG4gIH0pO1xuICByZXR1cm4gY2hpbGQgPyB7XG4gICAgYmxvY2ssXG4gICAgY2hpbGQsXG4gICAgYmxvY2tQYXRoLFxuICAgIGNoaWxkUGF0aDogYmxvY2tQYXRoPy5jb25jYXQoY2hpbGRJbmRleClcbiAgfSA6IHtcbiAgICBibG9jayxcbiAgICBibG9ja1BhdGgsXG4gICAgY2hpbGQ6IHZvaWQgMCxcbiAgICBjaGlsZFBhdGg6IHZvaWQgMFxuICB9O1xufVxuY29uc3QgZGVidWckNiA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFBhdGNoZXNcIik7XG5mdW5jdGlvbiBjcmVhdGVXaXRoUGF0Y2hlcyh7XG4gIGVkaXRvckFjdG9yLFxuICBwYXRjaEZ1bmN0aW9ucyxcbiAgc2NoZW1hVHlwZXMsXG4gIHN1YnNjcmlwdGlvbnNcbn0pIHtcbiAgbGV0IHByZXZpb3VzQ2hpbGRyZW47XG4gIGNvbnN0IGFwcGx5UGF0Y2ggPSBjcmVhdGVBcHBseVBhdGNoKHNjaGVtYVR5cGVzKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIElTX1BST0NFU1NJTkdfUkVNT1RFX0NIQU5HRVMuc2V0KGVkaXRvciwgITEpLCBQQVRDSElORy5zZXQoZWRpdG9yLCAhMCksIHByZXZpb3VzQ2hpbGRyZW4gPSBbLi4uZWRpdG9yLmNoaWxkcmVuXTtcbiAgICBjb25zdCB7XG4gICAgICBhcHBseTogYXBwbHkyXG4gICAgfSA9IGVkaXRvcjtcbiAgICBsZXQgYnVmZmVyZWRQYXRjaGVzID0gW107XG4gICAgY29uc3QgaGFuZGxlQnVmZmVyZWRSZW1vdGVQYXRjaGVzID0gKCkgPT4ge1xuICAgICAgaWYgKGJ1ZmZlcmVkUGF0Y2hlcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHBhdGNoZXMgPSBidWZmZXJlZFBhdGNoZXM7XG4gICAgICBidWZmZXJlZFBhdGNoZXMgPSBbXTtcbiAgICAgIGxldCBjaGFuZ2VkID0gITE7XG4gICAgICB3aXRoUmVtb3RlQ2hhbmdlcyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICB3aXRob3V0UGF0Y2hpbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICB3aXRob3V0U2F2aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICBwYXRjaGVzLmZvckVhY2goKHBhdGNoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWckNi5lbmFibGVkICYmIGRlYnVnJDYoYEhhbmRsaW5nIHJlbW90ZSBwYXRjaCAke0pTT04uc3RyaW5naWZ5KHBhdGNoKX1gKSwgY2hhbmdlZCA9IGFwcGx5UGF0Y2goZWRpdG9yLCBwYXRjaCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLCBjaGFuZ2VkICYmIChlZGl0b3Iubm9ybWFsaXplKCksIGVkaXRvci5vbkNoYW5nZSgpKTtcbiAgICAgIH0pO1xuICAgIH0sIGhhbmRsZVBhdGNoZXMgPSAoe1xuICAgICAgcGF0Y2hlc1xuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHJlbW90ZVBhdGNoZXMgPSBwYXRjaGVzLmZpbHRlcigocCkgPT4gcC5vcmlnaW4gIT09IFwibG9jYWxcIik7XG4gICAgICByZW1vdGVQYXRjaGVzLmxlbmd0aCAhPT0gMCAmJiAoYnVmZmVyZWRQYXRjaGVzID0gYnVmZmVyZWRQYXRjaGVzLmNvbmNhdChyZW1vdGVQYXRjaGVzKSwgaGFuZGxlQnVmZmVyZWRSZW1vdGVQYXRjaGVzKCkpO1xuICAgIH07XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbnMucHVzaCgoKSA9PiB7XG4gICAgICBkZWJ1ZyQ2KFwiU3Vic2NyaWJpbmcgdG8gcmVtb3RlIHBhdGNoZXNcIik7XG4gICAgICBjb25zdCBzdWIgPSBlZGl0b3JBY3Rvci5vbihcInBhdGNoZXNcIiwgaGFuZGxlUGF0Y2hlcyk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkZWJ1ZyQ2KFwiVW5zdWJzY3JpYmluZyB0byByZW1vdGUgcGF0Y2hlc1wiKSwgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9O1xuICAgIH0pLCBlZGl0b3IuYXBwbHkgPSAob3BlcmF0aW9uKSA9PiB7XG4gICAgICBsZXQgcGF0Y2hlcyA9IFtdO1xuICAgICAgcHJldmlvdXNDaGlsZHJlbiA9IGVkaXRvci5jaGlsZHJlbjtcbiAgICAgIGNvbnN0IGVkaXRvcldhc0VtcHR5ID0gaXNFcXVhbFRvRW1wdHlFZGl0b3IocHJldmlvdXNDaGlsZHJlbiwgc2NoZW1hVHlwZXMpO1xuICAgICAgYXBwbHkyKG9wZXJhdGlvbik7XG4gICAgICBjb25zdCBlZGl0b3JJc0VtcHR5ID0gaXNFcXVhbFRvRW1wdHlFZGl0b3IoZWRpdG9yLmNoaWxkcmVuLCBzY2hlbWFUeXBlcyk7XG4gICAgICBpZiAoIWlzUGF0Y2hpbmcoZWRpdG9yKSlcbiAgICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICAgIHN3aXRjaCAoZWRpdG9yV2FzRW1wdHkgJiYgIWVkaXRvcklzRW1wdHkgJiYgb3BlcmF0aW9uLnR5cGUgIT09IFwic2V0X3NlbGVjdGlvblwiICYmIHBhdGNoZXMucHVzaChpbnNlcnQocHJldmlvdXNDaGlsZHJlbiwgXCJiZWZvcmVcIiwgWzBdKSksIG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJpbnNlcnRfdGV4dFwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4ucGF0Y2hGdW5jdGlvbnMuaW5zZXJ0VGV4dFBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZW1vdmVfdGV4dFwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4ucGF0Y2hGdW5jdGlvbnMucmVtb3ZlVGV4dFBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZW1vdmVfbm9kZVwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4ucGF0Y2hGdW5jdGlvbnMucmVtb3ZlTm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzcGxpdF9ub2RlXCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5wYXRjaEZ1bmN0aW9ucy5zcGxpdE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgcHJldmlvdXNDaGlsZHJlbildO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW5zZXJ0X25vZGVcIjpcbiAgICAgICAgICBwYXRjaGVzID0gWy4uLnBhdGNoZXMsIC4uLnBhdGNoRnVuY3Rpb25zLmluc2VydE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgcHJldmlvdXNDaGlsZHJlbildO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2V0X25vZGVcIjpcbiAgICAgICAgICBwYXRjaGVzID0gWy4uLnBhdGNoZXMsIC4uLnBhdGNoRnVuY3Rpb25zLnNldE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgcHJldmlvdXNDaGlsZHJlbildO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWVyZ2Vfbm9kZVwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4ucGF0Y2hGdW5jdGlvbnMubWVyZ2VOb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIHByZXZpb3VzQ2hpbGRyZW4pXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1vdmVfbm9kZVwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4ucGF0Y2hGdW5jdGlvbnMubW92ZU5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgcHJldmlvdXNDaGlsZHJlbildO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKCFlZGl0b3JXYXNFbXB0eSAmJiBlZGl0b3JJc0VtcHR5ICYmIFtcIm1lcmdlX25vZGVcIiwgXCJzZXRfbm9kZVwiLCBcInJlbW92ZV90ZXh0XCIsIFwicmVtb3ZlX25vZGVcIl0uaW5jbHVkZXMob3BlcmF0aW9uLnR5cGUpICYmIChwYXRjaGVzID0gWy4uLnBhdGNoZXMsIHVuc2V0KFtdKV0sIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcIm5vdGlmeS51bnNldFwiLFxuICAgICAgICBwcmV2aW91c1ZhbHVlOiBmcm9tU2xhdGVWYWx1ZShwcmV2aW91c0NoaWxkcmVuLCBzY2hlbWFUeXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSlcbiAgICAgIH0pKSwgZWRpdG9yV2FzRW1wdHkgJiYgcGF0Y2hlcy5sZW5ndGggPiAwICYmIChwYXRjaGVzID0gW3NldElmTWlzc2luZyhbXSwgW10pLCAuLi5wYXRjaGVzXSksIHBhdGNoZXMubGVuZ3RoID4gMClcbiAgICAgICAgZm9yIChjb25zdCBwYXRjaCBvZiBwYXRjaGVzKVxuICAgICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJpbnRlcm5hbC5wYXRjaFwiLFxuICAgICAgICAgICAgcGF0Y2g6IHtcbiAgICAgICAgICAgICAgLi4ucGF0Y2gsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJsb2NhbFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWN0aW9uSWQ6IGdldEN1cnJlbnRBY3Rpb25JZChlZGl0b3IpLFxuICAgICAgICAgICAgdmFsdWU6IGZyb21TbGF0ZVZhbHVlKGVkaXRvci5jaGlsZHJlbiwgc2NoZW1hVHlwZXMuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpXG4gICAgICAgICAgfSk7XG4gICAgICByZXR1cm4gZWRpdG9yO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IGRlYnVnJDUgPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhQbGFjZWhvbGRlckJsb2NrXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFBsYWNlaG9sZGVyQmxvY2soZWRpdG9yQWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGFwcGx5OiBhcHBseTJcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3IuYXBwbHkgPSAob3ApID0+IHtcbiAgICAgIGlmIChlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLm1hdGNoZXMoe1xuICAgICAgICBcImVkaXQgbW9kZVwiOiBcInJlYWQgb25seVwiXG4gICAgICB9KSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNDaGFuZ2luZ1JlbW90ZWx5KGVkaXRvcikpIHtcbiAgICAgICAgYXBwbHkyKG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzVW5kb2luZyhlZGl0b3IpIHx8IGlzUmVkb2luZyhlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvcC50eXBlID09PSBcInJlbW92ZV9ub2RlXCIpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG9wLm5vZGU7XG4gICAgICAgIGlmIChvcC5wYXRoWzBdID09PSAwICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgICAgIGNvbnN0IG5leHRQYXRoID0gUGF0aC5uZXh0KG9wLnBhdGgpO1xuICAgICAgICAgIGVkaXRvci5jaGlsZHJlbltuZXh0UGF0aFswXV0gfHwgKGRlYnVnJDUoXCJBZGRpbmcgcGxhY2Vob2xkZXIgYmxvY2tcIiksIEVkaXRvci5pbnNlcnROb2RlKGVkaXRvciwgZWRpdG9yLnB0ZUNyZWF0ZVRleHRCbG9jayh7XG4gICAgICAgICAgICBkZWNvcmF0b3JzOiBbXVxuICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFwcGx5MihvcCk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3QgZGVidWckNCA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFBvcnRhYmxlVGV4dEJsb2NrU3R5bGVcIik7XG5mdW5jdGlvbiBjcmVhdGVXaXRoUG9ydGFibGVUZXh0QmxvY2tTdHlsZShlZGl0b3JBY3RvciwgdHlwZXMpIHtcbiAgY29uc3QgZGVmYXVsdFN0eWxlID0gdHlwZXMuc3R5bGVzWzBdLnZhbHVlO1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgbm9ybWFsaXplTm9kZVxuICAgIH0gPSBlZGl0b3I7XG4gICAgcmV0dXJuIGVkaXRvci5ub3JtYWxpemVOb2RlID0gKG5vZGVFbnRyeSkgPT4ge1xuICAgICAgY29uc3QgWywgcGF0aF0gPSBub2RlRW50cnk7XG4gICAgICBmb3IgKGNvbnN0IG9wIG9mIGVkaXRvci5vcGVyYXRpb25zKVxuICAgICAgICBpZiAob3AudHlwZSA9PT0gXCJzcGxpdF9ub2RlXCIgJiYgb3AucGF0aC5sZW5ndGggPT09IDEgJiYgZWRpdG9yLmlzVGV4dEJsb2NrKG9wLnByb3BlcnRpZXMpICYmIG9wLnByb3BlcnRpZXMuc3R5bGUgIT09IGRlZmF1bHRTdHlsZSAmJiBvcC5wYXRoWzBdID09PSBwYXRoWzBdICYmICFQYXRoLmVxdWFscyhwYXRoLCBvcC5wYXRoKSkge1xuICAgICAgICAgIGNvbnN0IFtjaGlsZF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIFtvcC5wYXRoWzBdICsgMSwgMF0pO1xuICAgICAgICAgIGlmIChUZXh0LmlzVGV4dChjaGlsZCkgJiYgY2hpbGQudGV4dCA9PT0gXCJcIikge1xuICAgICAgICAgICAgZGVidWckNChgTm9ybWFsaXppbmcgc3BsaXQgbm9kZSB0byAke2RlZmF1bHRTdHlsZX0gc3R5bGVgLCBvcCksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBzdHlsZTogZGVmYXVsdFN0eWxlXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGF0OiBbb3AucGF0aFswXSArIDFdLFxuICAgICAgICAgICAgICB2b2lkczogITFcbiAgICAgICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgbm9ybWFsaXplTm9kZShub2RlRW50cnkpO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFBvcnRhYmxlVGV4dFNlbGVjdGlvbnNcIik7XG5mdW5jdGlvbiBjcmVhdGVXaXRoUG9ydGFibGVUZXh0U2VsZWN0aW9ucyhlZGl0b3JBY3RvciwgdHlwZXMpIHtcbiAgbGV0IHByZXZTZWxlY3Rpb24gPSBudWxsO1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgY29uc3QgZW1pdFBvcnRhYmxlVGV4dFNlbGVjdGlvbiA9ICgpID0+IHtcbiAgICAgIGlmIChwcmV2U2VsZWN0aW9uICE9PSBlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBwdFJhbmdlID0gbnVsbDtcbiAgICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICBjb25zdCBleGlzdGluZyA9IFNMQVRFX1RPX1BPUlRBQkxFX1RFWFRfUkFOR0UuZ2V0KGVkaXRvci5zZWxlY3Rpb24pO1xuICAgICAgICAgIGlmIChleGlzdGluZylcbiAgICAgICAgICAgIHB0UmFuZ2UgPSBleGlzdGluZztcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZWRpdG9yLmNoaWxkcmVuO1xuICAgICAgICAgICAgcHRSYW5nZSA9IHRvUG9ydGFibGVUZXh0UmFuZ2UodmFsdWUsIGVkaXRvci5zZWxlY3Rpb24sIHR5cGVzKSwgU0xBVEVfVE9fUE9SVEFCTEVfVEVYVF9SQU5HRS5zZXQoZWRpdG9yLnNlbGVjdGlvbiwgcHRSYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB0UmFuZ2UgPyBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcIm5vdGlmeS5zZWxlY3Rpb25cIixcbiAgICAgICAgICBzZWxlY3Rpb246IHB0UmFuZ2VcbiAgICAgICAgfSkgOiBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcIm5vdGlmeS5zZWxlY3Rpb25cIixcbiAgICAgICAgICBzZWxlY3Rpb246IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBwcmV2U2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICB9LCB7XG4gICAgICBvbkNoYW5nZVxuICAgIH0gPSBlZGl0b3I7XG4gICAgcmV0dXJuIGVkaXRvci5vbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgIG9uQ2hhbmdlKCksIGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkubWF0Y2hlcyh7XG4gICAgICAgIHNldHVwOiBcInNldHRpbmcgdXBcIlxuICAgICAgfSkgfHwgZW1pdFBvcnRhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IGRlYnVnJDMgPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhTY2hlbWFUeXBlc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhTY2hlbWFUeXBlcyh7XG4gIGVkaXRvckFjdG9yLFxuICBzY2hlbWFUeXBlc1xufSkge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgZWRpdG9yLmlzVGV4dEJsb2NrID0gKHZhbHVlKSA9PiBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayh2YWx1ZSkgJiYgdmFsdWUuX3R5cGUgPT09IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUsIGVkaXRvci5pc1RleHRTcGFuID0gKHZhbHVlKSA9PiBpc1BvcnRhYmxlVGV4dFNwYW4kMSh2YWx1ZSkgJiYgdmFsdWUuX3R5cGUgPT09IHNjaGVtYVR5cGVzLnNwYW4ubmFtZSwgZWRpdG9yLmlzTGlzdEJsb2NrID0gKHZhbHVlKSA9PiBpc1BvcnRhYmxlVGV4dExpc3RCbG9jayh2YWx1ZSkgJiYgdmFsdWUuX3R5cGUgPT09IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUsIGVkaXRvci5pc1ZvaWQgPSAoZWxlbWVudCkgPT4gc2NoZW1hVHlwZXMuYmxvY2submFtZSAhPT0gZWxlbWVudC5fdHlwZSAmJiAoc2NoZW1hVHlwZXMuYmxvY2tPYmplY3RzLm1hcCgob2JqKSA9PiBvYmoubmFtZSkuaW5jbHVkZXMoZWxlbWVudC5fdHlwZSkgfHwgc2NoZW1hVHlwZXMuaW5saW5lT2JqZWN0cy5tYXAoKG9iaikgPT4gb2JqLm5hbWUpLmluY2x1ZGVzKGVsZW1lbnQuX3R5cGUpKSwgZWRpdG9yLmlzSW5saW5lID0gKGVsZW1lbnQpID0+IHNjaGVtYVR5cGVzLmlubGluZU9iamVjdHMubWFwKChvYmopID0+IG9iai5uYW1lKS5pbmNsdWRlcyhlbGVtZW50Ll90eXBlKSAmJiBcIl9faW5saW5lXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50Ll9faW5saW5lID09PSAhMDtcbiAgICBjb25zdCB7XG4gICAgICBub3JtYWxpemVOb2RlXG4gICAgfSA9IGVkaXRvcjtcbiAgICByZXR1cm4gZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSAoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuICAgICAgaWYgKG5vZGUuX3R5cGUgPT09IHZvaWQgMCAmJiBwYXRoLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBkZWJ1ZyQzKFwiU2V0dGluZyBzcGFuIHR5cGUgb24gdGV4dCBub2RlIHdpdGhvdXQgYSB0eXBlXCIpO1xuICAgICAgICBjb25zdCBzcGFuID0gbm9kZSwga2V5ID0gc3Bhbi5fa2V5IHx8IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKTtcbiAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIC4uLnNwYW4sXG4gICAgICAgICAgX3R5cGU6IHNjaGVtYVR5cGVzLnNwYW4ubmFtZSxcbiAgICAgICAgICBfa2V5OiBrZXlcbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuX2tleSA9PT0gdm9pZCAwICYmIChwYXRoLmxlbmd0aCA9PT0gMSB8fCBwYXRoLmxlbmd0aCA9PT0gMikpIHtcbiAgICAgICAgZGVidWckMyhcIlNldHRpbmcgbWlzc2luZyBrZXkgb24gY2hpbGQgbm9kZSB3aXRob3V0IGEga2V5XCIpO1xuICAgICAgICBjb25zdCBrZXkgPSBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCk7XG4gICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBfa2V5OiBrZXlcbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9ybWFsaXplTm9kZShlbnRyeSk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlV2l0aFV0aWxzKHtcbiAgZWRpdG9yQWN0b3IsXG4gIHNjaGVtYVR5cGVzXG59KSB7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLnB0ZUNyZWF0ZVRleHRCbG9jayA9IChvcHRpb25zKSA9PiB0b1NsYXRlVmFsdWUoW3tcbiAgICAgIF90eXBlOiBzY2hlbWFUeXBlcy5ibG9jay5uYW1lLFxuICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgc3R5bGU6IHNjaGVtYVR5cGVzLnN0eWxlc1swXS52YWx1ZSB8fCBcIm5vcm1hbFwiLFxuICAgICAgLi4ub3B0aW9ucy5saXN0SXRlbSA/IHtcbiAgICAgICAgbGlzdEl0ZW06IG9wdGlvbnMubGlzdEl0ZW1cbiAgICAgIH0gOiB7fSxcbiAgICAgIC4uLm9wdGlvbnMubGV2ZWwgPyB7XG4gICAgICAgIGxldmVsOiBvcHRpb25zLmxldmVsXG4gICAgICB9IDoge30sXG4gICAgICBtYXJrRGVmczogW10sXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgX3R5cGU6IFwic3BhblwiLFxuICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgIG1hcmtzOiBvcHRpb25zLmRlY29yYXRvcnMuZmlsdGVyKChkZWNvcmF0b3IpID0+IHNjaGVtYVR5cGVzLmRlY29yYXRvcnMuZmluZCgoe1xuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pID0+IHZhbHVlID09PSBkZWNvcmF0b3IpKVxuICAgICAgfV1cbiAgICB9XSwge1xuICAgICAgc2NoZW1hVHlwZXNcbiAgICB9KVswXSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3Qgd2l0aFBsdWdpbnMgPSAoZWRpdG9yLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGUgPSBlZGl0b3IsIHtcbiAgICBlZGl0b3JBY3RvclxuICB9ID0gb3B0aW9ucywgc2NoZW1hVHlwZXMgPSBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLCBvcGVyYXRpb25Ub1BhdGNoZXMgPSBjcmVhdGVPcGVyYXRpb25Ub1BhdGNoZXMoc2NoZW1hVHlwZXMpLCB3aXRoT2JqZWN0S2V5cyA9IGNyZWF0ZVdpdGhPYmplY3RLZXlzKGVkaXRvckFjdG9yLCBzY2hlbWFUeXBlcyksIHdpdGhTY2hlbWFUeXBlcyA9IGNyZWF0ZVdpdGhTY2hlbWFUeXBlcyh7XG4gICAgZWRpdG9yQWN0b3IsXG4gICAgc2NoZW1hVHlwZXNcbiAgfSksIHdpdGhQYXRjaGVzID0gY3JlYXRlV2l0aFBhdGNoZXMoe1xuICAgIGVkaXRvckFjdG9yLFxuICAgIHBhdGNoRnVuY3Rpb25zOiBvcGVyYXRpb25Ub1BhdGNoZXMsXG4gICAgc2NoZW1hVHlwZXMsXG4gICAgc3Vic2NyaXB0aW9uczogb3B0aW9ucy5zdWJzY3JpcHRpb25zXG4gIH0pLCB3aXRoTWF4QmxvY2tzID0gY3JlYXRlV2l0aE1heEJsb2NrcyhlZGl0b3JBY3RvciksIHdpdGhVbmRvUmVkbyA9IGNyZWF0ZVdpdGhVbmRvUmVkbyh7XG4gICAgZWRpdG9yQWN0b3IsXG4gICAgYmxvY2tTY2hlbWFUeXBlOiBzY2hlbWFUeXBlcy5ibG9jayxcbiAgICBzdWJzY3JpcHRpb25zOiBvcHRpb25zLnN1YnNjcmlwdGlvbnNcbiAgfSksIHdpdGhQb3J0YWJsZVRleHRNYXJrTW9kZWwgPSBjcmVhdGVXaXRoUG9ydGFibGVUZXh0TWFya01vZGVsKGVkaXRvckFjdG9yLCBzY2hlbWFUeXBlcyksIHdpdGhQb3J0YWJsZVRleHRCbG9ja1N0eWxlID0gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dEJsb2NrU3R5bGUoZWRpdG9yQWN0b3IsIHNjaGVtYVR5cGVzKSwgd2l0aFBsYWNlaG9sZGVyQmxvY2sgPSBjcmVhdGVXaXRoUGxhY2Vob2xkZXJCbG9jayhlZGl0b3JBY3RvciksIHdpdGhVdGlscyA9IGNyZWF0ZVdpdGhVdGlscyh7XG4gICAgZWRpdG9yQWN0b3IsXG4gICAgc2NoZW1hVHlwZXNcbiAgfSksIHdpdGhQb3J0YWJsZVRleHRTZWxlY3Rpb25zID0gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dFNlbGVjdGlvbnMoZWRpdG9yQWN0b3IsIHNjaGVtYVR5cGVzKTtcbiAgcmV0dXJuIGNyZWF0ZVdpdGhFdmVudExpc3RlbmVycyhlZGl0b3JBY3Rvciwgb3B0aW9ucy5zdWJzY3JpcHRpb25zKSh3aXRoU2NoZW1hVHlwZXMod2l0aE9iamVjdEtleXMod2l0aFBvcnRhYmxlVGV4dE1hcmtNb2RlbCh3aXRoUG9ydGFibGVUZXh0QmxvY2tTdHlsZSh3aXRoUGxhY2Vob2xkZXJCbG9jayh3aXRoVXRpbHMod2l0aE1heEJsb2Nrcyh3aXRoVW5kb1JlZG8od2l0aFBhdGNoZXMod2l0aFBvcnRhYmxlVGV4dFNlbGVjdGlvbnMoZSkpKSkpKSkpKSkpO1xufSwgZGVidWckMiA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnQ6UG9ydGFibGVUZXh0RWRpdG9yOlNsYXRlQ29udGFpbmVyXCIpLCBzbGF0ZUVkaXRvcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGNyZWF0ZVNsYXRlRWRpdG9yKGNvbmZpZykge1xuICBjb25zdCBleGlzdGluZ1NsYXRlRWRpdG9yID0gc2xhdGVFZGl0b3JzLmdldChjb25maWcuZWRpdG9yQWN0b3IpO1xuICBpZiAoZXhpc3RpbmdTbGF0ZUVkaXRvcilcbiAgICByZXR1cm4gZGVidWckMihcIlJldXNpbmcgZXhpc3RpbmcgU2xhdGUgZWRpdG9yIGluc3RhbmNlXCIsIGNvbmZpZy5lZGl0b3JBY3Rvci5pZCksIGV4aXN0aW5nU2xhdGVFZGl0b3I7XG4gIGRlYnVnJDIoXCJDcmVhdGluZyBuZXcgU2xhdGUgZWRpdG9yIGluc3RhbmNlXCIsIGNvbmZpZy5lZGl0b3JBY3Rvci5pZCk7XG4gIGNvbnN0IHVuc3Vic2NyaXB0aW9ucyA9IFtdLCBzdWJzY3JpcHRpb25zID0gW10sIGluc3RhbmNlID0gd2l0aFBsdWdpbnMod2l0aFJlYWN0KGNyZWF0ZUVkaXRvciQxKCkpLCB7XG4gICAgZWRpdG9yQWN0b3I6IGNvbmZpZy5lZGl0b3JBY3RvcixcbiAgICBzdWJzY3JpcHRpb25zXG4gIH0pO1xuICBLRVlfVE9fVkFMVUVfRUxFTUVOVC5zZXQoaW5zdGFuY2UsIHt9KSwgS0VZX1RPX1NMQVRFX0VMRU1FTlQuc2V0KGluc3RhbmNlLCB7fSk7XG4gIGZvciAoY29uc3Qgc3Vic2NyaXB0aW9uIG9mIHN1YnNjcmlwdGlvbnMpXG4gICAgdW5zdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKCkpO1xuICBjb25zdCBpbml0aWFsVmFsdWUgPSBbaW5zdGFuY2UucHRlQ3JlYXRlVGV4dEJsb2NrKHtcbiAgICBkZWNvcmF0b3JzOiBbXVxuICB9KV0sIHNsYXRlRWRpdG9yID0ge1xuICAgIGluc3RhbmNlLFxuICAgIGluaXRpYWxWYWx1ZVxuICB9O1xuICByZXR1cm4gc2xhdGVFZGl0b3JzLnNldChjb25maWcuZWRpdG9yQWN0b3IsIHNsYXRlRWRpdG9yKSwgc2xhdGVFZGl0b3I7XG59XG5jb25zdCB0b2dnbGVBbm5vdGF0aW9uT2ZmID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJhbm5vdGF0aW9uLnRvZ2dsZVwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiBpc0FjdGl2ZUFubm90YXRpb24oZXZlbnQuYW5ub3RhdGlvbi5uYW1lKShzbmFwc2hvdCksXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJhbm5vdGF0aW9uLnJlbW92ZVwiLFxuICAgIGFubm90YXRpb246IGV2ZW50LmFubm90YXRpb25cbiAgfSldXVxufSksIHRvZ2dsZUFubm90YXRpb25PbiA9IGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiYW5ub3RhdGlvbi50b2dnbGVcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4gIWlzQWN0aXZlQW5ub3RhdGlvbihldmVudC5hbm5vdGF0aW9uLm5hbWUpKHNuYXBzaG90KSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImFubm90YXRpb24uYWRkXCIsXG4gICAgYW5ub3RhdGlvbjogZXZlbnQuYW5ub3RhdGlvblxuICB9KV1dXG59KSwgdG9nZ2xlRGVjb3JhdG9yT2ZmID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJkZWNvcmF0b3IudG9nZ2xlXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IGlzQWN0aXZlRGVjb3JhdG9yKGV2ZW50LmRlY29yYXRvcikoc25hcHNob3QpLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiZGVjb3JhdG9yLnJlbW92ZVwiLFxuICAgIGRlY29yYXRvcjogZXZlbnQuZGVjb3JhdG9yXG4gIH0pXV1cbn0pLCB0b2dnbGVEZWNvcmF0b3JPbiA9IGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiZGVjb3JhdG9yLnRvZ2dsZVwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiAhaXNBY3RpdmVEZWNvcmF0b3IoZXZlbnQuZGVjb3JhdG9yKShzbmFwc2hvdCksXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJkZWNvcmF0b3IuYWRkXCIsXG4gICAgZGVjb3JhdG9yOiBldmVudC5kZWNvcmF0b3JcbiAgfSldXVxufSksIHRvZ2dsZUxpc3RJdGVtT2ZmID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJsaXN0IGl0ZW0udG9nZ2xlXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IGlzQWN0aXZlTGlzdEl0ZW0oZXZlbnQubGlzdEl0ZW0pKHNuYXBzaG90KSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImxpc3QgaXRlbS5yZW1vdmVcIixcbiAgICBsaXN0SXRlbTogZXZlbnQubGlzdEl0ZW1cbiAgfSldXVxufSksIHRvZ2dsZUxpc3RJdGVtT24gPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImxpc3QgaXRlbS50b2dnbGVcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4gIWlzQWN0aXZlTGlzdEl0ZW0oZXZlbnQubGlzdEl0ZW0pKHNuYXBzaG90KSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImxpc3QgaXRlbS5hZGRcIixcbiAgICBsaXN0SXRlbTogZXZlbnQubGlzdEl0ZW1cbiAgfSldXVxufSksIHRvZ2dsZVN0eWxlT2ZmID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJzdHlsZS50b2dnbGVcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4gaXNBY3RpdmVTdHlsZShldmVudC5zdHlsZSkoc25hcHNob3QpLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwic3R5bGUucmVtb3ZlXCIsXG4gICAgc3R5bGU6IGV2ZW50LnN0eWxlXG4gIH0pXV1cbn0pLCB0b2dnbGVTdHlsZU9uID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJzdHlsZS50b2dnbGVcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4gIWlzQWN0aXZlU3R5bGUoZXZlbnQuc3R5bGUpKHNuYXBzaG90KSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcInN0eWxlLmFkZFwiLFxuICAgIHN0eWxlOiBldmVudC5zdHlsZVxuICB9KV1dXG59KSwgcmFpc2VEZXNlcmlhbGl6YXRpb25TdWNjZXNzT3JGYWlsdXJlID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJkZXNlcmlhbGl6ZVwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgY29uc3QgZGVzZXJpYWxpemVFdmVudHMgPSBzbmFwc2hvdC5jb250ZXh0LmNvbnZlcnRlcnMuZmxhdE1hcCgoY29udmVydGVyKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoY29udmVydGVyLm1pbWVUeXBlKTtcbiAgICAgIHJldHVybiBkYXRhID8gW2NvbnZlcnRlci5kZXNlcmlhbGl6ZSh7XG4gICAgICAgIHNuYXBzaG90LFxuICAgICAgICBldmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiZGVzZXJpYWxpemVcIixcbiAgICAgICAgICBkYXRhXG4gICAgICAgIH1cbiAgICAgIH0pXSA6IFtdO1xuICAgIH0pO1xuICAgIHJldHVybiBkZXNlcmlhbGl6ZUV2ZW50cy5maW5kKChkZXNlcmlhbGl6ZUV2ZW50KSA9PiBkZXNlcmlhbGl6ZUV2ZW50LnR5cGUgPT09IFwiZGVzZXJpYWxpemF0aW9uLnN1Y2Nlc3NcIikgfHwge1xuICAgICAgdHlwZTogXCJkZXNlcmlhbGl6YXRpb24uZmFpbHVyZVwiLFxuICAgICAgbWltZVR5cGU6IFwiKi8qXCIsXG4gICAgICByZWFzb246IGRlc2VyaWFsaXplRXZlbnRzLm1hcCgoZGVzZXJpYWxpemVFdmVudCkgPT4gZGVzZXJpYWxpemVFdmVudC50eXBlID09PSBcImRlc2VyaWFsaXphdGlvbi5mYWlsdXJlXCIgPyBkZXNlcmlhbGl6ZUV2ZW50LnJlYXNvbiA6IFwiXCIpLmpvaW4oXCIsIFwiKVxuICAgIH07XG4gIH0sXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0sIGRlc2VyaWFsaXplRXZlbnQpID0+IFtyYWlzZSh7XG4gICAgLi4uZGVzZXJpYWxpemVFdmVudCxcbiAgICBkYXRhVHJhbnNmZXI6IGV2ZW50LmRhdGFUcmFuc2ZlclxuICB9KV1dXG59KSwgcmFpc2VJbnNlcnRCbG9ja3MgPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImRlc2VyaWFsaXphdGlvbi5zdWNjZXNzXCIsXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJpbnNlcnQuYmxvY2tzXCIsXG4gICAgYmxvY2tzOiBldmVudC5kYXRhXG4gIH0pXV1cbn0pLCByYWlzZVNlcmlhbGl6YXRpb25TdWNjZXNzT3JGYWlsdXJlID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJzZXJpYWxpemVcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGlmIChzbmFwc2hvdC5jb250ZXh0LmNvbnZlcnRlcnMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHNlcmlhbGl6ZUV2ZW50cyA9IHNuYXBzaG90LmNvbnRleHQuY29udmVydGVycy5tYXAoKGNvbnZlcnRlcikgPT4gY29udmVydGVyLnNlcmlhbGl6ZSh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkpO1xuICAgIHJldHVybiBzZXJpYWxpemVFdmVudHMubGVuZ3RoID09PSAwID8gITEgOiBzZXJpYWxpemVFdmVudHM7XG4gIH0sXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0sIHNlcmlhbGl6ZUV2ZW50cykgPT4gc2VyaWFsaXplRXZlbnRzLm1hcCgoc2VyaWFsaXplRXZlbnQpID0+IHJhaXNlKHtcbiAgICAuLi5zZXJpYWxpemVFdmVudCxcbiAgICBkYXRhVHJhbnNmZXI6IGV2ZW50LmRhdGFUcmFuc2ZlclxuICB9KSldXG59KSwgcmFpc2VEYXRhVHJhbnNmZXJTZXQgPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcInNlcmlhbGl6YXRpb24uc3VjY2Vzc1wiLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiZGF0YSB0cmFuc2Zlci5zZXRcIixcbiAgICBkYXRhOiBldmVudC5kYXRhLFxuICAgIGRhdGFUcmFuc2ZlcjogZXZlbnQuZGF0YVRyYW5zZmVyLFxuICAgIG1pbWVUeXBlOiBldmVudC5taW1lVHlwZVxuICB9KV1dXG59KSwgZGVmYXVsdEJlaGF2aW9ycyA9IFt0b2dnbGVBbm5vdGF0aW9uT2ZmLCB0b2dnbGVBbm5vdGF0aW9uT24sIHRvZ2dsZURlY29yYXRvck9mZiwgdG9nZ2xlRGVjb3JhdG9yT24sIHRvZ2dsZUxpc3RJdGVtT2ZmLCB0b2dnbGVMaXN0SXRlbU9uLCB0b2dnbGVTdHlsZU9mZiwgdG9nZ2xlU3R5bGVPbiwgcmFpc2VEZXNlcmlhbGl6YXRpb25TdWNjZXNzT3JGYWlsdXJlLCByYWlzZUluc2VydEJsb2NrcywgcmFpc2VTZXJpYWxpemF0aW9uU3VjY2Vzc09yRmFpbHVyZSwgcmFpc2VEYXRhVHJhbnNmZXJTZXRdLCBrZXlJcyA9IHtcbiAgbGluZUJyZWFrOiAoZXZlbnQpID0+IGV2ZW50LmtleSA9PT0gXCJFbnRlclwiICYmIGV2ZW50LnNoaWZ0S2V5XG59LCByYWlzZVNvZnRCcmVhayA9IGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwia2V5LmRvd25cIixcbiAgZ3VhcmQ6ICh7XG4gICAgZXZlbnRcbiAgfSkgPT4ga2V5SXMubGluZUJyZWFrKGV2ZW50LmtleWJvYXJkRXZlbnQpLFxuICBhY3Rpb25zOiBbKCkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImluc2VydC5zb2Z0IGJyZWFrXCJcbiAgfSldXVxufSksIGZvdW5kYXRpb25hbEJlaGF2aW9ycyA9IFtyYWlzZVNvZnRCcmVha107XG5mdW5jdGlvbiBnZXRBY3RpdmVEZWNvcmF0b3JzKHtcbiAgc2NoZW1hLFxuICBzbGF0ZUVkaXRvckluc3RhbmNlXG59KSB7XG4gIGNvbnN0IGRlY29yYXRvcnMgPSBzY2hlbWEuZGVjb3JhdG9ycy5tYXAoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLnZhbHVlKTtcbiAgcmV0dXJuICh7XG4gICAgLi4uRWRpdG9yLm1hcmtzKHNsYXRlRWRpdG9ySW5zdGFuY2UpID8/IHt9XG4gIH0ubWFya3MgPz8gW10pLmZpbHRlcigobWFyaykgPT4gZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFZGl0b3JTbmFwc2hvdCh7XG4gIGNvbnZlcnRlcnMsXG4gIGVkaXRvcixcbiAga2V5R2VuZXJhdG9yLFxuICBzY2hlbWEsXG4gIGhhc1RhZ1xufSkge1xuICBjb25zdCB2YWx1ZSA9IGZyb21TbGF0ZVZhbHVlKGVkaXRvci5jaGlsZHJlbiwgc2NoZW1hLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKSwgc2VsZWN0aW9uID0gdG9Qb3J0YWJsZVRleHRSYW5nZSh2YWx1ZSwgZWRpdG9yLnNlbGVjdGlvbiwgc2NoZW1hKTtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0OiB7XG4gICAgICBhY3RpdmVEZWNvcmF0b3JzOiBnZXRBY3RpdmVEZWNvcmF0b3JzKHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBzbGF0ZUVkaXRvckluc3RhbmNlOiBlZGl0b3JcbiAgICAgIH0pLFxuICAgICAgY29udmVydGVycyxcbiAgICAgIGtleUdlbmVyYXRvcixcbiAgICAgIHNjaGVtYSxcbiAgICAgIHNlbGVjdGlvbixcbiAgICAgIHZhbHVlXG4gICAgfSxcbiAgICBiZXRhOiB7XG4gICAgICBoYXNUYWdcbiAgICB9XG4gIH07XG59XG5jb25zdCBlZGl0b3JNYWNoaW5lID0gc2V0dXAoe1xuICB0eXBlczoge1xuICAgIGNvbnRleHQ6IHt9LFxuICAgIGV2ZW50czoge30sXG4gICAgZW1pdHRlZDoge30sXG4gICAgaW5wdXQ6IHt9LFxuICAgIHRhZ3M6IHt9XG4gIH0sXG4gIGFjdGlvbnM6IHtcbiAgICBcImFkZCBiZWhhdmlvciB0byBjb250ZXh0XCI6IGFzc2lnbih7XG4gICAgICBiZWhhdmlvcnM6ICh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwiYWRkIGJlaGF2aW9yXCIpLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4uY29udGV4dC5iZWhhdmlvcnMsIGV2ZW50LmJlaGF2aW9yXSkpXG4gICAgfSksXG4gICAgXCJyZW1vdmUgYmVoYXZpb3IgZnJvbSBjb250ZXh0XCI6IGFzc2lnbih7XG4gICAgICBiZWhhdmlvcnM6ICh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwicmVtb3ZlIGJlaGF2aW9yXCIpLCBjb250ZXh0LmJlaGF2aW9ycy5kZWxldGUoZXZlbnQuYmVoYXZpb3IpLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4uY29udGV4dC5iZWhhdmlvcnNdKSlcbiAgICB9KSxcbiAgICBcImFzc2lnbiBiZWhhdmlvcnNcIjogYXNzaWduKHtcbiAgICAgIGJlaGF2aW9yczogKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJ1cGRhdGUgYmVoYXZpb3JzXCIpLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4uZXZlbnQuYmVoYXZpb3JzXSkpXG4gICAgfSksXG4gICAgXCJhc3NpZ24gc2NoZW1hXCI6IGFzc2lnbih7XG4gICAgICBzY2hlbWE6ICh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwidXBkYXRlIHNjaGVtYVwiKSwgZXZlbnQuc2NoZW1hKVxuICAgIH0pLFxuICAgIFwiZW1pdCBwYXRjaCBldmVudFwiOiBlbnF1ZXVlQWN0aW9ucygoe1xuICAgICAgZXZlbnQsXG4gICAgICBlbnF1ZXVlXG4gICAgfSkgPT4ge1xuICAgICAgYXNzZXJ0RXZlbnQoZXZlbnQsIFwiaW50ZXJuYWwucGF0Y2hcIiksIGVucXVldWUuZW1pdChldmVudCksIGVucXVldWUuZW1pdCh7XG4gICAgICAgIHR5cGU6IFwicGF0Y2hcIixcbiAgICAgICAgcGF0Y2g6IGV2ZW50LnBhdGNoXG4gICAgICB9KTtcbiAgICB9KSxcbiAgICBcImVtaXQgbXV0YXRpb24gZXZlbnRcIjogZW1pdCgoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwibXV0YXRpb25cIiksIGV2ZW50KSksXG4gICAgXCJlbWl0IHJlYWQgb25seVwiOiBlbWl0KHtcbiAgICAgIHR5cGU6IFwicmVhZCBvbmx5XCJcbiAgICB9KSxcbiAgICBcImVtaXQgZWRpdGFibGVcIjogZW1pdCh7XG4gICAgICB0eXBlOiBcImVkaXRhYmxlXCJcbiAgICB9KSxcbiAgICBcImRlZmVyIGV2ZW50XCI6IGFzc2lnbih7XG4gICAgICBwZW5kaW5nRXZlbnRzOiAoe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBbXCJpbnRlcm5hbC5wYXRjaFwiLCBcIm11dGF0aW9uXCJdKSwgWy4uLmNvbnRleHQucGVuZGluZ0V2ZW50cywgZXZlbnRdKVxuICAgIH0pLFxuICAgIFwiZW1pdCBwZW5kaW5nIGV2ZW50c1wiOiBlbnF1ZXVlQWN0aW9ucygoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGVucXVldWVcbiAgICB9KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGNvbnRleHQucGVuZGluZ0V2ZW50cylcbiAgICAgICAgZXZlbnQudHlwZSA9PT0gXCJpbnRlcm5hbC5wYXRjaFwiID8gKGVucXVldWUuZW1pdChldmVudCksIGVucXVldWUuZW1pdCh7XG4gICAgICAgICAgdHlwZTogXCJwYXRjaFwiLFxuICAgICAgICAgIHBhdGNoOiBldmVudC5wYXRjaFxuICAgICAgICB9KSkgOiBlbnF1ZXVlLmVtaXQoZXZlbnQpO1xuICAgIH0pLFxuICAgIFwiZW1pdCByZWFkeVwiOiBlbWl0KHtcbiAgICAgIHR5cGU6IFwicmVhZHlcIlxuICAgIH0pLFxuICAgIFwiY2xlYXIgcGVuZGluZyBldmVudHNcIjogYXNzaWduKHtcbiAgICAgIHBlbmRpbmdFdmVudHM6IFtdXG4gICAgfSksXG4gICAgXCJoYW5kbGUgYmVoYXZpb3IgZXZlbnRcIjogZW5xdWV1ZUFjdGlvbnMoKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBldmVudCxcbiAgICAgIGVucXVldWUsXG4gICAgICBzZWxmXG4gICAgfSkgPT4ge1xuICAgICAgYXNzZXJ0RXZlbnQoZXZlbnQsIFtcImJlaGF2aW9yIGV2ZW50XCIsIFwiY3VzdG9tIGJlaGF2aW9yIGV2ZW50XCJdKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRBY3Rpb24gPSBldmVudC50eXBlID09PSBcImN1c3RvbSBiZWhhdmlvciBldmVudFwiIHx8IGV2ZW50LmJlaGF2aW9yRXZlbnQudHlwZSA9PT0gXCJjb3B5XCIgfHwgZXZlbnQuYmVoYXZpb3JFdmVudC50eXBlID09PSBcImRlc2VyaWFsaXplXCIgfHwgZXZlbnQuYmVoYXZpb3JFdmVudC50eXBlID09PSBcImtleS5kb3duXCIgfHwgZXZlbnQuYmVoYXZpb3JFdmVudC50eXBlID09PSBcImtleS51cFwiIHx8IGV2ZW50LmJlaGF2aW9yRXZlbnQudHlwZSA9PT0gXCJwYXN0ZVwiIHx8IGV2ZW50LmJlaGF2aW9yRXZlbnQudHlwZSA9PT0gXCJzZXJpYWxpemVcIiA/IHZvaWQgMCA6IHtcbiAgICAgICAgLi4uZXZlbnQuYmVoYXZpb3JFdmVudCxcbiAgICAgICAgZWRpdG9yOiBldmVudC5lZGl0b3JcbiAgICAgIH0sIGRlZmF1bHRBY3Rpb25DYWxsYmFjayA9IGV2ZW50LnR5cGUgPT09IFwiYmVoYXZpb3IgZXZlbnRcIiA/IGV2ZW50LmRlZmF1bHRBY3Rpb25DYWxsYmFjayA6IHZvaWQgMCwgZXZlbnRCZWhhdmlvcnMgPSBbLi4uZm91bmRhdGlvbmFsQmVoYXZpb3JzLCAuLi5jb250ZXh0LmJlaGF2aW9ycy52YWx1ZXMoKSwgLi4uZGVmYXVsdEJlaGF2aW9yc10uZmlsdGVyKChiZWhhdmlvcikgPT4gYmVoYXZpb3Iub24gPT09IGV2ZW50LmJlaGF2aW9yRXZlbnQudHlwZSk7XG4gICAgICBpZiAoZXZlbnRCZWhhdmlvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChkZWZhdWx0QWN0aW9uQ2FsbGJhY2spIHtcbiAgICAgICAgICB3aXRoQXBwbHlpbmdCZWhhdmlvckFjdGlvbnMoZXZlbnQuZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBkZWZhdWx0QWN0aW9uQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobmV3IEVycm9yKGBQZXJmb3JtaW5nIGFjdGlvbiBcIiR7ZXZlbnQuYmVoYXZpb3JFdmVudC50eXBlfVwiIGZhaWxlZCBkdWUgdG86ICR7ZXJyb3IubWVzc2FnZX1gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVmYXVsdEFjdGlvbilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHdpdGhBcHBseWluZ0JlaGF2aW9yQWN0aW9ucyhldmVudC5lZGl0b3IsICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGVyZm9ybUFjdGlvbih7XG4gICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgIGFjdGlvbjogZGVmYXVsdEFjdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobmV3IEVycm9yKGBQZXJmb3JtaW5nIGFjdGlvbiBcIiR7ZGVmYXVsdEFjdGlvbi50eXBlfVwiIGFzIGEgcmVzdWx0IG9mIFwiJHtldmVudC5iZWhhdmlvckV2ZW50LnR5cGV9XCIgZmFpbGVkIGR1ZSB0bzogJHtlcnJvci5tZXNzYWdlfWApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBldmVudC5lZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZWRpdG9yU25hcHNob3QgPSBjcmVhdGVFZGl0b3JTbmFwc2hvdCh7XG4gICAgICAgIGNvbnZlcnRlcnM6IFsuLi5jb250ZXh0LmNvbnZlcnRlcnNdLFxuICAgICAgICBlZGl0b3I6IGV2ZW50LmVkaXRvcixcbiAgICAgICAga2V5R2VuZXJhdG9yOiBjb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYSxcbiAgICAgICAgaGFzVGFnOiAodGFnKSA9PiBzZWxmLmdldFNuYXBzaG90KCkuaGFzVGFnKHRhZylcbiAgICAgIH0pO1xuICAgICAgbGV0IGJlaGF2aW9yT3ZlcndyaXR0ZW4gPSAhMTtcbiAgICAgIGZvciAoY29uc3QgZXZlbnRCZWhhdmlvciBvZiBldmVudEJlaGF2aW9ycykge1xuICAgICAgICBjb25zdCBzaG91bGRSdW4gPSBldmVudEJlaGF2aW9yLmd1YXJkID09PSB2b2lkIDAgfHwgZXZlbnRCZWhhdmlvci5ndWFyZCh7XG4gICAgICAgICAgY29udGV4dDogZWRpdG9yU25hcHNob3QuY29udGV4dCxcbiAgICAgICAgICBzbmFwc2hvdDogZWRpdG9yU25hcHNob3QsXG4gICAgICAgICAgZXZlbnQ6IGV2ZW50LmJlaGF2aW9yRXZlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc2hvdWxkUnVuKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBhY3Rpb25JbnRlbmRTZXRzID0gZXZlbnRCZWhhdmlvci5hY3Rpb25zLm1hcCgoYWN0aW9uU2V0KSA9PiBhY3Rpb25TZXQoe1xuICAgICAgICAgIGNvbnRleHQ6IGVkaXRvclNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgICAgc25hcHNob3Q6IGVkaXRvclNuYXBzaG90LFxuICAgICAgICAgIGV2ZW50OiBldmVudC5iZWhhdmlvckV2ZW50XG4gICAgICAgIH0sIHNob3VsZFJ1bikpO1xuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbkludGVuZHMgb2YgYWN0aW9uSW50ZW5kU2V0cylcbiAgICAgICAgICBiZWhhdmlvck92ZXJ3cml0dGVuID0gYmVoYXZpb3JPdmVyd3JpdHRlbiB8fCBhY3Rpb25JbnRlbmRzLmxlbmd0aCA+IDAgJiYgYWN0aW9uSW50ZW5kcy5zb21lKChhY3Rpb25JbnRlbmQpID0+IGFjdGlvbkludGVuZC50eXBlICE9PSBcImVmZmVjdFwiKSwgd2l0aEFwcGx5aW5nQmVoYXZpb3JBY3Rpb25JbnRlbmRTZXQoZXZlbnQuZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbkludGVuZCBvZiBhY3Rpb25JbnRlbmRzKSB7XG4gICAgICAgICAgICAgIGlmIChhY3Rpb25JbnRlbmQudHlwZSA9PT0gXCJyYWlzZVwiKSB7XG4gICAgICAgICAgICAgICAgaXNDdXN0b21CZWhhdmlvckV2ZW50KGFjdGlvbkludGVuZC5ldmVudCkgPyBlbnF1ZXVlLnJhaXNlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY3VzdG9tIGJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgICAgICAgICAgICBiZWhhdmlvckV2ZW50OiBhY3Rpb25JbnRlbmQuZXZlbnQsXG4gICAgICAgICAgICAgICAgICBlZGl0b3I6IGV2ZW50LmVkaXRvclxuICAgICAgICAgICAgICAgIH0pIDogZW5xdWV1ZS5yYWlzZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgICAgICAgICAgICBiZWhhdmlvckV2ZW50OiBhY3Rpb25JbnRlbmQuZXZlbnQsXG4gICAgICAgICAgICAgICAgICBlZGl0b3I6IGV2ZW50LmVkaXRvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAuLi5hY3Rpb25JbnRlbmQsXG4gICAgICAgICAgICAgICAgZWRpdG9yOiBldmVudC5lZGl0b3JcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwZXJmb3JtQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICBhY3Rpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG5ldyBFcnJvcihgUGVyZm9ybWluZyBhY3Rpb24gXCIke2FjdGlvbi50eXBlfVwiIGFzIGEgcmVzdWx0IG9mIFwiJHtldmVudC5iZWhhdmlvckV2ZW50LnR5cGV9XCIgZmFpbGVkIGR1ZSB0bzogJHtlcnJvci5tZXNzYWdlfWApKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBldmVudC5lZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgaWYgKGJlaGF2aW9yT3ZlcndyaXR0ZW4pIHtcbiAgICAgICAgICBldmVudC5uYXRpdmVFdmVudD8ucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFiZWhhdmlvck92ZXJ3cml0dGVuKSB7XG4gICAgICAgIGlmIChkZWZhdWx0QWN0aW9uQ2FsbGJhY2spIHtcbiAgICAgICAgICB3aXRoQXBwbHlpbmdCZWhhdmlvckFjdGlvbnMoZXZlbnQuZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBkZWZhdWx0QWN0aW9uQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobmV3IEVycm9yKGBQZXJmb3JtaW5nIFwiJHtldmVudC5iZWhhdmlvckV2ZW50LnR5cGV9XCIgZmFpbGVkIGR1ZSB0bzogJHtlcnJvci5tZXNzYWdlfWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWZhdWx0QWN0aW9uKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgd2l0aEFwcGx5aW5nQmVoYXZpb3JBY3Rpb25zKGV2ZW50LmVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwZXJmb3JtQWN0aW9uKHtcbiAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgYWN0aW9uOiBkZWZhdWx0QWN0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihuZXcgRXJyb3IoYFBlcmZvcm1pbmcgYWN0aW9uIFwiJHtkZWZhdWx0QWN0aW9uLnR5cGV9XCIgYXMgYSByZXN1bHQgb2YgXCIke2V2ZW50LmJlaGF2aW9yRXZlbnQudHlwZX1cIiBmYWlsZWQgZHVlIHRvOiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksIGV2ZW50LmVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgfVxuICAgIH0pXG4gIH1cbn0pLmNyZWF0ZU1hY2hpbmUoe1xuICBpZDogXCJlZGl0b3JcIixcbiAgY29udGV4dDogKHtcbiAgICBpbnB1dFxuICB9KSA9PiAoe1xuICAgIGJlaGF2aW9yczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLmlucHV0LmJlaGF2aW9ycyA/PyBjb3JlQmVoYXZpb3JzXSksXG4gICAgY29udmVydGVyczogbmV3IFNldChpbnB1dC5jb252ZXJ0ZXJzID8/IFtdKSxcbiAgICBrZXlHZW5lcmF0b3I6IGlucHV0LmtleUdlbmVyYXRvcixcbiAgICBwZW5kaW5nRXZlbnRzOiBbXSxcbiAgICBzY2hlbWE6IGlucHV0LnNjaGVtYSxcbiAgICBzZWxlY3Rpb246IG51bGwsXG4gICAgaW5pdGlhbFJlYWRPbmx5OiBpbnB1dC5yZWFkT25seSA/PyAhMSxcbiAgICBtYXhCbG9ja3M6IGlucHV0Lm1heEJsb2NrcyxcbiAgICB2YWx1ZTogaW5wdXQudmFsdWVcbiAgfSksXG4gIG9uOiB7XG4gICAgXCJub3RpZnkuYmx1cnJlZFwiOiB7XG4gICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiAoe1xuICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgdHlwZTogXCJibHVycmVkXCJcbiAgICAgIH0pKVxuICAgIH0sXG4gICAgXCJub3RpZnkuZG9uZSBsb2FkaW5nXCI6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoe1xuICAgICAgICB0eXBlOiBcImRvbmUgbG9hZGluZ1wiXG4gICAgICB9KVxuICAgIH0sXG4gICAgXCJub3RpZnkuZXJyb3JcIjoge1xuICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gKHtcbiAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIlxuICAgICAgfSkpXG4gICAgfSxcbiAgICBcIm5vdGlmeS5pbnZhbGlkIHZhbHVlXCI6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+ICh7XG4gICAgICAgIC4uLmV2ZW50LFxuICAgICAgICB0eXBlOiBcImludmFsaWQgdmFsdWVcIlxuICAgICAgfSkpXG4gICAgfSxcbiAgICBcIm5vdGlmeS5mb2N1c2VkXCI6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+ICh7XG4gICAgICAgIC4uLmV2ZW50LFxuICAgICAgICB0eXBlOiBcImZvY3VzZWRcIlxuICAgICAgfSkpXG4gICAgfSxcbiAgICBcIm5vdGlmeS5zZWxlY3Rpb25cIjoge1xuICAgICAgYWN0aW9uczogW2Fzc2lnbih7XG4gICAgICAgIHNlbGVjdGlvbjogKHtcbiAgICAgICAgICBldmVudFxuICAgICAgICB9KSA9PiBldmVudC5zZWxlY3Rpb25cbiAgICAgIH0pLCBlbWl0KCh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiAoe1xuICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgdHlwZTogXCJzZWxlY3Rpb25cIlxuICAgICAgfSkpXVxuICAgIH0sXG4gICAgXCJub3RpZnkudW5zZXRcIjoge1xuICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gKHtcbiAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgIHR5cGU6IFwidW5zZXRcIlxuICAgICAgfSkpXG4gICAgfSxcbiAgICBcIm5vdGlmeS5sb2FkaW5nXCI6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoe1xuICAgICAgICB0eXBlOiBcImxvYWRpbmdcIlxuICAgICAgfSlcbiAgICB9LFxuICAgIFwibm90aWZ5LnZhbHVlIGNoYW5nZWRcIjoge1xuICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gKHtcbiAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgIHR5cGU6IFwidmFsdWUgY2hhbmdlZFwiXG4gICAgICB9KSlcbiAgICB9LFxuICAgIFwiYWRkIGJlaGF2aW9yXCI6IHtcbiAgICAgIGFjdGlvbnM6IFwiYWRkIGJlaGF2aW9yIHRvIGNvbnRleHRcIlxuICAgIH0sXG4gICAgXCJyZW1vdmUgYmVoYXZpb3JcIjoge1xuICAgICAgYWN0aW9uczogXCJyZW1vdmUgYmVoYXZpb3IgZnJvbSBjb250ZXh0XCJcbiAgICB9LFxuICAgIHBhdGNoZXM6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50KVxuICAgIH0sXG4gICAgXCJ1cGRhdGUgYmVoYXZpb3JzXCI6IHtcbiAgICAgIGFjdGlvbnM6IFwiYXNzaWduIGJlaGF2aW9yc1wiXG4gICAgfSxcbiAgICBcInVwZGF0ZSBrZXkgZ2VuZXJhdG9yXCI6IHtcbiAgICAgIGFjdGlvbnM6IGFzc2lnbih7XG4gICAgICAgIGtleUdlbmVyYXRvcjogKHtcbiAgICAgICAgICBldmVudFxuICAgICAgICB9KSA9PiBldmVudC5rZXlHZW5lcmF0b3JcbiAgICAgIH0pXG4gICAgfSxcbiAgICBcInVwZGF0ZSBzY2hlbWFcIjoge1xuICAgICAgYWN0aW9uczogXCJhc3NpZ24gc2NoZW1hXCJcbiAgICB9LFxuICAgIFwidXBkYXRlIHZhbHVlXCI6IHtcbiAgICAgIGFjdGlvbnM6IGFzc2lnbih7XG4gICAgICAgIHZhbHVlOiAoe1xuICAgICAgICAgIGV2ZW50XG4gICAgICAgIH0pID0+IGV2ZW50LnZhbHVlXG4gICAgICB9KVxuICAgIH0sXG4gICAgXCJ1cGRhdGUgbWF4QmxvY2tzXCI6IHtcbiAgICAgIGFjdGlvbnM6IGFzc2lnbih7XG4gICAgICAgIG1heEJsb2NrczogKHtcbiAgICAgICAgICBldmVudFxuICAgICAgICB9KSA9PiBldmVudC5tYXhCbG9ja3NcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuICB0eXBlOiBcInBhcmFsbGVsXCIsXG4gIHN0YXRlczoge1xuICAgIFwiZWRpdCBtb2RlXCI6IHtcbiAgICAgIGluaXRpYWw6IFwicmVhZCBvbmx5XCIsXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgXCJyZWFkIG9ubHlcIjoge1xuICAgICAgICAgIGluaXRpYWw6IFwiZGV0ZXJtaW5lIGluaXRpYWwgZWRpdCBtb2RlXCIsXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIFwiYmVoYXZpb3IgZXZlbnRcIjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBcImhhbmRsZSBiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgICAgICBndWFyZDogKHtcbiAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICB9KSA9PiBldmVudC5iZWhhdmlvckV2ZW50LnR5cGUgPT09IFwiY29weVwiIHx8IGV2ZW50LmJlaGF2aW9yRXZlbnQudHlwZSA9PT0gXCJkYXRhIHRyYW5zZmVyLnNldFwiIHx8IGV2ZW50LmJlaGF2aW9yRXZlbnQudHlwZSA9PT0gXCJzZXJpYWxpemVcIiB8fCBldmVudC5iZWhhdmlvckV2ZW50LnR5cGUgPT09IFwic2VyaWFsaXphdGlvbi5mYWlsdXJlXCIgfHwgZXZlbnQuYmVoYXZpb3JFdmVudC50eXBlID09PSBcInNlcmlhbGl6YXRpb24uc3VjY2Vzc1wiIHx8IGV2ZW50LmJlaGF2aW9yRXZlbnQudHlwZSA9PT0gXCJzZWxlY3RcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RhdGVzOiB7XG4gICAgICAgICAgICBcImRldGVybWluZSBpbml0aWFsIGVkaXQgbW9kZVwiOiB7XG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgXCJkb25lIHN5bmNpbmcgaW5pdGlhbCB2YWx1ZVwiOiBbe1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcIiNlZGl0b3IuZWRpdCBtb2RlLnJlYWQgb25seS5yZWFkIG9ubHlcIixcbiAgICAgICAgICAgICAgICAgIGd1YXJkOiAoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgICAgICB9KSA9PiBjb250ZXh0LmluaXRpYWxSZWFkT25seVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCIjZWRpdG9yLmVkaXQgbW9kZS5lZGl0YWJsZVwiXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicmVhZCBvbmx5XCI6IHtcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBcInVwZGF0ZSByZWFkT25seVwiOiB7XG4gICAgICAgICAgICAgICAgICBndWFyZDogKHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgICAgIH0pID0+ICFldmVudC5yZWFkT25seSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCIjZWRpdG9yLmVkaXQgbW9kZS5lZGl0YWJsZVwiLFxuICAgICAgICAgICAgICAgICAgYWN0aW9uczogW1wiZW1pdCBlZGl0YWJsZVwiXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZWRpdGFibGU6IHtcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgXCJ1cGRhdGUgcmVhZE9ubHlcIjoge1xuICAgICAgICAgICAgICBndWFyZDogKHtcbiAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICB9KSA9PiBldmVudC5yZWFkT25seSxcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcIiNlZGl0b3IuZWRpdCBtb2RlLnJlYWQgb25seS5yZWFkIG9ubHlcIixcbiAgICAgICAgICAgICAgYWN0aW9uczogW1wiZW1pdCByZWFkIG9ubHlcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImJlaGF2aW9yIGV2ZW50XCI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogXCJoYW5kbGUgYmVoYXZpb3IgZXZlbnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY3VzdG9tIGJlaGF2aW9yIGV2ZW50XCI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogXCJoYW5kbGUgYmVoYXZpb3IgZXZlbnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYW5ub3RhdGlvbi4qXCI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgIH0pID0+IGV2ZW50KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYmxvY2suKlwiOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICB9KSA9PiBldmVudClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibHVyOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICB9KSA9PiBldmVudClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImN1c3RvbS4qXCI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgIH0pID0+ICh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjdXN0b20uKlwiLFxuICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZGVjb3JhdG9yLipcIjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgfSkgPT4gZXZlbnQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJkZWxldGUuKlwiOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICB9KSA9PiBldmVudClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb2N1czoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgfSkgPT4gZXZlbnQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJoaXN0b3J5LipcIjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgfSkgPT4gZXZlbnQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJpbnNlcnQuKlwiOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICB9KSA9PiBldmVudClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImxpc3QgaXRlbS4qXCI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgIH0pID0+IGV2ZW50KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibW92ZS4qXCI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgIH0pID0+IGV2ZW50KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgfSkgPT4gZXZlbnQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzZWxlY3QuKlwiOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICB9KSA9PiBldmVudClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0eWxlLipcIjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgfSkgPT4gZXZlbnQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0ZXh0IGJsb2NrLipcIjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgfSkgPT4gZXZlbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbml0aWFsOiBcImlkbGVcIixcbiAgICAgICAgICBzdGF0ZXM6IHtcbiAgICAgICAgICAgIGlkbGU6IHtcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBkcmFnc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCJkcmFnZ2luZyBpbnRlcm5hbGx5XCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImRyYWdnaW5nIGludGVybmFsbHlcIjoge1xuICAgICAgICAgICAgICB0YWdzOiBbXCJkcmFnZ2luZyBpbnRlcm5hbGx5XCJdLFxuICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIGRyYWdlbmQ6IHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCJpZGxlXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRyb3A6IHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCJpZGxlXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNldHVwOiB7XG4gICAgICBpbml0aWFsOiBcInNldHRpbmcgdXBcIixcbiAgICAgIHN0YXRlczoge1xuICAgICAgICBcInNldHRpbmcgdXBcIjoge1xuICAgICAgICAgIGV4aXQ6IFtcImVtaXQgcmVhZHlcIl0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIFwiaW50ZXJuYWwucGF0Y2hcIjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBcImRlZmVyIGV2ZW50XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdXRhdGlvbjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBcImRlZmVyIGV2ZW50XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImRvbmUgc3luY2luZyBpbml0aWFsIHZhbHVlXCI6IHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcInByaXN0aW5lXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByaXN0aW5lOiB7XG4gICAgICAgICAgaW5pdGlhbDogXCJpZGxlXCIsXG4gICAgICAgICAgc3RhdGVzOiB7XG4gICAgICAgICAgICBpZGxlOiB7XG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXppbmc6IHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImludGVybmFsLnBhdGNoXCI6IHtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFwiZGVmZXIgZXZlbnRcIixcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCIjZWRpdG9yLnNldHVwLmRpcnR5XCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG11dGF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICBhY3Rpb25zOiBcImRlZmVyIGV2ZW50XCIsXG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiI2VkaXRvci5zZXR1cC5kaXJ0eVwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm9ybWFsaXppbmc6IHtcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBcImRvbmUgbm9ybWFsaXppbmdcIjoge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcImlkbGVcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJpbnRlcm5hbC5wYXRjaFwiOiB7XG4gICAgICAgICAgICAgICAgICBhY3Rpb25zOiBcImRlZmVyIGV2ZW50XCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG11dGF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICBhY3Rpb25zOiBcImRlZmVyIGV2ZW50XCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRpcnR5OiB7XG4gICAgICAgICAgZW50cnk6IFtcImVtaXQgcGVuZGluZyBldmVudHNcIiwgXCJjbGVhciBwZW5kaW5nIGV2ZW50c1wiXSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgXCJpbnRlcm5hbC5wYXRjaFwiOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFwiZW1pdCBwYXRjaCBldmVudFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXV0YXRpb246IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogXCJlbWl0IG11dGF0aW9uIGV2ZW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuZnVuY3Rpb24gZ2V0VmFsdWUoe1xuICBlZGl0b3JBY3RvclNuYXBzaG90LFxuICBzbGF0ZUVkaXRvckluc3RhbmNlXG59KSB7XG4gIHJldHVybiBmcm9tU2xhdGVWYWx1ZShzbGF0ZUVkaXRvckluc3RhbmNlLmNoaWxkcmVuLCBlZGl0b3JBY3RvclNuYXBzaG90LmNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChzbGF0ZUVkaXRvckluc3RhbmNlKSk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gdXNlRWRpdG9yU2VsZWN0b3IoZWRpdG9yLCBzZWxlY3RvciwgdDApIHtcbiAgY29uc3QgJCA9IGMoMyksIGNvbXBhcmUgPSB0MCA9PT0gdm9pZCAwID8gZGVmYXVsdENvbXBhcmUgOiB0MDtcbiAgbGV0IHQxO1xuICByZXR1cm4gJFswXSAhPT0gZWRpdG9yLl9pbnRlcm5hbC5zbGF0ZUVkaXRvci5pbnN0YW5jZSB8fCAkWzFdICE9PSBzZWxlY3RvciA/ICh0MSA9IChlZGl0b3JBY3RvclNuYXBzaG90KSA9PiB7XG4gICAgY29uc3Qgc25hcHNob3QgPSBnZXRFZGl0b3JTbmFwc2hvdCh7XG4gICAgICBlZGl0b3JBY3RvclNuYXBzaG90LFxuICAgICAgc2xhdGVFZGl0b3JJbnN0YW5jZTogZWRpdG9yLl9pbnRlcm5hbC5zbGF0ZUVkaXRvci5pbnN0YW5jZVxuICAgIH0pO1xuICAgIHJldHVybiBzZWxlY3RvcihzbmFwc2hvdCk7XG4gIH0sICRbMF0gPSBlZGl0b3IuX2ludGVybmFsLnNsYXRlRWRpdG9yLmluc3RhbmNlLCAkWzFdID0gc2VsZWN0b3IsICRbMl0gPSB0MSkgOiB0MSA9ICRbMl0sIHVzZVNlbGVjdG9yKGVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3IsIHQxLCBjb21wYXJlKTtcbn1cbmZ1bmN0aW9uIGdldEVkaXRvclNuYXBzaG90KHtcbiAgZWRpdG9yQWN0b3JTbmFwc2hvdCxcbiAgc2xhdGVFZGl0b3JJbnN0YW5jZVxufSkge1xuICByZXR1cm4ge1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIGNvbnZlcnRlcnM6IFsuLi5lZGl0b3JBY3RvclNuYXBzaG90LmNvbnRleHQuY29udmVydGVyc10sXG4gICAgICBhY3RpdmVEZWNvcmF0b3JzOiBnZXRBY3RpdmVEZWNvcmF0b3JzKHtcbiAgICAgICAgc2NoZW1hOiBlZGl0b3JBY3RvclNuYXBzaG90LmNvbnRleHQuc2NoZW1hLFxuICAgICAgICBzbGF0ZUVkaXRvckluc3RhbmNlXG4gICAgICB9KSxcbiAgICAgIGtleUdlbmVyYXRvcjogZWRpdG9yQWN0b3JTbmFwc2hvdC5jb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3JTbmFwc2hvdC5jb250ZXh0LnNjaGVtYSxcbiAgICAgIHNlbGVjdGlvbjogZWRpdG9yQWN0b3JTbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbixcbiAgICAgIHZhbHVlOiBnZXRWYWx1ZSh7XG4gICAgICAgIGVkaXRvckFjdG9yU25hcHNob3QsXG4gICAgICAgIHNsYXRlRWRpdG9ySW5zdGFuY2VcbiAgICAgIH0pXG4gICAgfSxcbiAgICBiZXRhOiB7XG4gICAgICBoYXNUYWc6ICh0YWcpID0+IGVkaXRvckFjdG9yU25hcHNob3QuaGFzVGFnKHRhZylcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVFZGl0b3IoY29uZmlnKSB7XG4gIGNvbnN0IGVkaXRvckFjdG9yID0gY3JlYXRlQWN0b3IoZWRpdG9yTWFjaGluZSwge1xuICAgIGlucHV0OiBlZGl0b3JDb25maWdUb01hY2hpbmVJbnB1dChjb25maWcpXG4gIH0pO1xuICByZXR1cm4gZWRpdG9yQWN0b3Iuc3RhcnQoKSwgY3JlYXRlRWRpdG9yRnJvbUFjdG9yKGVkaXRvckFjdG9yKTtcbn1cbmZ1bmN0aW9uIHVzZUNyZWF0ZUVkaXRvcihjb25maWcpIHtcbiAgY29uc3QgJCA9IGMoNik7XG4gIGxldCB0MDtcbiAgJFswXSAhPT0gY29uZmlnID8gKHQwID0gZWRpdG9yQ29uZmlnVG9NYWNoaW5lSW5wdXQoY29uZmlnKSwgJFswXSA9IGNvbmZpZywgJFsxXSA9IHQwKSA6IHQwID0gJFsxXTtcbiAgbGV0IHQxO1xuICAkWzJdICE9PSB0MCA/ICh0MSA9IHtcbiAgICBpbnB1dDogdDBcbiAgfSwgJFsyXSA9IHQwLCAkWzNdID0gdDEpIDogdDEgPSAkWzNdO1xuICBjb25zdCBlZGl0b3JBY3RvciA9IHVzZUFjdG9yUmVmKGVkaXRvck1hY2hpbmUsIHQxKTtcbiAgbGV0IHQyLCB0MztcbiAgcmV0dXJuICRbNF0gIT09IGVkaXRvckFjdG9yID8gKHQzID0gY3JlYXRlRWRpdG9yRnJvbUFjdG9yKGVkaXRvckFjdG9yKSwgJFs0XSA9IGVkaXRvckFjdG9yLCAkWzVdID0gdDMpIDogdDMgPSAkWzVdLCB0MiA9IHQzLCB0Mjtcbn1cbmZ1bmN0aW9uIGVkaXRvckNvbmZpZ1RvTWFjaGluZUlucHV0KGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIGJlaGF2aW9yczogY29uZmlnLmJlaGF2aW9ycyxcbiAgICBjb252ZXJ0ZXJzOiBjb3JlQ29udmVydGVycyxcbiAgICBrZXlHZW5lcmF0b3I6IGNvbmZpZy5rZXlHZW5lcmF0b3IgPz8gZGVmYXVsdEtleUdlbmVyYXRvcixcbiAgICBtYXhCbG9ja3M6IGNvbmZpZy5tYXhCbG9ja3MsXG4gICAgcmVhZE9ubHk6IGNvbmZpZy5yZWFkT25seSxcbiAgICBzY2hlbWE6IGNvbmZpZy5zY2hlbWFEZWZpbml0aW9uID8gY29tcGlsZVNjaGVtYURlZmluaXRpb24oY29uZmlnLnNjaGVtYURlZmluaXRpb24pIDogY3JlYXRlRWRpdG9yU2NoZW1hKGNvbmZpZy5zY2hlbWEuaGFzT3duUHJvcGVydHkoXCJqc29uVHlwZVwiKSA/IGNvbmZpZy5zY2hlbWEgOiBjb21waWxlVHlwZShjb25maWcuc2NoZW1hKSksXG4gICAgdmFsdWU6IGNvbmZpZy5pbml0aWFsVmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVkaXRvckZyb21BY3RvcihlZGl0b3JBY3Rvcikge1xuICBjb25zdCBzbGF0ZUVkaXRvciA9IGNyZWF0ZVNsYXRlRWRpdG9yKHtcbiAgICBlZGl0b3JBY3RvclxuICB9KSwgZWRpdGFibGUgPSBjcmVhdGVFZGl0YWJsZUFQSShzbGF0ZUVkaXRvci5pbnN0YW5jZSwgZWRpdG9yQWN0b3IpO1xuICByZXR1cm4ge1xuICAgIGdldFNuYXBzaG90OiAoKSA9PiBnZXRFZGl0b3JTbmFwc2hvdCh7XG4gICAgICBlZGl0b3JBY3RvclNuYXBzaG90OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLFxuICAgICAgc2xhdGVFZGl0b3JJbnN0YW5jZTogc2xhdGVFZGl0b3IuaW5zdGFuY2VcbiAgICB9KSxcbiAgICByZWdpc3RlckJlaGF2aW9yOiAoY29uZmlnKSA9PiAoZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcImFkZCBiZWhhdmlvclwiLFxuICAgICAgYmVoYXZpb3I6IGNvbmZpZy5iZWhhdmlvclxuICAgIH0pLCAoKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJyZW1vdmUgYmVoYXZpb3JcIixcbiAgICAgICAgYmVoYXZpb3I6IGNvbmZpZy5iZWhhdmlvclxuICAgICAgfSk7XG4gICAgfSksXG4gICAgc2VuZDogKGV2ZW50KSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKGV2ZW50KTtcbiAgICB9LFxuICAgIG9uOiAoZXZlbnQsIGxpc3RlbmVyKSA9PiBlZGl0b3JBY3Rvci5vbihldmVudCwgKGV2ZW50MikgPT4ge1xuICAgICAgc3dpdGNoIChldmVudDIudHlwZSkge1xuICAgICAgICBjYXNlIFwiYmx1cnJlZFwiOlxuICAgICAgICBjYXNlIFwiZG9uZSBsb2FkaW5nXCI6XG4gICAgICAgIGNhc2UgXCJlZGl0YWJsZVwiOlxuICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgY2FzZSBcImZvY3VzZWRcIjpcbiAgICAgICAgY2FzZSBcImludmFsaWQgdmFsdWVcIjpcbiAgICAgICAgY2FzZSBcImxvYWRpbmdcIjpcbiAgICAgICAgY2FzZSBcIm11dGF0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJwYXRjaFwiOlxuICAgICAgICBjYXNlIFwicmVhZCBvbmx5XCI6XG4gICAgICAgIGNhc2UgXCJyZWFkeVwiOlxuICAgICAgICBjYXNlIFwic2VsZWN0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJ2YWx1ZSBjaGFuZ2VkXCI6XG4gICAgICAgICAgbGlzdGVuZXIoZXZlbnQyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KSxcbiAgICBfaW50ZXJuYWw6IHtcbiAgICAgIGVkaXRhYmxlLFxuICAgICAgZWRpdG9yQWN0b3IsXG4gICAgICBzbGF0ZUVkaXRvclxuICAgIH1cbiAgfTtcbn1cbmNvbnN0IEVkaXRvckFjdG9yQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pLCBQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKSwgdXNlUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uID0gKCkgPT4ge1xuICBjb25zdCBzZWxlY3Rpb24gPSB1c2VDb250ZXh0KFBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvbkNvbnRleHQpO1xuICBpZiAoc2VsZWN0aW9uID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGB1c2VQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25gIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFBvcnRhYmxlVGV4dEVkaXRvcj4gY29tcG9uZW50J3MgY29udGV4dC5cIik7XG4gIHJldHVybiBzZWxlY3Rpb247XG59LCBkZWJ1ZyQxID0gZGVidWdXaXRoTmFtZShcImNvbXBvbmVudDpQb3J0YWJsZVRleHRFZGl0b3I6U2VsZWN0aW9uUHJvdmlkZXJcIik7XG5mdW5jdGlvbiBQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25Qcm92aWRlcihwcm9wcykge1xuICBjb25zdCAkID0gYyg2KSwgW3NlbGVjdGlvbiwgc2V0U2VsZWN0aW9uXSA9IHVzZVN0YXRlKG51bGwpO1xuICBsZXQgdDAsIHQxO1xuICAkWzBdICE9PSBwcm9wcy5lZGl0b3JBY3RvciA/ICh0MCA9ICgpID0+IHtcbiAgICBkZWJ1ZyQxKFwiU3Vic2NyaWJpbmcgdG8gc2VsZWN0aW9uIGNoYW5nZXNcIik7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gcHJvcHMuZWRpdG9yQWN0b3Iub24oXCJzZWxlY3Rpb25cIiwgKGV2ZW50KSA9PiB7XG4gICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICBzZXRTZWxlY3Rpb24oZXZlbnQuc2VsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkZWJ1ZyQxKFwiVW5zdWJzY3JpYmluZyB0byBzZWxlY3Rpb24gY2hhbmdlc1wiKSwgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgdDEgPSBbcHJvcHMuZWRpdG9yQWN0b3JdLCAkWzBdID0gcHJvcHMuZWRpdG9yQWN0b3IsICRbMV0gPSB0MCwgJFsyXSA9IHQxKSA6ICh0MCA9ICRbMV0sIHQxID0gJFsyXSksIHVzZUVmZmVjdCh0MCwgdDEpO1xuICBsZXQgdDI7XG4gIHJldHVybiAkWzNdICE9PSBwcm9wcy5jaGlsZHJlbiB8fCAkWzRdICE9PSBzZWxlY3Rpb24gPyAodDIgPSAvKiBAX19QVVJFX18gKi8ganN4KFBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHNlbGVjdGlvbiwgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pLCAkWzNdID0gcHJvcHMuY2hpbGRyZW4sICRbNF0gPSBzZWxlY3Rpb24sICRbNV0gPSB0MikgOiB0MiA9ICRbNV0sIHQyO1xufVxuY29uc3QgZGVidWcgPSBkZWJ1Z1dpdGhOYW1lKFwiY29tcG9uZW50OlBvcnRhYmxlVGV4dEVkaXRvclwiKTtcbmNsYXNzIFBvcnRhYmxlVGV4dEVkaXRvciBleHRlbmRzIENvbXBvbmVudCB7XG4gIHN0YXRpYyBkaXNwbGF5TmFtZSA9IFwiUG9ydGFibGVUZXh0RWRpdG9yXCI7XG4gIC8qKlxuICAgKiBBbiBvYnNlcnZhYmxlIG9mIGFsbCB0aGUgZWRpdG9yIGNoYW5nZXMuXG4gICAqL1xuICBjaGFuZ2UkID0gbmV3IFN1YmplY3QoKTtcbiAgLyoqXG4gICAqIEEgbG9va3VwIHRhYmxlIGZvciBhbGwgdGhlIHJlbGV2YW50IHNjaGVtYSB0eXBlcyBmb3IgdGhpcyBwb3J0YWJsZSB0ZXh0IHR5cGUuXG4gICAqL1xuICAvKipcbiAgICogVGhlIGVkaXRvciBpbnN0YW5jZVxuICAgKi9cbiAgLypcbiAgICogVGhlIGVkaXRvciBBUEkgKGN1cnJlbnRseSBpbXBsZW1lbnRlZCB3aXRoIFNsYXRlKS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpLCBwcm9wcy5lZGl0b3IgPyB0aGlzLmVkaXRvciA9IHByb3BzLmVkaXRvciA6IHRoaXMuZWRpdG9yID0gY3JlYXRlRWRpdG9yKHtcbiAgICAgIGtleUdlbmVyYXRvcjogcHJvcHMua2V5R2VuZXJhdG9yID8/IGRlZmF1bHRLZXlHZW5lcmF0b3IsXG4gICAgICBzY2hlbWE6IHByb3BzLnNjaGVtYVR5cGUsXG4gICAgICBpbml0aWFsVmFsdWU6IHByb3BzLnZhbHVlLFxuICAgICAgbWF4QmxvY2tzOiBwcm9wcy5tYXhCbG9ja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IE51bWJlci5wYXJzZUludChwcm9wcy5tYXhCbG9ja3MudG9TdHJpbmcoKSwgMTApLFxuICAgICAgcmVhZE9ubHk6IHByb3BzLnJlYWRPbmx5XG4gICAgfSksIHRoaXMuc2NoZW1hVHlwZXMgPSB0aGlzLmVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSwgdGhpcy5lZGl0YWJsZSA9IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0YWJsZTtcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgIXRoaXMucHJvcHMuZWRpdG9yICYmICFwcmV2UHJvcHMuZWRpdG9yICYmIHRoaXMucHJvcHMuc2NoZW1hVHlwZSAhPT0gcHJldlByb3BzLnNjaGVtYVR5cGUgJiYgKHRoaXMuc2NoZW1hVHlwZXMgPSBjcmVhdGVFZGl0b3JTY2hlbWEodGhpcy5wcm9wcy5zY2hlbWFUeXBlLmhhc093blByb3BlcnR5KFwianNvblR5cGVcIikgPyB0aGlzLnByb3BzLnNjaGVtYVR5cGUgOiBjb21waWxlVHlwZSh0aGlzLnByb3BzLnNjaGVtYVR5cGUpKSwgdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJ1cGRhdGUgc2NoZW1hXCIsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hVHlwZXNcbiAgICB9KSksICF0aGlzLnByb3BzLmVkaXRvciAmJiAhcHJldlByb3BzLmVkaXRvciAmJiAodGhpcy5wcm9wcy5yZWFkT25seSAhPT0gcHJldlByb3BzLnJlYWRPbmx5ICYmIHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwidXBkYXRlIHJlYWRPbmx5XCIsXG4gICAgICByZWFkT25seTogdGhpcy5wcm9wcy5yZWFkT25seSA/PyAhMVxuICAgIH0pLCB0aGlzLnByb3BzLm1heEJsb2NrcyAhPT0gcHJldlByb3BzLm1heEJsb2NrcyAmJiB0aGlzLmVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcInVwZGF0ZSBtYXhCbG9ja3NcIixcbiAgICAgIG1heEJsb2NrczogdGhpcy5wcm9wcy5tYXhCbG9ja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IE51bWJlci5wYXJzZUludCh0aGlzLnByb3BzLm1heEJsb2Nrcy50b1N0cmluZygpLCAxMClcbiAgICB9KSwgdGhpcy5wcm9wcy52YWx1ZSAhPT0gcHJldlByb3BzLnZhbHVlICYmIHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwidXBkYXRlIHZhbHVlXCIsXG4gICAgICB2YWx1ZTogdGhpcy5wcm9wcy52YWx1ZVxuICAgIH0pLCB0aGlzLnByb3BzLmVkaXRvclJlZiAhPT0gcHJldlByb3BzLmVkaXRvclJlZiAmJiB0aGlzLnByb3BzLmVkaXRvclJlZiAmJiAodGhpcy5wcm9wcy5lZGl0b3JSZWYuY3VycmVudCA9IHRoaXMpKTtcbiAgfVxuICBzZXRFZGl0YWJsZSA9IChlZGl0YWJsZSkgPT4ge1xuICAgIHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0YWJsZSA9IHtcbiAgICAgIC4uLnRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0YWJsZSxcbiAgICAgIC4uLmVkaXRhYmxlXG4gICAgfTtcbiAgfTtcbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGxlZ2FjeVBhdGNoZXMgPSB0aGlzLnByb3BzLmVkaXRvciA/IHZvaWQgMCA6IHRoaXMucHJvcHMuaW5jb21pbmdQYXRjaGVzJCA/PyB0aGlzLnByb3BzLnBhdGNoZXMkO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgICAgbGVnYWN5UGF0Y2hlcyA/IC8qIEBfX1BVUkVfXyAqLyBqc3goUm91dGVQYXRjaGVzT2JzZXJ2YWJsZVRvRWRpdG9yQWN0b3IsIHsgZWRpdG9yQWN0b3I6IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0b3JBY3RvciwgcGF0Y2hlcyQ6IGxlZ2FjeVBhdGNoZXMgfSkgOiBudWxsLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChSb3V0ZUV2ZW50c1RvQ2hhbmdlcywgeyBlZGl0b3JBY3RvcjogdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLCBvbkNoYW5nZTogKGNoYW5nZSkgPT4ge1xuICAgICAgICB0aGlzLnByb3BzLmVkaXRvciB8fCB0aGlzLnByb3BzLm9uQ2hhbmdlKGNoYW5nZSksIHRoaXMuY2hhbmdlJC5uZXh0KGNoYW5nZSk7XG4gICAgICB9IH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChTeW5jaHJvbml6ZXIsIHsgZWRpdG9yQWN0b3I6IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0b3JBY3Rvciwgc2xhdGVFZGl0b3I6IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5zbGF0ZUVkaXRvci5pbnN0YW5jZSB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goRWRpdG9yQWN0b3JDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0aGlzLmVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3IsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFNsYXRlLCB7IGVkaXRvcjogdGhpcy5lZGl0b3IuX2ludGVybmFsLnNsYXRlRWRpdG9yLmluc3RhbmNlLCBpbml0aWFsVmFsdWU6IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5zbGF0ZUVkaXRvci5pbml0aWFsVmFsdWUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFBvcnRhYmxlVGV4dEVkaXRvckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHRoaXMsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvblByb3ZpZGVyLCB7IGVkaXRvckFjdG9yOiB0aGlzLmVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3IsIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pIH0pIH0pIH0pXG4gICAgXSB9KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGJ1aWx0LWluIHNlbGVjdG9ycyBvciB3cml0ZSB5b3VyIG93bjogaHR0cHM6Ly93d3cucG9ydGFibGV0ZXh0Lm9yZy9yZWZlcmVuY2Uvc2VsZWN0b3JzL1xuICAgKlxuICAgKiBgYGBcbiAgICogaW1wb3J0ICogYXMgc2VsZWN0b3JzIGZyb20gJ0Bwb3J0YWJsZXRleHQvZWRpdG9yL3NlbGVjdG9ycydcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogY29uc3QgaXNBY3RpdmUgPSB1c2VFZGl0b3JTZWxlY3RvcihlZGl0b3IsIHNlbGVjdG9ycy5nZXRBY3RpdmVBbm5vdGF0aW9ucylcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgYWN0aXZlQW5ub3RhdGlvbnMgPSAoZWRpdG9yKSA9PiBlZGl0b3IgJiYgZWRpdG9yLmVkaXRhYmxlID8gZWRpdG9yLmVkaXRhYmxlLmFjdGl2ZUFubm90YXRpb25zKCkgOiBbXTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBidWlsdC1pbiBzZWxlY3RvcnMgb3Igd3JpdGUgeW91ciBvd246IGh0dHBzOi8vd3d3LnBvcnRhYmxldGV4dC5vcmcvcmVmZXJlbmNlL3NlbGVjdG9ycy9cbiAgICpcbiAgICogYGBgXG4gICAqIGltcG9ydCAqIGFzIHNlbGVjdG9ycyBmcm9tICdAcG9ydGFibGV0ZXh0L2VkaXRvci9zZWxlY3RvcnMnXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGNvbnN0IGlzQWN0aXZlID0gdXNlRWRpdG9yU2VsZWN0b3IoZWRpdG9yLCBzZWxlY3RvcnMuaXNBY3RpdmVBbm5vdGF0aW9uKC4uLikpXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGlzQW5ub3RhdGlvbkFjdGl2ZSA9IChlZGl0b3IsIGFubm90YXRpb25UeXBlKSA9PiBlZGl0b3IgJiYgZWRpdG9yLmVkaXRhYmxlID8gZWRpdG9yLmVkaXRhYmxlLmlzQW5ub3RhdGlvbkFjdGl2ZShhbm5vdGF0aW9uVHlwZSkgOiAhMTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBgZWRpdG9yLnNlbmQoLi4uKWAgaW5zdGVhZFxuICAgKlxuICAgKiBgYGBcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogZWRpdG9yLnNlbmQoe1xuICAgKiAgdHlwZTogJ2Fubm90YXRpb24uYWRkJyxcbiAgICogIGFubm90YXRpb246IHtcbiAgICogICAgbmFtZTogJy4uLicsXG4gICAqICAgIHZhbHVlOiB7Li4ufSxcbiAgICogIH1cbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgYWRkQW5ub3RhdGlvbiA9IChlZGl0b3IsIHR5cGUsIHZhbHVlKSA9PiBlZGl0b3IuZWRpdGFibGU/LmFkZEFubm90YXRpb24odHlwZSwgdmFsdWUpO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGBlZGl0b3Iuc2VuZCguLi4pYCBpbnN0ZWFkXG4gICAqXG4gICAqIGBgYFxuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBlZGl0b3Iuc2VuZCh7XG4gICAqICB0eXBlOiAnYmx1cicsXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGJsdXIgPSAoZWRpdG9yKSA9PiB7XG4gICAgZGVidWcoXCJIb3N0IGJsdXJyZWRcIiksIGVkaXRvci5lZGl0YWJsZT8uYmx1cigpO1xuICB9O1xuICBzdGF0aWMgZGVsZXRlID0gKGVkaXRvciwgc2VsZWN0aW9uLCBvcHRpb25zKSA9PiBlZGl0b3IuZWRpdGFibGU/LmRlbGV0ZShzZWxlY3Rpb24sIG9wdGlvbnMpO1xuICBzdGF0aWMgZmluZERPTU5vZGUgPSAoZWRpdG9yLCBlbGVtZW50KSA9PiBlZGl0b3IuZWRpdGFibGU/LmZpbmRET01Ob2RlKGVsZW1lbnQpO1xuICBzdGF0aWMgZmluZEJ5UGF0aCA9IChlZGl0b3IsIHBhdGgpID0+IGVkaXRvci5lZGl0YWJsZT8uZmluZEJ5UGF0aChwYXRoKSB8fCBbXTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBgZWRpdG9yLnNlbmQoLi4uKWAgaW5zdGVhZFxuICAgKlxuICAgKiBgYGBcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogZWRpdG9yLnNlbmQoe1xuICAgKiAgdHlwZTogJ2ZvY3VzJyxcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgZm9jdXMgPSAoZWRpdG9yKSA9PiB7XG4gICAgZGVidWcoXCJIb3N0IHJlcXVlc3RpbmcgZm9jdXNcIiksIGVkaXRvci5lZGl0YWJsZT8uZm9jdXMoKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBidWlsdC1pbiBzZWxlY3RvcnMgb3Igd3JpdGUgeW91ciBvd246IGh0dHBzOi8vd3d3LnBvcnRhYmxldGV4dC5vcmcvcmVmZXJlbmNlL3NlbGVjdG9ycy9cbiAgICpcbiAgICogYGBgXG4gICAqIGltcG9ydCAqIGFzIHNlbGVjdG9ycyBmcm9tICdAcG9ydGFibGV0ZXh0L2VkaXRvci9zZWxlY3RvcnMnXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGNvbnN0IGZvY3VzQmxvY2sgPSB1c2VFZGl0b3JTZWxlY3RvcihlZGl0b3IsIHNlbGVjdG9ycy5nZXRGb2N1c0Jsb2NrKVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBmb2N1c0Jsb2NrID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlPy5mb2N1c0Jsb2NrKCk7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYnVpbHQtaW4gc2VsZWN0b3JzIG9yIHdyaXRlIHlvdXIgb3duOiBodHRwczovL3d3dy5wb3J0YWJsZXRleHQub3JnL3JlZmVyZW5jZS9zZWxlY3RvcnMvXG4gICAqXG4gICAqIGBgYFxuICAgKiBpbXBvcnQgKiBhcyBzZWxlY3RvcnMgZnJvbSAnQHBvcnRhYmxldGV4dC9lZGl0b3Ivc2VsZWN0b3JzJ1xuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBjb25zdCBmb2N1c0NoaWxkID0gdXNlRWRpdG9yU2VsZWN0b3IoZWRpdG9yLCBzZWxlY3RvcnMuZ2V0Rm9jdXNDaGlsZClcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgZm9jdXNDaGlsZCA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uZm9jdXNDaGlsZCgpO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGJ1aWx0LWluIHNlbGVjdG9ycyBvciB3cml0ZSB5b3VyIG93bjogaHR0cHM6Ly93d3cucG9ydGFibGV0ZXh0Lm9yZy9yZWZlcmVuY2Uvc2VsZWN0b3JzL1xuICAgKlxuICAgKiBgYGBcbiAgICogaW1wb3J0ICogYXMgc2VsZWN0b3JzIGZyb20gJ0Bwb3J0YWJsZXRleHQvZWRpdG9yL3NlbGVjdG9ycydcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogY29uc3Qgc2VsZWN0aW9uID0gdXNlRWRpdG9yU2VsZWN0b3IoZWRpdG9yLCBzZWxlY3RvcnMuZ2V0U2VsZWN0aW9uKVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBnZXRTZWxlY3Rpb24gPSAoZWRpdG9yKSA9PiBlZGl0b3IuZWRpdGFibGUgPyBlZGl0b3IuZWRpdGFibGUuZ2V0U2VsZWN0aW9uKCkgOiBudWxsO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGJ1aWx0LWluIHNlbGVjdG9ycyBvciB3cml0ZSB5b3VyIG93bjogaHR0cHM6Ly93d3cucG9ydGFibGV0ZXh0Lm9yZy9yZWZlcmVuY2Uvc2VsZWN0b3JzL1xuICAgKlxuICAgKiBgYGBcbiAgICogaW1wb3J0ICogYXMgc2VsZWN0b3JzIGZyb20gJ0Bwb3J0YWJsZXRleHQvZWRpdG9yL3NlbGVjdG9ycydcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogY29uc3QgdmFsdWUgPSB1c2VFZGl0b3JTZWxlY3RvcihlZGl0b3IsIHNlbGVjdG9ycy5nZXRWYWx1ZSlcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgZ2V0VmFsdWUgPSAoZWRpdG9yKSA9PiBlZGl0b3IuZWRpdGFibGU/LmdldFZhbHVlKCk7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYnVpbHQtaW4gc2VsZWN0b3JzIG9yIHdyaXRlIHlvdXIgb3duOiBodHRwczovL3d3dy5wb3J0YWJsZXRleHQub3JnL3JlZmVyZW5jZS9zZWxlY3RvcnMvXG4gICAqXG4gICAqIGBgYFxuICAgKiBpbXBvcnQgKiBhcyBzZWxlY3RvcnMgZnJvbSAnQHBvcnRhYmxldGV4dC9lZGl0b3Ivc2VsZWN0b3JzJ1xuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBjb25zdCBpc0FjdGl2ZSA9IHVzZUVkaXRvclNlbGVjdG9yKGVkaXRvciwgc2VsZWN0b3JzLmlzQWN0aXZlU3R5bGUoLi4uKSlcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgaGFzQmxvY2tTdHlsZSA9IChlZGl0b3IsIGJsb2NrU3R5bGUpID0+IGVkaXRvci5lZGl0YWJsZT8uaGFzQmxvY2tTdHlsZShibG9ja1N0eWxlKTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBidWlsdC1pbiBzZWxlY3RvcnMgb3Igd3JpdGUgeW91ciBvd246IGh0dHBzOi8vd3d3LnBvcnRhYmxldGV4dC5vcmcvcmVmZXJlbmNlL3NlbGVjdG9ycy9cbiAgICpcbiAgICogYGBgXG4gICAqIGltcG9ydCAqIGFzIHNlbGVjdG9ycyBmcm9tICdAcG9ydGFibGV0ZXh0L2VkaXRvci9zZWxlY3RvcnMnXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGNvbnN0IGlzQWN0aXZlID0gdXNlRWRpdG9yU2VsZWN0b3IoZWRpdG9yLCBzZWxlY3RvcnMuaXNBY3RpdmVMaXN0SXRlbSguLi4pKVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBoYXNMaXN0U3R5bGUgPSAoZWRpdG9yLCBsaXN0U3R5bGUpID0+IGVkaXRvci5lZGl0YWJsZT8uaGFzTGlzdFN0eWxlKGxpc3RTdHlsZSk7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYnVpbHQtaW4gc2VsZWN0b3JzIG9yIHdyaXRlIHlvdXIgb3duOiBodHRwczovL3d3dy5wb3J0YWJsZXRleHQub3JnL3JlZmVyZW5jZS9zZWxlY3RvcnMvXG4gICAqXG4gICAqIGBgYFxuICAgKiBpbXBvcnQgKiBhcyBzZWxlY3RvcnMgZnJvbSAnQHBvcnRhYmxldGV4dC9lZGl0b3Ivc2VsZWN0b3JzJ1xuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBjb25zdCBpc1NlbGVjdGlvbkNvbGxhcHNlZCA9IHVzZUVkaXRvclNlbGVjdG9yKGVkaXRvciwgc2VsZWN0b3JzLmlzU2VsZWN0aW9uQ29sbGFwc2VkKVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBpc0NvbGxhcHNlZFNlbGVjdGlvbiA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uaXNDb2xsYXBzZWRTZWxlY3Rpb24oKTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBidWlsdC1pbiBzZWxlY3RvcnMgb3Igd3JpdGUgeW91ciBvd246IGh0dHBzOi8vd3d3LnBvcnRhYmxldGV4dC5vcmcvcmVmZXJlbmNlL3NlbGVjdG9ycy9cbiAgICpcbiAgICogYGBgXG4gICAqIGltcG9ydCAqIGFzIHNlbGVjdG9ycyBmcm9tICdAcG9ydGFibGV0ZXh0L2VkaXRvci9zZWxlY3RvcnMnXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGNvbnN0IGlzU2VsZWN0aW9uRXhwYW5kZWQgPSB1c2VFZGl0b3JTZWxlY3RvcihlZGl0b3IsIHNlbGVjdG9ycy5pc1NlbGVjdGlvbkV4cGFuZGVkKVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBpc0V4cGFuZGVkU2VsZWN0aW9uID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlPy5pc0V4cGFuZGVkU2VsZWN0aW9uKCk7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYnVpbHQtaW4gc2VsZWN0b3JzIG9yIHdyaXRlIHlvdXIgb3duOiBodHRwczovL3d3dy5wb3J0YWJsZXRleHQub3JnL3JlZmVyZW5jZS9zZWxlY3RvcnMvXG4gICAqXG4gICAqIGBgYFxuICAgKiBpbXBvcnQgKiBhcyBzZWxlY3RvcnMgZnJvbSAnQHBvcnRhYmxldGV4dC9lZGl0b3Ivc2VsZWN0b3JzJ1xuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBjb25zdCBpc0FjdGl2ZSA9IHVzZUVkaXRvclNlbGVjdG9yKGVkaXRvciwgc2VsZWN0b3JzLmlzQWN0aXZlRGVjb3JhdG9yKC4uLikpXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGlzTWFya0FjdGl2ZSA9IChlZGl0b3IsIG1hcmspID0+IGVkaXRvci5lZGl0YWJsZT8uaXNNYXJrQWN0aXZlKG1hcmspO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGBlZGl0b3Iuc2VuZCguLi4pYCBpbnN0ZWFkXG4gICAqXG4gICAqIGBgYFxuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBlZGl0b3Iuc2VuZCh7XG4gICAqICB0eXBlOiAnaW5zZXJ0LnNwYW4nLFxuICAgKiAgdGV4dDogJy4uLicsXG4gICAqICBhbm5vdGF0aW9uczogW3tuYW1lOiAnLi4uJywgdmFsdWU6IHsuLi59fV0sXG4gICAqICBkZWNvcmF0b3JzOiBbJy4uLiddLFxuICAgKiB9KVxuICAgKiBlZGl0b3Iuc2VuZCh7XG4gICAqICB0eXBlOiAnaW5zZXJ0LmlubGluZSBvYmplY3QnLFxuICAgKiAgaW5saW5lT2JqZWN0OiB7XG4gICAqICAgIG5hbWU6ICcuLi4nLFxuICAgKiAgICB2YWx1ZTogey4uLn0sXG4gICAqICB9LFxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBpbnNlcnRDaGlsZCA9IChlZGl0b3IsIHR5cGUsIHZhbHVlKSA9PiAoZGVidWcoXCJIb3N0IGluc2VydGluZyBjaGlsZFwiKSwgZWRpdG9yLmVkaXRhYmxlPy5pbnNlcnRDaGlsZCh0eXBlLCB2YWx1ZSkpO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGBlZGl0b3Iuc2VuZCguLi4pYCBpbnN0ZWFkXG4gICAqXG4gICAqIGBgYFxuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBlZGl0b3Iuc2VuZCh7XG4gICAqICB0eXBlOiAnaW5zZXJ0LmJsb2NrIG9iamVjdCcsXG4gICAqICBibG9ja09iamVjdDoge1xuICAgKiAgICBuYW1lOiAnLi4uJyxcbiAgICogICAgdmFsdWU6IHsuLi59LFxuICAgKiAgfSxcbiAgICogIHBsYWNlbWVudDogJ2F1dG8nIHwgJ2FmdGVyJyB8ICdiZWZvcmUnLFxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBpbnNlcnRCbG9jayA9IChlZGl0b3IsIHR5cGUsIHZhbHVlKSA9PiBlZGl0b3IuZWRpdGFibGU/Lmluc2VydEJsb2NrKHR5cGUsIHZhbHVlKTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBgZWRpdG9yLnNlbmQoLi4uKWAgaW5zdGVhZFxuICAgKlxuICAgKiBgYGBcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogZWRpdG9yLnNlbmQoe1xuICAgKiAgdHlwZTogJ2luc2VydC5icmVhaycsXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGluc2VydEJyZWFrID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlPy5pbnNlcnRCcmVhaygpO1xuICBzdGF0aWMgaXNWb2lkID0gKGVkaXRvciwgZWxlbWVudCkgPT4gZWRpdG9yLmVkaXRhYmxlPy5pc1ZvaWQoZWxlbWVudCk7XG4gIHN0YXRpYyBpc09iamVjdFBhdGggPSAoX2VkaXRvciwgcGF0aCkgPT4ge1xuICAgIGlmICghcGF0aCB8fCAhQXJyYXkuaXNBcnJheShwYXRoKSkgcmV0dXJuICExO1xuICAgIGNvbnN0IGlzQ2hpbGRPYmplY3RFZGl0UGF0aCA9IHBhdGgubGVuZ3RoID4gMyAmJiBwYXRoWzFdID09PSBcImNoaWxkcmVuXCI7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMSAmJiBwYXRoWzFdICE9PSBcImNoaWxkcmVuXCIgfHwgaXNDaGlsZE9iamVjdEVkaXRQYXRoO1xuICB9O1xuICBzdGF0aWMgbWFya3MgPSAoZWRpdG9yKSA9PiBlZGl0b3IuZWRpdGFibGU/Lm1hcmtzKCk7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYGVkaXRvci5zZW5kKC4uLilgIGluc3RlYWRcbiAgICpcbiAgICogYGBgXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGVkaXRvci5zZW5kKHtcbiAgICogIHR5cGU6ICdzZWxlY3QnLFxuICAgKiAgc2VsZWN0aW9uOiB7Li4ufSxcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgc2VsZWN0ID0gKGVkaXRvciwgc2VsZWN0aW9uKSA9PiB7XG4gICAgZGVidWcoXCJIb3N0IHNldHRpbmcgc2VsZWN0aW9uXCIsIHNlbGVjdGlvbiksIGVkaXRvci5lZGl0YWJsZT8uc2VsZWN0KHNlbGVjdGlvbik7XG4gIH07XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYGVkaXRvci5zZW5kKC4uLilgIGluc3RlYWRcbiAgICpcbiAgICogYGBgXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGVkaXRvci5zZW5kKHtcbiAgICogIHR5cGU6ICdhbm5vdGF0aW9uLnJlbW92ZScsXG4gICAqICBhbm5vdGF0aW9uOiB7XG4gICAqICAgIG5hbWU6ICcuLi4nLFxuICAgKiAgfSxcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgcmVtb3ZlQW5ub3RhdGlvbiA9IChlZGl0b3IsIHR5cGUpID0+IGVkaXRvci5lZGl0YWJsZT8ucmVtb3ZlQW5ub3RhdGlvbih0eXBlKTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBgZWRpdG9yLnNlbmQoLi4uKWAgaW5zdGVhZFxuICAgKlxuICAgKiBgYGBcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogZWRpdG9yLnNlbmQoe1xuICAgKiAgdHlwZTogJ3N0eWxlLnRvZ2dsZScsXG4gICAqICBzdHlsZTogJy4uLicsXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIHRvZ2dsZUJsb2NrU3R5bGUgPSAoZWRpdG9yLCBibG9ja1N0eWxlKSA9PiAoZGVidWcoXCJIb3N0IGlzIHRvZ2dsaW5nIGJsb2NrIHN0eWxlXCIpLCBlZGl0b3IuZWRpdGFibGU/LnRvZ2dsZUJsb2NrU3R5bGUoYmxvY2tTdHlsZSkpO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGBlZGl0b3Iuc2VuZCguLi4pYCBpbnN0ZWFkXG4gICAqXG4gICAqIGBgYFxuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBlZGl0b3Iuc2VuZCh7XG4gICAqICB0eXBlOiAnbGlzdCBpdGVtLnRvZ2dsZScsXG4gICAqICBsaXN0SXRlbTogJy4uLicsXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIHRvZ2dsZUxpc3QgPSAoZWRpdG9yLCBsaXN0U3R5bGUpID0+IGVkaXRvci5lZGl0YWJsZT8udG9nZ2xlTGlzdChsaXN0U3R5bGUpO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGBlZGl0b3Iuc2VuZCguLi4pYCBpbnN0ZWFkXG4gICAqXG4gICAqIGBgYFxuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBlZGl0b3Iuc2VuZCh7XG4gICAqICB0eXBlOiAnZGVjb3JhdG9yLnRvZ2dsZScsXG4gICAqICBkZWNvcmF0b3I6ICcuLi4nLFxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyB0b2dnbGVNYXJrID0gKGVkaXRvciwgbWFyaykgPT4ge1xuICAgIGRlYnVnKFwiSG9zdCB0b2dnbGluZyBtYXJrXCIsIG1hcmspLCBlZGl0b3IuZWRpdGFibGU/LnRvZ2dsZU1hcmsobWFyayk7XG4gIH07XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYnVpbHQtaW4gc2VsZWN0b3JzIG9yIHdyaXRlIHlvdXIgb3duOiBodHRwczovL3d3dy5wb3J0YWJsZXRleHQub3JnL3JlZmVyZW5jZS9zZWxlY3RvcnMvXG4gICAqXG4gICAqIGBgYFxuICAgKiBpbXBvcnQgKiBhcyBzZWxlY3RvcnMgZnJvbSAnQHBvcnRhYmxldGV4dC9lZGl0b3Ivc2VsZWN0b3JzJ1xuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBjb25zdCBzZWxlY3RlZFNsaWNlID0gdXNlRWRpdG9yU2VsZWN0b3IoZWRpdG9yLCBzZWxlY3RvcnMuZ2V0U2VsZWN0ZWRTbGljZSlcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgZ2V0RnJhZ21lbnQgPSAoZWRpdG9yKSA9PiBlZGl0b3IuZWRpdGFibGU/LmdldEZyYWdtZW50KCk7XG4gIHN0YXRpYyB1bmRvID0gKGVkaXRvcikgPT4ge1xuICAgIGRlYnVnKFwiSG9zdCB1bmRvaW5nXCIpLCBlZGl0b3IuZWRpdGFibGU/LnVuZG8oKTtcbiAgfTtcbiAgc3RhdGljIHJlZG8gPSAoZWRpdG9yKSA9PiB7XG4gICAgZGVidWcoXCJIb3N0IHJlZG9pbmdcIiksIGVkaXRvci5lZGl0YWJsZT8ucmVkbygpO1xuICB9O1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGJ1aWx0LWluIHNlbGVjdG9ycyBvciB3cml0ZSB5b3VyIG93bjogaHR0cHM6Ly93d3cucG9ydGFibGV0ZXh0Lm9yZy9yZWZlcmVuY2Uvc2VsZWN0b3JzL1xuICAgKlxuICAgKiBgYGBcbiAgICogaW1wb3J0ICogYXMgc2VsZWN0b3JzIGZyb20gJ0Bwb3J0YWJsZXRleHQvZWRpdG9yL3NlbGVjdG9ycydcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogY29uc3QgaXNPdmVybGFwcGluZyA9IHVzZUVkaXRvclNlbGVjdG9yKGVkaXRvciwgc2VsZWN0b3JzLmlzT3ZlcmxhcHBpbmdTZWxlY3Rpb24oc2VsZWN0aW9uQikpXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGlzU2VsZWN0aW9uc092ZXJsYXBwaW5nID0gKGVkaXRvciwgc2VsZWN0aW9uQSwgc2VsZWN0aW9uQikgPT4gZWRpdG9yLmVkaXRhYmxlPy5pc1NlbGVjdGlvbnNPdmVybGFwcGluZyhzZWxlY3Rpb25BLCBzZWxlY3Rpb25CKTtcbn1cbmZ1bmN0aW9uIFJvdXRlUGF0Y2hlc09ic2VydmFibGVUb0VkaXRvckFjdG9yKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDQpO1xuICBsZXQgdDAsIHQxO1xuICByZXR1cm4gJFswXSAhPT0gcHJvcHMuZWRpdG9yQWN0b3IgfHwgJFsxXSAhPT0gcHJvcHMucGF0Y2hlcyQgPyAodDAgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gcHJvcHMucGF0Y2hlcyQuc3Vic2NyaWJlKChwYXlsb2FkKSA9PiB7XG4gICAgICBwcm9wcy5lZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJwYXRjaGVzXCIsXG4gICAgICAgIC4uLnBheWxvYWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCB0MSA9IFtwcm9wcy5lZGl0b3JBY3RvciwgcHJvcHMucGF0Y2hlcyRdLCAkWzBdID0gcHJvcHMuZWRpdG9yQWN0b3IsICRbMV0gPSBwcm9wcy5wYXRjaGVzJCwgJFsyXSA9IHQwLCAkWzNdID0gdDEpIDogKHQwID0gJFsyXSwgdDEgPSAkWzNdKSwgdXNlRWZmZWN0KHQwLCB0MSksIG51bGw7XG59XG5mdW5jdGlvbiBSb3V0ZUV2ZW50c1RvQ2hhbmdlcyhwcm9wcykge1xuICBjb25zdCAkID0gYyg3KTtcbiAgbGV0IHQwO1xuICAkWzBdICE9PSBwcm9wcyA/ICh0MCA9IChjaGFuZ2UpID0+IHByb3BzLm9uQ2hhbmdlKGNoYW5nZSksICRbMF0gPSBwcm9wcywgJFsxXSA9IHQwKSA6IHQwID0gJFsxXTtcbiAgY29uc3QgaGFuZGxlQ2hhbmdlID0gdXNlRWZmZWN0RXZlbnQodDApO1xuICBsZXQgdDE7XG4gICRbMl0gIT09IGhhbmRsZUNoYW5nZSB8fCAkWzNdICE9PSBwcm9wcy5lZGl0b3JBY3RvciA/ICh0MSA9ICgpID0+IHtcbiAgICBkZWJ1ZyhcIlN1YnNjcmliaW5nIHRvIGVkaXRvciBjaGFuZ2VzXCIpO1xuICAgIGNvbnN0IHN1YiA9IHByb3BzLmVkaXRvckFjdG9yLm9uKFwiKlwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGJiNTogc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJibHVycmVkXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJibHVyXCIsXG4gICAgICAgICAgICBldmVudDogZXZlbnQuZXZlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhayBiYjU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInBhdGNoXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2UoZXZlbnQpO1xuICAgICAgICAgIGJyZWFrIGJiNTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwibG9hZGluZ1wiOiB7XG4gICAgICAgICAgaGFuZGxlQ2hhbmdlKHtcbiAgICAgICAgICAgIHR5cGU6IFwibG9hZGluZ1wiLFxuICAgICAgICAgICAgaXNMb2FkaW5nOiAhMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrIGJiNTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZG9uZSBsb2FkaW5nXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJsb2FkaW5nXCIsXG4gICAgICAgICAgICBpc0xvYWRpbmc6ICExXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWsgYmI1O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmb2N1c2VkXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJmb2N1c1wiLFxuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LmV2ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWsgYmI1O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ2YWx1ZSBjaGFuZ2VkXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWsgYmI1O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJpbnZhbGlkIHZhbHVlXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkVmFsdWVcIixcbiAgICAgICAgICAgIHJlc29sdXRpb246IGV2ZW50LnJlc29sdXRpb24sXG4gICAgICAgICAgICB2YWx1ZTogZXZlbnQudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhayBiYjU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgICAgICBsZXZlbDogXCJ3YXJuaW5nXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhayBiYjU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm11dGF0aW9uXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2UoZXZlbnQpO1xuICAgICAgICAgIGJyZWFrIGJiNTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicmVhZHlcIjoge1xuICAgICAgICAgIGhhbmRsZUNoYW5nZShldmVudCk7XG4gICAgICAgICAgYnJlYWsgYmI1O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzZWxlY3Rpb25cIjoge1xuICAgICAgICAgIGhhbmRsZUNoYW5nZShldmVudCk7XG4gICAgICAgICAgYnJlYWsgYmI1O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ1bnNldFwiOlxuICAgICAgICAgIGhhbmRsZUNoYW5nZShldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRlYnVnKFwiVW5zdWJzY3JpYmluZyB0byBjaGFuZ2VzXCIpLCBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCAkWzJdID0gaGFuZGxlQ2hhbmdlLCAkWzNdID0gcHJvcHMuZWRpdG9yQWN0b3IsICRbNF0gPSB0MSkgOiB0MSA9ICRbNF07XG4gIGxldCB0MjtcbiAgcmV0dXJuICRbNV0gIT09IHByb3BzLmVkaXRvckFjdG9yID8gKHQyID0gW3Byb3BzLmVkaXRvckFjdG9yXSwgJFs1XSA9IHByb3BzLmVkaXRvckFjdG9yLCAkWzZdID0gdDIpIDogdDIgPSAkWzZdLCB1c2VFZmZlY3QodDEsIHQyKSwgbnVsbDtcbn1cbmNvbnN0IEVkaXRvckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHZvaWQgMCk7XG5mdW5jdGlvbiBFZGl0b3JQcm92aWRlcihwcm9wcykge1xuICBjb25zdCAkID0gYygyOCksIGVkaXRvciA9IHVzZUNyZWF0ZUVkaXRvcihwcm9wcy5pbml0aWFsQ29uZmlnKSwgZWRpdG9yQWN0b3IgPSBlZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLCBzbGF0ZUVkaXRvciA9IGVkaXRvci5faW50ZXJuYWwuc2xhdGVFZGl0b3I7XG4gIGxldCB0MCwgdDE7XG4gICRbMF0gIT09IGVkaXRvciA/ICh0MSA9IG5ldyBQb3J0YWJsZVRleHRFZGl0b3Ioe1xuICAgIGVkaXRvclxuICB9KSwgJFswXSA9IGVkaXRvciwgJFsxXSA9IHQxKSA6IHQxID0gJFsxXSwgdDAgPSB0MTtcbiAgY29uc3QgcG9ydGFibGVUZXh0RWRpdG9yID0gdDA7XG4gIGxldCB0MjtcbiAgJFsyXSAhPT0gcG9ydGFibGVUZXh0RWRpdG9yLmNoYW5nZSQgPyAodDIgPSAoY2hhbmdlKSA9PiB7XG4gICAgcG9ydGFibGVUZXh0RWRpdG9yLmNoYW5nZSQubmV4dChjaGFuZ2UpO1xuICB9LCAkWzJdID0gcG9ydGFibGVUZXh0RWRpdG9yLmNoYW5nZSQsICRbM10gPSB0MikgOiB0MiA9ICRbM107XG4gIGxldCB0MztcbiAgJFs0XSAhPT0gZWRpdG9yQWN0b3IgfHwgJFs1XSAhPT0gdDIgPyAodDMgPSAvKiBAX19QVVJFX18gKi8ganN4KFJvdXRlRXZlbnRzVG9DaGFuZ2VzLCB7IGVkaXRvckFjdG9yLCBvbkNoYW5nZTogdDIgfSksICRbNF0gPSBlZGl0b3JBY3RvciwgJFs1XSA9IHQyLCAkWzZdID0gdDMpIDogdDMgPSAkWzZdO1xuICBsZXQgdDQ7XG4gICRbN10gIT09IGVkaXRvckFjdG9yIHx8ICRbOF0gIT09IHNsYXRlRWRpdG9yLmluc3RhbmNlID8gKHQ0ID0gLyogQF9fUFVSRV9fICovIGpzeChTeW5jaHJvbml6ZXIsIHsgZWRpdG9yQWN0b3IsIHNsYXRlRWRpdG9yOiBzbGF0ZUVkaXRvci5pbnN0YW5jZSB9KSwgJFs3XSA9IGVkaXRvckFjdG9yLCAkWzhdID0gc2xhdGVFZGl0b3IuaW5zdGFuY2UsICRbOV0gPSB0NCkgOiB0NCA9ICRbOV07XG4gIGxldCB0NTtcbiAgJFsxMF0gIT09IGVkaXRvckFjdG9yIHx8ICRbMTFdICE9PSBwcm9wcy5jaGlsZHJlbiA/ICh0NSA9IC8qIEBfX1BVUkVfXyAqLyBqc3goUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uUHJvdmlkZXIsIHsgZWRpdG9yQWN0b3IsIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSwgJFsxMF0gPSBlZGl0b3JBY3RvciwgJFsxMV0gPSBwcm9wcy5jaGlsZHJlbiwgJFsxMl0gPSB0NSkgOiB0NSA9ICRbMTJdO1xuICBsZXQgdDY7XG4gICRbMTNdICE9PSBwb3J0YWJsZVRleHRFZGl0b3IgfHwgJFsxNF0gIT09IHQ1ID8gKHQ2ID0gLyogQF9fUFVSRV9fICovIGpzeChQb3J0YWJsZVRleHRFZGl0b3JDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBwb3J0YWJsZVRleHRFZGl0b3IsIGNoaWxkcmVuOiB0NSB9KSwgJFsxM10gPSBwb3J0YWJsZVRleHRFZGl0b3IsICRbMTRdID0gdDUsICRbMTVdID0gdDYpIDogdDYgPSAkWzE1XTtcbiAgbGV0IHQ3O1xuICAkWzE2XSAhPT0gc2xhdGVFZGl0b3IuaW5pdGlhbFZhbHVlIHx8ICRbMTddICE9PSBzbGF0ZUVkaXRvci5pbnN0YW5jZSB8fCAkWzE4XSAhPT0gdDYgPyAodDcgPSAvKiBAX19QVVJFX18gKi8ganN4KFNsYXRlLCB7IGVkaXRvcjogc2xhdGVFZGl0b3IuaW5zdGFuY2UsIGluaXRpYWxWYWx1ZTogc2xhdGVFZGl0b3IuaW5pdGlhbFZhbHVlLCBjaGlsZHJlbjogdDYgfSksICRbMTZdID0gc2xhdGVFZGl0b3IuaW5pdGlhbFZhbHVlLCAkWzE3XSA9IHNsYXRlRWRpdG9yLmluc3RhbmNlLCAkWzE4XSA9IHQ2LCAkWzE5XSA9IHQ3KSA6IHQ3ID0gJFsxOV07XG4gIGxldCB0ODtcbiAgJFsyMF0gIT09IGVkaXRvckFjdG9yIHx8ICRbMjFdICE9PSB0NyA/ICh0OCA9IC8qIEBfX1BVUkVfXyAqLyBqc3goRWRpdG9yQWN0b3JDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBlZGl0b3JBY3RvciwgY2hpbGRyZW46IHQ3IH0pLCAkWzIwXSA9IGVkaXRvckFjdG9yLCAkWzIxXSA9IHQ3LCAkWzIyXSA9IHQ4KSA6IHQ4ID0gJFsyMl07XG4gIGxldCB0OTtcbiAgcmV0dXJuICRbMjNdICE9PSBlZGl0b3IgfHwgJFsyNF0gIT09IHQzIHx8ICRbMjVdICE9PSB0NCB8fCAkWzI2XSAhPT0gdDggPyAodDkgPSAvKiBAX19QVVJFX18gKi8ganN4cyhFZGl0b3JDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBlZGl0b3IsIGNoaWxkcmVuOiBbXG4gICAgdDMsXG4gICAgdDQsXG4gICAgdDhcbiAgXSB9KSwgJFsyM10gPSBlZGl0b3IsICRbMjRdID0gdDMsICRbMjVdID0gdDQsICRbMjZdID0gdDgsICRbMjddID0gdDkpIDogdDkgPSAkWzI3XSwgdDk7XG59XG5mdW5jdGlvbiB1c2VFZGl0b3IoKSB7XG4gIGNvbnN0IGVkaXRvciA9IFJlYWN0LnVzZUNvbnRleHQoRWRpdG9yQ29udGV4dCk7XG4gIGlmICghZWRpdG9yKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIEVkaXRvciBzZXQuIFVzZSBFZGl0b3JQcm92aWRlciB0byBzZXQgb25lLlwiKTtcbiAgcmV0dXJuIGVkaXRvcjtcbn1cbmV4cG9ydCB7XG4gIEVkaXRvckFjdG9yQ29udGV4dCxcbiAgRWRpdG9yUHJvdmlkZXIsXG4gIElTX0RSQUdHSU5HLFxuICBJU19EUkFHR0lOR19CTE9DS19FTEVNRU5ULFxuICBJU19EUkFHR0lOR19CTE9DS19UQVJHRVRfUE9TSVRJT04sXG4gIElTX0RSQUdHSU5HX0VMRU1FTlRfVEFSR0VULFxuICBLRVlfVE9fVkFMVUVfRUxFTUVOVCxcbiAgUG9ydGFibGVUZXh0RWRpdG9yLFxuICBkZWJ1Z1dpdGhOYW1lLFxuICBkZWZhdWx0S2V5R2VuZXJhdG9yLFxuICBkZWZpbmVTY2hlbWEsXG4gIGZyb21TbGF0ZVZhbHVlLFxuICBpc0VxdWFsVG9FbXB0eUVkaXRvcixcbiAgbW92ZVJhbmdlQnlPcGVyYXRpb24sXG4gIHRvUG9ydGFibGVUZXh0UmFuZ2UsXG4gIHRvU2xhdGVSYW5nZSxcbiAgdG9TbGF0ZVZhbHVlLFxuICB1c2VFZGl0b3IsXG4gIHVzZUVkaXRvclNlbGVjdG9yLFxuICB1c2VQb3J0YWJsZVRleHRFZGl0b3IsXG4gIHVzZVBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVkaXRvci1wcm92aWRlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/editor-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.get-text-before.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/selector.get-text-before.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBlockTextBefore: () => (/* binding */ getBlockTextBefore)\n/* harmony export */ });\n/* harmony import */ var _util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.slice-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\");\n/* harmony import */ var _util_reverse_selection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.reverse-selection.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.reverse-selection.js\");\n/* harmony import */ var _selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selector.is-at-the-start-of-block.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-at-the-start-of-block.js\");\n\n\n\nconst getBlockTextBefore = (snapshot) => {\n  if (!snapshot.context.selection)\n    return \"\";\n  const point = (snapshot.context.selection.backward ? (0,_util_reverse_selection_js__WEBPACK_IMPORTED_MODULE_0__.reverseSelection)(snapshot.context.selection) : snapshot.context.selection).anchor, key = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__.isKeyedSegment)(point.path[0]) ? point.path[0]._key : void 0, block = key ? snapshot.context.value.find((block2) => block2._key === key) : void 0;\n  if (!block)\n    return \"\";\n  const startOfBlock = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__.getBlockStartPoint)({\n    node: block,\n    path: [{\n      _key: block._key\n    }]\n  });\n  return (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_2__.getSelectionText)({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: startOfBlock,\n        focus: point\n      }\n    }\n  });\n};\n\n//# sourceMappingURL=selector.get-text-before.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvc2VsZWN0b3IuZ2V0LXRleHQtYmVmb3JlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNEU7QUFDYjtBQUNXO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw0RUFBZ0IseUVBQXlFLHFFQUFjO0FBQzlKO0FBQ0E7QUFDQSx1QkFBdUIseUVBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsU0FBUyx1RkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNib29rcHJvL0Rvd25sb2Fkcy9jb25pY2FwcHMvaWdlbmUvbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3NlbGVjdG9yLmdldC10ZXh0LWJlZm9yZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRCbG9ja1N0YXJ0UG9pbnQsIGlzS2V5ZWRTZWdtZW50IH0gZnJvbSBcIi4vdXRpbC5zbGljZS1ibG9ja3MuanNcIjtcbmltcG9ydCB7IHJldmVyc2VTZWxlY3Rpb24gfSBmcm9tIFwiLi91dGlsLnJldmVyc2Utc2VsZWN0aW9uLmpzXCI7XG5pbXBvcnQgeyBnZXRTZWxlY3Rpb25UZXh0IH0gZnJvbSBcIi4vc2VsZWN0b3IuaXMtYXQtdGhlLXN0YXJ0LW9mLWJsb2NrLmpzXCI7XG5jb25zdCBnZXRCbG9ja1RleHRCZWZvcmUgPSAoc25hcHNob3QpID0+IHtcbiAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICByZXR1cm4gXCJcIjtcbiAgY29uc3QgcG9pbnQgPSAoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYmFja3dhcmQgPyByZXZlcnNlU2VsZWN0aW9uKHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKSA6IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKS5hbmNob3IsIGtleSA9IGlzS2V5ZWRTZWdtZW50KHBvaW50LnBhdGhbMF0pID8gcG9pbnQucGF0aFswXS5fa2V5IDogdm9pZCAwLCBibG9jayA9IGtleSA/IHNuYXBzaG90LmNvbnRleHQudmFsdWUuZmluZCgoYmxvY2syKSA9PiBibG9jazIuX2tleSA9PT0ga2V5KSA6IHZvaWQgMDtcbiAgaWYgKCFibG9jaylcbiAgICByZXR1cm4gXCJcIjtcbiAgY29uc3Qgc3RhcnRPZkJsb2NrID0gZ2V0QmxvY2tTdGFydFBvaW50KHtcbiAgICBub2RlOiBibG9jayxcbiAgICBwYXRoOiBbe1xuICAgICAgX2tleTogYmxvY2suX2tleVxuICAgIH1dXG4gIH0pO1xuICByZXR1cm4gZ2V0U2VsZWN0aW9uVGV4dCh7XG4gICAgLi4uc25hcHNob3QsXG4gICAgY29udGV4dDoge1xuICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICBhbmNob3I6IHN0YXJ0T2ZCbG9jayxcbiAgICAgICAgZm9jdXM6IHBvaW50XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5leHBvcnQge1xuICBnZXRCbG9ja1RleHRCZWZvcmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3Rvci5nZXQtdGV4dC1iZWZvcmUuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.get-text-before.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-active-style.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-active-style.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getActiveListItem: () => (/* binding */ getActiveListItem),\n/* harmony export */   getActiveStyle: () => (/* binding */ getActiveStyle),\n/* harmony export */   getSelectedSpans: () => (/* binding */ getSelectedSpans),\n/* harmony export */   getTrimmedSelection: () => (/* binding */ getTrimmedSelection),\n/* harmony export */   isActiveAnnotation: () => (/* binding */ isActiveAnnotation),\n/* harmony export */   isActiveDecorator: () => (/* binding */ isActiveDecorator),\n/* harmony export */   isActiveListItem: () => (/* binding */ isActiveListItem),\n/* harmony export */   isActiveStyle: () => (/* binding */ isActiveStyle)\n/* harmony export */ });\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var _util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.slice-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\");\n/* harmony import */ var _selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selector.is-at-the-start-of-block.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-at-the-start-of-block.js\");\n\n\n\nconst getSelectedSpans = (snapshot) => {\n  if (!snapshot.context.selection)\n    return [];\n  const selectedSpans = [], startPoint = snapshot.context.selection.backward ? snapshot.context.selection.focus : snapshot.context.selection.anchor, endPoint = snapshot.context.selection.backward ? snapshot.context.selection.anchor : snapshot.context.selection.focus, startBlockKey = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(startPoint.path[0]) ? startPoint.path[0]._key : void 0, endBlockKey = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(endPoint.path[0]) ? endPoint.path[0]._key : void 0;\n  if (!startBlockKey || !endBlockKey)\n    return selectedSpans;\n  const startSpanKey = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(startPoint.path[2]) ? startPoint.path[2]._key : void 0, endSpanKey = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(endPoint.path[2]) ? endPoint.path[2]._key : void 0;\n  for (const block of snapshot.context.value)\n    if ((0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block)) {\n      if (block._key === startBlockKey) {\n        for (const child of block.children)\n          if ((0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(child)) {\n            if (startSpanKey && child._key === startSpanKey) {\n              if (startPoint.offset < child.text.length && selectedSpans.push({\n                node: child,\n                path: [{\n                  _key: block._key\n                }, \"children\", {\n                  _key: child._key\n                }]\n              }), startSpanKey === endSpanKey)\n                break;\n              continue;\n            }\n            if (endSpanKey && child._key === endSpanKey) {\n              endPoint.offset > 0 && selectedSpans.push({\n                node: child,\n                path: [{\n                  _key: block._key\n                }, \"children\", {\n                  _key: child._key\n                }]\n              });\n              break;\n            }\n            selectedSpans.length > 0 && selectedSpans.push({\n              node: child,\n              path: [{\n                _key: block._key\n              }, \"children\", {\n                _key: child._key\n              }]\n            });\n          }\n        if (startBlockKey === endBlockKey)\n          break;\n        continue;\n      }\n      if (block._key === endBlockKey) {\n        for (const child of block.children)\n          if ((0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(child)) {\n            if (endSpanKey && child._key === endSpanKey) {\n              endPoint.offset > 0 && selectedSpans.push({\n                node: child,\n                path: [{\n                  _key: block._key\n                }, \"children\", {\n                  _key: child._key\n                }]\n              });\n              break;\n            }\n            selectedSpans.push({\n              node: child,\n              path: [{\n                _key: block._key\n              }, \"children\", {\n                _key: child._key\n              }]\n            });\n          }\n        break;\n      }\n      if (selectedSpans.length > 0)\n        for (const child of block.children)\n          (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(child) && selectedSpans.push({\n            node: child,\n            path: [{\n              _key: block._key\n            }, \"children\", {\n              _key: child._key\n            }]\n          });\n    }\n  return selectedSpans;\n}, getActiveListItem = (snapshot) => {\n  if (!snapshot.context.selection)\n    return;\n  const guards = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.createGuards)(snapshot.context), selectedTextBlocks = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getSelectedBlocks)(snapshot).map((block) => block.node).filter(guards.isTextBlock), firstTextBlock = selectedTextBlocks.at(0);\n  if (!firstTextBlock)\n    return;\n  const firstListItem = firstTextBlock.listItem;\n  if (firstListItem && selectedTextBlocks.every((block) => block.listItem === firstListItem))\n    return firstListItem;\n}, getActiveStyle = (snapshot) => {\n  if (!snapshot.context.selection)\n    return;\n  const guards = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.createGuards)(snapshot.context), selectedTextBlocks = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getSelectedBlocks)(snapshot).map((block) => block.node).filter(guards.isTextBlock), firstTextBlock = selectedTextBlocks.at(0);\n  if (!firstTextBlock)\n    return;\n  const firstStyle = firstTextBlock.style;\n  if (firstStyle && selectedTextBlocks.every((block) => block.style === firstStyle))\n    return firstStyle;\n}, getTrimmedSelection = (snapshot) => {\n  if (!snapshot.context.selection)\n    return snapshot.context.selection;\n  const startPoint = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getSelectionStartPoint)(snapshot), endPoint = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getSelectionEndPoint)(snapshot);\n  if (!startPoint || !endPoint)\n    return snapshot.context.selection;\n  const startBlockKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_2__.isKeyedSegment)(startPoint.path[0]) ? startPoint.path[0]._key : null, startChildKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_2__.isKeyedSegment)(startPoint.path[2]) ? startPoint.path[2]._key : null, endBlockKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_2__.isKeyedSegment)(endPoint.path[0]) ? endPoint.path[0]._key : null, endChildKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_2__.isKeyedSegment)(endPoint.path[2]) ? endPoint.path[2]._key : null;\n  if (!startBlockKey || !endBlockKey)\n    return snapshot.context.selection;\n  let startBlockFound = !1, adjustedStartPoint, trimStartPoint = !1, adjustedEndPoint, trimEndPoint = !1, previousPotentialEndpoint;\n  for (const block of snapshot.context.value)\n    if (!(block._key === startBlockKey && (startBlockFound = !0, (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block) && (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_2__.isEmptyTextBlock)(block))) && startBlockFound && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block)) {\n      if (block._key === endBlockKey && (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_2__.isEmptyTextBlock)(block))\n        break;\n      for (const child of block.children) {\n        if (child._key === endChildKey && (!(0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(child) || endPoint.offset === 0)) {\n          adjustedEndPoint = previousPotentialEndpoint ? {\n            path: [{\n              _key: previousPotentialEndpoint.blockKey\n            }, \"children\", {\n              _key: previousPotentialEndpoint.span._key\n            }],\n            offset: previousPotentialEndpoint.span.text.length\n          } : void 0, trimEndPoint = !0;\n          break;\n        }\n        if (trimStartPoint) {\n          const lonelySpan = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(child) && block.children.length === 1;\n          ((0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(child) && child.text.length > 0 || lonelySpan) && (adjustedStartPoint = {\n            path: [{\n              _key: block._key\n            }, \"children\", {\n              _key: child._key\n            }],\n            offset: 0\n          }, previousPotentialEndpoint = {\n            blockKey: block._key,\n            span: child\n          }, trimStartPoint = !1);\n          continue;\n        }\n        if (child._key === startChildKey) {\n          if (!(0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(child)) {\n            trimStartPoint = !0;\n            continue;\n          }\n          if (startPoint.offset === child.text.length) {\n            trimStartPoint = !0, previousPotentialEndpoint = child.text.length > 0 ? {\n              blockKey: block._key,\n              span: child\n            } : previousPotentialEndpoint;\n            continue;\n          }\n        }\n        previousPotentialEndpoint = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(child) && child.text.length > 0 ? {\n          blockKey: block._key,\n          span: child\n        } : previousPotentialEndpoint;\n      }\n      if (block._key === endBlockKey)\n        break;\n    }\n  const trimmedSelection = snapshot.context.selection.backward ? {\n    anchor: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,\n    focus: adjustedStartPoint ?? startPoint,\n    backward: !0\n  } : {\n    anchor: adjustedStartPoint ?? startPoint,\n    focus: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint\n  };\n  if ((0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: trimmedSelection\n    }\n  })) {\n    const focusTextBlock = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: trimmedSelection\n      }\n    });\n    if (focusTextBlock && !(0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_2__.isEmptyTextBlock)(focusTextBlock.node))\n      return null;\n  }\n  return trimmedSelection;\n};\nfunction isActiveAnnotation(annotation) {\n  return (snapshot) => {\n    if (!snapshot.context.selection)\n      return !1;\n    const selectedBlocks = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getSelectedBlocks)(snapshot), focusSpan = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.getFocusSpan)(snapshot), selectedSpans = (0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionExpanded)(snapshot) ? getSelectedSpans(snapshot) : focusSpan ? [focusSpan] : [];\n    if (selectedSpans.length === 0 || selectedSpans.some((span) => !span.node.marks || span.node.marks?.length === 0))\n      return !1;\n    const selectionMarkDefs = selectedBlocks.flatMap((block) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block.node) ? block.node.markDefs ?? [] : []);\n    return selectedSpans.every((span) => (span.node.marks?.flatMap((mark) => {\n      const markDef = selectionMarkDefs.find((markDef2) => markDef2._key === mark);\n      return markDef ? [markDef._type] : [];\n    }) ?? []).includes(annotation));\n  };\n}\nfunction isActiveDecorator(decorator) {\n  return (snapshot) => {\n    if ((0,_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionExpanded)(snapshot)) {\n      const selectedSpans = getSelectedSpans(snapshot);\n      return selectedSpans.length > 0 && selectedSpans.every((span) => span.node.marks?.includes(decorator));\n    }\n    return snapshot.context.activeDecorators.includes(decorator);\n  };\n}\nfunction isActiveListItem(listItem) {\n  return (snapshot) => getActiveListItem(snapshot) === listItem;\n}\nfunction isActiveStyle(style) {\n  return (snapshot) => getActiveStyle(snapshot) === style;\n}\n\n//# sourceMappingURL=selector.is-active-style.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvc2VsZWN0b3IuaXMtYWN0aXZlLXN0eWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTBGO0FBQ2hCO0FBQ3lJO0FBQ25OO0FBQ0E7QUFDQTtBQUNBLDRSQUE0UiwyREFBWSx1RUFBdUUsMkRBQVk7QUFDM1g7QUFDQTtBQUNBLHVCQUF1QiwyREFBWSxzRUFBc0UsMkRBQVk7QUFDckg7QUFDQSxRQUFRLHNFQUF1QjtBQUMvQjtBQUNBO0FBQ0EsY0FBYyxpRUFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUVBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUVBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsaUJBQWlCLG1GQUFZLHlDQUF5Qyx3RkFBaUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsaUJBQWlCLG1GQUFZLHlDQUF5Qyx3RkFBaUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EscUJBQXFCLDZGQUFzQix1QkFBdUIsMkZBQW9CO0FBQ3RGO0FBQ0E7QUFDQSx3QkFBd0IscUVBQWMsdUVBQXVFLHFFQUFjLHFFQUFxRSxxRUFBYyxpRUFBaUUscUVBQWM7QUFDN1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsc0VBQXVCLFdBQVcsdUVBQWdCLGdDQUFnQyxzRUFBdUI7QUFDMUssd0NBQXdDLHVFQUFnQjtBQUN4RDtBQUNBO0FBQ0EsNENBQTRDLGlFQUFrQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlFQUFrQjtBQUMvQyxXQUFXLGlFQUFrQjtBQUM3QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpRUFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlFQUFrQjtBQUN0RDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyRkFBb0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwyQkFBMkIsd0ZBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCLHVFQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdGQUFpQix3QkFBd0IsbUZBQVksNEJBQTRCLDBGQUFtQjtBQUMvSDtBQUNBO0FBQ0EsZ0VBQWdFLHNFQUF1QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBGQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbWFjYm9va3Byby9Eb3dubG9hZHMvY29uaWNhcHBzL2lnZW5lL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvX2NodW5rcy1lcy9zZWxlY3Rvci5pcy1hY3RpdmUtc3R5bGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNLZXlTZWdtZW50LCBpc1BvcnRhYmxlVGV4dFRleHRCbG9jaywgaXNQb3J0YWJsZVRleHRTcGFuIH0gZnJvbSBcIkBzYW5pdHkvdHlwZXNcIjtcbmltcG9ydCB7IGlzRW1wdHlUZXh0QmxvY2ssIGlzS2V5ZWRTZWdtZW50IH0gZnJvbSBcIi4vdXRpbC5zbGljZS1ibG9ja3MuanNcIjtcbmltcG9ydCB7IGdldFNlbGVjdGVkQmxvY2tzLCBjcmVhdGVHdWFyZHMsIGlzU2VsZWN0aW9uQ29sbGFwc2VkLCBnZXRGb2N1c1RleHRCbG9jaywgZ2V0U2VsZWN0aW9uU3RhcnRQb2ludCwgZ2V0U2VsZWN0aW9uRW5kUG9pbnQsIGdldEZvY3VzU3BhbiwgaXNTZWxlY3Rpb25FeHBhbmRlZCB9IGZyb20gXCIuL3NlbGVjdG9yLmlzLWF0LXRoZS1zdGFydC1vZi1ibG9jay5qc1wiO1xuY29uc3QgZ2V0U2VsZWN0ZWRTcGFucyA9IChzbmFwc2hvdCkgPT4ge1xuICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3Qgc2VsZWN0ZWRTcGFucyA9IFtdLCBzdGFydFBvaW50ID0gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYmFja3dhcmQgPyBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cyA6IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmFuY2hvciwgZW5kUG9pbnQgPSBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmFuY2hvciA6IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLCBzdGFydEJsb2NrS2V5ID0gaXNLZXlTZWdtZW50KHN0YXJ0UG9pbnQucGF0aFswXSkgPyBzdGFydFBvaW50LnBhdGhbMF0uX2tleSA6IHZvaWQgMCwgZW5kQmxvY2tLZXkgPSBpc0tleVNlZ21lbnQoZW5kUG9pbnQucGF0aFswXSkgPyBlbmRQb2ludC5wYXRoWzBdLl9rZXkgOiB2b2lkIDA7XG4gIGlmICghc3RhcnRCbG9ja0tleSB8fCAhZW5kQmxvY2tLZXkpXG4gICAgcmV0dXJuIHNlbGVjdGVkU3BhbnM7XG4gIGNvbnN0IHN0YXJ0U3BhbktleSA9IGlzS2V5U2VnbWVudChzdGFydFBvaW50LnBhdGhbMl0pID8gc3RhcnRQb2ludC5wYXRoWzJdLl9rZXkgOiB2b2lkIDAsIGVuZFNwYW5LZXkgPSBpc0tleVNlZ21lbnQoZW5kUG9pbnQucGF0aFsyXSkgPyBlbmRQb2ludC5wYXRoWzJdLl9rZXkgOiB2b2lkIDA7XG4gIGZvciAoY29uc3QgYmxvY2sgb2Ygc25hcHNob3QuY29udGV4dC52YWx1ZSlcbiAgICBpZiAoaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soYmxvY2spKSB7XG4gICAgICBpZiAoYmxvY2suX2tleSA9PT0gc3RhcnRCbG9ja0tleSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGJsb2NrLmNoaWxkcmVuKVxuICAgICAgICAgIGlmIChpc1BvcnRhYmxlVGV4dFNwYW4oY2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRTcGFuS2V5ICYmIGNoaWxkLl9rZXkgPT09IHN0YXJ0U3BhbktleSkge1xuICAgICAgICAgICAgICBpZiAoc3RhcnRQb2ludC5vZmZzZXQgPCBjaGlsZC50ZXh0Lmxlbmd0aCAmJiBzZWxlY3RlZFNwYW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgfSksIHN0YXJ0U3BhbktleSA9PT0gZW5kU3BhbktleSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kU3BhbktleSAmJiBjaGlsZC5fa2V5ID09PSBlbmRTcGFuS2V5KSB7XG4gICAgICAgICAgICAgIGVuZFBvaW50Lm9mZnNldCA+IDAgJiYgc2VsZWN0ZWRTcGFucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdGVkU3BhbnMubGVuZ3RoID4gMCAmJiBzZWxlY3RlZFNwYW5zLnB1c2goe1xuICAgICAgICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0QmxvY2tLZXkgPT09IGVuZEJsb2NrS2V5KVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChibG9jay5fa2V5ID09PSBlbmRCbG9ja0tleSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGJsb2NrLmNoaWxkcmVuKVxuICAgICAgICAgIGlmIChpc1BvcnRhYmxlVGV4dFNwYW4oY2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAoZW5kU3BhbktleSAmJiBjaGlsZC5fa2V5ID09PSBlbmRTcGFuS2V5KSB7XG4gICAgICAgICAgICAgIGVuZFBvaW50Lm9mZnNldCA+IDAgJiYgc2VsZWN0ZWRTcGFucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdGVkU3BhbnMucHVzaCh7XG4gICAgICAgICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RlZFNwYW5zLmxlbmd0aCA+IDApXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgYmxvY2suY2hpbGRyZW4pXG4gICAgICAgICAgaXNQb3J0YWJsZVRleHRTcGFuKGNoaWxkKSAmJiBzZWxlY3RlZFNwYW5zLnB1c2goe1xuICAgICAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9KTtcbiAgICB9XG4gIHJldHVybiBzZWxlY3RlZFNwYW5zO1xufSwgZ2V0QWN0aXZlTGlzdEl0ZW0gPSAoc25hcHNob3QpID0+IHtcbiAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICByZXR1cm47XG4gIGNvbnN0IGd1YXJkcyA9IGNyZWF0ZUd1YXJkcyhzbmFwc2hvdC5jb250ZXh0KSwgc2VsZWN0ZWRUZXh0QmxvY2tzID0gZ2V0U2VsZWN0ZWRCbG9ja3Moc25hcHNob3QpLm1hcCgoYmxvY2spID0+IGJsb2NrLm5vZGUpLmZpbHRlcihndWFyZHMuaXNUZXh0QmxvY2spLCBmaXJzdFRleHRCbG9jayA9IHNlbGVjdGVkVGV4dEJsb2Nrcy5hdCgwKTtcbiAgaWYgKCFmaXJzdFRleHRCbG9jaylcbiAgICByZXR1cm47XG4gIGNvbnN0IGZpcnN0TGlzdEl0ZW0gPSBmaXJzdFRleHRCbG9jay5saXN0SXRlbTtcbiAgaWYgKGZpcnN0TGlzdEl0ZW0gJiYgc2VsZWN0ZWRUZXh0QmxvY2tzLmV2ZXJ5KChibG9jaykgPT4gYmxvY2subGlzdEl0ZW0gPT09IGZpcnN0TGlzdEl0ZW0pKVxuICAgIHJldHVybiBmaXJzdExpc3RJdGVtO1xufSwgZ2V0QWN0aXZlU3R5bGUgPSAoc25hcHNob3QpID0+IHtcbiAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICByZXR1cm47XG4gIGNvbnN0IGd1YXJkcyA9IGNyZWF0ZUd1YXJkcyhzbmFwc2hvdC5jb250ZXh0KSwgc2VsZWN0ZWRUZXh0QmxvY2tzID0gZ2V0U2VsZWN0ZWRCbG9ja3Moc25hcHNob3QpLm1hcCgoYmxvY2spID0+IGJsb2NrLm5vZGUpLmZpbHRlcihndWFyZHMuaXNUZXh0QmxvY2spLCBmaXJzdFRleHRCbG9jayA9IHNlbGVjdGVkVGV4dEJsb2Nrcy5hdCgwKTtcbiAgaWYgKCFmaXJzdFRleHRCbG9jaylcbiAgICByZXR1cm47XG4gIGNvbnN0IGZpcnN0U3R5bGUgPSBmaXJzdFRleHRCbG9jay5zdHlsZTtcbiAgaWYgKGZpcnN0U3R5bGUgJiYgc2VsZWN0ZWRUZXh0QmxvY2tzLmV2ZXJ5KChibG9jaykgPT4gYmxvY2suc3R5bGUgPT09IGZpcnN0U3R5bGUpKVxuICAgIHJldHVybiBmaXJzdFN0eWxlO1xufSwgZ2V0VHJpbW1lZFNlbGVjdGlvbiA9IChzbmFwc2hvdCkgPT4ge1xuICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKVxuICAgIHJldHVybiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbjtcbiAgY29uc3Qgc3RhcnRQb2ludCA9IGdldFNlbGVjdGlvblN0YXJ0UG9pbnQoc25hcHNob3QpLCBlbmRQb2ludCA9IGdldFNlbGVjdGlvbkVuZFBvaW50KHNuYXBzaG90KTtcbiAgaWYgKCFzdGFydFBvaW50IHx8ICFlbmRQb2ludClcbiAgICByZXR1cm4gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb247XG4gIGNvbnN0IHN0YXJ0QmxvY2tLZXkgPSBpc0tleWVkU2VnbWVudChzdGFydFBvaW50LnBhdGhbMF0pID8gc3RhcnRQb2ludC5wYXRoWzBdLl9rZXkgOiBudWxsLCBzdGFydENoaWxkS2V5ID0gaXNLZXllZFNlZ21lbnQoc3RhcnRQb2ludC5wYXRoWzJdKSA/IHN0YXJ0UG9pbnQucGF0aFsyXS5fa2V5IDogbnVsbCwgZW5kQmxvY2tLZXkgPSBpc0tleWVkU2VnbWVudChlbmRQb2ludC5wYXRoWzBdKSA/IGVuZFBvaW50LnBhdGhbMF0uX2tleSA6IG51bGwsIGVuZENoaWxkS2V5ID0gaXNLZXllZFNlZ21lbnQoZW5kUG9pbnQucGF0aFsyXSkgPyBlbmRQb2ludC5wYXRoWzJdLl9rZXkgOiBudWxsO1xuICBpZiAoIXN0YXJ0QmxvY2tLZXkgfHwgIWVuZEJsb2NrS2V5KVxuICAgIHJldHVybiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbjtcbiAgbGV0IHN0YXJ0QmxvY2tGb3VuZCA9ICExLCBhZGp1c3RlZFN0YXJ0UG9pbnQsIHRyaW1TdGFydFBvaW50ID0gITEsIGFkanVzdGVkRW5kUG9pbnQsIHRyaW1FbmRQb2ludCA9ICExLCBwcmV2aW91c1BvdGVudGlhbEVuZHBvaW50O1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIHNuYXBzaG90LmNvbnRleHQudmFsdWUpXG4gICAgaWYgKCEoYmxvY2suX2tleSA9PT0gc3RhcnRCbG9ja0tleSAmJiAoc3RhcnRCbG9ja0ZvdW5kID0gITAsIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKGJsb2NrKSAmJiBpc0VtcHR5VGV4dEJsb2NrKGJsb2NrKSkpICYmIHN0YXJ0QmxvY2tGb3VuZCAmJiBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhibG9jaykpIHtcbiAgICAgIGlmIChibG9jay5fa2V5ID09PSBlbmRCbG9ja0tleSAmJiBpc0VtcHR5VGV4dEJsb2NrKGJsb2NrKSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGJsb2NrLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZC5fa2V5ID09PSBlbmRDaGlsZEtleSAmJiAoIWlzUG9ydGFibGVUZXh0U3BhbihjaGlsZCkgfHwgZW5kUG9pbnQub2Zmc2V0ID09PSAwKSkge1xuICAgICAgICAgIGFkanVzdGVkRW5kUG9pbnQgPSBwcmV2aW91c1BvdGVudGlhbEVuZHBvaW50ID8ge1xuICAgICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgICAgX2tleTogcHJldmlvdXNQb3RlbnRpYWxFbmRwb2ludC5ibG9ja0tleVxuICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgIF9rZXk6IHByZXZpb3VzUG90ZW50aWFsRW5kcG9pbnQuc3Bhbi5fa2V5XG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIG9mZnNldDogcHJldmlvdXNQb3RlbnRpYWxFbmRwb2ludC5zcGFuLnRleHQubGVuZ3RoXG4gICAgICAgICAgfSA6IHZvaWQgMCwgdHJpbUVuZFBvaW50ID0gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyaW1TdGFydFBvaW50KSB7XG4gICAgICAgICAgY29uc3QgbG9uZWx5U3BhbiA9IGlzUG9ydGFibGVUZXh0U3BhbihjaGlsZCkgJiYgYmxvY2suY2hpbGRyZW4ubGVuZ3RoID09PSAxO1xuICAgICAgICAgIChpc1BvcnRhYmxlVGV4dFNwYW4oY2hpbGQpICYmIGNoaWxkLnRleHQubGVuZ3RoID4gMCB8fCBsb25lbHlTcGFuKSAmJiAoYWRqdXN0ZWRTdGFydFBvaW50ID0ge1xuICAgICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgfSwgcHJldmlvdXNQb3RlbnRpYWxFbmRwb2ludCA9IHtcbiAgICAgICAgICAgIGJsb2NrS2V5OiBibG9jay5fa2V5LFxuICAgICAgICAgICAgc3BhbjogY2hpbGRcbiAgICAgICAgICB9LCB0cmltU3RhcnRQb2ludCA9ICExKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQuX2tleSA9PT0gc3RhcnRDaGlsZEtleSkge1xuICAgICAgICAgIGlmICghaXNQb3J0YWJsZVRleHRTcGFuKGNoaWxkKSkge1xuICAgICAgICAgICAgdHJpbVN0YXJ0UG9pbnQgPSAhMDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnRQb2ludC5vZmZzZXQgPT09IGNoaWxkLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0cmltU3RhcnRQb2ludCA9ICEwLCBwcmV2aW91c1BvdGVudGlhbEVuZHBvaW50ID0gY2hpbGQudGV4dC5sZW5ndGggPiAwID8ge1xuICAgICAgICAgICAgICBibG9ja0tleTogYmxvY2suX2tleSxcbiAgICAgICAgICAgICAgc3BhbjogY2hpbGRcbiAgICAgICAgICAgIH0gOiBwcmV2aW91c1BvdGVudGlhbEVuZHBvaW50O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzUG90ZW50aWFsRW5kcG9pbnQgPSBpc1BvcnRhYmxlVGV4dFNwYW4oY2hpbGQpICYmIGNoaWxkLnRleHQubGVuZ3RoID4gMCA/IHtcbiAgICAgICAgICBibG9ja0tleTogYmxvY2suX2tleSxcbiAgICAgICAgICBzcGFuOiBjaGlsZFxuICAgICAgICB9IDogcHJldmlvdXNQb3RlbnRpYWxFbmRwb2ludDtcbiAgICAgIH1cbiAgICAgIGlmIChibG9jay5fa2V5ID09PSBlbmRCbG9ja0tleSlcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICBjb25zdCB0cmltbWVkU2VsZWN0aW9uID0gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYmFja3dhcmQgPyB7XG4gICAgYW5jaG9yOiB0cmltRW5kUG9pbnQgJiYgYWRqdXN0ZWRFbmRQb2ludCA/IGFkanVzdGVkRW5kUG9pbnQgOiBlbmRQb2ludCxcbiAgICBmb2N1czogYWRqdXN0ZWRTdGFydFBvaW50ID8/IHN0YXJ0UG9pbnQsXG4gICAgYmFja3dhcmQ6ICEwXG4gIH0gOiB7XG4gICAgYW5jaG9yOiBhZGp1c3RlZFN0YXJ0UG9pbnQgPz8gc3RhcnRQb2ludCxcbiAgICBmb2N1czogdHJpbUVuZFBvaW50ICYmIGFkanVzdGVkRW5kUG9pbnQgPyBhZGp1c3RlZEVuZFBvaW50IDogZW5kUG9pbnRcbiAgfTtcbiAgaWYgKGlzU2VsZWN0aW9uQ29sbGFwc2VkKHtcbiAgICAuLi5zbmFwc2hvdCxcbiAgICBjb250ZXh0OiB7XG4gICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgc2VsZWN0aW9uOiB0cmltbWVkU2VsZWN0aW9uXG4gICAgfVxuICB9KSkge1xuICAgIGNvbnN0IGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soe1xuICAgICAgLi4uc25hcHNob3QsXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvbjogdHJpbW1lZFNlbGVjdGlvblxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChmb2N1c1RleHRCbG9jayAmJiAhaXNFbXB0eVRleHRCbG9jayhmb2N1c1RleHRCbG9jay5ub2RlKSlcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB0cmltbWVkU2VsZWN0aW9uO1xufTtcbmZ1bmN0aW9uIGlzQWN0aXZlQW5ub3RhdGlvbihhbm5vdGF0aW9uKSB7XG4gIHJldHVybiAoc25hcHNob3QpID0+IHtcbiAgICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHNlbGVjdGVkQmxvY2tzID0gZ2V0U2VsZWN0ZWRCbG9ja3Moc25hcHNob3QpLCBmb2N1c1NwYW4gPSBnZXRGb2N1c1NwYW4oc25hcHNob3QpLCBzZWxlY3RlZFNwYW5zID0gaXNTZWxlY3Rpb25FeHBhbmRlZChzbmFwc2hvdCkgPyBnZXRTZWxlY3RlZFNwYW5zKHNuYXBzaG90KSA6IGZvY3VzU3BhbiA/IFtmb2N1c1NwYW5dIDogW107XG4gICAgaWYgKHNlbGVjdGVkU3BhbnMubGVuZ3RoID09PSAwIHx8IHNlbGVjdGVkU3BhbnMuc29tZSgoc3BhbikgPT4gIXNwYW4ubm9kZS5tYXJrcyB8fCBzcGFuLm5vZGUubWFya3M/Lmxlbmd0aCA9PT0gMCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3Qgc2VsZWN0aW9uTWFya0RlZnMgPSBzZWxlY3RlZEJsb2Nrcy5mbGF0TWFwKChibG9jaykgPT4gaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soYmxvY2subm9kZSkgPyBibG9jay5ub2RlLm1hcmtEZWZzID8/IFtdIDogW10pO1xuICAgIHJldHVybiBzZWxlY3RlZFNwYW5zLmV2ZXJ5KChzcGFuKSA9PiAoc3Bhbi5ub2RlLm1hcmtzPy5mbGF0TWFwKChtYXJrKSA9PiB7XG4gICAgICBjb25zdCBtYXJrRGVmID0gc2VsZWN0aW9uTWFya0RlZnMuZmluZCgobWFya0RlZjIpID0+IG1hcmtEZWYyLl9rZXkgPT09IG1hcmspO1xuICAgICAgcmV0dXJuIG1hcmtEZWYgPyBbbWFya0RlZi5fdHlwZV0gOiBbXTtcbiAgICB9KSA/PyBbXSkuaW5jbHVkZXMoYW5ub3RhdGlvbikpO1xuICB9O1xufVxuZnVuY3Rpb24gaXNBY3RpdmVEZWNvcmF0b3IoZGVjb3JhdG9yKSB7XG4gIHJldHVybiAoc25hcHNob3QpID0+IHtcbiAgICBpZiAoaXNTZWxlY3Rpb25FeHBhbmRlZChzbmFwc2hvdCkpIHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkU3BhbnMgPSBnZXRTZWxlY3RlZFNwYW5zKHNuYXBzaG90KTtcbiAgICAgIHJldHVybiBzZWxlY3RlZFNwYW5zLmxlbmd0aCA+IDAgJiYgc2VsZWN0ZWRTcGFucy5ldmVyeSgoc3BhbikgPT4gc3Bhbi5ub2RlLm1hcmtzPy5pbmNsdWRlcyhkZWNvcmF0b3IpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNuYXBzaG90LmNvbnRleHQuYWN0aXZlRGVjb3JhdG9ycy5pbmNsdWRlcyhkZWNvcmF0b3IpO1xuICB9O1xufVxuZnVuY3Rpb24gaXNBY3RpdmVMaXN0SXRlbShsaXN0SXRlbSkge1xuICByZXR1cm4gKHNuYXBzaG90KSA9PiBnZXRBY3RpdmVMaXN0SXRlbShzbmFwc2hvdCkgPT09IGxpc3RJdGVtO1xufVxuZnVuY3Rpb24gaXNBY3RpdmVTdHlsZShzdHlsZSkge1xuICByZXR1cm4gKHNuYXBzaG90KSA9PiBnZXRBY3RpdmVTdHlsZShzbmFwc2hvdCkgPT09IHN0eWxlO1xufVxuZXhwb3J0IHtcbiAgZ2V0QWN0aXZlTGlzdEl0ZW0sXG4gIGdldEFjdGl2ZVN0eWxlLFxuICBnZXRTZWxlY3RlZFNwYW5zLFxuICBnZXRUcmltbWVkU2VsZWN0aW9uLFxuICBpc0FjdGl2ZUFubm90YXRpb24sXG4gIGlzQWN0aXZlRGVjb3JhdG9yLFxuICBpc0FjdGl2ZUxpc3RJdGVtLFxuICBpc0FjdGl2ZVN0eWxlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0b3IuaXMtYWN0aXZlLXN0eWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-active-style.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-at-the-start-of-block.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-at-the-start-of-block.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGuards: () => (/* binding */ createGuards),\n/* harmony export */   getCaretWordSelection: () => (/* binding */ getCaretWordSelection),\n/* harmony export */   getFirstBlock: () => (/* binding */ getFirstBlock),\n/* harmony export */   getFocusBlock: () => (/* binding */ getFocusBlock),\n/* harmony export */   getFocusBlockObject: () => (/* binding */ getFocusBlockObject),\n/* harmony export */   getFocusChild: () => (/* binding */ getFocusChild),\n/* harmony export */   getFocusListBlock: () => (/* binding */ getFocusListBlock),\n/* harmony export */   getFocusSpan: () => (/* binding */ getFocusSpan),\n/* harmony export */   getFocusTextBlock: () => (/* binding */ getFocusTextBlock),\n/* harmony export */   getLastBlock: () => (/* binding */ getLastBlock),\n/* harmony export */   getNextBlock: () => (/* binding */ getNextBlock),\n/* harmony export */   getNextInlineObject: () => (/* binding */ getNextInlineObject),\n/* harmony export */   getPreviousBlock: () => (/* binding */ getPreviousBlock),\n/* harmony export */   getPreviousInlineObject: () => (/* binding */ getPreviousInlineObject),\n/* harmony export */   getSelectedBlocks: () => (/* binding */ getSelectedBlocks),\n/* harmony export */   getSelectedSlice: () => (/* binding */ getSelectedSlice),\n/* harmony export */   getSelectionEndBlock: () => (/* binding */ getSelectionEndBlock),\n/* harmony export */   getSelectionEndPoint: () => (/* binding */ getSelectionEndPoint),\n/* harmony export */   getSelectionStartBlock: () => (/* binding */ getSelectionStartBlock),\n/* harmony export */   getSelectionStartPoint: () => (/* binding */ getSelectionStartPoint),\n/* harmony export */   getSelectionText: () => (/* binding */ getSelectionText),\n/* harmony export */   isAtTheEndOfBlock: () => (/* binding */ isAtTheEndOfBlock),\n/* harmony export */   isAtTheStartOfBlock: () => (/* binding */ isAtTheStartOfBlock),\n/* harmony export */   isSelectionCollapsed: () => (/* binding */ isSelectionCollapsed),\n/* harmony export */   isSelectionExpanded: () => (/* binding */ isSelectionExpanded)\n/* harmony export */ });\n/* harmony import */ var _util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.slice-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\");\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n\n\nfunction createGuards({\n  schema\n}) {\n  function isListBlock(block) {\n    return (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextListBlock)(block) && block._type === schema.block.name;\n  }\n  function isTextBlock(block) {\n    return (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block) && block._type === schema.block.name;\n  }\n  return {\n    isListBlock,\n    isTextBlock\n  };\n}\nconst getFocusBlock = (snapshot) => {\n  const key = snapshot.context.selection && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(snapshot.context.selection.focus.path[0]) ? snapshot.context.selection.focus.path[0]._key : void 0, node = key ? snapshot.context.value.find((block) => block._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [{\n      _key: key\n    }]\n  } : void 0;\n}, getFocusListBlock = (snapshot) => {\n  const guards = createGuards(snapshot.context), focusBlock = getFocusBlock(snapshot);\n  return focusBlock && guards.isListBlock(focusBlock.node) ? {\n    node: focusBlock.node,\n    path: focusBlock.path\n  } : void 0;\n}, getFocusTextBlock = (snapshot) => {\n  const focusBlock = getFocusBlock(snapshot);\n  return focusBlock && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(focusBlock.node) ? {\n    node: focusBlock.node,\n    path: focusBlock.path\n  } : void 0;\n}, getFocusBlockObject = (snapshot) => {\n  const focusBlock = getFocusBlock(snapshot);\n  return focusBlock && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(focusBlock.node) ? {\n    node: focusBlock.node,\n    path: focusBlock.path\n  } : void 0;\n}, getFocusChild = (snapshot) => {\n  const focusBlock = getFocusTextBlock(snapshot);\n  if (!focusBlock)\n    return;\n  const key = snapshot.context.selection && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(snapshot.context.selection.focus.path[2]) ? snapshot.context.selection.focus.path[2]._key : void 0, node = key ? focusBlock.node.children.find((span) => span._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [...focusBlock.path, \"children\", {\n      _key: key\n    }]\n  } : void 0;\n}, getFocusSpan = (snapshot) => {\n  const focusChild = getFocusChild(snapshot);\n  return focusChild && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(focusChild.node) ? {\n    node: focusChild.node,\n    path: focusChild.path\n  } : void 0;\n}, getFirstBlock = (snapshot) => {\n  const node = snapshot.context.value[0];\n  return node ? {\n    node,\n    path: [{\n      _key: node._key\n    }]\n  } : void 0;\n}, getLastBlock = (snapshot) => {\n  const node = snapshot.context.value[snapshot.context.value.length - 1] ? snapshot.context.value[snapshot.context.value.length - 1] : void 0;\n  return node ? {\n    node,\n    path: [{\n      _key: node._key\n    }]\n  } : void 0;\n}, getSelectedBlocks = (snapshot) => {\n  if (!snapshot.context.selection)\n    return [];\n  const selectedBlocks = [], startKey = snapshot.context.selection.backward ? (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(snapshot.context.selection.focus.path[0]) ? snapshot.context.selection.focus.path[0]._key : void 0 : (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(snapshot.context.selection.anchor.path[0]) ? snapshot.context.selection.anchor.path[0]._key : void 0, endKey = snapshot.context.selection.backward ? (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(snapshot.context.selection.anchor.path[0]) ? snapshot.context.selection.anchor.path[0]._key : void 0 : (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(snapshot.context.selection.focus.path[0]) ? snapshot.context.selection.focus.path[0]._key : void 0;\n  if (!startKey || !endKey)\n    return selectedBlocks;\n  for (const block of snapshot.context.value) {\n    if (block._key === startKey) {\n      if (selectedBlocks.push({\n        node: block,\n        path: [{\n          _key: block._key\n        }]\n      }), startKey === endKey)\n        break;\n      continue;\n    }\n    if (block._key === endKey) {\n      selectedBlocks.push({\n        node: block,\n        path: [{\n          _key: block._key\n        }]\n      });\n      break;\n    }\n    selectedBlocks.length > 0 && selectedBlocks.push({\n      node: block,\n      path: [{\n        _key: block._key\n      }]\n    });\n  }\n  return selectedBlocks;\n}, getSelectionStartBlock = (snapshot) => {\n  if (!snapshot.context.selection)\n    return;\n  const key = snapshot.context.selection.backward ? (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(snapshot.context.selection.focus.path[0]) ? snapshot.context.selection.focus.path[0]._key : void 0 : (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(snapshot.context.selection.anchor.path[0]) ? snapshot.context.selection.anchor.path[0]._key : void 0, node = key ? snapshot.context.value.find((block) => block._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [{\n      _key: key\n    }]\n  } : void 0;\n}, getSelectionEndBlock = (snapshot) => {\n  if (!snapshot.context.selection)\n    return;\n  const key = snapshot.context.selection.backward ? (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(snapshot.context.selection.anchor.path[0]) ? snapshot.context.selection.anchor.path[0]._key : void 0 : (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(snapshot.context.selection.focus.path[0]) ? snapshot.context.selection.focus.path[0]._key : void 0, node = key ? snapshot.context.value.find((block) => block._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [{\n      _key: key\n    }]\n  } : void 0;\n}, getPreviousBlock = (snapshot) => {\n  let previousBlock;\n  const selectionStartBlock = getSelectionStartBlock(snapshot);\n  if (!selectionStartBlock)\n    return;\n  let foundSelectionStartBlock = !1;\n  for (const block of snapshot.context.value) {\n    if (block._key === selectionStartBlock.node._key) {\n      foundSelectionStartBlock = !0;\n      break;\n    }\n    previousBlock = {\n      node: block,\n      path: [{\n        _key: block._key\n      }]\n    };\n  }\n  if (foundSelectionStartBlock && previousBlock)\n    return previousBlock;\n}, getNextBlock = (snapshot) => {\n  let nextBlock;\n  const selectionEndBlock = getSelectionEndBlock(snapshot);\n  if (!selectionEndBlock)\n    return;\n  let foundSelectionEndBlock = !1;\n  for (const block of snapshot.context.value) {\n    if (block._key === selectionEndBlock.node._key) {\n      foundSelectionEndBlock = !0;\n      continue;\n    }\n    if (foundSelectionEndBlock) {\n      nextBlock = {\n        node: block,\n        path: [{\n          _key: block._key\n        }]\n      };\n      break;\n    }\n  }\n  if (foundSelectionEndBlock && nextBlock)\n    return nextBlock;\n}, getSelectionEndPoint = (snapshot) => {\n  if (snapshot.context.selection)\n    return snapshot.context.selection.backward ? snapshot.context.selection.anchor : snapshot.context.selection.focus;\n}, getSelectionStartPoint = (snapshot) => {\n  if (snapshot.context.selection)\n    return snapshot.context.selection.backward ? snapshot.context.selection.focus : snapshot.context.selection.anchor;\n}, getNextInlineObject = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot), selectionEndPoint = getSelectionEndPoint(snapshot), selectionEndPointChildKey = selectionEndPoint && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(selectionEndPoint.path[2]) ? selectionEndPoint.path[2]._key : void 0;\n  if (!focusTextBlock || !selectionEndPointChildKey)\n    return;\n  let endPointChildFound = !1, inlineObject;\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = !0;\n      continue;\n    }\n    if (!(0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__.isSpan)(snapshot.context, child) && endPointChildFound) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, \"children\", {\n          _key: child._key\n        }]\n      };\n      break;\n    }\n  }\n  return inlineObject;\n}, getPreviousInlineObject = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot), selectionStartPoint = getSelectionStartPoint(snapshot), selectionStartPointChildKey = selectionStartPoint && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(selectionStartPoint.path[2]) ? selectionStartPoint.path[2]._key : void 0;\n  if (!focusTextBlock || !selectionStartPointChildKey)\n    return;\n  let inlineObject;\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionStartPointChildKey)\n      break;\n    (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__.isSpan)(snapshot.context, child) || (inlineObject = {\n      node: child,\n      path: [...focusTextBlock.path, \"children\", {\n        _key: child._key\n      }]\n    });\n  }\n  return inlineObject;\n}, getSelectedSlice = (snapshot) => (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__.sliceBlocks)({\n  blocks: snapshot.context.value,\n  selection: snapshot.context.selection\n}), getSelectionText = (snapshot) => getSelectedSlice(snapshot).reduce((text, block) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block) ? text + block.children.reduce((text2, child) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(child) ? text2 + child.text : text2, \"\") : text, \"\"), isSelectionCollapsed = (snapshot) => snapshot.context.selection ? JSON.stringify(snapshot.context.selection.anchor.path) === JSON.stringify(snapshot.context.selection.focus.path) && snapshot.context.selection?.anchor.offset === snapshot.context.selection?.focus.offset : !1, isSelectionExpanded = (snapshot) => !isSelectionCollapsed(snapshot), getCaretWordSelection = (snapshot) => {\n  if (!snapshot.context.selection || !isSelectionCollapsed(snapshot))\n    return null;\n  const focusTextBlock = getFocusTextBlock(snapshot), selectionStartPoint = getSelectionStartPoint(snapshot), selectionStartOffset = selectionStartPoint ? (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__.spanSelectionPointToBlockOffset)({\n    value: snapshot.context.value,\n    selectionPoint: selectionStartPoint\n  }) : void 0;\n  if (!focusTextBlock || !selectionStartPoint || !selectionStartOffset)\n    return null;\n  const previousInlineObject = getPreviousInlineObject(snapshot), blockStartPoint = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__.getBlockStartPoint)(focusTextBlock), textDirectlyBefore = getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: previousInlineObject ? {\n          path: previousInlineObject.path,\n          offset: 0\n        } : blockStartPoint,\n        focus: selectionStartPoint\n      }\n    }\n  }).split(/\\s+/).at(-1), nextInlineObject = getNextInlineObject(snapshot), blockEndPoint = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__.getBlockEndPoint)(focusTextBlock), textDirectlyAfter = getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: selectionStartPoint,\n        focus: nextInlineObject ? {\n          path: nextInlineObject.path,\n          offset: 0\n        } : blockEndPoint\n      }\n    }\n  }).split(/\\s+/).at(0);\n  if ((textDirectlyBefore === void 0 || textDirectlyBefore === \"\") && (textDirectlyAfter === void 0 || textDirectlyAfter === \"\"))\n    return null;\n  const caretWordStartOffset = textDirectlyBefore ? {\n    ...selectionStartOffset,\n    offset: selectionStartOffset.offset - textDirectlyBefore.length\n  } : selectionStartOffset, caretWordEndOffset = textDirectlyAfter ? {\n    ...selectionStartOffset,\n    offset: selectionStartOffset.offset + textDirectlyAfter.length\n  } : selectionStartOffset, caretWordStartSelectionPoint = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__.blockOffsetToSpanSelectionPoint)({\n    value: snapshot.context.value,\n    blockOffset: caretWordStartOffset,\n    direction: \"backward\"\n  }), caretWordEndSelectionPoint = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__.blockOffsetToSpanSelectionPoint)({\n    value: snapshot.context.value,\n    blockOffset: caretWordEndOffset,\n    direction: \"forward\"\n  });\n  if (!caretWordStartSelectionPoint || !caretWordEndSelectionPoint)\n    return null;\n  const caretWordSelection = {\n    anchor: caretWordStartSelectionPoint,\n    focus: caretWordEndSelectionPoint\n  };\n  return isSelectionExpanded({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: caretWordSelection\n    }\n  }) ? caretWordSelection : null;\n};\nfunction isAtTheEndOfBlock(block) {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot))\n      return !1;\n    const blockEndPoint = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__.getBlockEndPoint)(block);\n    return (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__.isEqualSelectionPoints)(snapshot.context.selection.focus, blockEndPoint);\n  };\n}\nfunction isAtTheStartOfBlock(block) {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot))\n      return !1;\n    const blockStartPoint = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__.getBlockStartPoint)(block);\n    return (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_1__.isEqualSelectionPoints)(snapshot.context.selection.focus, blockStartPoint);\n  };\n}\n\n//# sourceMappingURL=selector.is-at-the-start-of-block.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvc2VsZWN0b3IuaXMtYXQtdGhlLXN0YXJ0LW9mLWJsb2NrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2TDtBQUMxRTtBQUNuSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsV0FBVyxzRUFBdUI7QUFDbEM7QUFDQTtBQUNBLFdBQVcsc0VBQXVCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJEQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osQ0FBQztBQUNEO0FBQ0EsdUJBQXVCLHNFQUF1QjtBQUM5QztBQUNBO0FBQ0EsSUFBSTtBQUNKLENBQUM7QUFDRDtBQUNBLHdCQUF3QixzRUFBdUI7QUFDL0M7QUFDQTtBQUNBLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJEQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQSx1QkFBdUIsaUVBQWtCO0FBQ3pDO0FBQ0E7QUFDQSxJQUFJO0FBQ0osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQTtBQUNBLDhFQUE4RSwyREFBWSxzR0FBc0csMkRBQVksc0pBQXNKLDJEQUFZLHdHQUF3RywyREFBWTtBQUNsZTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG9EQUFvRCwyREFBWSxzR0FBc0csMkRBQVk7QUFDbEw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKLENBQUM7QUFDRDtBQUNBO0FBQ0Esb0RBQW9ELDJEQUFZLHdHQUF3RywyREFBWTtBQUNwTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMkpBQTJKLDJEQUFZO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZEQUFNO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtS0FBbUssMkRBQVk7QUFDL0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2REFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUMsbUNBQW1DLGtFQUFXO0FBQy9DO0FBQ0E7QUFDQSxDQUFDLHVGQUF1RixzRUFBdUIseURBQXlELGlFQUFrQjtBQUMxTDtBQUNBO0FBQ0EsMkpBQTJKLHNGQUErQjtBQUMxTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvRkFBb0YseUVBQWtCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEdBQUcseUZBQXlGLHVFQUFnQjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSSx1REFBdUQsc0ZBQStCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZ0NBQWdDLHNGQUErQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUVBQWdCO0FBQzFDLFdBQVcsNkVBQXNCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5RUFBa0I7QUFDOUMsV0FBVyw2RUFBc0I7QUFDakM7QUFDQTtBQTJCRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbWFjYm9va3Byby9Eb3dubG9hZHMvY29uaWNhcHBzL2lnZW5lL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvX2NodW5rcy1lcy9zZWxlY3Rvci5pcy1hdC10aGUtc3RhcnQtb2YtYmxvY2suanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNTcGFuLCBzbGljZUJsb2Nrcywgc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCwgZ2V0QmxvY2tTdGFydFBvaW50LCBnZXRCbG9ja0VuZFBvaW50LCBibG9ja09mZnNldFRvU3BhblNlbGVjdGlvblBvaW50LCBpc0VxdWFsU2VsZWN0aW9uUG9pbnRzIH0gZnJvbSBcIi4vdXRpbC5zbGljZS1ibG9ja3MuanNcIjtcbmltcG9ydCB7IGlzUG9ydGFibGVUZXh0TGlzdEJsb2NrLCBpc1BvcnRhYmxlVGV4dFRleHRCbG9jaywgaXNLZXlTZWdtZW50LCBpc1BvcnRhYmxlVGV4dFNwYW4gfSBmcm9tIFwiQHNhbml0eS90eXBlc1wiO1xuZnVuY3Rpb24gY3JlYXRlR3VhcmRzKHtcbiAgc2NoZW1hXG59KSB7XG4gIGZ1bmN0aW9uIGlzTGlzdEJsb2NrKGJsb2NrKSB7XG4gICAgcmV0dXJuIGlzUG9ydGFibGVUZXh0TGlzdEJsb2NrKGJsb2NrKSAmJiBibG9jay5fdHlwZSA9PT0gc2NoZW1hLmJsb2NrLm5hbWU7XG4gIH1cbiAgZnVuY3Rpb24gaXNUZXh0QmxvY2soYmxvY2spIHtcbiAgICByZXR1cm4gaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soYmxvY2spICYmIGJsb2NrLl90eXBlID09PSBzY2hlbWEuYmxvY2submFtZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzTGlzdEJsb2NrLFxuICAgIGlzVGV4dEJsb2NrXG4gIH07XG59XG5jb25zdCBnZXRGb2N1c0Jsb2NrID0gKHNuYXBzaG90KSA9PiB7XG4gIGNvbnN0IGtleSA9IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uICYmIGlzS2V5U2VnbWVudChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdKSA/IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0uX2tleSA6IHZvaWQgMCwgbm9kZSA9IGtleSA/IHNuYXBzaG90LmNvbnRleHQudmFsdWUuZmluZCgoYmxvY2spID0+IGJsb2NrLl9rZXkgPT09IGtleSkgOiB2b2lkIDA7XG4gIHJldHVybiBub2RlICYmIGtleSA/IHtcbiAgICBub2RlLFxuICAgIHBhdGg6IFt7XG4gICAgICBfa2V5OiBrZXlcbiAgICB9XVxuICB9IDogdm9pZCAwO1xufSwgZ2V0Rm9jdXNMaXN0QmxvY2sgPSAoc25hcHNob3QpID0+IHtcbiAgY29uc3QgZ3VhcmRzID0gY3JlYXRlR3VhcmRzKHNuYXBzaG90LmNvbnRleHQpLCBmb2N1c0Jsb2NrID0gZ2V0Rm9jdXNCbG9jayhzbmFwc2hvdCk7XG4gIHJldHVybiBmb2N1c0Jsb2NrICYmIGd1YXJkcy5pc0xpc3RCbG9jayhmb2N1c0Jsb2NrLm5vZGUpID8ge1xuICAgIG5vZGU6IGZvY3VzQmxvY2subm9kZSxcbiAgICBwYXRoOiBmb2N1c0Jsb2NrLnBhdGhcbiAgfSA6IHZvaWQgMDtcbn0sIGdldEZvY3VzVGV4dEJsb2NrID0gKHNuYXBzaG90KSA9PiB7XG4gIGNvbnN0IGZvY3VzQmxvY2sgPSBnZXRGb2N1c0Jsb2NrKHNuYXBzaG90KTtcbiAgcmV0dXJuIGZvY3VzQmxvY2sgJiYgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soZm9jdXNCbG9jay5ub2RlKSA/IHtcbiAgICBub2RlOiBmb2N1c0Jsb2NrLm5vZGUsXG4gICAgcGF0aDogZm9jdXNCbG9jay5wYXRoXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRGb2N1c0Jsb2NrT2JqZWN0ID0gKHNuYXBzaG90KSA9PiB7XG4gIGNvbnN0IGZvY3VzQmxvY2sgPSBnZXRGb2N1c0Jsb2NrKHNuYXBzaG90KTtcbiAgcmV0dXJuIGZvY3VzQmxvY2sgJiYgIWlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKGZvY3VzQmxvY2subm9kZSkgPyB7XG4gICAgbm9kZTogZm9jdXNCbG9jay5ub2RlLFxuICAgIHBhdGg6IGZvY3VzQmxvY2sucGF0aFxuICB9IDogdm9pZCAwO1xufSwgZ2V0Rm9jdXNDaGlsZCA9IChzbmFwc2hvdCkgPT4ge1xuICBjb25zdCBmb2N1c0Jsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soc25hcHNob3QpO1xuICBpZiAoIWZvY3VzQmxvY2spXG4gICAgcmV0dXJuO1xuICBjb25zdCBrZXkgPSBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiAmJiBpc0tleVNlZ21lbnQoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFsyXSkgPyBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzJdLl9rZXkgOiB2b2lkIDAsIG5vZGUgPSBrZXkgPyBmb2N1c0Jsb2NrLm5vZGUuY2hpbGRyZW4uZmluZCgoc3BhbikgPT4gc3Bhbi5fa2V5ID09PSBrZXkpIDogdm9pZCAwO1xuICByZXR1cm4gbm9kZSAmJiBrZXkgPyB7XG4gICAgbm9kZSxcbiAgICBwYXRoOiBbLi4uZm9jdXNCbG9jay5wYXRoLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgIF9rZXk6IGtleVxuICAgIH1dXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRGb2N1c1NwYW4gPSAoc25hcHNob3QpID0+IHtcbiAgY29uc3QgZm9jdXNDaGlsZCA9IGdldEZvY3VzQ2hpbGQoc25hcHNob3QpO1xuICByZXR1cm4gZm9jdXNDaGlsZCAmJiBpc1BvcnRhYmxlVGV4dFNwYW4oZm9jdXNDaGlsZC5ub2RlKSA/IHtcbiAgICBub2RlOiBmb2N1c0NoaWxkLm5vZGUsXG4gICAgcGF0aDogZm9jdXNDaGlsZC5wYXRoXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRGaXJzdEJsb2NrID0gKHNuYXBzaG90KSA9PiB7XG4gIGNvbnN0IG5vZGUgPSBzbmFwc2hvdC5jb250ZXh0LnZhbHVlWzBdO1xuICByZXR1cm4gbm9kZSA/IHtcbiAgICBub2RlLFxuICAgIHBhdGg6IFt7XG4gICAgICBfa2V5OiBub2RlLl9rZXlcbiAgICB9XVxuICB9IDogdm9pZCAwO1xufSwgZ2V0TGFzdEJsb2NrID0gKHNuYXBzaG90KSA9PiB7XG4gIGNvbnN0IG5vZGUgPSBzbmFwc2hvdC5jb250ZXh0LnZhbHVlW3NuYXBzaG90LmNvbnRleHQudmFsdWUubGVuZ3RoIC0gMV0gPyBzbmFwc2hvdC5jb250ZXh0LnZhbHVlW3NuYXBzaG90LmNvbnRleHQudmFsdWUubGVuZ3RoIC0gMV0gOiB2b2lkIDA7XG4gIHJldHVybiBub2RlID8ge1xuICAgIG5vZGUsXG4gICAgcGF0aDogW3tcbiAgICAgIF9rZXk6IG5vZGUuX2tleVxuICAgIH1dXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRTZWxlY3RlZEJsb2NrcyA9IChzbmFwc2hvdCkgPT4ge1xuICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3Qgc2VsZWN0ZWRCbG9ja3MgPSBbXSwgc3RhcnRLZXkgPSBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IGlzS2V5U2VnbWVudChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdKSA/IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0uX2tleSA6IHZvaWQgMCA6IGlzS2V5U2VnbWVudChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXSkgPyBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXS5fa2V5IDogdm9pZCAwLCBlbmRLZXkgPSBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IGlzS2V5U2VnbWVudChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXSkgPyBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXS5fa2V5IDogdm9pZCAwIDogaXNLZXlTZWdtZW50KHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0pID8gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFswXS5fa2V5IDogdm9pZCAwO1xuICBpZiAoIXN0YXJ0S2V5IHx8ICFlbmRLZXkpXG4gICAgcmV0dXJuIHNlbGVjdGVkQmxvY2tzO1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIHNuYXBzaG90LmNvbnRleHQudmFsdWUpIHtcbiAgICBpZiAoYmxvY2suX2tleSA9PT0gc3RhcnRLZXkpIHtcbiAgICAgIGlmIChzZWxlY3RlZEJsb2Nrcy5wdXNoKHtcbiAgICAgICAgbm9kZTogYmxvY2ssXG4gICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICB9XVxuICAgICAgfSksIHN0YXJ0S2V5ID09PSBlbmRLZXkpXG4gICAgICAgIGJyZWFrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChibG9jay5fa2V5ID09PSBlbmRLZXkpIHtcbiAgICAgIHNlbGVjdGVkQmxvY2tzLnB1c2goe1xuICAgICAgICBub2RlOiBibG9jayxcbiAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgIH1dXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzZWxlY3RlZEJsb2Nrcy5sZW5ndGggPiAwICYmIHNlbGVjdGVkQmxvY2tzLnB1c2goe1xuICAgICAgbm9kZTogYmxvY2ssXG4gICAgICBwYXRoOiBbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9XVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzZWxlY3RlZEJsb2Nrcztcbn0sIGdldFNlbGVjdGlvblN0YXJ0QmxvY2sgPSAoc25hcHNob3QpID0+IHtcbiAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICByZXR1cm47XG4gIGNvbnN0IGtleSA9IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmJhY2t3YXJkID8gaXNLZXlTZWdtZW50KHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0pID8gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFswXS5fa2V5IDogdm9pZCAwIDogaXNLZXlTZWdtZW50KHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmFuY2hvci5wYXRoWzBdKSA/IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmFuY2hvci5wYXRoWzBdLl9rZXkgOiB2b2lkIDAsIG5vZGUgPSBrZXkgPyBzbmFwc2hvdC5jb250ZXh0LnZhbHVlLmZpbmQoKGJsb2NrKSA9PiBibG9jay5fa2V5ID09PSBrZXkpIDogdm9pZCAwO1xuICByZXR1cm4gbm9kZSAmJiBrZXkgPyB7XG4gICAgbm9kZSxcbiAgICBwYXRoOiBbe1xuICAgICAgX2tleToga2V5XG4gICAgfV1cbiAgfSA6IHZvaWQgMDtcbn0sIGdldFNlbGVjdGlvbkVuZEJsb2NrID0gKHNuYXBzaG90KSA9PiB7XG4gIGlmICghc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pXG4gICAgcmV0dXJuO1xuICBjb25zdCBrZXkgPSBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IGlzS2V5U2VnbWVudChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXSkgPyBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXS5fa2V5IDogdm9pZCAwIDogaXNLZXlTZWdtZW50KHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0pID8gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFswXS5fa2V5IDogdm9pZCAwLCBub2RlID0ga2V5ID8gc25hcHNob3QuY29udGV4dC52YWx1ZS5maW5kKChibG9jaykgPT4gYmxvY2suX2tleSA9PT0ga2V5KSA6IHZvaWQgMDtcbiAgcmV0dXJuIG5vZGUgJiYga2V5ID8ge1xuICAgIG5vZGUsXG4gICAgcGF0aDogW3tcbiAgICAgIF9rZXk6IGtleVxuICAgIH1dXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRQcmV2aW91c0Jsb2NrID0gKHNuYXBzaG90KSA9PiB7XG4gIGxldCBwcmV2aW91c0Jsb2NrO1xuICBjb25zdCBzZWxlY3Rpb25TdGFydEJsb2NrID0gZ2V0U2VsZWN0aW9uU3RhcnRCbG9jayhzbmFwc2hvdCk7XG4gIGlmICghc2VsZWN0aW9uU3RhcnRCbG9jaylcbiAgICByZXR1cm47XG4gIGxldCBmb3VuZFNlbGVjdGlvblN0YXJ0QmxvY2sgPSAhMTtcbiAgZm9yIChjb25zdCBibG9jayBvZiBzbmFwc2hvdC5jb250ZXh0LnZhbHVlKSB7XG4gICAgaWYgKGJsb2NrLl9rZXkgPT09IHNlbGVjdGlvblN0YXJ0QmxvY2subm9kZS5fa2V5KSB7XG4gICAgICBmb3VuZFNlbGVjdGlvblN0YXJ0QmxvY2sgPSAhMDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2aW91c0Jsb2NrID0ge1xuICAgICAgbm9kZTogYmxvY2ssXG4gICAgICBwYXRoOiBbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9XVxuICAgIH07XG4gIH1cbiAgaWYgKGZvdW5kU2VsZWN0aW9uU3RhcnRCbG9jayAmJiBwcmV2aW91c0Jsb2NrKVxuICAgIHJldHVybiBwcmV2aW91c0Jsb2NrO1xufSwgZ2V0TmV4dEJsb2NrID0gKHNuYXBzaG90KSA9PiB7XG4gIGxldCBuZXh0QmxvY2s7XG4gIGNvbnN0IHNlbGVjdGlvbkVuZEJsb2NrID0gZ2V0U2VsZWN0aW9uRW5kQmxvY2soc25hcHNob3QpO1xuICBpZiAoIXNlbGVjdGlvbkVuZEJsb2NrKVxuICAgIHJldHVybjtcbiAgbGV0IGZvdW5kU2VsZWN0aW9uRW5kQmxvY2sgPSAhMTtcbiAgZm9yIChjb25zdCBibG9jayBvZiBzbmFwc2hvdC5jb250ZXh0LnZhbHVlKSB7XG4gICAgaWYgKGJsb2NrLl9rZXkgPT09IHNlbGVjdGlvbkVuZEJsb2NrLm5vZGUuX2tleSkge1xuICAgICAgZm91bmRTZWxlY3Rpb25FbmRCbG9jayA9ICEwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChmb3VuZFNlbGVjdGlvbkVuZEJsb2NrKSB7XG4gICAgICBuZXh0QmxvY2sgPSB7XG4gICAgICAgIG5vZGU6IGJsb2NrLFxuICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgfV1cbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGZvdW5kU2VsZWN0aW9uRW5kQmxvY2sgJiYgbmV4dEJsb2NrKVxuICAgIHJldHVybiBuZXh0QmxvY2s7XG59LCBnZXRTZWxlY3Rpb25FbmRQb2ludCA9IChzbmFwc2hvdCkgPT4ge1xuICBpZiAoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pXG4gICAgcmV0dXJuIHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmJhY2t3YXJkID8gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYW5jaG9yIDogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXM7XG59LCBnZXRTZWxlY3Rpb25TdGFydFBvaW50ID0gKHNuYXBzaG90KSA9PiB7XG4gIGlmIChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICByZXR1cm4gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYmFja3dhcmQgPyBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cyA6IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmFuY2hvcjtcbn0sIGdldE5leHRJbmxpbmVPYmplY3QgPSAoc25hcHNob3QpID0+IHtcbiAgY29uc3QgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCksIHNlbGVjdGlvbkVuZFBvaW50ID0gZ2V0U2VsZWN0aW9uRW5kUG9pbnQoc25hcHNob3QpLCBzZWxlY3Rpb25FbmRQb2ludENoaWxkS2V5ID0gc2VsZWN0aW9uRW5kUG9pbnQgJiYgaXNLZXlTZWdtZW50KHNlbGVjdGlvbkVuZFBvaW50LnBhdGhbMl0pID8gc2VsZWN0aW9uRW5kUG9pbnQucGF0aFsyXS5fa2V5IDogdm9pZCAwO1xuICBpZiAoIWZvY3VzVGV4dEJsb2NrIHx8ICFzZWxlY3Rpb25FbmRQb2ludENoaWxkS2V5KVxuICAgIHJldHVybjtcbiAgbGV0IGVuZFBvaW50Q2hpbGRGb3VuZCA9ICExLCBpbmxpbmVPYmplY3Q7XG4gIGZvciAoY29uc3QgY2hpbGQgb2YgZm9jdXNUZXh0QmxvY2subm9kZS5jaGlsZHJlbikge1xuICAgIGlmIChjaGlsZC5fa2V5ID09PSBzZWxlY3Rpb25FbmRQb2ludENoaWxkS2V5KSB7XG4gICAgICBlbmRQb2ludENoaWxkRm91bmQgPSAhMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIWlzU3BhbihzbmFwc2hvdC5jb250ZXh0LCBjaGlsZCkgJiYgZW5kUG9pbnRDaGlsZEZvdW5kKSB7XG4gICAgICBpbmxpbmVPYmplY3QgPSB7XG4gICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICBwYXRoOiBbLi4uZm9jdXNUZXh0QmxvY2sucGF0aCwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICB9XVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5saW5lT2JqZWN0O1xufSwgZ2V0UHJldmlvdXNJbmxpbmVPYmplY3QgPSAoc25hcHNob3QpID0+IHtcbiAgY29uc3QgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCksIHNlbGVjdGlvblN0YXJ0UG9pbnQgPSBnZXRTZWxlY3Rpb25TdGFydFBvaW50KHNuYXBzaG90KSwgc2VsZWN0aW9uU3RhcnRQb2ludENoaWxkS2V5ID0gc2VsZWN0aW9uU3RhcnRQb2ludCAmJiBpc0tleVNlZ21lbnQoc2VsZWN0aW9uU3RhcnRQb2ludC5wYXRoWzJdKSA/IHNlbGVjdGlvblN0YXJ0UG9pbnQucGF0aFsyXS5fa2V5IDogdm9pZCAwO1xuICBpZiAoIWZvY3VzVGV4dEJsb2NrIHx8ICFzZWxlY3Rpb25TdGFydFBvaW50Q2hpbGRLZXkpXG4gICAgcmV0dXJuO1xuICBsZXQgaW5saW5lT2JqZWN0O1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGZvY3VzVGV4dEJsb2NrLm5vZGUuY2hpbGRyZW4pIHtcbiAgICBpZiAoY2hpbGQuX2tleSA9PT0gc2VsZWN0aW9uU3RhcnRQb2ludENoaWxkS2V5KVxuICAgICAgYnJlYWs7XG4gICAgaXNTcGFuKHNuYXBzaG90LmNvbnRleHQsIGNoaWxkKSB8fCAoaW5saW5lT2JqZWN0ID0ge1xuICAgICAgbm9kZTogY2hpbGQsXG4gICAgICBwYXRoOiBbLi4uZm9jdXNUZXh0QmxvY2sucGF0aCwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgIH1dXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGlubGluZU9iamVjdDtcbn0sIGdldFNlbGVjdGVkU2xpY2UgPSAoc25hcHNob3QpID0+IHNsaWNlQmxvY2tzKHtcbiAgYmxvY2tzOiBzbmFwc2hvdC5jb250ZXh0LnZhbHVlLFxuICBzZWxlY3Rpb246IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uXG59KSwgZ2V0U2VsZWN0aW9uVGV4dCA9IChzbmFwc2hvdCkgPT4gZ2V0U2VsZWN0ZWRTbGljZShzbmFwc2hvdCkucmVkdWNlKCh0ZXh0LCBibG9jaykgPT4gaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soYmxvY2spID8gdGV4dCArIGJsb2NrLmNoaWxkcmVuLnJlZHVjZSgodGV4dDIsIGNoaWxkKSA9PiBpc1BvcnRhYmxlVGV4dFNwYW4oY2hpbGQpID8gdGV4dDIgKyBjaGlsZC50ZXh0IDogdGV4dDIsIFwiXCIpIDogdGV4dCwgXCJcIiksIGlzU2VsZWN0aW9uQ29sbGFwc2VkID0gKHNuYXBzaG90KSA9PiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiA/IEpTT04uc3RyaW5naWZ5KHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmFuY2hvci5wYXRoKSA9PT0gSlNPTi5zdHJpbmdpZnkoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aCkgJiYgc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24/LmFuY2hvci5vZmZzZXQgPT09IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uPy5mb2N1cy5vZmZzZXQgOiAhMSwgaXNTZWxlY3Rpb25FeHBhbmRlZCA9IChzbmFwc2hvdCkgPT4gIWlzU2VsZWN0aW9uQ29sbGFwc2VkKHNuYXBzaG90KSwgZ2V0Q2FyZXRXb3JkU2VsZWN0aW9uID0gKHNuYXBzaG90KSA9PiB7XG4gIGlmICghc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24gfHwgIWlzU2VsZWN0aW9uQ29sbGFwc2VkKHNuYXBzaG90KSlcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCksIHNlbGVjdGlvblN0YXJ0UG9pbnQgPSBnZXRTZWxlY3Rpb25TdGFydFBvaW50KHNuYXBzaG90KSwgc2VsZWN0aW9uU3RhcnRPZmZzZXQgPSBzZWxlY3Rpb25TdGFydFBvaW50ID8gc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCh7XG4gICAgdmFsdWU6IHNuYXBzaG90LmNvbnRleHQudmFsdWUsXG4gICAgc2VsZWN0aW9uUG9pbnQ6IHNlbGVjdGlvblN0YXJ0UG9pbnRcbiAgfSkgOiB2b2lkIDA7XG4gIGlmICghZm9jdXNUZXh0QmxvY2sgfHwgIXNlbGVjdGlvblN0YXJ0UG9pbnQgfHwgIXNlbGVjdGlvblN0YXJ0T2Zmc2V0KVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBwcmV2aW91c0lubGluZU9iamVjdCA9IGdldFByZXZpb3VzSW5saW5lT2JqZWN0KHNuYXBzaG90KSwgYmxvY2tTdGFydFBvaW50ID0gZ2V0QmxvY2tTdGFydFBvaW50KGZvY3VzVGV4dEJsb2NrKSwgdGV4dERpcmVjdGx5QmVmb3JlID0gZ2V0U2VsZWN0aW9uVGV4dCh7XG4gICAgLi4uc25hcHNob3QsXG4gICAgY29udGV4dDoge1xuICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICBhbmNob3I6IHByZXZpb3VzSW5saW5lT2JqZWN0ID8ge1xuICAgICAgICAgIHBhdGg6IHByZXZpb3VzSW5saW5lT2JqZWN0LnBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0gOiBibG9ja1N0YXJ0UG9pbnQsXG4gICAgICAgIGZvY3VzOiBzZWxlY3Rpb25TdGFydFBvaW50XG4gICAgICB9XG4gICAgfVxuICB9KS5zcGxpdCgvXFxzKy8pLmF0KC0xKSwgbmV4dElubGluZU9iamVjdCA9IGdldE5leHRJbmxpbmVPYmplY3Qoc25hcHNob3QpLCBibG9ja0VuZFBvaW50ID0gZ2V0QmxvY2tFbmRQb2ludChmb2N1c1RleHRCbG9jayksIHRleHREaXJlY3RseUFmdGVyID0gZ2V0U2VsZWN0aW9uVGV4dCh7XG4gICAgLi4uc25hcHNob3QsXG4gICAgY29udGV4dDoge1xuICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICBhbmNob3I6IHNlbGVjdGlvblN0YXJ0UG9pbnQsXG4gICAgICAgIGZvY3VzOiBuZXh0SW5saW5lT2JqZWN0ID8ge1xuICAgICAgICAgIHBhdGg6IG5leHRJbmxpbmVPYmplY3QucGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSA6IGJsb2NrRW5kUG9pbnRcbiAgICAgIH1cbiAgICB9XG4gIH0pLnNwbGl0KC9cXHMrLykuYXQoMCk7XG4gIGlmICgodGV4dERpcmVjdGx5QmVmb3JlID09PSB2b2lkIDAgfHwgdGV4dERpcmVjdGx5QmVmb3JlID09PSBcIlwiKSAmJiAodGV4dERpcmVjdGx5QWZ0ZXIgPT09IHZvaWQgMCB8fCB0ZXh0RGlyZWN0bHlBZnRlciA9PT0gXCJcIikpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGNhcmV0V29yZFN0YXJ0T2Zmc2V0ID0gdGV4dERpcmVjdGx5QmVmb3JlID8ge1xuICAgIC4uLnNlbGVjdGlvblN0YXJ0T2Zmc2V0LFxuICAgIG9mZnNldDogc2VsZWN0aW9uU3RhcnRPZmZzZXQub2Zmc2V0IC0gdGV4dERpcmVjdGx5QmVmb3JlLmxlbmd0aFxuICB9IDogc2VsZWN0aW9uU3RhcnRPZmZzZXQsIGNhcmV0V29yZEVuZE9mZnNldCA9IHRleHREaXJlY3RseUFmdGVyID8ge1xuICAgIC4uLnNlbGVjdGlvblN0YXJ0T2Zmc2V0LFxuICAgIG9mZnNldDogc2VsZWN0aW9uU3RhcnRPZmZzZXQub2Zmc2V0ICsgdGV4dERpcmVjdGx5QWZ0ZXIubGVuZ3RoXG4gIH0gOiBzZWxlY3Rpb25TdGFydE9mZnNldCwgY2FyZXRXb3JkU3RhcnRTZWxlY3Rpb25Qb2ludCA9IGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQoe1xuICAgIHZhbHVlOiBzbmFwc2hvdC5jb250ZXh0LnZhbHVlLFxuICAgIGJsb2NrT2Zmc2V0OiBjYXJldFdvcmRTdGFydE9mZnNldCxcbiAgICBkaXJlY3Rpb246IFwiYmFja3dhcmRcIlxuICB9KSwgY2FyZXRXb3JkRW5kU2VsZWN0aW9uUG9pbnQgPSBibG9ja09mZnNldFRvU3BhblNlbGVjdGlvblBvaW50KHtcbiAgICB2YWx1ZTogc25hcHNob3QuY29udGV4dC52YWx1ZSxcbiAgICBibG9ja09mZnNldDogY2FyZXRXb3JkRW5kT2Zmc2V0LFxuICAgIGRpcmVjdGlvbjogXCJmb3J3YXJkXCJcbiAgfSk7XG4gIGlmICghY2FyZXRXb3JkU3RhcnRTZWxlY3Rpb25Qb2ludCB8fCAhY2FyZXRXb3JkRW5kU2VsZWN0aW9uUG9pbnQpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGNhcmV0V29yZFNlbGVjdGlvbiA9IHtcbiAgICBhbmNob3I6IGNhcmV0V29yZFN0YXJ0U2VsZWN0aW9uUG9pbnQsXG4gICAgZm9jdXM6IGNhcmV0V29yZEVuZFNlbGVjdGlvblBvaW50XG4gIH07XG4gIHJldHVybiBpc1NlbGVjdGlvbkV4cGFuZGVkKHtcbiAgICAuLi5zbmFwc2hvdCxcbiAgICBjb250ZXh0OiB7XG4gICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgc2VsZWN0aW9uOiBjYXJldFdvcmRTZWxlY3Rpb25cbiAgICB9XG4gIH0pID8gY2FyZXRXb3JkU2VsZWN0aW9uIDogbnVsbDtcbn07XG5mdW5jdGlvbiBpc0F0VGhlRW5kT2ZCbG9jayhibG9jaykge1xuICByZXR1cm4gKHNuYXBzaG90KSA9PiB7XG4gICAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiB8fCAhaXNTZWxlY3Rpb25Db2xsYXBzZWQoc25hcHNob3QpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGJsb2NrRW5kUG9pbnQgPSBnZXRCbG9ja0VuZFBvaW50KGJsb2NrKTtcbiAgICByZXR1cm4gaXNFcXVhbFNlbGVjdGlvblBvaW50cyhzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cywgYmxvY2tFbmRQb2ludCk7XG4gIH07XG59XG5mdW5jdGlvbiBpc0F0VGhlU3RhcnRPZkJsb2NrKGJsb2NrKSB7XG4gIHJldHVybiAoc25hcHNob3QpID0+IHtcbiAgICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uIHx8ICFpc1NlbGVjdGlvbkNvbGxhcHNlZChzbmFwc2hvdCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgYmxvY2tTdGFydFBvaW50ID0gZ2V0QmxvY2tTdGFydFBvaW50KGJsb2NrKTtcbiAgICByZXR1cm4gaXNFcXVhbFNlbGVjdGlvblBvaW50cyhzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cywgYmxvY2tTdGFydFBvaW50KTtcbiAgfTtcbn1cbmV4cG9ydCB7XG4gIGNyZWF0ZUd1YXJkcyxcbiAgZ2V0Q2FyZXRXb3JkU2VsZWN0aW9uLFxuICBnZXRGaXJzdEJsb2NrLFxuICBnZXRGb2N1c0Jsb2NrLFxuICBnZXRGb2N1c0Jsb2NrT2JqZWN0LFxuICBnZXRGb2N1c0NoaWxkLFxuICBnZXRGb2N1c0xpc3RCbG9jayxcbiAgZ2V0Rm9jdXNTcGFuLFxuICBnZXRGb2N1c1RleHRCbG9jayxcbiAgZ2V0TGFzdEJsb2NrLFxuICBnZXROZXh0QmxvY2ssXG4gIGdldE5leHRJbmxpbmVPYmplY3QsXG4gIGdldFByZXZpb3VzQmxvY2ssXG4gIGdldFByZXZpb3VzSW5saW5lT2JqZWN0LFxuICBnZXRTZWxlY3RlZEJsb2NrcyxcbiAgZ2V0U2VsZWN0ZWRTbGljZSxcbiAgZ2V0U2VsZWN0aW9uRW5kQmxvY2ssXG4gIGdldFNlbGVjdGlvbkVuZFBvaW50LFxuICBnZXRTZWxlY3Rpb25TdGFydEJsb2NrLFxuICBnZXRTZWxlY3Rpb25TdGFydFBvaW50LFxuICBnZXRTZWxlY3Rpb25UZXh0LFxuICBpc0F0VGhlRW5kT2ZCbG9jayxcbiAgaXNBdFRoZVN0YXJ0T2ZCbG9jayxcbiAgaXNTZWxlY3Rpb25Db2xsYXBzZWQsXG4gIGlzU2VsZWN0aW9uRXhwYW5kZWRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3Rvci5pcy1hdC10aGUtc3RhcnQtb2YtYmxvY2suanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-at-the-start-of-block.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.block-offsets-to-selection.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/util.block-offsets-to-selection.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blockOffsetsToSelection: () => (/* binding */ blockOffsetsToSelection),\n/* harmony export */   isTextBlock: () => (/* binding */ isTextBlock),\n/* harmony export */   parseBlock: () => (/* binding */ parseBlock)\n/* harmony export */ });\n/* harmony import */ var _util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.slice-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\");\n\nfunction isTypedObject(object) {\n  return isRecord(object) && typeof object._type == \"string\";\n}\nfunction isRecord(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction parseBlock({\n  context,\n  block,\n  options\n}) {\n  return parseTextBlock({\n    block,\n    context,\n    options\n  }) ?? parseBlockObject({\n    blockObject: block,\n    context,\n    options\n  });\n}\nfunction parseBlockObject({\n  blockObject,\n  context,\n  options\n}) {\n  if (isTypedObject(blockObject) && !(blockObject._type === context.schema.block.name || blockObject._type === \"block\" || !context.schema.blockObjects.some(({\n    name\n  }) => name === blockObject._type)))\n    return {\n      ...blockObject,\n      _key: options.refreshKeys ? context.keyGenerator() : typeof blockObject._key == \"string\" ? blockObject._key : context.keyGenerator()\n    };\n}\nfunction isTextBlock(schema, block) {\n  return parseTextBlock({\n    block,\n    context: {\n      schema,\n      keyGenerator: () => \"\"\n    },\n    options: {\n      refreshKeys: !1\n    }\n  }) !== void 0;\n}\nfunction parseTextBlock({\n  block,\n  context,\n  options\n}) {\n  if (!isTypedObject(block) || block._type !== context.schema.block.name)\n    return;\n  const _key = options.refreshKeys ? context.keyGenerator() : typeof block._key == \"string\" ? block._key : context.keyGenerator(), unparsedMarkDefs = Array.isArray(block.markDefs) ? block.markDefs : [], markDefKeyMap = /* @__PURE__ */ new Map(), markDefs = unparsedMarkDefs.flatMap((markDef) => {\n    if (!isTypedObject(markDef))\n      return [];\n    if (typeof markDef._key != \"string\")\n      return [];\n    if (context.schema.annotations.some((annotation) => annotation.name === markDef._type)) {\n      const _key2 = options.refreshKeys ? context.keyGenerator() : markDef._key;\n      return markDefKeyMap.set(markDef._key, _key2), [{\n        ...markDef,\n        _key: _key2\n      }];\n    }\n    return [];\n  }), children = (Array.isArray(block.children) ? block.children : []).map((child) => parseSpan({\n    span: child,\n    context,\n    markDefKeyMap,\n    options\n  }) ?? parseInlineObject({\n    inlineObject: child,\n    context,\n    options\n  })).filter((child) => child !== void 0), parsedBlock = {\n    // Spread the entire block to allow custom properties on it\n    ...block,\n    _key,\n    children: children.length > 0 ? children : [{\n      _key: context.keyGenerator(),\n      _type: context.schema.span.name,\n      text: \"\",\n      marks: []\n    }],\n    markDefs\n  };\n  if (typeof parsedBlock.style != \"string\" || !context.schema.styles.find((style) => style.value === block.style)) {\n    const defaultStyle = context.schema.styles.at(0)?.value;\n    defaultStyle !== void 0 ? parsedBlock.style = defaultStyle : delete parsedBlock.style;\n  }\n  return (typeof parsedBlock.listItem != \"string\" || !context.schema.lists.find((list) => list.value === block.listItem)) && delete parsedBlock.listItem, typeof parsedBlock.level != \"number\" && delete parsedBlock.level, parsedBlock;\n}\nfunction parseSpan({\n  span,\n  context,\n  markDefKeyMap,\n  options\n}) {\n  if (!isTypedObject(span) || span._type !== context.schema.span.name || span._type !== \"span\")\n    return;\n  const marks = (Array.isArray(span.marks) ? span.marks : []).flatMap((mark) => {\n    if (typeof mark != \"string\")\n      return [];\n    const markDefKey = markDefKeyMap.get(mark);\n    return markDefKey !== void 0 ? [markDefKey] : context.schema.decorators.some((decorator) => decorator.value === mark) ? [mark] : [];\n  });\n  return {\n    // Spread the entire span to allow custom properties on it\n    ...span,\n    _type: \"span\",\n    _key: options.refreshKeys ? context.keyGenerator() : typeof span._key == \"string\" ? span._key : context.keyGenerator(),\n    text: typeof span.text == \"string\" ? span.text : \"\",\n    marks\n  };\n}\nfunction parseInlineObject({\n  inlineObject,\n  context,\n  options\n}) {\n  if (isTypedObject(inlineObject) && !(inlineObject._type === context.schema.span.name || inlineObject._type === \"span\" || // Respect the schema definition and don't parse inline objects that are not defined\n  !context.schema.inlineObjects.some(({\n    name\n  }) => name === inlineObject._type)))\n    return {\n      // Spread the entire inline object to allow custom properties on it\n      ...inlineObject,\n      _key: options.refreshKeys ? context.keyGenerator() : typeof inlineObject._key == \"string\" ? inlineObject._key : context.keyGenerator()\n    };\n}\nfunction blockOffsetsToSelection({\n  value,\n  offsets,\n  backward\n}) {\n  const anchor = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.blockOffsetToSpanSelectionPoint)({\n    value,\n    blockOffset: offsets.anchor,\n    direction: backward ? \"backward\" : \"forward\"\n  }), focus = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.blockOffsetToSpanSelectionPoint)({\n    value,\n    blockOffset: offsets.focus,\n    direction: backward ? \"forward\" : \"backward\"\n  });\n  return !anchor || !focus ? null : {\n    anchor,\n    focus,\n    backward\n  };\n}\n\n//# sourceMappingURL=util.block-offsets-to-selection.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvdXRpbC5ibG9jay1vZmZzZXRzLXRvLXNlbGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCLHNGQUErQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxHQUFHLFdBQVcsc0ZBQStCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbWFjYm9va3Byby9Eb3dubG9hZHMvY29uaWNhcHBzL2lnZW5lL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvX2NodW5rcy1lcy91dGlsLmJsb2NrLW9mZnNldHMtdG8tc2VsZWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQgfSBmcm9tIFwiLi91dGlsLnNsaWNlLWJsb2Nrcy5qc1wiO1xuZnVuY3Rpb24gaXNUeXBlZE9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuIGlzUmVjb3JkKG9iamVjdCkgJiYgdHlwZW9mIG9iamVjdC5fdHlwZSA9PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNSZWNvcmQodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gcGFyc2VCbG9jayh7XG4gIGNvbnRleHQsXG4gIGJsb2NrLFxuICBvcHRpb25zXG59KSB7XG4gIHJldHVybiBwYXJzZVRleHRCbG9jayh7XG4gICAgYmxvY2ssXG4gICAgY29udGV4dCxcbiAgICBvcHRpb25zXG4gIH0pID8/IHBhcnNlQmxvY2tPYmplY3Qoe1xuICAgIGJsb2NrT2JqZWN0OiBibG9jayxcbiAgICBjb250ZXh0LFxuICAgIG9wdGlvbnNcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZUJsb2NrT2JqZWN0KHtcbiAgYmxvY2tPYmplY3QsXG4gIGNvbnRleHQsXG4gIG9wdGlvbnNcbn0pIHtcbiAgaWYgKGlzVHlwZWRPYmplY3QoYmxvY2tPYmplY3QpICYmICEoYmxvY2tPYmplY3QuX3R5cGUgPT09IGNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUgfHwgYmxvY2tPYmplY3QuX3R5cGUgPT09IFwiYmxvY2tcIiB8fCAhY29udGV4dC5zY2hlbWEuYmxvY2tPYmplY3RzLnNvbWUoKHtcbiAgICBuYW1lXG4gIH0pID0+IG5hbWUgPT09IGJsb2NrT2JqZWN0Ll90eXBlKSkpXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmJsb2NrT2JqZWN0LFxuICAgICAgX2tleTogb3B0aW9ucy5yZWZyZXNoS2V5cyA/IGNvbnRleHQua2V5R2VuZXJhdG9yKCkgOiB0eXBlb2YgYmxvY2tPYmplY3QuX2tleSA9PSBcInN0cmluZ1wiID8gYmxvY2tPYmplY3QuX2tleSA6IGNvbnRleHQua2V5R2VuZXJhdG9yKClcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNUZXh0QmxvY2soc2NoZW1hLCBibG9jaykge1xuICByZXR1cm4gcGFyc2VUZXh0QmxvY2soe1xuICAgIGJsb2NrLFxuICAgIGNvbnRleHQ6IHtcbiAgICAgIHNjaGVtYSxcbiAgICAgIGtleUdlbmVyYXRvcjogKCkgPT4gXCJcIlxuICAgIH0sXG4gICAgb3B0aW9uczoge1xuICAgICAgcmVmcmVzaEtleXM6ICExXG4gICAgfVxuICB9KSAhPT0gdm9pZCAwO1xufVxuZnVuY3Rpb24gcGFyc2VUZXh0QmxvY2soe1xuICBibG9jayxcbiAgY29udGV4dCxcbiAgb3B0aW9uc1xufSkge1xuICBpZiAoIWlzVHlwZWRPYmplY3QoYmxvY2spIHx8IGJsb2NrLl90eXBlICE9PSBjb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lKVxuICAgIHJldHVybjtcbiAgY29uc3QgX2tleSA9IG9wdGlvbnMucmVmcmVzaEtleXMgPyBjb250ZXh0LmtleUdlbmVyYXRvcigpIDogdHlwZW9mIGJsb2NrLl9rZXkgPT0gXCJzdHJpbmdcIiA/IGJsb2NrLl9rZXkgOiBjb250ZXh0LmtleUdlbmVyYXRvcigpLCB1bnBhcnNlZE1hcmtEZWZzID0gQXJyYXkuaXNBcnJheShibG9jay5tYXJrRGVmcykgPyBibG9jay5tYXJrRGVmcyA6IFtdLCBtYXJrRGVmS2V5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgbWFya0RlZnMgPSB1bnBhcnNlZE1hcmtEZWZzLmZsYXRNYXAoKG1hcmtEZWYpID0+IHtcbiAgICBpZiAoIWlzVHlwZWRPYmplY3QobWFya0RlZikpXG4gICAgICByZXR1cm4gW107XG4gICAgaWYgKHR5cGVvZiBtYXJrRGVmLl9rZXkgIT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBbXTtcbiAgICBpZiAoY29udGV4dC5zY2hlbWEuYW5ub3RhdGlvbnMuc29tZSgoYW5ub3RhdGlvbikgPT4gYW5ub3RhdGlvbi5uYW1lID09PSBtYXJrRGVmLl90eXBlKSkge1xuICAgICAgY29uc3QgX2tleTIgPSBvcHRpb25zLnJlZnJlc2hLZXlzID8gY29udGV4dC5rZXlHZW5lcmF0b3IoKSA6IG1hcmtEZWYuX2tleTtcbiAgICAgIHJldHVybiBtYXJrRGVmS2V5TWFwLnNldChtYXJrRGVmLl9rZXksIF9rZXkyKSwgW3tcbiAgICAgICAgLi4ubWFya0RlZixcbiAgICAgICAgX2tleTogX2tleTJcbiAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH0pLCBjaGlsZHJlbiA9IChBcnJheS5pc0FycmF5KGJsb2NrLmNoaWxkcmVuKSA/IGJsb2NrLmNoaWxkcmVuIDogW10pLm1hcCgoY2hpbGQpID0+IHBhcnNlU3Bhbih7XG4gICAgc3BhbjogY2hpbGQsXG4gICAgY29udGV4dCxcbiAgICBtYXJrRGVmS2V5TWFwLFxuICAgIG9wdGlvbnNcbiAgfSkgPz8gcGFyc2VJbmxpbmVPYmplY3Qoe1xuICAgIGlubGluZU9iamVjdDogY2hpbGQsXG4gICAgY29udGV4dCxcbiAgICBvcHRpb25zXG4gIH0pKS5maWx0ZXIoKGNoaWxkKSA9PiBjaGlsZCAhPT0gdm9pZCAwKSwgcGFyc2VkQmxvY2sgPSB7XG4gICAgLy8gU3ByZWFkIHRoZSBlbnRpcmUgYmxvY2sgdG8gYWxsb3cgY3VzdG9tIHByb3BlcnRpZXMgb24gaXRcbiAgICAuLi5ibG9jayxcbiAgICBfa2V5LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbi5sZW5ndGggPiAwID8gY2hpbGRyZW4gOiBbe1xuICAgICAgX2tleTogY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgIF90eXBlOiBjb250ZXh0LnNjaGVtYS5zcGFuLm5hbWUsXG4gICAgICB0ZXh0OiBcIlwiLFxuICAgICAgbWFya3M6IFtdXG4gICAgfV0sXG4gICAgbWFya0RlZnNcbiAgfTtcbiAgaWYgKHR5cGVvZiBwYXJzZWRCbG9jay5zdHlsZSAhPSBcInN0cmluZ1wiIHx8ICFjb250ZXh0LnNjaGVtYS5zdHlsZXMuZmluZCgoc3R5bGUpID0+IHN0eWxlLnZhbHVlID09PSBibG9jay5zdHlsZSkpIHtcbiAgICBjb25zdCBkZWZhdWx0U3R5bGUgPSBjb250ZXh0LnNjaGVtYS5zdHlsZXMuYXQoMCk/LnZhbHVlO1xuICAgIGRlZmF1bHRTdHlsZSAhPT0gdm9pZCAwID8gcGFyc2VkQmxvY2suc3R5bGUgPSBkZWZhdWx0U3R5bGUgOiBkZWxldGUgcGFyc2VkQmxvY2suc3R5bGU7XG4gIH1cbiAgcmV0dXJuICh0eXBlb2YgcGFyc2VkQmxvY2subGlzdEl0ZW0gIT0gXCJzdHJpbmdcIiB8fCAhY29udGV4dC5zY2hlbWEubGlzdHMuZmluZCgobGlzdCkgPT4gbGlzdC52YWx1ZSA9PT0gYmxvY2subGlzdEl0ZW0pKSAmJiBkZWxldGUgcGFyc2VkQmxvY2subGlzdEl0ZW0sIHR5cGVvZiBwYXJzZWRCbG9jay5sZXZlbCAhPSBcIm51bWJlclwiICYmIGRlbGV0ZSBwYXJzZWRCbG9jay5sZXZlbCwgcGFyc2VkQmxvY2s7XG59XG5mdW5jdGlvbiBwYXJzZVNwYW4oe1xuICBzcGFuLFxuICBjb250ZXh0LFxuICBtYXJrRGVmS2V5TWFwLFxuICBvcHRpb25zXG59KSB7XG4gIGlmICghaXNUeXBlZE9iamVjdChzcGFuKSB8fCBzcGFuLl90eXBlICE9PSBjb250ZXh0LnNjaGVtYS5zcGFuLm5hbWUgfHwgc3Bhbi5fdHlwZSAhPT0gXCJzcGFuXCIpXG4gICAgcmV0dXJuO1xuICBjb25zdCBtYXJrcyA9IChBcnJheS5pc0FycmF5KHNwYW4ubWFya3MpID8gc3Bhbi5tYXJrcyA6IFtdKS5mbGF0TWFwKChtYXJrKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBtYXJrICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgbWFya0RlZktleSA9IG1hcmtEZWZLZXlNYXAuZ2V0KG1hcmspO1xuICAgIHJldHVybiBtYXJrRGVmS2V5ICE9PSB2b2lkIDAgPyBbbWFya0RlZktleV0gOiBjb250ZXh0LnNjaGVtYS5kZWNvcmF0b3JzLnNvbWUoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLnZhbHVlID09PSBtYXJrKSA/IFttYXJrXSA6IFtdO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICAvLyBTcHJlYWQgdGhlIGVudGlyZSBzcGFuIHRvIGFsbG93IGN1c3RvbSBwcm9wZXJ0aWVzIG9uIGl0XG4gICAgLi4uc3BhbixcbiAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgX2tleTogb3B0aW9ucy5yZWZyZXNoS2V5cyA/IGNvbnRleHQua2V5R2VuZXJhdG9yKCkgOiB0eXBlb2Ygc3Bhbi5fa2V5ID09IFwic3RyaW5nXCIgPyBzcGFuLl9rZXkgOiBjb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgIHRleHQ6IHR5cGVvZiBzcGFuLnRleHQgPT0gXCJzdHJpbmdcIiA/IHNwYW4udGV4dCA6IFwiXCIsXG4gICAgbWFya3NcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlSW5saW5lT2JqZWN0KHtcbiAgaW5saW5lT2JqZWN0LFxuICBjb250ZXh0LFxuICBvcHRpb25zXG59KSB7XG4gIGlmIChpc1R5cGVkT2JqZWN0KGlubGluZU9iamVjdCkgJiYgIShpbmxpbmVPYmplY3QuX3R5cGUgPT09IGNvbnRleHQuc2NoZW1hLnNwYW4ubmFtZSB8fCBpbmxpbmVPYmplY3QuX3R5cGUgPT09IFwic3BhblwiIHx8IC8vIFJlc3BlY3QgdGhlIHNjaGVtYSBkZWZpbml0aW9uIGFuZCBkb24ndCBwYXJzZSBpbmxpbmUgb2JqZWN0cyB0aGF0IGFyZSBub3QgZGVmaW5lZFxuICAhY29udGV4dC5zY2hlbWEuaW5saW5lT2JqZWN0cy5zb21lKCh7XG4gICAgbmFtZVxuICB9KSA9PiBuYW1lID09PSBpbmxpbmVPYmplY3QuX3R5cGUpKSlcbiAgICByZXR1cm4ge1xuICAgICAgLy8gU3ByZWFkIHRoZSBlbnRpcmUgaW5saW5lIG9iamVjdCB0byBhbGxvdyBjdXN0b20gcHJvcGVydGllcyBvbiBpdFxuICAgICAgLi4uaW5saW5lT2JqZWN0LFxuICAgICAgX2tleTogb3B0aW9ucy5yZWZyZXNoS2V5cyA/IGNvbnRleHQua2V5R2VuZXJhdG9yKCkgOiB0eXBlb2YgaW5saW5lT2JqZWN0Ll9rZXkgPT0gXCJzdHJpbmdcIiA/IGlubGluZU9iamVjdC5fa2V5IDogY29udGV4dC5rZXlHZW5lcmF0b3IoKVxuICAgIH07XG59XG5mdW5jdGlvbiBibG9ja09mZnNldHNUb1NlbGVjdGlvbih7XG4gIHZhbHVlLFxuICBvZmZzZXRzLFxuICBiYWNrd2FyZFxufSkge1xuICBjb25zdCBhbmNob3IgPSBibG9ja09mZnNldFRvU3BhblNlbGVjdGlvblBvaW50KHtcbiAgICB2YWx1ZSxcbiAgICBibG9ja09mZnNldDogb2Zmc2V0cy5hbmNob3IsXG4gICAgZGlyZWN0aW9uOiBiYWNrd2FyZCA/IFwiYmFja3dhcmRcIiA6IFwiZm9yd2FyZFwiXG4gIH0pLCBmb2N1cyA9IGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQoe1xuICAgIHZhbHVlLFxuICAgIGJsb2NrT2Zmc2V0OiBvZmZzZXRzLmZvY3VzLFxuICAgIGRpcmVjdGlvbjogYmFja3dhcmQgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIlxuICB9KTtcbiAgcmV0dXJuICFhbmNob3IgfHwgIWZvY3VzID8gbnVsbCA6IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXMsXG4gICAgYmFja3dhcmRcbiAgfTtcbn1cbmV4cG9ydCB7XG4gIGJsb2NrT2Zmc2V0c1RvU2VsZWN0aW9uLFxuICBpc1RleHRCbG9jayxcbiAgcGFyc2VCbG9ja1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuYmxvY2stb2Zmc2V0cy10by1zZWxlY3Rpb24uanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.block-offsets-to-selection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.reverse-selection.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/util.reverse-selection.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reverseSelection: () => (/* binding */ reverseSelection)\n/* harmony export */ });\nfunction reverseSelection(selection) {\n  return selection.backward ? {\n    anchor: selection.focus,\n    focus: selection.anchor,\n    backward: !1\n  } : {\n    anchor: selection.focus,\n    focus: selection.anchor,\n    backward: !0\n  };\n}\n\n//# sourceMappingURL=util.reverse-selection.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvdXRpbC5yZXZlcnNlLXNlbGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL21hY2Jvb2twcm8vRG93bmxvYWRzL2NvbmljYXBwcy9pZ2VuZS9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvdXRpbC5yZXZlcnNlLXNlbGVjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiByZXZlcnNlU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICByZXR1cm4gc2VsZWN0aW9uLmJhY2t3YXJkID8ge1xuICAgIGFuY2hvcjogc2VsZWN0aW9uLmZvY3VzLFxuICAgIGZvY3VzOiBzZWxlY3Rpb24uYW5jaG9yLFxuICAgIGJhY2t3YXJkOiAhMVxuICB9IDoge1xuICAgIGFuY2hvcjogc2VsZWN0aW9uLmZvY3VzLFxuICAgIGZvY3VzOiBzZWxlY3Rpb24uYW5jaG9yLFxuICAgIGJhY2t3YXJkOiAhMFxuICB9O1xufVxuZXhwb3J0IHtcbiAgcmV2ZXJzZVNlbGVjdGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwucmV2ZXJzZS1zZWxlY3Rpb24uanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.reverse-selection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blockOffsetToSpanSelectionPoint: () => (/* binding */ blockOffsetToSpanSelectionPoint),\n/* harmony export */   getBlockEndPoint: () => (/* binding */ getBlockEndPoint),\n/* harmony export */   getBlockStartPoint: () => (/* binding */ getBlockStartPoint),\n/* harmony export */   getTextBlockText: () => (/* binding */ getTextBlockText),\n/* harmony export */   isEmptyTextBlock: () => (/* binding */ isEmptyTextBlock),\n/* harmony export */   isEqualSelectionPoints: () => (/* binding */ isEqualSelectionPoints),\n/* harmony export */   isKeyedSegment: () => (/* binding */ isKeyedSegment),\n/* harmony export */   isSpan: () => (/* binding */ isSpan),\n/* harmony export */   sliceBlocks: () => (/* binding */ sliceBlocks),\n/* harmony export */   spanSelectionPointToBlockOffset: () => (/* binding */ spanSelectionPointToBlockOffset)\n/* harmony export */ });\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n\nfunction isKeyedSegment(segment) {\n  return typeof segment == \"object\" && segment !== null && \"_key\" in segment;\n}\nfunction blockOffsetToSpanSelectionPoint({\n  value,\n  blockOffset,\n  direction\n}) {\n  let offsetLeft = blockOffset.offset, selectionPoint, skippedInlineObject = !1;\n  for (const block of value)\n    if (block._key === blockOffset.path[0]._key && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block))\n      for (const child of block.children) {\n        if (direction === \"forward\") {\n          if (!(0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(child))\n            continue;\n          if (offsetLeft <= child.text.length) {\n            selectionPoint = {\n              path: [...blockOffset.path, \"children\", {\n                _key: child._key\n              }],\n              offset: offsetLeft\n            };\n            break;\n          }\n          offsetLeft -= child.text.length;\n          continue;\n        }\n        if (!(0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(child)) {\n          skippedInlineObject = !0;\n          continue;\n        }\n        if (offsetLeft === 0 && selectionPoint && !skippedInlineObject) {\n          skippedInlineObject && (selectionPoint = {\n            path: [...blockOffset.path, \"children\", {\n              _key: child._key\n            }],\n            offset: 0\n          });\n          break;\n        }\n        if (offsetLeft > child.text.length) {\n          offsetLeft -= child.text.length;\n          continue;\n        }\n        if (offsetLeft <= child.text.length && (selectionPoint = {\n          path: [...blockOffset.path, \"children\", {\n            _key: child._key\n          }],\n          offset: offsetLeft\n        }, offsetLeft -= child.text.length, offsetLeft !== 0))\n          break;\n      }\n  return selectionPoint;\n}\nfunction spanSelectionPointToBlockOffset({\n  value,\n  selectionPoint\n}) {\n  let offset = 0;\n  const blockKey = isKeyedSegment(selectionPoint.path[0]) ? selectionPoint.path[0]._key : void 0, spanKey = isKeyedSegment(selectionPoint.path[2]) ? selectionPoint.path[2]._key : void 0;\n  if (!(!blockKey || !spanKey)) {\n    for (const block of value)\n      if (block._key === blockKey && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block)) {\n        for (const child of block.children)\n          if ((0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(child)) {\n            if (child._key === spanKey)\n              return {\n                path: [{\n                  _key: block._key\n                }],\n                offset: offset + selectionPoint.offset\n              };\n            offset += child.text.length;\n          }\n      }\n  }\n}\nfunction getBlockEndPoint({\n  node,\n  path\n}) {\n  if ((0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(node)) {\n    const lastChild = node.children[node.children.length - 1];\n    if (lastChild)\n      return {\n        path: [...path, \"children\", {\n          _key: lastChild._key\n        }],\n        offset: (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(lastChild) ? lastChild.text.length : 0\n      };\n  }\n  return {\n    path,\n    offset: 0\n  };\n}\nfunction getBlockStartPoint({\n  node,\n  path\n}) {\n  return (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(node) ? {\n    path: [...path, \"children\", {\n      _key: node.children[0]._key\n    }],\n    offset: 0\n  } : {\n    path,\n    offset: 0\n  };\n}\nfunction getTextBlockText(block) {\n  return block.children.map((child) => child.text ?? \"\").join(\"\");\n}\nfunction isEmptyTextBlock(block) {\n  if (!(0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block))\n    return !1;\n  const onlyText = block.children.every(_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan), blockText = getTextBlockText(block);\n  return onlyText && blockText === \"\";\n}\nfunction isEqualSelectionPoints(a, b) {\n  return a.offset === b.offset && JSON.stringify(a.path) === JSON.stringify(b.path);\n}\nfunction isSpan(context, child) {\n  return child._type === context.schema.span.name;\n}\nfunction sliceBlocks({\n  blocks,\n  selection\n}) {\n  const slice = [];\n  if (!selection)\n    return slice;\n  let startBlock;\n  const middleBlocks = [];\n  let endBlock;\n  const startPoint = selection.backward ? selection.focus : selection.anchor, endPoint = selection.backward ? selection.anchor : selection.focus, startBlockKey = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(startPoint.path[0]) ? startPoint.path[0]._key : void 0, endBlockKey = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(endPoint.path[0]) ? endPoint.path[0]._key : void 0, startChildKey = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(startPoint.path[2]) ? startPoint.path[2]._key : void 0, endChildKey = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(endPoint.path[2]) ? endPoint.path[2]._key : void 0;\n  if (!startBlockKey || !endBlockKey)\n    return slice;\n  for (const block of blocks) {\n    if (!(0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block) && block._key === startBlockKey && block._key === endBlockKey) {\n      startBlock = block;\n      break;\n    }\n    if (block._key === startBlockKey) {\n      if (!(0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block)) {\n        startBlock = block;\n        continue;\n      }\n      if (startChildKey) {\n        for (const child of block.children) {\n          if (child._key === startChildKey) {\n            if ((0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(child)) {\n              const text = child._key === endChildKey ? child.text.slice(startPoint.offset, endPoint.offset) : child.text.slice(startPoint.offset);\n              startBlock = {\n                ...block,\n                children: [{\n                  ...child,\n                  text\n                }]\n              };\n            } else\n              startBlock = {\n                ...block,\n                children: [child]\n              };\n            if (startChildKey === endChildKey)\n              break;\n            continue;\n          }\n          if (startBlock && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(startBlock) && (endChildKey && child._key === endChildKey && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(child) ? startBlock.children.push({\n            ...child,\n            text: child.text.slice(0, endPoint.offset)\n          }) : startBlock.children.push(child), block._key === endBlockKey && endChildKey && child._key === endChildKey))\n            break;\n        }\n        if (startBlockKey === endBlockKey)\n          break;\n        continue;\n      }\n      if (startBlock = block, startBlockKey === endBlockKey)\n        break;\n    }\n    if (block._key === endBlockKey) {\n      if (!(0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block)) {\n        endBlock = block;\n        break;\n      }\n      if (endChildKey) {\n        endBlock = {\n          ...block,\n          children: []\n        };\n        for (const child of block.children)\n          if (endBlock && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(endBlock)) {\n            if (child._key === endChildKey && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(child)) {\n              endBlock.children.push({\n                ...child,\n                text: child.text.slice(0, endPoint.offset)\n              });\n              break;\n            }\n            if (endBlock.children.push(child), endChildKey && child._key === endChildKey)\n              break;\n          }\n        break;\n      }\n      endBlock = block;\n      break;\n    }\n    startBlock && middleBlocks.push(block);\n  }\n  return [...startBlock ? [startBlock] : [], ...middleBlocks, ...endBlock ? [endBlock] : []];\n}\n\n//# sourceMappingURL=util.slice-blocks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvdXRpbC5zbGljZS1ibG9ja3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBMEY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG1EQUFtRCxzRUFBdUI7QUFDMUU7QUFDQTtBQUNBLGVBQWUsaUVBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlFQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0VBQXVCO0FBQzVEO0FBQ0EsY0FBYyxpRUFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTUFBTSxzRUFBdUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsaUVBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFNBQVMsc0VBQXVCO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0VBQXVCO0FBQzlCO0FBQ0Esd0NBQXdDLDZEQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtLQUFrSywyREFBWSx1RUFBdUUsMkRBQVkscUVBQXFFLDJEQUFZLHVFQUF1RSwyREFBWTtBQUNyYTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNFQUF1QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0VBQXVCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpRUFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0VBQXVCLDhEQUE4RCxpRUFBa0I7QUFDbkk7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0VBQXVCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzRUFBdUI7QUFDakQsOENBQThDLGlFQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNib29rcHJvL0Rvd25sb2Fkcy9jb25pY2FwcHMvaWdlbmUvbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3V0aWwuc2xpY2UtYmxvY2tzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrLCBpc1BvcnRhYmxlVGV4dFNwYW4sIGlzS2V5U2VnbWVudCB9IGZyb20gXCJAc2FuaXR5L3R5cGVzXCI7XG5mdW5jdGlvbiBpc0tleWVkU2VnbWVudChzZWdtZW50KSB7XG4gIHJldHVybiB0eXBlb2Ygc2VnbWVudCA9PSBcIm9iamVjdFwiICYmIHNlZ21lbnQgIT09IG51bGwgJiYgXCJfa2V5XCIgaW4gc2VnbWVudDtcbn1cbmZ1bmN0aW9uIGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQoe1xuICB2YWx1ZSxcbiAgYmxvY2tPZmZzZXQsXG4gIGRpcmVjdGlvblxufSkge1xuICBsZXQgb2Zmc2V0TGVmdCA9IGJsb2NrT2Zmc2V0Lm9mZnNldCwgc2VsZWN0aW9uUG9pbnQsIHNraXBwZWRJbmxpbmVPYmplY3QgPSAhMTtcbiAgZm9yIChjb25zdCBibG9jayBvZiB2YWx1ZSlcbiAgICBpZiAoYmxvY2suX2tleSA9PT0gYmxvY2tPZmZzZXQucGF0aFswXS5fa2V5ICYmIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKGJsb2NrKSlcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgYmxvY2suY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJmb3J3YXJkXCIpIHtcbiAgICAgICAgICBpZiAoIWlzUG9ydGFibGVUZXh0U3BhbihjaGlsZCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBpZiAob2Zmc2V0TGVmdCA8PSBjaGlsZC50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uUG9pbnQgPSB7XG4gICAgICAgICAgICAgIHBhdGg6IFsuLi5ibG9ja09mZnNldC5wYXRoLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldExlZnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgb2Zmc2V0TGVmdCAtPSBjaGlsZC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUG9ydGFibGVUZXh0U3BhbihjaGlsZCkpIHtcbiAgICAgICAgICBza2lwcGVkSW5saW5lT2JqZWN0ID0gITA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldExlZnQgPT09IDAgJiYgc2VsZWN0aW9uUG9pbnQgJiYgIXNraXBwZWRJbmxpbmVPYmplY3QpIHtcbiAgICAgICAgICBza2lwcGVkSW5saW5lT2JqZWN0ICYmIChzZWxlY3Rpb25Qb2ludCA9IHtcbiAgICAgICAgICAgIHBhdGg6IFsuLi5ibG9ja09mZnNldC5wYXRoLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0TGVmdCA+IGNoaWxkLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgb2Zmc2V0TGVmdCAtPSBjaGlsZC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0TGVmdCA8PSBjaGlsZC50ZXh0Lmxlbmd0aCAmJiAoc2VsZWN0aW9uUG9pbnQgPSB7XG4gICAgICAgICAgcGF0aDogWy4uLmJsb2NrT2Zmc2V0LnBhdGgsIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgIH1dLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0TGVmdFxuICAgICAgICB9LCBvZmZzZXRMZWZ0IC09IGNoaWxkLnRleHQubGVuZ3RoLCBvZmZzZXRMZWZ0ICE9PSAwKSlcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgcmV0dXJuIHNlbGVjdGlvblBvaW50O1xufVxuZnVuY3Rpb24gc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCh7XG4gIHZhbHVlLFxuICBzZWxlY3Rpb25Qb2ludFxufSkge1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY29uc3QgYmxvY2tLZXkgPSBpc0tleWVkU2VnbWVudChzZWxlY3Rpb25Qb2ludC5wYXRoWzBdKSA/IHNlbGVjdGlvblBvaW50LnBhdGhbMF0uX2tleSA6IHZvaWQgMCwgc3BhbktleSA9IGlzS2V5ZWRTZWdtZW50KHNlbGVjdGlvblBvaW50LnBhdGhbMl0pID8gc2VsZWN0aW9uUG9pbnQucGF0aFsyXS5fa2V5IDogdm9pZCAwO1xuICBpZiAoISghYmxvY2tLZXkgfHwgIXNwYW5LZXkpKSB7XG4gICAgZm9yIChjb25zdCBibG9jayBvZiB2YWx1ZSlcbiAgICAgIGlmIChibG9jay5fa2V5ID09PSBibG9ja0tleSAmJiBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhibG9jaykpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBibG9jay5jaGlsZHJlbilcbiAgICAgICAgICBpZiAoaXNQb3J0YWJsZVRleHRTcGFuKGNoaWxkKSkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLl9rZXkgPT09IHNwYW5LZXkpXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCArIHNlbGVjdGlvblBvaW50Lm9mZnNldFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGNoaWxkLnRleHQubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0QmxvY2tFbmRQb2ludCh7XG4gIG5vZGUsXG4gIHBhdGhcbn0pIHtcbiAgaWYgKGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKG5vZGUpKSB7XG4gICAgY29uc3QgbGFzdENoaWxkID0gbm9kZS5jaGlsZHJlbltub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0Q2hpbGQpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiBbLi4ucGF0aCwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgX2tleTogbGFzdENoaWxkLl9rZXlcbiAgICAgICAgfV0sXG4gICAgICAgIG9mZnNldDogaXNQb3J0YWJsZVRleHRTcGFuKGxhc3RDaGlsZCkgPyBsYXN0Q2hpbGQudGV4dC5sZW5ndGggOiAwXG4gICAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgcGF0aCxcbiAgICBvZmZzZXQ6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEJsb2NrU3RhcnRQb2ludCh7XG4gIG5vZGUsXG4gIHBhdGhcbn0pIHtcbiAgcmV0dXJuIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKG5vZGUpID8ge1xuICAgIHBhdGg6IFsuLi5wYXRoLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgIF9rZXk6IG5vZGUuY2hpbGRyZW5bMF0uX2tleVxuICAgIH1dLFxuICAgIG9mZnNldDogMFxuICB9IDoge1xuICAgIHBhdGgsXG4gICAgb2Zmc2V0OiAwXG4gIH07XG59XG5mdW5jdGlvbiBnZXRUZXh0QmxvY2tUZXh0KGJsb2NrKSB7XG4gIHJldHVybiBibG9jay5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC50ZXh0ID8/IFwiXCIpLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBpc0VtcHR5VGV4dEJsb2NrKGJsb2NrKSB7XG4gIGlmICghaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soYmxvY2spKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3Qgb25seVRleHQgPSBibG9jay5jaGlsZHJlbi5ldmVyeShpc1BvcnRhYmxlVGV4dFNwYW4pLCBibG9ja1RleHQgPSBnZXRUZXh0QmxvY2tUZXh0KGJsb2NrKTtcbiAgcmV0dXJuIG9ubHlUZXh0ICYmIGJsb2NrVGV4dCA9PT0gXCJcIjtcbn1cbmZ1bmN0aW9uIGlzRXF1YWxTZWxlY3Rpb25Qb2ludHMoYSwgYikge1xuICByZXR1cm4gYS5vZmZzZXQgPT09IGIub2Zmc2V0ICYmIEpTT04uc3RyaW5naWZ5KGEucGF0aCkgPT09IEpTT04uc3RyaW5naWZ5KGIucGF0aCk7XG59XG5mdW5jdGlvbiBpc1NwYW4oY29udGV4dCwgY2hpbGQpIHtcbiAgcmV0dXJuIGNoaWxkLl90eXBlID09PSBjb250ZXh0LnNjaGVtYS5zcGFuLm5hbWU7XG59XG5mdW5jdGlvbiBzbGljZUJsb2Nrcyh7XG4gIGJsb2NrcyxcbiAgc2VsZWN0aW9uXG59KSB7XG4gIGNvbnN0IHNsaWNlID0gW107XG4gIGlmICghc2VsZWN0aW9uKVxuICAgIHJldHVybiBzbGljZTtcbiAgbGV0IHN0YXJ0QmxvY2s7XG4gIGNvbnN0IG1pZGRsZUJsb2NrcyA9IFtdO1xuICBsZXQgZW5kQmxvY2s7XG4gIGNvbnN0IHN0YXJ0UG9pbnQgPSBzZWxlY3Rpb24uYmFja3dhcmQgPyBzZWxlY3Rpb24uZm9jdXMgOiBzZWxlY3Rpb24uYW5jaG9yLCBlbmRQb2ludCA9IHNlbGVjdGlvbi5iYWNrd2FyZCA/IHNlbGVjdGlvbi5hbmNob3IgOiBzZWxlY3Rpb24uZm9jdXMsIHN0YXJ0QmxvY2tLZXkgPSBpc0tleVNlZ21lbnQoc3RhcnRQb2ludC5wYXRoWzBdKSA/IHN0YXJ0UG9pbnQucGF0aFswXS5fa2V5IDogdm9pZCAwLCBlbmRCbG9ja0tleSA9IGlzS2V5U2VnbWVudChlbmRQb2ludC5wYXRoWzBdKSA/IGVuZFBvaW50LnBhdGhbMF0uX2tleSA6IHZvaWQgMCwgc3RhcnRDaGlsZEtleSA9IGlzS2V5U2VnbWVudChzdGFydFBvaW50LnBhdGhbMl0pID8gc3RhcnRQb2ludC5wYXRoWzJdLl9rZXkgOiB2b2lkIDAsIGVuZENoaWxkS2V5ID0gaXNLZXlTZWdtZW50KGVuZFBvaW50LnBhdGhbMl0pID8gZW5kUG9pbnQucGF0aFsyXS5fa2V5IDogdm9pZCAwO1xuICBpZiAoIXN0YXJ0QmxvY2tLZXkgfHwgIWVuZEJsb2NrS2V5KVxuICAgIHJldHVybiBzbGljZTtcbiAgZm9yIChjb25zdCBibG9jayBvZiBibG9ja3MpIHtcbiAgICBpZiAoIWlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKGJsb2NrKSAmJiBibG9jay5fa2V5ID09PSBzdGFydEJsb2NrS2V5ICYmIGJsb2NrLl9rZXkgPT09IGVuZEJsb2NrS2V5KSB7XG4gICAgICBzdGFydEJsb2NrID0gYmxvY2s7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGJsb2NrLl9rZXkgPT09IHN0YXJ0QmxvY2tLZXkpIHtcbiAgICAgIGlmICghaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soYmxvY2spKSB7XG4gICAgICAgIHN0YXJ0QmxvY2sgPSBibG9jaztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnRDaGlsZEtleSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGJsb2NrLmNoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLl9rZXkgPT09IHN0YXJ0Q2hpbGRLZXkpIHtcbiAgICAgICAgICAgIGlmIChpc1BvcnRhYmxlVGV4dFNwYW4oY2hpbGQpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBjaGlsZC5fa2V5ID09PSBlbmRDaGlsZEtleSA/IGNoaWxkLnRleHQuc2xpY2Uoc3RhcnRQb2ludC5vZmZzZXQsIGVuZFBvaW50Lm9mZnNldCkgOiBjaGlsZC50ZXh0LnNsaWNlKHN0YXJ0UG9pbnQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgc3RhcnRCbG9jayA9IHtcbiAgICAgICAgICAgICAgICAuLi5ibG9jayxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICAgICAgICAgIC4uLmNoaWxkLFxuICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgc3RhcnRCbG9jayA9IHtcbiAgICAgICAgICAgICAgICAuLi5ibG9jayxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW2NoaWxkXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHN0YXJ0Q2hpbGRLZXkgPT09IGVuZENoaWxkS2V5KVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnRCbG9jayAmJiBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhzdGFydEJsb2NrKSAmJiAoZW5kQ2hpbGRLZXkgJiYgY2hpbGQuX2tleSA9PT0gZW5kQ2hpbGRLZXkgJiYgaXNQb3J0YWJsZVRleHRTcGFuKGNoaWxkKSA/IHN0YXJ0QmxvY2suY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAuLi5jaGlsZCxcbiAgICAgICAgICAgIHRleHQ6IGNoaWxkLnRleHQuc2xpY2UoMCwgZW5kUG9pbnQub2Zmc2V0KVxuICAgICAgICAgIH0pIDogc3RhcnRCbG9jay5jaGlsZHJlbi5wdXNoKGNoaWxkKSwgYmxvY2suX2tleSA9PT0gZW5kQmxvY2tLZXkgJiYgZW5kQ2hpbGRLZXkgJiYgY2hpbGQuX2tleSA9PT0gZW5kQ2hpbGRLZXkpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0QmxvY2tLZXkgPT09IGVuZEJsb2NrS2V5KVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydEJsb2NrID0gYmxvY2ssIHN0YXJ0QmxvY2tLZXkgPT09IGVuZEJsb2NrS2V5KVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGJsb2NrLl9rZXkgPT09IGVuZEJsb2NrS2V5KSB7XG4gICAgICBpZiAoIWlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKGJsb2NrKSkge1xuICAgICAgICBlbmRCbG9jayA9IGJsb2NrO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChlbmRDaGlsZEtleSkge1xuICAgICAgICBlbmRCbG9jayA9IHtcbiAgICAgICAgICAuLi5ibG9jayxcbiAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBibG9jay5jaGlsZHJlbilcbiAgICAgICAgICBpZiAoZW5kQmxvY2sgJiYgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soZW5kQmxvY2spKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuX2tleSA9PT0gZW5kQ2hpbGRLZXkgJiYgaXNQb3J0YWJsZVRleHRTcGFuKGNoaWxkKSkge1xuICAgICAgICAgICAgICBlbmRCbG9jay5jaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAuLi5jaGlsZCxcbiAgICAgICAgICAgICAgICB0ZXh0OiBjaGlsZC50ZXh0LnNsaWNlKDAsIGVuZFBvaW50Lm9mZnNldClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZEJsb2NrLmNoaWxkcmVuLnB1c2goY2hpbGQpLCBlbmRDaGlsZEtleSAmJiBjaGlsZC5fa2V5ID09PSBlbmRDaGlsZEtleSlcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGVuZEJsb2NrID0gYmxvY2s7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc3RhcnRCbG9jayAmJiBtaWRkbGVCbG9ja3MucHVzaChibG9jayk7XG4gIH1cbiAgcmV0dXJuIFsuLi5zdGFydEJsb2NrID8gW3N0YXJ0QmxvY2tdIDogW10sIC4uLm1pZGRsZUJsb2NrcywgLi4uZW5kQmxvY2sgPyBbZW5kQmxvY2tdIDogW11dO1xufVxuZXhwb3J0IHtcbiAgYmxvY2tPZmZzZXRUb1NwYW5TZWxlY3Rpb25Qb2ludCxcbiAgZ2V0QmxvY2tFbmRQb2ludCxcbiAgZ2V0QmxvY2tTdGFydFBvaW50LFxuICBnZXRUZXh0QmxvY2tUZXh0LFxuICBpc0VtcHR5VGV4dEJsb2NrLFxuICBpc0VxdWFsU2VsZWN0aW9uUG9pbnRzLFxuICBpc0tleWVkU2VnbWVudCxcbiAgaXNTcGFuLFxuICBzbGljZUJsb2NrcyxcbiAgc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuc2xpY2UtYmxvY2tzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EditorEventListener: () => (/* binding */ EditorEventListener),\n/* harmony export */   EditorProvider: () => (/* reexport safe */ _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.EditorProvider),\n/* harmony export */   PortableTextEditable: () => (/* binding */ PortableTextEditable),\n/* harmony export */   PortableTextEditor: () => (/* reexport safe */ _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.PortableTextEditor),\n/* harmony export */   defineSchema: () => (/* reexport safe */ _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.defineSchema),\n/* harmony export */   keyGenerator: () => (/* reexport safe */ _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.defaultKeyGenerator),\n/* harmony export */   useEditor: () => (/* reexport safe */ _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.useEditor),\n/* harmony export */   useEditorSelector: () => (/* reexport safe */ _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.useEditorSelector),\n/* harmony export */   usePortableTextEditor: () => (/* reexport safe */ _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.usePortableTextEditor),\n/* harmony export */   usePortableTextEditorSelection: () => (/* reexport safe */ _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.usePortableTextEditorSelection)\n/* harmony export */ });\n/* harmony import */ var _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_chunks-es/editor-provider.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/editor-provider.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _xstate_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @xstate/react */ \"(ssr)/./node_modules/@xstate/react/dist/xstate-react.development.esm.js\");\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/./node_modules/lodash/isEqual.js\");\n/* harmony import */ var lodash_noop_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/noop.js */ \"(ssr)/./node_modules/lodash/noop.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! slate-react */ \"(ssr)/./node_modules/slate-react/dist/index.es.js\");\n/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-compiler-runtime */ \"(ssr)/./node_modules/react-compiler-runtime/dist/index.js\");\n/* harmony import */ var lodash_uniq_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/uniq.js */ \"(ssr)/./node_modules/lodash/uniq.js\");\n/* harmony import */ var _chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./_chunks-es/behavior.core.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/behavior.core.js\");\n/* harmony import */ var use_effect_event__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! use-effect-event */ \"(ssr)/./node_modules/use-effect-event/dist/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction normalizePoint(point, value) {\n  if (!point || !value)\n    return null;\n  const newPath = [];\n  let newOffset = point.offset || 0;\n  const blockKey = typeof point.path[0] == \"object\" && \"_key\" in point.path[0] && point.path[0]._key, childKey = typeof point.path[2] == \"object\" && \"_key\" in point.path[2] && point.path[2]._key, block = value.find((blk) => blk._key === blockKey);\n  if (block)\n    newPath.push({\n      _key: block._key\n    });\n  else\n    return null;\n  if (block && point.path[1] === \"children\") {\n    if (!block.children || Array.isArray(block.children) && block.children.length === 0)\n      return null;\n    const child = Array.isArray(block.children) && block.children.find((cld) => cld._key === childKey);\n    if (child)\n      newPath.push(\"children\"), newPath.push({\n        _key: child._key\n      }), newOffset = child.text && child.text.length >= point.offset ? point.offset : child.text && child.text.length || 0;\n    else\n      return null;\n  }\n  return {\n    path: newPath,\n    offset: newOffset\n  };\n}\nfunction normalizeSelection(selection, value) {\n  if (!selection || !value || value.length === 0)\n    return null;\n  let newAnchor = null, newFocus = null;\n  const {\n    anchor,\n    focus\n  } = selection;\n  return anchor && value.find((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__({\n    _key: blk._key\n  }, anchor.path[0])) && (newAnchor = normalizePoint(anchor, value)), focus && value.find((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__({\n    _key: blk._key\n  }, focus.path[0])) && (newFocus = normalizePoint(focus, value)), newAnchor && newFocus ? {\n    anchor: newAnchor,\n    focus: newFocus,\n    backward: selection.backward\n  } : null;\n}\nfunction DefaultBlockObject(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_4__.c)(4);\n  let t0;\n  $[0] === Symbol.for(\"react.memo_cache_sentinel\") ? (t0 = {\n    userSelect: \"none\"\n  }, $[0] = t0) : t0 = $[0];\n  let t1;\n  return $[1] !== props.value._key || $[2] !== props.value._type ? (t1 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", { style: t0, children: [\n    \"[\",\n    props.value._type,\n    \": \",\n    props.value._key,\n    \"]\"\n  ] }), $[1] = props.value._key, $[2] = props.value._type, $[3] = t1) : t1 = $[3], t1;\n}\nfunction DefaultInlineObject(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_4__.c)(4);\n  let t0;\n  $[0] === Symbol.for(\"react.memo_cache_sentinel\") ? (t0 = {\n    userSelect: \"none\"\n  }, $[0] = t0) : t0 = $[0];\n  let t1;\n  return $[1] !== props.value._key || $[2] !== props.value._type ? (t1 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"span\", { style: t0, children: [\n    \"[\",\n    props.value._type,\n    \": \",\n    props.value._key,\n    \"]\"\n  ] }), $[1] = props.value._key, $[2] = props.value._type, $[3] = t1) : t1 = $[3], t1;\n}\nconst debug$3 = (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.debugWithName)(\"components:DraggableBlock\"), DraggableBlock = (t0) => {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_4__.c)(51), {\n    children,\n    element,\n    readOnly,\n    blockRef\n  } = t0, editor = (0,slate_react__WEBPACK_IMPORTED_MODULE_7__.useSlateStatic)(), dragGhostRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(void 0), [isDragOver, setIsDragOver] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(!1);\n  let t1, t2;\n  $[0] !== editor || $[1] !== element ? (t2 = slate__WEBPACK_IMPORTED_MODULE_8__.Editor.isVoid(editor, element), $[0] = editor, $[1] = element, $[2] = t2) : t2 = $[2], t1 = t2;\n  const isVoid = t1;\n  let t3, t4;\n  $[3] !== editor || $[4] !== element ? (t4 = slate__WEBPACK_IMPORTED_MODULE_8__.Editor.isInline(editor, element), $[3] = editor, $[4] = element, $[5] = t4) : t4 = $[5], t3 = t4;\n  const isInline = t3, [blockElement, setBlockElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n  let t5, t6;\n  $[6] !== blockRef || $[7] !== editor || $[8] !== element ? (t5 = () => setBlockElement(blockRef ? blockRef.current : slate_react__WEBPACK_IMPORTED_MODULE_7__.ReactEditor.toDOMNode(editor, element)), t6 = [editor, element, blockRef], $[6] = blockRef, $[7] = editor, $[8] = element, $[9] = t5, $[10] = t6) : (t5 = $[9], t6 = $[10]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(t5, t6);\n  let t7;\n  $[11] !== blockElement || $[12] !== editor || $[13] !== element ? (t7 = (event) => {\n    const isMyDragOver = _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.IS_DRAGGING_BLOCK_ELEMENT.get(editor);\n    if (!isMyDragOver || !blockElement)\n      return;\n    event.preventDefault(), event.dataTransfer.dropEffect = \"move\", _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.IS_DRAGGING_ELEMENT_TARGET.set(editor, element);\n    const elementRect = blockElement.getBoundingClientRect(), offset = elementRect.top, height = elementRect.height, Y = event.pageY, loc = Math.abs(offset - Y);\n    if (element === editor.children[0] || (loc < height / 2 ? _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, \"top\") : _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, \"bottom\")), isMyDragOver === element) {\n      event.dataTransfer.dropEffect = \"none\";\n      return;\n    }\n    setIsDragOver(!0);\n  }, $[11] = blockElement, $[12] = editor, $[13] = element, $[14] = t7) : t7 = $[14];\n  const handleDragOver = t7;\n  let t8;\n  $[15] === Symbol.for(\"react.memo_cache_sentinel\") ? (t8 = () => {\n    setIsDragOver(!1);\n  }, $[15] = t8) : t8 = $[15];\n  const handleDragLeave = t8;\n  let t9;\n  $[16] !== editor || $[17] !== element ? (t9 = (event_0) => {\n    const targetBlock = _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.IS_DRAGGING_ELEMENT_TARGET.get(editor);\n    if (targetBlock) {\n      _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.IS_DRAGGING.set(editor, !1), event_0.preventDefault(), event_0.stopPropagation(), _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.IS_DRAGGING_ELEMENT_TARGET.delete(editor), dragGhostRef.current && (debug$3(\"Removing drag ghost\"), document.body.removeChild(dragGhostRef.current));\n      const dragPosition = _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);\n      _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.IS_DRAGGING_BLOCK_TARGET_POSITION.delete(editor);\n      let targetPath = slate_react__WEBPACK_IMPORTED_MODULE_7__.ReactEditor.findPath(editor, targetBlock);\n      const myPath = slate_react__WEBPACK_IMPORTED_MODULE_7__.ReactEditor.findPath(editor, element), isBefore = slate__WEBPACK_IMPORTED_MODULE_8__.Path.isBefore(myPath, targetPath);\n      if (dragPosition === \"bottom\" && !isBefore) {\n        if (targetPath[0] >= editor.children.length - 1) {\n          debug$3(\"target is already at the bottom, not moving\");\n          return;\n        }\n        const originalPath = targetPath;\n        targetPath = slate__WEBPACK_IMPORTED_MODULE_8__.Path.next(targetPath), debug$3(`Adjusting targetPath from ${JSON.stringify(originalPath)} to ${JSON.stringify(targetPath)}`);\n      }\n      if (dragPosition === \"top\" && isBefore && targetPath[0] !== editor.children.length - 1) {\n        const originalPath_0 = targetPath;\n        targetPath = slate__WEBPACK_IMPORTED_MODULE_8__.Path.previous(targetPath), debug$3(`Adjusting targetPath from ${JSON.stringify(originalPath_0)} to ${JSON.stringify(targetPath)}`);\n      }\n      if (slate__WEBPACK_IMPORTED_MODULE_8__.Path.equals(targetPath, myPath)) {\n        event_0.preventDefault(), debug$3(\"targetPath and myPath is the same, not moving\");\n        return;\n      }\n      debug$3(`Moving element ${element._key} from path ${JSON.stringify(myPath)} to ${JSON.stringify(targetPath)} (${dragPosition})`), slate__WEBPACK_IMPORTED_MODULE_8__.Transforms.moveNodes(editor, {\n        at: myPath,\n        to: targetPath\n      }), editor.onChange();\n      return;\n    }\n    debug$3(\"No target element, not doing anything\");\n  }, $[16] = editor, $[17] = element, $[18] = t9) : t9 = $[18];\n  const handleDragEnd = t9;\n  let t10;\n  $[19] !== editor || $[20] !== element ? (t10 = (event_1) => {\n    _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.IS_DRAGGING_BLOCK_ELEMENT.get(editor) && (debug$3(\"On drop (prevented)\", element), event_1.preventDefault(), event_1.stopPropagation(), setIsDragOver(!1));\n  }, $[19] = editor, $[20] = element, $[21] = t10) : t10 = $[21];\n  const handleDrop = t10;\n  let t11;\n  $[22] !== editor || $[23] !== element || $[24] !== isVoid ? (t11 = (event_2) => {\n    if (!isVoid) {\n      _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.IS_DRAGGING_BLOCK_ELEMENT.delete(editor);\n      return;\n    }\n    _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.IS_DRAGGING.set(editor, !0), _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.IS_DRAGGING_BLOCK_ELEMENT.set(editor, element), event_2.stopPropagation();\n    const target = event_2.target;\n    target instanceof HTMLElement && (target.style.opacity = \"1\");\n  }, $[22] = editor, $[23] = element, $[24] = isVoid, $[25] = t11) : t11 = $[25];\n  const handleDrag = t11;\n  let t12;\n  $[26] !== blockElement || $[27] !== editor || $[28] !== handleDrag || $[29] !== isInline || $[30] !== isVoid ? (t12 = (event_3) => {\n    if (!isVoid || isInline) {\n      debug$3(\"Not dragging block\"), _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.IS_DRAGGING_BLOCK_ELEMENT.delete(editor), _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.IS_DRAGGING.set(editor, !1);\n      return;\n    }\n    if (debug$3(\"Drag start\"), _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.IS_DRAGGING.set(editor, !0), event_3.dataTransfer && (event_3.dataTransfer.setData(\"application/portable-text\", \"something\"), event_3.dataTransfer.effectAllowed = \"move\"), blockElement && blockElement instanceof HTMLElement) {\n      let dragGhost = blockElement.cloneNode(!0);\n      const customGhost = dragGhost.querySelector(\"[data-pt-drag-ghost-element]\");\n      if (customGhost && (dragGhost = customGhost), dragGhost.setAttribute(\"data-dragged\", \"\"), document.body) {\n        dragGhostRef.current = dragGhost, dragGhost.style.position = \"absolute\", dragGhost.style.left = \"-99999px\", dragGhost.style.boxSizing = \"border-box\", document.body.appendChild(dragGhost);\n        const rect = blockElement.getBoundingClientRect(), x = event_3.clientX - rect.left, y = event_3.clientY - rect.top;\n        dragGhost.style.width = `${rect.width}px`, dragGhost.style.height = `${rect.height}px`, event_3.dataTransfer.setDragImage(dragGhost, x, y);\n      }\n    }\n    handleDrag(event_3);\n  }, $[26] = blockElement, $[27] = editor, $[28] = handleDrag, $[29] = isInline, $[30] = isVoid, $[31] = t12) : t12 = $[31];\n  const handleDragStart = t12;\n  let t13;\n  $[32] !== editor || $[33] !== isDragOver ? (t13 = isDragOver && editor.children[0] === _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.IS_DRAGGING_ELEMENT_TARGET.get(editor), $[32] = editor, $[33] = isDragOver, $[34] = t13) : t13 = $[34];\n  const isDraggingOverFirstBlock = t13;\n  let t14;\n  $[35] !== editor || $[36] !== isDragOver ? (t14 = isDragOver && editor.children[editor.children.length - 1] === _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.IS_DRAGGING_ELEMENT_TARGET.get(editor), $[35] = editor, $[36] = isDragOver, $[37] = t14) : t14 = $[37];\n  const isDraggingOverLastBlock = t14, dragPosition_0 = _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor), isDraggingOverTop = isDraggingOverFirstBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition_0 === \"top\", isDraggingOverBottom = isDraggingOverLastBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition_0 === \"bottom\";\n  let t15, t16;\n  $[38] === Symbol.for(\"react.memo_cache_sentinel\") ? (t16 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"pt-drop-indicator\", style: {\n    position: \"absolute\",\n    width: \"100%\",\n    height: 1,\n    borderBottom: \"1px solid currentColor\",\n    zIndex: 5\n  } }), $[38] = t16) : t16 = $[38], t15 = t16;\n  const dropIndicator = t15;\n  if (readOnly) {\n    let t172;\n    return $[39] !== children ? (t172 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children }), $[39] = children, $[40] = t172) : t172 = $[40], t172;\n  }\n  const t17 = isDraggingOverTop && dropIndicator, t18 = isDraggingOverBottom && dropIndicator;\n  let t19;\n  return $[41] !== children || $[42] !== handleDrag || $[43] !== handleDragEnd || $[44] !== handleDragOver || $[45] !== handleDragStart || $[46] !== handleDrop || $[47] !== isVoid || $[48] !== t17 || $[49] !== t18 ? (t19 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", { draggable: isVoid, onDragStart: handleDragStart, onDrag: handleDrag, onDragOver: handleDragOver, onDragLeave: handleDragLeave, onDragEnd: handleDragEnd, onDrop: handleDrop, children: [\n    t17,\n    children,\n    t18\n  ] }), $[41] = children, $[42] = handleDrag, $[43] = handleDragEnd, $[44] = handleDragOver, $[45] = handleDragStart, $[46] = handleDrop, $[47] = isVoid, $[48] = t17, $[49] = t18, $[50] = t19) : t19 = $[50], t19;\n};\nDraggableBlock.displayName = \"DraggableBlock\";\n(0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.debugWithName)(\"components:Element\");\nconst EMPTY_ANNOTATIONS = [], inlineBlockStyle = {\n  display: \"inline-block\"\n}, Element = ({\n  attributes,\n  children,\n  element,\n  schemaTypes,\n  readOnly,\n  renderBlock,\n  renderChild,\n  renderListItem,\n  renderStyle,\n  spellCheck\n}) => {\n  const editor = (0,slate_react__WEBPACK_IMPORTED_MODULE_7__.useSlateStatic)(), selected = (0,slate_react__WEBPACK_IMPORTED_MODULE_7__.useSelected)(), blockRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null), inlineBlockObjectRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null), focused = selected && editor.selection && slate__WEBPACK_IMPORTED_MODULE_8__.Range.isCollapsed(editor.selection) || !1, value = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.fromSlateValue)([element], schemaTypes.block.name, _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.KEY_TO_VALUE_ELEMENT.get(editor))[0], [editor, element, schemaTypes.block.name]);\n  let renderedBlock = children, className;\n  const blockPath = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => [{\n    _key: element._key\n  }], [element]);\n  if (typeof element._type != \"string\")\n    throw new Error(\"Expected element to have a _type property\");\n  if (typeof element._key != \"string\")\n    throw new Error(\"Expected element to have a _key property\");\n  if (editor.isInline(element)) {\n    const path = slate_react__WEBPACK_IMPORTED_MODULE_7__.ReactEditor.findPath(editor, element), [block] = slate__WEBPACK_IMPORTED_MODULE_8__.Editor.node(editor, path, {\n      depth: 1\n    }), schemaType = schemaTypes.inlineObjects.find((_type) => _type.name === element._type);\n    if (!schemaType)\n      throw new Error(\"Could not find type for inline block element\");\n    if (slate__WEBPACK_IMPORTED_MODULE_8__.Element.isElement(block)) {\n      const elmPath = [{\n        _key: block._key\n      }, \"children\", {\n        _key: element._key\n      }];\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"span\", { ...attributes, children: [\n        children,\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"span\", { draggable: !readOnly, className: \"pt-inline-object\", \"data-testid\": \"pt-inline-object\", ref: inlineBlockObjectRef, style: inlineBlockStyle, contentEditable: !1, children: [\n          renderChild && renderChild({\n            annotations: EMPTY_ANNOTATIONS,\n            // These inline objects currently doesn't support annotations. This is a limitation of the current PT spec/model.\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultInlineObject, { value }),\n            editorElementRef: inlineBlockObjectRef,\n            focused,\n            path: elmPath,\n            schemaType,\n            selected,\n            type: schemaType,\n            value\n          }),\n          !renderChild && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultInlineObject, { value })\n        ] }, element._key)\n      ] });\n    }\n    throw new Error(\"Block not found!\");\n  }\n  if (element._type === schemaTypes.block.name) {\n    className = \"pt-block pt-text-block\";\n    const isListItem = \"listItem\" in element, style = \"style\" in element && element.style || \"normal\";\n    className = `pt-block pt-text-block pt-text-block-style-${style}`;\n    const blockStyleType = schemaTypes.styles.find((item) => item.value === style);\n    renderStyle && blockStyleType && (renderedBlock = renderStyle({\n      block: element,\n      children,\n      focused,\n      selected,\n      value: style,\n      path: blockPath,\n      schemaType: blockStyleType,\n      editorElementRef: blockRef\n    }));\n    let level;\n    if (isListItem && (typeof element.level == \"number\" && (level = element.level), className += ` pt-list-item pt-list-item-${element.listItem} pt-list-item-level-${level || 1}`), editor.isListBlock(value) && isListItem && element.listItem) {\n      const listType = schemaTypes.lists.find((item_0) => item_0.value === element.listItem);\n      renderListItem && listType && (renderedBlock = renderListItem({\n        block: value,\n        children: renderedBlock,\n        focused,\n        selected,\n        value: element.listItem,\n        path: blockPath,\n        schemaType: listType,\n        level: value.level || 1,\n        editorElementRef: blockRef\n      }));\n    }\n    const renderProps = Object.defineProperty({\n      children: renderedBlock,\n      editorElementRef: blockRef,\n      focused,\n      level,\n      listItem: isListItem ? element.listItem : void 0,\n      path: blockPath,\n      selected,\n      style,\n      schemaType: schemaTypes.block,\n      value\n    }, \"type\", {\n      enumerable: !1,\n      get() {\n        return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaTypes.block;\n      }\n    }), propsOrDefaultRendered = renderBlock ? renderBlock(renderProps) : children;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ...attributes, className, spellCheck, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DraggableBlock, { element, readOnly, blockRef, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: blockRef, children: propsOrDefaultRendered }) }) }, element._key);\n  }\n  const schemaType_0 = schemaTypes.blockObjects.find((_type_0) => _type_0.name === element._type);\n  if (!schemaType_0)\n    throw new Error(`Could not find schema type for block element of _type ${element._type}`);\n  className = \"pt-block pt-object-block\";\n  const block_0 = (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.fromSlateValue)([element], schemaTypes.block.name, _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.KEY_TO_VALUE_ELEMENT.get(editor))[0];\n  let renderedBlockFromProps;\n  if (renderBlock) {\n    const _props = Object.defineProperty({\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultBlockObject, { value }),\n      editorElementRef: blockRef,\n      focused,\n      path: blockPath,\n      schemaType: schemaType_0,\n      selected,\n      value: block_0\n    }, \"type\", {\n      enumerable: !1,\n      get() {\n        return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaType_0;\n      }\n    });\n    renderedBlockFromProps = renderBlock(_props);\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", { ...attributes, className, children: [\n    children,\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DraggableBlock, { element, readOnly, blockRef, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: blockRef, contentEditable: !1, children: renderedBlockFromProps || /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultBlockObject, { value }) }) })\n  ] }, element._key);\n};\nElement.displayName = \"Element\";\nconst debug$2 = (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.debugWithName)(\"components:Leaf\"), EMPTY_MARKS = [], Leaf = (props) => {\n  const {\n    editorActor,\n    attributes,\n    children,\n    leaf,\n    schemaTypes,\n    renderChild,\n    renderDecorator,\n    renderAnnotation\n  } = props, spanRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null), portableTextEditor = (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.usePortableTextEditor)(), blockSelected = (0,slate_react__WEBPACK_IMPORTED_MODULE_7__.useSelected)(), [focused, setFocused] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(!1), [selected, setSelected] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(!1), block = children.props.parent, path = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => block ? [{\n    _key: block?._key\n  }, \"children\", {\n    _key: leaf._key\n  }] : [], [block, leaf._key]), decoratorValues = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => schemaTypes.decorators.map((dec) => dec.value), [schemaTypes.decorators]), marks = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => lodash_uniq_js__WEBPACK_IMPORTED_MODULE_5__((leaf.marks || EMPTY_MARKS).filter((mark) => decoratorValues.includes(mark))), [decoratorValues, leaf.marks]), annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS, annotations = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => annotationMarks.map((mark_0) => !decoratorValues.includes(mark_0) && block?.markDefs?.find((def) => def._key === mark_0)).filter(Boolean), [annotationMarks, block, decoratorValues]), shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected;\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      setFocused(!1);\n      return;\n    }\n    const sel = _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.PortableTextEditor.getSelection(portableTextEditor);\n    sel && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(sel.focus.path, path) && _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.PortableTextEditor.isCollapsedSelection(portableTextEditor) && (0,react__WEBPACK_IMPORTED_MODULE_3__.startTransition)(() => {\n      setFocused(!0);\n    });\n  }, [shouldTrackSelectionAndFocus, path, portableTextEditor]);\n  const setSelectedFromRange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    if (!shouldTrackSelectionAndFocus)\n      return;\n    debug$2(\"Setting selection and focus from range\");\n    const winSelection = window.getSelection();\n    if (!winSelection) {\n      setSelected(!1);\n      return;\n    }\n    if (winSelection && winSelection.rangeCount > 0) {\n      const range = winSelection.getRangeAt(0);\n      spanRef.current && range.intersectsNode(spanRef.current) ? setSelected(!0) : setSelected(!1);\n    } else\n      setSelected(!1);\n  }, [shouldTrackSelectionAndFocus]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (!shouldTrackSelectionAndFocus)\n      return;\n    const onBlur = editorActor.on(\"blur\", () => {\n      setFocused(!1), setSelected(!1);\n    }), onFocus = editorActor.on(\"focus\", () => {\n      const sel_0 = _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.PortableTextEditor.getSelection(portableTextEditor);\n      sel_0 && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(sel_0.focus.path, path) && _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.PortableTextEditor.isCollapsedSelection(portableTextEditor) && setFocused(!0), setSelectedFromRange();\n    }), onSelection = editorActor.on(\"selection\", (event) => {\n      event.selection && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(event.selection.focus.path, path) && _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.PortableTextEditor.isCollapsedSelection(portableTextEditor) ? setFocused(!0) : setFocused(!1), setSelectedFromRange();\n    });\n    return () => {\n      onBlur.unsubscribe(), onFocus.unsubscribe(), onSelection.unsubscribe();\n    };\n  }, [editorActor, path, portableTextEditor, setSelectedFromRange, shouldTrackSelectionAndFocus]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => setSelectedFromRange(), [setSelectedFromRange]);\n  const content = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => {\n    let returnedChildren = children;\n    if (slate__WEBPACK_IMPORTED_MODULE_8__.Text.isText(leaf) && leaf._type === schemaTypes.span.name && (marks.forEach((mark_1) => {\n      const schemaType = schemaTypes.decorators.find((dec_0) => dec_0.value === mark_1);\n      if (schemaType && renderDecorator) {\n        const _props = Object.defineProperty({\n          children: returnedChildren,\n          editorElementRef: spanRef,\n          focused,\n          path,\n          selected,\n          schemaType,\n          value: mark_1\n        }, \"type\", {\n          enumerable: !1,\n          get() {\n            return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaType;\n          }\n        });\n        returnedChildren = renderDecorator(_props);\n      }\n    }), block && annotations.length > 0 && annotations.forEach((annotation) => {\n      const schemaType_0 = schemaTypes.annotations.find((t) => t.name === annotation._type);\n      if (schemaType_0)\n        if (renderAnnotation) {\n          const _props_0 = Object.defineProperty({\n            block,\n            children: returnedChildren,\n            editorElementRef: spanRef,\n            focused,\n            path,\n            selected,\n            schemaType: schemaType_0,\n            value: annotation\n          }, \"type\", {\n            enumerable: !1,\n            get() {\n              return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaType_0;\n            }\n          });\n          returnedChildren = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { ref: spanRef, children: renderAnnotation(_props_0) });\n        } else\n          returnedChildren = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { ref: spanRef, children: returnedChildren });\n    }), block && renderChild)) {\n      const child = block.children.find((_child) => _child._key === leaf._key);\n      if (child) {\n        const _props_1 = Object.defineProperty({\n          annotations,\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: returnedChildren }),\n          editorElementRef: spanRef,\n          focused,\n          path,\n          schemaType: schemaTypes.span,\n          selected,\n          value: child\n        }, \"type\", {\n          enumerable: !1,\n          get() {\n            return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaTypes.span;\n          }\n        });\n        returnedChildren = renderChild(_props_1);\n      }\n    }\n    return returnedChildren;\n  }, [annotations, block, children, focused, leaf, marks, path, renderAnnotation, renderChild, renderDecorator, schemaTypes.annotations, schemaTypes.decorators, schemaTypes.span, selected]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { ...attributes, ref: spanRef, children: content }, leaf._key), [leaf, attributes, content]);\n};\nLeaf.displayName = \"Leaf\";\nconst debug$1 = (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.debugWithName)(\"plugin:withHotKeys\");\nfunction createWithHotkeys(editorActor, portableTextEditor, hotkeysFromOptions) {\n  const reservedHotkeys = [\"enter\", \"tab\", \"shift\", \"delete\", \"end\"], activeHotkeys = hotkeysFromOptions ?? {};\n  return function(editor) {\n    return editor.pteWithHotKeys = (event) => {\n      Object.keys(activeHotkeys).forEach((cat) => {\n        if (cat === \"marks\")\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey))\n              throw new Error(`The hotkey ${hotkey} is reserved!`);\n            if ((0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_9__.isHotkey)(hotkey, event.nativeEvent)) {\n              event.preventDefault();\n              const possibleMark = activeHotkeys[cat];\n              if (possibleMark) {\n                const mark = possibleMark[hotkey];\n                debug$1(`HotKey ${hotkey} to toggle ${mark}`), editorActor.send({\n                  type: \"behavior event\",\n                  behaviorEvent: {\n                    type: \"decorator.toggle\",\n                    decorator: mark\n                  },\n                  editor\n                });\n              }\n            }\n          }\n        if (cat === \"custom\")\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey))\n              throw new Error(`The hotkey ${hotkey} is reserved!`);\n            if ((0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_9__.isHotkey)(hotkey, event.nativeEvent)) {\n              const possibleCommand = activeHotkeys[cat];\n              if (possibleCommand) {\n                const command = possibleCommand[hotkey];\n                command(event, portableTextEditor);\n              }\n            }\n          }\n      });\n    }, editor;\n  };\n}\nfunction withSyncRangeDecorations({\n  editorActor,\n  slateEditor,\n  syncRangeDecorations\n}) {\n  const originalApply = slateEditor.apply;\n  return slateEditor.apply = (op) => {\n    originalApply(op), !editorActor.getSnapshot().matches({\n      \"edit mode\": \"read only\"\n    }) && op.type !== \"set_selection\" && syncRangeDecorations(op);\n  }, () => {\n    slateEditor.apply = originalApply;\n  };\n}\nconst debug = (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.debugWithName)(\"component:Editable\"), PLACEHOLDER_STYLE = {\n  position: \"absolute\",\n  userSelect: \"none\",\n  pointerEvents: \"none\",\n  left: 0,\n  right: 0\n}, PortableTextEditable = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function(props, forwardedRef) {\n  const {\n    hotkeys,\n    onBlur,\n    onFocus,\n    onBeforeInput,\n    onPaste,\n    onCopy,\n    onClick,\n    rangeDecorations,\n    renderAnnotation,\n    renderBlock,\n    renderChild,\n    renderDecorator,\n    renderListItem,\n    renderPlaceholder,\n    renderStyle,\n    selection: propsSelection,\n    scrollSelectionIntoView,\n    spellCheck,\n    ...restProps\n  } = props, portableTextEditor = (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.usePortableTextEditor)(), ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null), [editableElement, setEditableElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null), [hasInvalidValue, setHasInvalidValue] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(!1), [rangeDecorationState, setRangeDecorationsState] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)([]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useImperativeHandle)(forwardedRef, () => ref.current);\n  const rangeDecorationsRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(rangeDecorations), editorActor = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.EditorActorContext), readOnly = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_10__.useSelector)(editorActor, (s) => s.matches({\n    \"edit mode\": \"read only\"\n  })), schemaTypes = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_10__.useSelector)(editorActor, (s_0) => s_0.context.schema), slateEditor = (0,slate_react__WEBPACK_IMPORTED_MODULE_7__.useSlate)(), blockTypeName = schemaTypes.block.name;\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => {\n    if (readOnly)\n      return debug(\"Editable is in read only mode\"), slateEditor;\n    const withHotKeys = createWithHotkeys(editorActor, portableTextEditor, hotkeys);\n    return debug(\"Editable is in edit mode\"), withHotKeys(slateEditor);\n  }, [editorActor, hotkeys, portableTextEditor, readOnly, slateEditor]);\n  const renderElement = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((eProps) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Element, { ...eProps, readOnly, renderBlock, renderChild, renderListItem, renderStyle, schemaTypes, spellCheck }), [schemaTypes, spellCheck, readOnly, renderBlock, renderChild, renderListItem, renderStyle]), renderLeaf = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((lProps) => {\n    if (lProps.leaf._type === \"span\") {\n      let rendered = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Leaf, { ...lProps, editorActor, schemaTypes, renderAnnotation, renderChild, renderDecorator, readOnly });\n      if (renderPlaceholder && lProps.leaf.placeholder && lProps.text.text === \"\")\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { style: PLACEHOLDER_STYLE, contentEditable: !1, children: renderPlaceholder() }),\n          rendered\n        ] });\n      const decoration = lProps.leaf.rangeDecoration;\n      return decoration && (rendered = decoration.component({\n        children: rendered\n      })), rendered;\n    }\n    return lProps.children;\n  }, [editorActor, readOnly, renderAnnotation, renderChild, renderDecorator, renderPlaceholder, schemaTypes]), restoreSelectionFromProps = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    if (propsSelection) {\n      debug(`Selection from props ${JSON.stringify(propsSelection)}`);\n      const normalizedSelection = normalizeSelection(propsSelection, (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.fromSlateValue)(slateEditor.children, blockTypeName));\n      if (normalizedSelection !== null) {\n        debug(`Normalized selection from props ${JSON.stringify(normalizedSelection)}`);\n        const slateRange = (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.toSlateRange)(normalizedSelection, slateEditor);\n        slateRange && (slate__WEBPACK_IMPORTED_MODULE_8__.Transforms.select(slateEditor, slateRange), slateEditor.operations.some((o) => o.type === \"set_selection\") || editorActor.send({\n          type: \"notify.selection\",\n          selection: normalizedSelection\n        }), slateEditor.onChange());\n      }\n    }\n  }, [blockTypeName, editorActor, propsSelection, slateEditor]), syncRangeDecorations = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((operation) => {\n    if (rangeDecorations && rangeDecorations.length > 0) {\n      const newSlateRanges = [];\n      if (rangeDecorations.forEach((rangeDecorationItem) => {\n        const slateRange_0 = (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.toSlateRange)(rangeDecorationItem.selection, slateEditor);\n        if (!slate__WEBPACK_IMPORTED_MODULE_8__.Range.isRange(slateRange_0)) {\n          rangeDecorationItem.onMoved && rangeDecorationItem.onMoved({\n            newSelection: null,\n            rangeDecoration: rangeDecorationItem,\n            origin: \"local\"\n          });\n          return;\n        }\n        let newRange;\n        if (operation && (newRange = (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.moveRangeByOperation)(slateRange_0, operation), newRange && newRange !== slateRange_0 || newRange === null && slateRange_0)) {\n          const value = _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.PortableTextEditor.getValue(portableTextEditor), newRangeSelection = (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.toPortableTextRange)(value, newRange, schemaTypes);\n          rangeDecorationItem.onMoved && rangeDecorationItem.onMoved({\n            newSelection: newRangeSelection,\n            rangeDecoration: rangeDecorationItem,\n            origin: \"local\"\n          });\n        }\n        newRange !== null && newSlateRanges.push({\n          ...newRange || slateRange_0,\n          rangeDecoration: rangeDecorationItem\n        });\n      }), newSlateRanges.length > 0) {\n        setRangeDecorationsState(newSlateRanges);\n        return;\n      }\n    }\n    setRangeDecorationsState((rangeDecorationState_0) => rangeDecorationState_0.length > 0 ? [] : rangeDecorationState_0);\n  }, [portableTextEditor, rangeDecorations, schemaTypes, slateEditor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    const onReady = editorActor.on(\"ready\", () => {\n      syncRangeDecorations(), restoreSelectionFromProps();\n    }), onInvalidValue = editorActor.on(\"invalid value\", () => {\n      setHasInvalidValue(!0);\n    }), onValueChanged = editorActor.on(\"value changed\", () => {\n      setHasInvalidValue(!1);\n    });\n    return () => {\n      onReady.unsubscribe(), onInvalidValue.unsubscribe(), onValueChanged.unsubscribe();\n    };\n  }, [editorActor, restoreSelectionFromProps, syncRangeDecorations]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    propsSelection && !hasInvalidValue && restoreSelectionFromProps();\n  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps]);\n  const [syncedRangeDecorations, setSyncedRangeDecorations] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(!1);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    syncedRangeDecorations || (setSyncedRangeDecorations(!0), syncRangeDecorations());\n  }, [syncRangeDecorations, syncedRangeDecorations]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(rangeDecorations, rangeDecorationsRef.current) || syncRangeDecorations(), rangeDecorationsRef.current = rangeDecorations;\n  }, [rangeDecorations, syncRangeDecorations]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    const teardown = withSyncRangeDecorations({\n      editorActor,\n      slateEditor,\n      syncRangeDecorations\n    });\n    return () => teardown();\n  }, [editorActor, slateEditor, syncRangeDecorations]);\n  const handleCopy = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event) => {\n    onCopy ? onCopy(event) !== void 0 && event.preventDefault() : event.nativeEvent.clipboardData && editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"copy\",\n        data: event.nativeEvent.clipboardData\n      },\n      editor: slateEditor,\n      nativeEvent: event\n    });\n  }, [onCopy, editorActor, slateEditor]), handlePaste = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event_0) => {\n    const value_0 = _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.PortableTextEditor.getValue(portableTextEditor), path = (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.toPortableTextRange)(value_0, slateEditor.selection, schemaTypes)?.focus.path || [], onPasteResult = onPaste?.({\n      event: event_0,\n      value: value_0,\n      path,\n      schemaTypes\n    });\n    onPasteResult || !slateEditor.selection ? (event_0.preventDefault(), editorActor.send({\n      type: \"notify.loading\"\n    }), Promise.resolve(onPasteResult).then((result_0) => {\n      debug(\"Custom paste function from client resolved\", result_0), !result_0 || !result_0.insert ? (debug(\"No result from custom paste handler, pasting normally\"), slateEditor.insertData(event_0.clipboardData)) : result_0.insert ? slateEditor.insertFragment((0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.toSlateValue)(result_0.insert, {\n        schemaTypes\n      })) : console.warn(\"Your onPaste function returned something unexpected:\", result_0);\n    }).catch((error) => (console.error(error), error)).finally(() => {\n      editorActor.send({\n        type: \"notify.done loading\"\n      });\n    })) : event_0.nativeEvent.clipboardData && editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"paste\",\n        data: event_0.nativeEvent.clipboardData\n      },\n      editor: slateEditor,\n      nativeEvent: event_0\n    }), debug(\"No result from custom paste handler, pasting normally\");\n  }, [editorActor, onPaste, portableTextEditor, schemaTypes, slateEditor]), handleOnFocus = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event_1) => {\n    if (onFocus && onFocus(event_1), !event_1.isDefaultPrevented()) {\n      const selection = _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.PortableTextEditor.getSelection(portableTextEditor);\n      selection === null && (slate__WEBPACK_IMPORTED_MODULE_8__.Transforms.select(slateEditor, slate__WEBPACK_IMPORTED_MODULE_8__.Editor.start(slateEditor, [])), slateEditor.onChange()), editorActor.send({\n        type: \"notify.focused\",\n        event: event_1\n      });\n      const newSelection = _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.PortableTextEditor.getSelection(portableTextEditor);\n      selection === newSelection && editorActor.send({\n        type: \"notify.selection\",\n        selection\n      });\n    }\n  }, [editorActor, onFocus, portableTextEditor, slateEditor]), handleClick = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event_2) => {\n    onClick && onClick(event_2);\n    const focusBlockPath = slateEditor.selection ? slateEditor.selection.focus.path.slice(0, 1) : void 0, focusBlock = focusBlockPath ? slate__WEBPACK_IMPORTED_MODULE_8__.Node.descendant(slateEditor, focusBlockPath) : void 0, [_, lastNodePath] = slate__WEBPACK_IMPORTED_MODULE_8__.Node.last(slateEditor, []), lastBlockPath = lastNodePath.slice(0, 1), lastNodeFocused = focusBlockPath ? slate__WEBPACK_IMPORTED_MODULE_8__.Path.equals(lastBlockPath, focusBlockPath) : !1, lastBlockIsVoid = focusBlock ? !slateEditor.isTextBlock(focusBlock) : !1;\n    slateEditor.selection && slate__WEBPACK_IMPORTED_MODULE_8__.Range.isCollapsed(slateEditor.selection) && lastNodeFocused && lastBlockIsVoid && (slate__WEBPACK_IMPORTED_MODULE_8__.Transforms.insertNodes(slateEditor, slateEditor.pteCreateTextBlock({\n      decorators: []\n    })), slateEditor.onChange());\n  }, [onClick, slateEditor]), handleOnBlur = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event_3) => {\n    onBlur && onBlur(event_3), event_3.isPropagationStopped() || editorActor.send({\n      type: \"notify.blurred\",\n      event: event_3\n    });\n  }, [editorActor, onBlur]), handleOnBeforeInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event_4) => {\n    onBeforeInput && onBeforeInput(event_4);\n  }, [onBeforeInput]), validateSelection = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    if (!slateEditor.selection)\n      return;\n    const root = slate_react__WEBPACK_IMPORTED_MODULE_7__.ReactEditor.findDocumentOrShadowRoot(slateEditor), {\n      activeElement\n    } = root;\n    if (ref.current !== activeElement)\n      return;\n    const domSelection = slate_react__WEBPACK_IMPORTED_MODULE_7__.ReactEditor.getWindow(slateEditor).getSelection();\n    if (!domSelection || domSelection.rangeCount === 0)\n      return;\n    const existingDOMRange = domSelection.getRangeAt(0);\n    try {\n      const newDOMRange = slate_react__WEBPACK_IMPORTED_MODULE_7__.ReactEditor.toDOMRange(slateEditor, slateEditor.selection);\n      (newDOMRange.startOffset !== existingDOMRange.startOffset || newDOMRange.endOffset !== existingDOMRange.endOffset) && (debug(\"DOM range out of sync, validating selection\"), domSelection?.removeAllRanges(), domSelection.addRange(newDOMRange));\n    } catch {\n      debug(\"Could not resolve selection, selecting top document\"), slate__WEBPACK_IMPORTED_MODULE_8__.Transforms.deselect(slateEditor), slateEditor.children.length > 0 && slate__WEBPACK_IMPORTED_MODULE_8__.Transforms.select(slateEditor, [0, 0]), slateEditor.onChange();\n    }\n  }, [ref, slateEditor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (editableElement) {\n      const mutationObserver = new MutationObserver(validateSelection);\n      return mutationObserver.observe(editableElement, {\n        attributeOldValue: !1,\n        attributes: !1,\n        characterData: !1,\n        childList: !0,\n        subtree: !0\n      }), () => {\n        mutationObserver.disconnect();\n      };\n    }\n  }, [validateSelection, editableElement]);\n  const handleKeyDown = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event_5) => {\n    props.onKeyDown && props.onKeyDown(event_5), event_5.isDefaultPrevented() || slateEditor.pteWithHotKeys(event_5), event_5.isDefaultPrevented() || editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"key.down\",\n        keyboardEvent: {\n          key: event_5.key,\n          code: event_5.code,\n          altKey: event_5.altKey,\n          ctrlKey: event_5.ctrlKey,\n          metaKey: event_5.metaKey,\n          shiftKey: event_5.shiftKey\n        }\n      },\n      editor: slateEditor,\n      nativeEvent: event_5\n    });\n  }, [props, editorActor, slateEditor]), handleKeyUp = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event_6) => {\n    props.onKeyUp && props.onKeyUp(event_6), event_6.isDefaultPrevented() || editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"key.up\",\n        keyboardEvent: {\n          key: event_6.key,\n          code: event_6.code,\n          altKey: event_6.altKey,\n          ctrlKey: event_6.ctrlKey,\n          metaKey: event_6.metaKey,\n          shiftKey: event_6.shiftKey\n        }\n      },\n      editor: slateEditor,\n      nativeEvent: event_6\n    });\n  }, [props, editorActor, slateEditor]), scrollSelectionIntoViewToSlate = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => {\n    if (scrollSelectionIntoView !== void 0)\n      return scrollSelectionIntoView === null ? lodash_noop_js__WEBPACK_IMPORTED_MODULE_2__ : (_editor, domRange) => {\n        scrollSelectionIntoView(portableTextEditor, domRange);\n      };\n  }, [portableTextEditor, scrollSelectionIntoView]), decorate = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(([, path_0]) => {\n    if ((0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.isEqualToEmptyEditor)(slateEditor.children, schemaTypes))\n      return [{\n        anchor: {\n          path: [0, 0],\n          offset: 0\n        },\n        focus: {\n          path: [0, 0],\n          offset: 0\n        },\n        placeholder: !0\n      }];\n    if (path_0.length === 0)\n      return [];\n    const result_1 = rangeDecorationState.filter((item) => slate__WEBPACK_IMPORTED_MODULE_8__.Range.isCollapsed(item) ? path_0.length !== 2 ? !1 : slate__WEBPACK_IMPORTED_MODULE_8__.Path.equals(item.focus.path, path_0) && slate__WEBPACK_IMPORTED_MODULE_8__.Path.equals(item.anchor.path, path_0) : slate__WEBPACK_IMPORTED_MODULE_8__.Range.intersection(item, {\n      anchor: {\n        path: path_0,\n        offset: 0\n      },\n      focus: {\n        path: path_0,\n        offset: 0\n      }\n    }) || slate__WEBPACK_IMPORTED_MODULE_8__.Range.includes(item, path_0));\n    return result_1.length > 0 ? result_1 : [];\n  }, [slateEditor, schemaTypes, rangeDecorationState]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    ref.current = slate_react__WEBPACK_IMPORTED_MODULE_7__.ReactEditor.toDOMNode(slateEditor, slateEditor), setEditableElement(ref.current);\n  }, [slateEditor, ref]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    const window_0 = slate_react__WEBPACK_IMPORTED_MODULE_7__.ReactEditor.getWindow(slateEditor), onDragEnd = () => {\n      editorActor.send({\n        type: \"dragend\"\n      });\n    }, onDrop = () => {\n      editorActor.send({\n        type: \"drop\"\n      });\n    };\n    return window_0.document.addEventListener(\"dragend\", onDragEnd), window_0.document.addEventListener(\"drop\", onDrop), () => {\n      window_0.document.removeEventListener(\"dragend\", onDragEnd), window_0.document.removeEventListener(\"drop\", onDrop);\n    };\n  }, [slateEditor, editorActor]), portableTextEditor ? hasInvalidValue ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    slate_react__WEBPACK_IMPORTED_MODULE_7__.Editable,\n    {\n      ...restProps,\n      autoFocus: !1,\n      className: restProps.className || \"pt-editable\",\n      decorate,\n      onBlur: handleOnBlur,\n      onCopy: handleCopy,\n      onClick: handleClick,\n      onDOMBeforeInput: handleOnBeforeInput,\n      onDragStart: (event_7) => {\n        props.onDragStart?.(event_7), !event_7.isDefaultPrevented() && !event_7.isPropagationStopped() && editorActor.send({\n          type: \"dragstart\"\n        });\n      },\n      onFocus: handleOnFocus,\n      onKeyDown: handleKeyDown,\n      onKeyUp: handleKeyUp,\n      onPaste: handlePaste,\n      readOnly,\n      renderPlaceholder: void 0,\n      renderElement,\n      renderLeaf,\n      scrollSelectionIntoView: scrollSelectionIntoViewToSlate\n    }\n  ) : null;\n});\nPortableTextEditable.displayName = \"ForwardRef(PortableTextEditable)\";\nfunction EditorEventListener(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_4__.c)(5), editor = (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_6__.useEditor)(), on = (0,use_effect_event__WEBPACK_IMPORTED_MODULE_11__.useEffectEvent)(props.on);\n  let t0;\n  $[0] !== editor || $[1] !== on ? (t0 = () => {\n    const subscription = editor.on(\"*\", on);\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, $[0] = editor, $[1] = on, $[2] = t0) : t0 = $[2];\n  let t1;\n  return $[3] !== editor ? (t1 = [editor], $[3] = editor, $[4] = t1) : t1 = $[4], (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(t0, t1), null;\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb1g7QUFDN047QUFDL0Y7QUFDWjtBQUNKO0FBQ047QUFDc0c7QUFDOUM7QUFDQztBQUNoRDtBQUNUO0FBQ3VCO0FBQ1A7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdUNBQXVDLDhDQUFPO0FBQzlDO0FBQ0EsR0FBRyxnR0FBZ0csOENBQU87QUFDMUc7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxZQUFZLHlEQUFDO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EseUZBQXlGLHVEQUFJLFVBQVU7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSx5REFBQztBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHlGQUF5Rix1REFBSSxXQUFXO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsNEVBQWE7QUFDN0IsWUFBWSx5REFBQztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxlQUFlLDJEQUFjLG1CQUFtQiw2Q0FBTSx3Q0FBd0MsK0NBQVE7QUFDMUc7QUFDQSw4Q0FBOEMseUNBQU07QUFDcEQ7QUFDQTtBQUNBLDhDQUE4Qyx5Q0FBTTtBQUNwRCx5REFBeUQsK0NBQVE7QUFDakU7QUFDQSx1SEFBdUgsb0RB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QTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFlBQVkseURBQUMsY0FBYyx3RUFBUyxTQUFTLGlFQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtGQUFrRixnREFBUztBQUMzRjtBQVlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNib29rcHJvL0Rvd25sb2Fkcy9jb25pY2FwcHMvaWdlbmUvbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWJ1Z1dpdGhOYW1lLCBJU19EUkFHR0lOR19FTEVNRU5UX1RBUkdFVCwgSVNfRFJBR0dJTkdfQkxPQ0tfVEFSR0VUX1BPU0lUSU9OLCBJU19EUkFHR0lOR19CTE9DS19FTEVNRU5ULCBJU19EUkFHR0lORywgZnJvbVNsYXRlVmFsdWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULCB1c2VQb3J0YWJsZVRleHRFZGl0b3IsIFBvcnRhYmxlVGV4dEVkaXRvciwgRWRpdG9yQWN0b3JDb250ZXh0LCB0b1NsYXRlUmFuZ2UsIG1vdmVSYW5nZUJ5T3BlcmF0aW9uLCB0b1BvcnRhYmxlVGV4dFJhbmdlLCB0b1NsYXRlVmFsdWUsIGlzRXF1YWxUb0VtcHR5RWRpdG9yLCB1c2VFZGl0b3IgfSBmcm9tIFwiLi9fY2h1bmtzLWVzL2VkaXRvci1wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgRWRpdG9yUHJvdmlkZXIsIGRlZmluZVNjaGVtYSwgZGVmYXVsdEtleUdlbmVyYXRvciwgdXNlRWRpdG9yU2VsZWN0b3IsIHVzZVBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvbiB9IGZyb20gXCIuL19jaHVua3MtZXMvZWRpdG9yLXByb3ZpZGVyLmpzXCI7XG5pbXBvcnQgeyBqc3hzLCBqc3gsIEZyYWdtZW50IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyB1c2VTZWxlY3RvciB9IGZyb20gXCJAeHN0YXRlL3JlYWN0XCI7XG5pbXBvcnQgaXNFcXVhbCBmcm9tIFwibG9kYXNoL2lzRXF1YWwuanNcIjtcbmltcG9ydCBub29wIGZyb20gXCJsb2Rhc2gvbm9vcC5qc1wiO1xuaW1wb3J0IHsgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VNZW1vLCBzdGFydFRyYW5zaXRpb24sIHVzZUNhbGxiYWNrLCBmb3J3YXJkUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBFZGl0b3IsIFBhdGgsIFRyYW5zZm9ybXMsIFJhbmdlLCBFbGVtZW50IGFzIEVsZW1lbnQkMSwgVGV4dCwgTm9kZSB9IGZyb20gXCJzbGF0ZVwiO1xuaW1wb3J0IHsgdXNlU2xhdGVTdGF0aWMsIFJlYWN0RWRpdG9yLCB1c2VTZWxlY3RlZCwgdXNlU2xhdGUsIEVkaXRhYmxlIH0gZnJvbSBcInNsYXRlLXJlYWN0XCI7XG5pbXBvcnQgeyBjIH0gZnJvbSBcInJlYWN0LWNvbXBpbGVyLXJ1bnRpbWVcIjtcbmltcG9ydCB1bmlxIGZyb20gXCJsb2Rhc2gvdW5pcS5qc1wiO1xuaW1wb3J0IHsgaXNIb3RrZXkgfSBmcm9tIFwiLi9fY2h1bmtzLWVzL2JlaGF2aW9yLmNvcmUuanNcIjtcbmltcG9ydCB7IHVzZUVmZmVjdEV2ZW50IH0gZnJvbSBcInVzZS1lZmZlY3QtZXZlbnRcIjtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVBvaW50KHBvaW50LCB2YWx1ZSkge1xuICBpZiAoIXBvaW50IHx8ICF2YWx1ZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgbmV3UGF0aCA9IFtdO1xuICBsZXQgbmV3T2Zmc2V0ID0gcG9pbnQub2Zmc2V0IHx8IDA7XG4gIGNvbnN0IGJsb2NrS2V5ID0gdHlwZW9mIHBvaW50LnBhdGhbMF0gPT0gXCJvYmplY3RcIiAmJiBcIl9rZXlcIiBpbiBwb2ludC5wYXRoWzBdICYmIHBvaW50LnBhdGhbMF0uX2tleSwgY2hpbGRLZXkgPSB0eXBlb2YgcG9pbnQucGF0aFsyXSA9PSBcIm9iamVjdFwiICYmIFwiX2tleVwiIGluIHBvaW50LnBhdGhbMl0gJiYgcG9pbnQucGF0aFsyXS5fa2V5LCBibG9jayA9IHZhbHVlLmZpbmQoKGJsaykgPT4gYmxrLl9rZXkgPT09IGJsb2NrS2V5KTtcbiAgaWYgKGJsb2NrKVxuICAgIG5ld1BhdGgucHVzaCh7XG4gICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgfSk7XG4gIGVsc2VcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKGJsb2NrICYmIHBvaW50LnBhdGhbMV0gPT09IFwiY2hpbGRyZW5cIikge1xuICAgIGlmICghYmxvY2suY2hpbGRyZW4gfHwgQXJyYXkuaXNBcnJheShibG9jay5jaGlsZHJlbikgJiYgYmxvY2suY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgY2hpbGQgPSBBcnJheS5pc0FycmF5KGJsb2NrLmNoaWxkcmVuKSAmJiBibG9jay5jaGlsZHJlbi5maW5kKChjbGQpID0+IGNsZC5fa2V5ID09PSBjaGlsZEtleSk7XG4gICAgaWYgKGNoaWxkKVxuICAgICAgbmV3UGF0aC5wdXNoKFwiY2hpbGRyZW5cIiksIG5ld1BhdGgucHVzaCh7XG4gICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgIH0pLCBuZXdPZmZzZXQgPSBjaGlsZC50ZXh0ICYmIGNoaWxkLnRleHQubGVuZ3RoID49IHBvaW50Lm9mZnNldCA/IHBvaW50Lm9mZnNldCA6IGNoaWxkLnRleHQgJiYgY2hpbGQudGV4dC5sZW5ndGggfHwgMDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgb2Zmc2V0OiBuZXdPZmZzZXRcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlbGVjdGlvbihzZWxlY3Rpb24sIHZhbHVlKSB7XG4gIGlmICghc2VsZWN0aW9uIHx8ICF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBuZXdBbmNob3IgPSBudWxsLCBuZXdGb2N1cyA9IG51bGw7XG4gIGNvbnN0IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfSA9IHNlbGVjdGlvbjtcbiAgcmV0dXJuIGFuY2hvciAmJiB2YWx1ZS5maW5kKChibGspID0+IGlzRXF1YWwoe1xuICAgIF9rZXk6IGJsay5fa2V5XG4gIH0sIGFuY2hvci5wYXRoWzBdKSkgJiYgKG5ld0FuY2hvciA9IG5vcm1hbGl6ZVBvaW50KGFuY2hvciwgdmFsdWUpKSwgZm9jdXMgJiYgdmFsdWUuZmluZCgoYmxrKSA9PiBpc0VxdWFsKHtcbiAgICBfa2V5OiBibGsuX2tleVxuICB9LCBmb2N1cy5wYXRoWzBdKSkgJiYgKG5ld0ZvY3VzID0gbm9ybWFsaXplUG9pbnQoZm9jdXMsIHZhbHVlKSksIG5ld0FuY2hvciAmJiBuZXdGb2N1cyA/IHtcbiAgICBhbmNob3I6IG5ld0FuY2hvcixcbiAgICBmb2N1czogbmV3Rm9jdXMsXG4gICAgYmFja3dhcmQ6IHNlbGVjdGlvbi5iYWNrd2FyZFxuICB9IDogbnVsbDtcbn1cbmZ1bmN0aW9uIERlZmF1bHRCbG9ja09iamVjdChwcm9wcykge1xuICBjb25zdCAkID0gYyg0KTtcbiAgbGV0IHQwO1xuICAkWzBdID09PSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb19jYWNoZV9zZW50aW5lbFwiKSA/ICh0MCA9IHtcbiAgICB1c2VyU2VsZWN0OiBcIm5vbmVcIlxuICB9LCAkWzBdID0gdDApIDogdDAgPSAkWzBdO1xuICBsZXQgdDE7XG4gIHJldHVybiAkWzFdICE9PSBwcm9wcy52YWx1ZS5fa2V5IHx8ICRbMl0gIT09IHByb3BzLnZhbHVlLl90eXBlID8gKHQxID0gLyogQF9fUFVSRV9fICovIGpzeHMoXCJkaXZcIiwgeyBzdHlsZTogdDAsIGNoaWxkcmVuOiBbXG4gICAgXCJbXCIsXG4gICAgcHJvcHMudmFsdWUuX3R5cGUsXG4gICAgXCI6IFwiLFxuICAgIHByb3BzLnZhbHVlLl9rZXksXG4gICAgXCJdXCJcbiAgXSB9KSwgJFsxXSA9IHByb3BzLnZhbHVlLl9rZXksICRbMl0gPSBwcm9wcy52YWx1ZS5fdHlwZSwgJFszXSA9IHQxKSA6IHQxID0gJFszXSwgdDE7XG59XG5mdW5jdGlvbiBEZWZhdWx0SW5saW5lT2JqZWN0KHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDQpO1xuICBsZXQgdDA7XG4gICRbMF0gPT09IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpID8gKHQwID0ge1xuICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiXG4gIH0sICRbMF0gPSB0MCkgOiB0MCA9ICRbMF07XG4gIGxldCB0MTtcbiAgcmV0dXJuICRbMV0gIT09IHByb3BzLnZhbHVlLl9rZXkgfHwgJFsyXSAhPT0gcHJvcHMudmFsdWUuX3R5cGUgPyAodDEgPSAvKiBAX19QVVJFX18gKi8ganN4cyhcInNwYW5cIiwgeyBzdHlsZTogdDAsIGNoaWxkcmVuOiBbXG4gICAgXCJbXCIsXG4gICAgcHJvcHMudmFsdWUuX3R5cGUsXG4gICAgXCI6IFwiLFxuICAgIHByb3BzLnZhbHVlLl9rZXksXG4gICAgXCJdXCJcbiAgXSB9KSwgJFsxXSA9IHByb3BzLnZhbHVlLl9rZXksICRbMl0gPSBwcm9wcy52YWx1ZS5fdHlwZSwgJFszXSA9IHQxKSA6IHQxID0gJFszXSwgdDE7XG59XG5jb25zdCBkZWJ1ZyQzID0gZGVidWdXaXRoTmFtZShcImNvbXBvbmVudHM6RHJhZ2dhYmxlQmxvY2tcIiksIERyYWdnYWJsZUJsb2NrID0gKHQwKSA9PiB7XG4gIGNvbnN0ICQgPSBjKDUxKSwge1xuICAgIGNoaWxkcmVuLFxuICAgIGVsZW1lbnQsXG4gICAgcmVhZE9ubHksXG4gICAgYmxvY2tSZWZcbiAgfSA9IHQwLCBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpLCBkcmFnR2hvc3RSZWYgPSB1c2VSZWYodm9pZCAwKSwgW2lzRHJhZ092ZXIsIHNldElzRHJhZ092ZXJdID0gdXNlU3RhdGUoITEpO1xuICBsZXQgdDEsIHQyO1xuICAkWzBdICE9PSBlZGl0b3IgfHwgJFsxXSAhPT0gZWxlbWVudCA/ICh0MiA9IEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBlbGVtZW50KSwgJFswXSA9IGVkaXRvciwgJFsxXSA9IGVsZW1lbnQsICRbMl0gPSB0MikgOiB0MiA9ICRbMl0sIHQxID0gdDI7XG4gIGNvbnN0IGlzVm9pZCA9IHQxO1xuICBsZXQgdDMsIHQ0O1xuICAkWzNdICE9PSBlZGl0b3IgfHwgJFs0XSAhPT0gZWxlbWVudCA/ICh0NCA9IEVkaXRvci5pc0lubGluZShlZGl0b3IsIGVsZW1lbnQpLCAkWzNdID0gZWRpdG9yLCAkWzRdID0gZWxlbWVudCwgJFs1XSA9IHQ0KSA6IHQ0ID0gJFs1XSwgdDMgPSB0NDtcbiAgY29uc3QgaXNJbmxpbmUgPSB0MywgW2Jsb2NrRWxlbWVudCwgc2V0QmxvY2tFbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpO1xuICBsZXQgdDUsIHQ2O1xuICAkWzZdICE9PSBibG9ja1JlZiB8fCAkWzddICE9PSBlZGl0b3IgfHwgJFs4XSAhPT0gZWxlbWVudCA/ICh0NSA9ICgpID0+IHNldEJsb2NrRWxlbWVudChibG9ja1JlZiA/IGJsb2NrUmVmLmN1cnJlbnQgOiBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlbGVtZW50KSksIHQ2ID0gW2VkaXRvciwgZWxlbWVudCwgYmxvY2tSZWZdLCAkWzZdID0gYmxvY2tSZWYsICRbN10gPSBlZGl0b3IsICRbOF0gPSBlbGVtZW50LCAkWzldID0gdDUsICRbMTBdID0gdDYpIDogKHQ1ID0gJFs5XSwgdDYgPSAkWzEwXSksIHVzZUVmZmVjdCh0NSwgdDYpO1xuICBsZXQgdDc7XG4gICRbMTFdICE9PSBibG9ja0VsZW1lbnQgfHwgJFsxMl0gIT09IGVkaXRvciB8fCAkWzEzXSAhPT0gZWxlbWVudCA/ICh0NyA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IGlzTXlEcmFnT3ZlciA9IElTX0RSQUdHSU5HX0JMT0NLX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG4gICAgaWYgKCFpc015RHJhZ092ZXIgfHwgIWJsb2NrRWxlbWVudClcbiAgICAgIHJldHVybjtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpLCBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFwibW92ZVwiLCBJU19EUkFHR0lOR19FTEVNRU5UX1RBUkdFVC5zZXQoZWRpdG9yLCBlbGVtZW50KTtcbiAgICBjb25zdCBlbGVtZW50UmVjdCA9IGJsb2NrRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgb2Zmc2V0ID0gZWxlbWVudFJlY3QudG9wLCBoZWlnaHQgPSBlbGVtZW50UmVjdC5oZWlnaHQsIFkgPSBldmVudC5wYWdlWSwgbG9jID0gTWF0aC5hYnMob2Zmc2V0IC0gWSk7XG4gICAgaWYgKGVsZW1lbnQgPT09IGVkaXRvci5jaGlsZHJlblswXSB8fCAobG9jIDwgaGVpZ2h0IC8gMiA/IElTX0RSQUdHSU5HX0JMT0NLX1RBUkdFVF9QT1NJVElPTi5zZXQoZWRpdG9yLCBcInRvcFwiKSA6IElTX0RSQUdHSU5HX0JMT0NLX1RBUkdFVF9QT1NJVElPTi5zZXQoZWRpdG9yLCBcImJvdHRvbVwiKSksIGlzTXlEcmFnT3ZlciA9PT0gZWxlbWVudCkge1xuICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBcIm5vbmVcIjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0SXNEcmFnT3ZlcighMCk7XG4gIH0sICRbMTFdID0gYmxvY2tFbGVtZW50LCAkWzEyXSA9IGVkaXRvciwgJFsxM10gPSBlbGVtZW50LCAkWzE0XSA9IHQ3KSA6IHQ3ID0gJFsxNF07XG4gIGNvbnN0IGhhbmRsZURyYWdPdmVyID0gdDc7XG4gIGxldCB0ODtcbiAgJFsxNV0gPT09IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpID8gKHQ4ID0gKCkgPT4ge1xuICAgIHNldElzRHJhZ092ZXIoITEpO1xuICB9LCAkWzE1XSA9IHQ4KSA6IHQ4ID0gJFsxNV07XG4gIGNvbnN0IGhhbmRsZURyYWdMZWF2ZSA9IHQ4O1xuICBsZXQgdDk7XG4gICRbMTZdICE9PSBlZGl0b3IgfHwgJFsxN10gIT09IGVsZW1lbnQgPyAodDkgPSAoZXZlbnRfMCkgPT4ge1xuICAgIGNvbnN0IHRhcmdldEJsb2NrID0gSVNfRFJBR0dJTkdfRUxFTUVOVF9UQVJHRVQuZ2V0KGVkaXRvcik7XG4gICAgaWYgKHRhcmdldEJsb2NrKSB7XG4gICAgICBJU19EUkFHR0lORy5zZXQoZWRpdG9yLCAhMSksIGV2ZW50XzAucHJldmVudERlZmF1bHQoKSwgZXZlbnRfMC5zdG9wUHJvcGFnYXRpb24oKSwgSVNfRFJBR0dJTkdfRUxFTUVOVF9UQVJHRVQuZGVsZXRlKGVkaXRvciksIGRyYWdHaG9zdFJlZi5jdXJyZW50ICYmIChkZWJ1ZyQzKFwiUmVtb3ZpbmcgZHJhZyBnaG9zdFwiKSwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkcmFnR2hvc3RSZWYuY3VycmVudCkpO1xuICAgICAgY29uc3QgZHJhZ1Bvc2l0aW9uID0gSVNfRFJBR0dJTkdfQkxPQ0tfVEFSR0VUX1BPU0lUSU9OLmdldChlZGl0b3IpO1xuICAgICAgSVNfRFJBR0dJTkdfQkxPQ0tfVEFSR0VUX1BPU0lUSU9OLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgbGV0IHRhcmdldFBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIHRhcmdldEJsb2NrKTtcbiAgICAgIGNvbnN0IG15UGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgZWxlbWVudCksIGlzQmVmb3JlID0gUGF0aC5pc0JlZm9yZShteVBhdGgsIHRhcmdldFBhdGgpO1xuICAgICAgaWYgKGRyYWdQb3NpdGlvbiA9PT0gXCJib3R0b21cIiAmJiAhaXNCZWZvcmUpIHtcbiAgICAgICAgaWYgKHRhcmdldFBhdGhbMF0gPj0gZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBkZWJ1ZyQzKFwidGFyZ2V0IGlzIGFscmVhZHkgYXQgdGhlIGJvdHRvbSwgbm90IG1vdmluZ1wiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxQYXRoID0gdGFyZ2V0UGF0aDtcbiAgICAgICAgdGFyZ2V0UGF0aCA9IFBhdGgubmV4dCh0YXJnZXRQYXRoKSwgZGVidWckMyhgQWRqdXN0aW5nIHRhcmdldFBhdGggZnJvbSAke0pTT04uc3RyaW5naWZ5KG9yaWdpbmFsUGF0aCl9IHRvICR7SlNPTi5zdHJpbmdpZnkodGFyZ2V0UGF0aCl9YCk7XG4gICAgICB9XG4gICAgICBpZiAoZHJhZ1Bvc2l0aW9uID09PSBcInRvcFwiICYmIGlzQmVmb3JlICYmIHRhcmdldFBhdGhbMF0gIT09IGVkaXRvci5jaGlsZHJlbi5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUGF0aF8wID0gdGFyZ2V0UGF0aDtcbiAgICAgICAgdGFyZ2V0UGF0aCA9IFBhdGgucHJldmlvdXModGFyZ2V0UGF0aCksIGRlYnVnJDMoYEFkanVzdGluZyB0YXJnZXRQYXRoIGZyb20gJHtKU09OLnN0cmluZ2lmeShvcmlnaW5hbFBhdGhfMCl9IHRvICR7SlNPTi5zdHJpbmdpZnkodGFyZ2V0UGF0aCl9YCk7XG4gICAgICB9XG4gICAgICBpZiAoUGF0aC5lcXVhbHModGFyZ2V0UGF0aCwgbXlQYXRoKSkge1xuICAgICAgICBldmVudF8wLnByZXZlbnREZWZhdWx0KCksIGRlYnVnJDMoXCJ0YXJnZXRQYXRoIGFuZCBteVBhdGggaXMgdGhlIHNhbWUsIG5vdCBtb3ZpbmdcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlYnVnJDMoYE1vdmluZyBlbGVtZW50ICR7ZWxlbWVudC5fa2V5fSBmcm9tIHBhdGggJHtKU09OLnN0cmluZ2lmeShteVBhdGgpfSB0byAke0pTT04uc3RyaW5naWZ5KHRhcmdldFBhdGgpfSAoJHtkcmFnUG9zaXRpb259KWApLCBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IG15UGF0aCxcbiAgICAgICAgdG86IHRhcmdldFBhdGhcbiAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVidWckMyhcIk5vIHRhcmdldCBlbGVtZW50LCBub3QgZG9pbmcgYW55dGhpbmdcIik7XG4gIH0sICRbMTZdID0gZWRpdG9yLCAkWzE3XSA9IGVsZW1lbnQsICRbMThdID0gdDkpIDogdDkgPSAkWzE4XTtcbiAgY29uc3QgaGFuZGxlRHJhZ0VuZCA9IHQ5O1xuICBsZXQgdDEwO1xuICAkWzE5XSAhPT0gZWRpdG9yIHx8ICRbMjBdICE9PSBlbGVtZW50ID8gKHQxMCA9IChldmVudF8xKSA9PiB7XG4gICAgSVNfRFJBR0dJTkdfQkxPQ0tfRUxFTUVOVC5nZXQoZWRpdG9yKSAmJiAoZGVidWckMyhcIk9uIGRyb3AgKHByZXZlbnRlZClcIiwgZWxlbWVudCksIGV2ZW50XzEucHJldmVudERlZmF1bHQoKSwgZXZlbnRfMS5zdG9wUHJvcGFnYXRpb24oKSwgc2V0SXNEcmFnT3ZlcighMSkpO1xuICB9LCAkWzE5XSA9IGVkaXRvciwgJFsyMF0gPSBlbGVtZW50LCAkWzIxXSA9IHQxMCkgOiB0MTAgPSAkWzIxXTtcbiAgY29uc3QgaGFuZGxlRHJvcCA9IHQxMDtcbiAgbGV0IHQxMTtcbiAgJFsyMl0gIT09IGVkaXRvciB8fCAkWzIzXSAhPT0gZWxlbWVudCB8fCAkWzI0XSAhPT0gaXNWb2lkID8gKHQxMSA9IChldmVudF8yKSA9PiB7XG4gICAgaWYgKCFpc1ZvaWQpIHtcbiAgICAgIElTX0RSQUdHSU5HX0JMT0NLX0VMRU1FTlQuZGVsZXRlKGVkaXRvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIElTX0RSQUdHSU5HLnNldChlZGl0b3IsICEwKSwgSVNfRFJBR0dJTkdfQkxPQ0tfRUxFTUVOVC5zZXQoZWRpdG9yLCBlbGVtZW50KSwgZXZlbnRfMi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudF8yLnRhcmdldDtcbiAgICB0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiAodGFyZ2V0LnN0eWxlLm9wYWNpdHkgPSBcIjFcIik7XG4gIH0sICRbMjJdID0gZWRpdG9yLCAkWzIzXSA9IGVsZW1lbnQsICRbMjRdID0gaXNWb2lkLCAkWzI1XSA9IHQxMSkgOiB0MTEgPSAkWzI1XTtcbiAgY29uc3QgaGFuZGxlRHJhZyA9IHQxMTtcbiAgbGV0IHQxMjtcbiAgJFsyNl0gIT09IGJsb2NrRWxlbWVudCB8fCAkWzI3XSAhPT0gZWRpdG9yIHx8ICRbMjhdICE9PSBoYW5kbGVEcmFnIHx8ICRbMjldICE9PSBpc0lubGluZSB8fCAkWzMwXSAhPT0gaXNWb2lkID8gKHQxMiA9IChldmVudF8zKSA9PiB7XG4gICAgaWYgKCFpc1ZvaWQgfHwgaXNJbmxpbmUpIHtcbiAgICAgIGRlYnVnJDMoXCJOb3QgZHJhZ2dpbmcgYmxvY2tcIiksIElTX0RSQUdHSU5HX0JMT0NLX0VMRU1FTlQuZGVsZXRlKGVkaXRvciksIElTX0RSQUdHSU5HLnNldChlZGl0b3IsICExKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRlYnVnJDMoXCJEcmFnIHN0YXJ0XCIpLCBJU19EUkFHR0lORy5zZXQoZWRpdG9yLCAhMCksIGV2ZW50XzMuZGF0YVRyYW5zZmVyICYmIChldmVudF8zLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwiYXBwbGljYXRpb24vcG9ydGFibGUtdGV4dFwiLCBcInNvbWV0aGluZ1wiKSwgZXZlbnRfMy5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwibW92ZVwiKSwgYmxvY2tFbGVtZW50ICYmIGJsb2NrRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICBsZXQgZHJhZ0dob3N0ID0gYmxvY2tFbGVtZW50LmNsb25lTm9kZSghMCk7XG4gICAgICBjb25zdCBjdXN0b21HaG9zdCA9IGRyYWdHaG9zdC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtcHQtZHJhZy1naG9zdC1lbGVtZW50XVwiKTtcbiAgICAgIGlmIChjdXN0b21HaG9zdCAmJiAoZHJhZ0dob3N0ID0gY3VzdG9tR2hvc3QpLCBkcmFnR2hvc3Quc2V0QXR0cmlidXRlKFwiZGF0YS1kcmFnZ2VkXCIsIFwiXCIpLCBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIGRyYWdHaG9zdFJlZi5jdXJyZW50ID0gZHJhZ0dob3N0LCBkcmFnR2hvc3Quc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCIsIGRyYWdHaG9zdC5zdHlsZS5sZWZ0ID0gXCItOTk5OTlweFwiLCBkcmFnR2hvc3Quc3R5bGUuYm94U2l6aW5nID0gXCJib3JkZXItYm94XCIsIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZHJhZ0dob3N0KTtcbiAgICAgICAgY29uc3QgcmVjdCA9IGJsb2NrRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgeCA9IGV2ZW50XzMuY2xpZW50WCAtIHJlY3QubGVmdCwgeSA9IGV2ZW50XzMuY2xpZW50WSAtIHJlY3QudG9wO1xuICAgICAgICBkcmFnR2hvc3Quc3R5bGUud2lkdGggPSBgJHtyZWN0LndpZHRofXB4YCwgZHJhZ0dob3N0LnN0eWxlLmhlaWdodCA9IGAke3JlY3QuaGVpZ2h0fXB4YCwgZXZlbnRfMy5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKGRyYWdHaG9zdCwgeCwgeSk7XG4gICAgICB9XG4gICAgfVxuICAgIGhhbmRsZURyYWcoZXZlbnRfMyk7XG4gIH0sICRbMjZdID0gYmxvY2tFbGVtZW50LCAkWzI3XSA9IGVkaXRvciwgJFsyOF0gPSBoYW5kbGVEcmFnLCAkWzI5XSA9IGlzSW5saW5lLCAkWzMwXSA9IGlzVm9pZCwgJFszMV0gPSB0MTIpIDogdDEyID0gJFszMV07XG4gIGNvbnN0IGhhbmRsZURyYWdTdGFydCA9IHQxMjtcbiAgbGV0IHQxMztcbiAgJFszMl0gIT09IGVkaXRvciB8fCAkWzMzXSAhPT0gaXNEcmFnT3ZlciA/ICh0MTMgPSBpc0RyYWdPdmVyICYmIGVkaXRvci5jaGlsZHJlblswXSA9PT0gSVNfRFJBR0dJTkdfRUxFTUVOVF9UQVJHRVQuZ2V0KGVkaXRvciksICRbMzJdID0gZWRpdG9yLCAkWzMzXSA9IGlzRHJhZ092ZXIsICRbMzRdID0gdDEzKSA6IHQxMyA9ICRbMzRdO1xuICBjb25zdCBpc0RyYWdnaW5nT3ZlckZpcnN0QmxvY2sgPSB0MTM7XG4gIGxldCB0MTQ7XG4gICRbMzVdICE9PSBlZGl0b3IgfHwgJFszNl0gIT09IGlzRHJhZ092ZXIgPyAodDE0ID0gaXNEcmFnT3ZlciAmJiBlZGl0b3IuY2hpbGRyZW5bZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCAtIDFdID09PSBJU19EUkFHR0lOR19FTEVNRU5UX1RBUkdFVC5nZXQoZWRpdG9yKSwgJFszNV0gPSBlZGl0b3IsICRbMzZdID0gaXNEcmFnT3ZlciwgJFszN10gPSB0MTQpIDogdDE0ID0gJFszN107XG4gIGNvbnN0IGlzRHJhZ2dpbmdPdmVyTGFzdEJsb2NrID0gdDE0LCBkcmFnUG9zaXRpb25fMCA9IElTX0RSQUdHSU5HX0JMT0NLX1RBUkdFVF9QT1NJVElPTi5nZXQoZWRpdG9yKSwgaXNEcmFnZ2luZ092ZXJUb3AgPSBpc0RyYWdnaW5nT3ZlckZpcnN0QmxvY2sgfHwgaXNEcmFnT3ZlciAmJiAhaXNEcmFnZ2luZ092ZXJGaXJzdEJsb2NrICYmICFpc0RyYWdnaW5nT3Zlckxhc3RCbG9jayAmJiBkcmFnUG9zaXRpb25fMCA9PT0gXCJ0b3BcIiwgaXNEcmFnZ2luZ092ZXJCb3R0b20gPSBpc0RyYWdnaW5nT3Zlckxhc3RCbG9jayB8fCBpc0RyYWdPdmVyICYmICFpc0RyYWdnaW5nT3ZlckZpcnN0QmxvY2sgJiYgIWlzRHJhZ2dpbmdPdmVyTGFzdEJsb2NrICYmIGRyYWdQb3NpdGlvbl8wID09PSBcImJvdHRvbVwiO1xuICBsZXQgdDE1LCB0MTY7XG4gICRbMzhdID09PSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb19jYWNoZV9zZW50aW5lbFwiKSA/ICh0MTYgPSAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInB0LWRyb3AtaW5kaWNhdG9yXCIsIHN0eWxlOiB7XG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgaGVpZ2h0OiAxLFxuICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgY3VycmVudENvbG9yXCIsXG4gICAgekluZGV4OiA1XG4gIH0gfSksICRbMzhdID0gdDE2KSA6IHQxNiA9ICRbMzhdLCB0MTUgPSB0MTY7XG4gIGNvbnN0IGRyb3BJbmRpY2F0b3IgPSB0MTU7XG4gIGlmIChyZWFkT25seSkge1xuICAgIGxldCB0MTcyO1xuICAgIHJldHVybiAkWzM5XSAhPT0gY2hpbGRyZW4gPyAodDE3MiA9IC8qIEBfX1BVUkVfXyAqLyBqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW4gfSksICRbMzldID0gY2hpbGRyZW4sICRbNDBdID0gdDE3MikgOiB0MTcyID0gJFs0MF0sIHQxNzI7XG4gIH1cbiAgY29uc3QgdDE3ID0gaXNEcmFnZ2luZ092ZXJUb3AgJiYgZHJvcEluZGljYXRvciwgdDE4ID0gaXNEcmFnZ2luZ092ZXJCb3R0b20gJiYgZHJvcEluZGljYXRvcjtcbiAgbGV0IHQxOTtcbiAgcmV0dXJuICRbNDFdICE9PSBjaGlsZHJlbiB8fCAkWzQyXSAhPT0gaGFuZGxlRHJhZyB8fCAkWzQzXSAhPT0gaGFuZGxlRHJhZ0VuZCB8fCAkWzQ0XSAhPT0gaGFuZGxlRHJhZ092ZXIgfHwgJFs0NV0gIT09IGhhbmRsZURyYWdTdGFydCB8fCAkWzQ2XSAhPT0gaGFuZGxlRHJvcCB8fCAkWzQ3XSAhPT0gaXNWb2lkIHx8ICRbNDhdICE9PSB0MTcgfHwgJFs0OV0gIT09IHQxOCA/ICh0MTkgPSAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7IGRyYWdnYWJsZTogaXNWb2lkLCBvbkRyYWdTdGFydDogaGFuZGxlRHJhZ1N0YXJ0LCBvbkRyYWc6IGhhbmRsZURyYWcsIG9uRHJhZ092ZXI6IGhhbmRsZURyYWdPdmVyLCBvbkRyYWdMZWF2ZTogaGFuZGxlRHJhZ0xlYXZlLCBvbkRyYWdFbmQ6IGhhbmRsZURyYWdFbmQsIG9uRHJvcDogaGFuZGxlRHJvcCwgY2hpbGRyZW46IFtcbiAgICB0MTcsXG4gICAgY2hpbGRyZW4sXG4gICAgdDE4XG4gIF0gfSksICRbNDFdID0gY2hpbGRyZW4sICRbNDJdID0gaGFuZGxlRHJhZywgJFs0M10gPSBoYW5kbGVEcmFnRW5kLCAkWzQ0XSA9IGhhbmRsZURyYWdPdmVyLCAkWzQ1XSA9IGhhbmRsZURyYWdTdGFydCwgJFs0Nl0gPSBoYW5kbGVEcm9wLCAkWzQ3XSA9IGlzVm9pZCwgJFs0OF0gPSB0MTcsICRbNDldID0gdDE4LCAkWzUwXSA9IHQxOSkgOiB0MTkgPSAkWzUwXSwgdDE5O1xufTtcbkRyYWdnYWJsZUJsb2NrLmRpc3BsYXlOYW1lID0gXCJEcmFnZ2FibGVCbG9ja1wiO1xuZGVidWdXaXRoTmFtZShcImNvbXBvbmVudHM6RWxlbWVudFwiKTtcbmNvbnN0IEVNUFRZX0FOTk9UQVRJT05TID0gW10sIGlubGluZUJsb2NrU3R5bGUgPSB7XG4gIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCJcbn0sIEVsZW1lbnQgPSAoe1xuICBhdHRyaWJ1dGVzLFxuICBjaGlsZHJlbixcbiAgZWxlbWVudCxcbiAgc2NoZW1hVHlwZXMsXG4gIHJlYWRPbmx5LFxuICByZW5kZXJCbG9jayxcbiAgcmVuZGVyQ2hpbGQsXG4gIHJlbmRlckxpc3RJdGVtLFxuICByZW5kZXJTdHlsZSxcbiAgc3BlbGxDaGVja1xufSkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpLCBzZWxlY3RlZCA9IHVzZVNlbGVjdGVkKCksIGJsb2NrUmVmID0gdXNlUmVmKG51bGwpLCBpbmxpbmVCbG9ja09iamVjdFJlZiA9IHVzZVJlZihudWxsKSwgZm9jdXNlZCA9IHNlbGVjdGVkICYmIGVkaXRvci5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbikgfHwgITEsIHZhbHVlID0gdXNlTWVtbygoKSA9PiBmcm9tU2xhdGVWYWx1ZShbZWxlbWVudF0sIHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKVswXSwgW2VkaXRvciwgZWxlbWVudCwgc2NoZW1hVHlwZXMuYmxvY2submFtZV0pO1xuICBsZXQgcmVuZGVyZWRCbG9jayA9IGNoaWxkcmVuLCBjbGFzc05hbWU7XG4gIGNvbnN0IGJsb2NrUGF0aCA9IHVzZU1lbW8oKCkgPT4gW3tcbiAgICBfa2V5OiBlbGVtZW50Ll9rZXlcbiAgfV0sIFtlbGVtZW50XSk7XG4gIGlmICh0eXBlb2YgZWxlbWVudC5fdHlwZSAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGVsZW1lbnQgdG8gaGF2ZSBhIF90eXBlIHByb3BlcnR5XCIpO1xuICBpZiAodHlwZW9mIGVsZW1lbnQuX2tleSAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGVsZW1lbnQgdG8gaGF2ZSBhIF9rZXkgcHJvcGVydHlcIik7XG4gIGlmIChlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCkpIHtcbiAgICBjb25zdCBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBlbGVtZW50KSwgW2Jsb2NrXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCwge1xuICAgICAgZGVwdGg6IDFcbiAgICB9KSwgc2NoZW1hVHlwZSA9IHNjaGVtYVR5cGVzLmlubGluZU9iamVjdHMuZmluZCgoX3R5cGUpID0+IF90eXBlLm5hbWUgPT09IGVsZW1lbnQuX3R5cGUpO1xuICAgIGlmICghc2NoZW1hVHlwZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHR5cGUgZm9yIGlubGluZSBibG9jayBlbGVtZW50XCIpO1xuICAgIGlmIChFbGVtZW50JDEuaXNFbGVtZW50KGJsb2NrKSkge1xuICAgICAgY29uc3QgZWxtUGF0aCA9IFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBfa2V5OiBlbGVtZW50Ll9rZXlcbiAgICAgIH1dO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwic3BhblwiLCB7IC4uLmF0dHJpYnV0ZXMsIGNoaWxkcmVuOiBbXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4cyhcInNwYW5cIiwgeyBkcmFnZ2FibGU6ICFyZWFkT25seSwgY2xhc3NOYW1lOiBcInB0LWlubGluZS1vYmplY3RcIiwgXCJkYXRhLXRlc3RpZFwiOiBcInB0LWlubGluZS1vYmplY3RcIiwgcmVmOiBpbmxpbmVCbG9ja09iamVjdFJlZiwgc3R5bGU6IGlubGluZUJsb2NrU3R5bGUsIGNvbnRlbnRFZGl0YWJsZTogITEsIGNoaWxkcmVuOiBbXG4gICAgICAgICAgcmVuZGVyQ2hpbGQgJiYgcmVuZGVyQ2hpbGQoe1xuICAgICAgICAgICAgYW5ub3RhdGlvbnM6IEVNUFRZX0FOTk9UQVRJT05TLFxuICAgICAgICAgICAgLy8gVGhlc2UgaW5saW5lIG9iamVjdHMgY3VycmVudGx5IGRvZXNuJ3Qgc3VwcG9ydCBhbm5vdGF0aW9ucy4gVGhpcyBpcyBhIGxpbWl0YXRpb24gb2YgdGhlIGN1cnJlbnQgUFQgc3BlYy9tb2RlbC5cbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KERlZmF1bHRJbmxpbmVPYmplY3QsIHsgdmFsdWUgfSksXG4gICAgICAgICAgICBlZGl0b3JFbGVtZW50UmVmOiBpbmxpbmVCbG9ja09iamVjdFJlZixcbiAgICAgICAgICAgIGZvY3VzZWQsXG4gICAgICAgICAgICBwYXRoOiBlbG1QYXRoLFxuICAgICAgICAgICAgc2NoZW1hVHlwZSxcbiAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgdHlwZTogc2NoZW1hVHlwZSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSksXG4gICAgICAgICAgIXJlbmRlckNoaWxkICYmIC8qIEBfX1BVUkVfXyAqLyBqc3goRGVmYXVsdElubGluZU9iamVjdCwgeyB2YWx1ZSB9KVxuICAgICAgICBdIH0sIGVsZW1lbnQuX2tleSlcbiAgICAgIF0gfSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJsb2NrIG5vdCBmb3VuZCFcIik7XG4gIH1cbiAgaWYgKGVsZW1lbnQuX3R5cGUgPT09IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUpIHtcbiAgICBjbGFzc05hbWUgPSBcInB0LWJsb2NrIHB0LXRleHQtYmxvY2tcIjtcbiAgICBjb25zdCBpc0xpc3RJdGVtID0gXCJsaXN0SXRlbVwiIGluIGVsZW1lbnQsIHN0eWxlID0gXCJzdHlsZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC5zdHlsZSB8fCBcIm5vcm1hbFwiO1xuICAgIGNsYXNzTmFtZSA9IGBwdC1ibG9jayBwdC10ZXh0LWJsb2NrIHB0LXRleHQtYmxvY2stc3R5bGUtJHtzdHlsZX1gO1xuICAgIGNvbnN0IGJsb2NrU3R5bGVUeXBlID0gc2NoZW1hVHlwZXMuc3R5bGVzLmZpbmQoKGl0ZW0pID0+IGl0ZW0udmFsdWUgPT09IHN0eWxlKTtcbiAgICByZW5kZXJTdHlsZSAmJiBibG9ja1N0eWxlVHlwZSAmJiAocmVuZGVyZWRCbG9jayA9IHJlbmRlclN0eWxlKHtcbiAgICAgIGJsb2NrOiBlbGVtZW50LFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBmb2N1c2VkLFxuICAgICAgc2VsZWN0ZWQsXG4gICAgICB2YWx1ZTogc3R5bGUsXG4gICAgICBwYXRoOiBibG9ja1BhdGgsXG4gICAgICBzY2hlbWFUeXBlOiBibG9ja1N0eWxlVHlwZSxcbiAgICAgIGVkaXRvckVsZW1lbnRSZWY6IGJsb2NrUmVmXG4gICAgfSkpO1xuICAgIGxldCBsZXZlbDtcbiAgICBpZiAoaXNMaXN0SXRlbSAmJiAodHlwZW9mIGVsZW1lbnQubGV2ZWwgPT0gXCJudW1iZXJcIiAmJiAobGV2ZWwgPSBlbGVtZW50LmxldmVsKSwgY2xhc3NOYW1lICs9IGAgcHQtbGlzdC1pdGVtIHB0LWxpc3QtaXRlbS0ke2VsZW1lbnQubGlzdEl0ZW19IHB0LWxpc3QtaXRlbS1sZXZlbC0ke2xldmVsIHx8IDF9YCksIGVkaXRvci5pc0xpc3RCbG9jayh2YWx1ZSkgJiYgaXNMaXN0SXRlbSAmJiBlbGVtZW50Lmxpc3RJdGVtKSB7XG4gICAgICBjb25zdCBsaXN0VHlwZSA9IHNjaGVtYVR5cGVzLmxpc3RzLmZpbmQoKGl0ZW1fMCkgPT4gaXRlbV8wLnZhbHVlID09PSBlbGVtZW50Lmxpc3RJdGVtKTtcbiAgICAgIHJlbmRlckxpc3RJdGVtICYmIGxpc3RUeXBlICYmIChyZW5kZXJlZEJsb2NrID0gcmVuZGVyTGlzdEl0ZW0oe1xuICAgICAgICBibG9jazogdmFsdWUsXG4gICAgICAgIGNoaWxkcmVuOiByZW5kZXJlZEJsb2NrLFxuICAgICAgICBmb2N1c2VkLFxuICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgdmFsdWU6IGVsZW1lbnQubGlzdEl0ZW0sXG4gICAgICAgIHBhdGg6IGJsb2NrUGF0aCxcbiAgICAgICAgc2NoZW1hVHlwZTogbGlzdFR5cGUsXG4gICAgICAgIGxldmVsOiB2YWx1ZS5sZXZlbCB8fCAxLFxuICAgICAgICBlZGl0b3JFbGVtZW50UmVmOiBibG9ja1JlZlxuICAgICAgfSkpO1xuICAgIH1cbiAgICBjb25zdCByZW5kZXJQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICBjaGlsZHJlbjogcmVuZGVyZWRCbG9jayxcbiAgICAgIGVkaXRvckVsZW1lbnRSZWY6IGJsb2NrUmVmLFxuICAgICAgZm9jdXNlZCxcbiAgICAgIGxldmVsLFxuICAgICAgbGlzdEl0ZW06IGlzTGlzdEl0ZW0gPyBlbGVtZW50Lmxpc3RJdGVtIDogdm9pZCAwLFxuICAgICAgcGF0aDogYmxvY2tQYXRoLFxuICAgICAgc2VsZWN0ZWQsXG4gICAgICBzdHlsZSxcbiAgICAgIHNjaGVtYVR5cGU6IHNjaGVtYVR5cGVzLmJsb2NrLFxuICAgICAgdmFsdWVcbiAgICB9LCBcInR5cGVcIiwge1xuICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJQcm9wZXJ0eSAndHlwZScgaXMgZGVwcmVjYXRlZCwgdXNlICdzY2hlbWFUeXBlJyBpbnN0ZWFkLlwiKSwgc2NoZW1hVHlwZXMuYmxvY2s7XG4gICAgICB9XG4gICAgfSksIHByb3BzT3JEZWZhdWx0UmVuZGVyZWQgPSByZW5kZXJCbG9jayA/IHJlbmRlckJsb2NrKHJlbmRlclByb3BzKSA6IGNoaWxkcmVuO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgLi4uYXR0cmlidXRlcywgY2xhc3NOYW1lLCBzcGVsbENoZWNrLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChEcmFnZ2FibGVCbG9jaywgeyBlbGVtZW50LCByZWFkT25seSwgYmxvY2tSZWYsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgcmVmOiBibG9ja1JlZiwgY2hpbGRyZW46IHByb3BzT3JEZWZhdWx0UmVuZGVyZWQgfSkgfSkgfSwgZWxlbWVudC5fa2V5KTtcbiAgfVxuICBjb25zdCBzY2hlbWFUeXBlXzAgPSBzY2hlbWFUeXBlcy5ibG9ja09iamVjdHMuZmluZCgoX3R5cGVfMCkgPT4gX3R5cGVfMC5uYW1lID09PSBlbGVtZW50Ll90eXBlKTtcbiAgaWYgKCFzY2hlbWFUeXBlXzApXG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBzY2hlbWEgdHlwZSBmb3IgYmxvY2sgZWxlbWVudCBvZiBfdHlwZSAke2VsZW1lbnQuX3R5cGV9YCk7XG4gIGNsYXNzTmFtZSA9IFwicHQtYmxvY2sgcHQtb2JqZWN0LWJsb2NrXCI7XG4gIGNvbnN0IGJsb2NrXzAgPSBmcm9tU2xhdGVWYWx1ZShbZWxlbWVudF0sIHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKVswXTtcbiAgbGV0IHJlbmRlcmVkQmxvY2tGcm9tUHJvcHM7XG4gIGlmIChyZW5kZXJCbG9jaykge1xuICAgIGNvbnN0IF9wcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChEZWZhdWx0QmxvY2tPYmplY3QsIHsgdmFsdWUgfSksXG4gICAgICBlZGl0b3JFbGVtZW50UmVmOiBibG9ja1JlZixcbiAgICAgIGZvY3VzZWQsXG4gICAgICBwYXRoOiBibG9ja1BhdGgsXG4gICAgICBzY2hlbWFUeXBlOiBzY2hlbWFUeXBlXzAsXG4gICAgICBzZWxlY3RlZCxcbiAgICAgIHZhbHVlOiBibG9ja18wXG4gICAgfSwgXCJ0eXBlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiUHJvcGVydHkgJ3R5cGUnIGlzIGRlcHJlY2F0ZWQsIHVzZSAnc2NoZW1hVHlwZScgaW5zdGVhZC5cIiksIHNjaGVtYVR5cGVfMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZW5kZXJlZEJsb2NrRnJvbVByb3BzID0gcmVuZGVyQmxvY2soX3Byb3BzKTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoXCJkaXZcIiwgeyAuLi5hdHRyaWJ1dGVzLCBjbGFzc05hbWUsIGNoaWxkcmVuOiBbXG4gICAgY2hpbGRyZW4sXG4gICAgLyogQF9fUFVSRV9fICovIGpzeChEcmFnZ2FibGVCbG9jaywgeyBlbGVtZW50LCByZWFkT25seSwgYmxvY2tSZWYsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgcmVmOiBibG9ja1JlZiwgY29udGVudEVkaXRhYmxlOiAhMSwgY2hpbGRyZW46IHJlbmRlcmVkQmxvY2tGcm9tUHJvcHMgfHwgLyogQF9fUFVSRV9fICovIGpzeChEZWZhdWx0QmxvY2tPYmplY3QsIHsgdmFsdWUgfSkgfSkgfSlcbiAgXSB9LCBlbGVtZW50Ll9rZXkpO1xufTtcbkVsZW1lbnQuZGlzcGxheU5hbWUgPSBcIkVsZW1lbnRcIjtcbmNvbnN0IGRlYnVnJDIgPSBkZWJ1Z1dpdGhOYW1lKFwiY29tcG9uZW50czpMZWFmXCIpLCBFTVBUWV9NQVJLUyA9IFtdLCBMZWFmID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBlZGl0b3JBY3RvcixcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuLFxuICAgIGxlYWYsXG4gICAgc2NoZW1hVHlwZXMsXG4gICAgcmVuZGVyQ2hpbGQsXG4gICAgcmVuZGVyRGVjb3JhdG9yLFxuICAgIHJlbmRlckFubm90YXRpb25cbiAgfSA9IHByb3BzLCBzcGFuUmVmID0gdXNlUmVmKG51bGwpLCBwb3J0YWJsZVRleHRFZGl0b3IgPSB1c2VQb3J0YWJsZVRleHRFZGl0b3IoKSwgYmxvY2tTZWxlY3RlZCA9IHVzZVNlbGVjdGVkKCksIFtmb2N1c2VkLCBzZXRGb2N1c2VkXSA9IHVzZVN0YXRlKCExKSwgW3NlbGVjdGVkLCBzZXRTZWxlY3RlZF0gPSB1c2VTdGF0ZSghMSksIGJsb2NrID0gY2hpbGRyZW4ucHJvcHMucGFyZW50LCBwYXRoID0gdXNlTWVtbygoKSA9PiBibG9jayA/IFt7XG4gICAgX2tleTogYmxvY2s/Ll9rZXlcbiAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgX2tleTogbGVhZi5fa2V5XG4gIH1dIDogW10sIFtibG9jaywgbGVhZi5fa2V5XSksIGRlY29yYXRvclZhbHVlcyA9IHVzZU1lbW8oKCkgPT4gc2NoZW1hVHlwZXMuZGVjb3JhdG9ycy5tYXAoKGRlYykgPT4gZGVjLnZhbHVlKSwgW3NjaGVtYVR5cGVzLmRlY29yYXRvcnNdKSwgbWFya3MgPSB1c2VNZW1vKCgpID0+IHVuaXEoKGxlYWYubWFya3MgfHwgRU1QVFlfTUFSS1MpLmZpbHRlcigobWFyaykgPT4gZGVjb3JhdG9yVmFsdWVzLmluY2x1ZGVzKG1hcmspKSksIFtkZWNvcmF0b3JWYWx1ZXMsIGxlYWYubWFya3NdKSwgYW5ub3RhdGlvbk1hcmtzID0gQXJyYXkuaXNBcnJheShsZWFmLm1hcmtzKSA/IGxlYWYubWFya3MgOiBFTVBUWV9NQVJLUywgYW5ub3RhdGlvbnMgPSB1c2VNZW1vKCgpID0+IGFubm90YXRpb25NYXJrcy5tYXAoKG1hcmtfMCkgPT4gIWRlY29yYXRvclZhbHVlcy5pbmNsdWRlcyhtYXJrXzApICYmIGJsb2NrPy5tYXJrRGVmcz8uZmluZCgoZGVmKSA9PiBkZWYuX2tleSA9PT0gbWFya18wKSkuZmlsdGVyKEJvb2xlYW4pLCBbYW5ub3RhdGlvbk1hcmtzLCBibG9jaywgZGVjb3JhdG9yVmFsdWVzXSksIHNob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXMgPSBhbm5vdGF0aW9ucy5sZW5ndGggPiAwICYmIGJsb2NrU2VsZWN0ZWQ7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NlbGVjdGlvbkFuZEZvY3VzKSB7XG4gICAgICBzZXRGb2N1c2VkKCExKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsID0gUG9ydGFibGVUZXh0RWRpdG9yLmdldFNlbGVjdGlvbihwb3J0YWJsZVRleHRFZGl0b3IpO1xuICAgIHNlbCAmJiBpc0VxdWFsKHNlbC5mb2N1cy5wYXRoLCBwYXRoKSAmJiBQb3J0YWJsZVRleHRFZGl0b3IuaXNDb2xsYXBzZWRTZWxlY3Rpb24ocG9ydGFibGVUZXh0RWRpdG9yKSAmJiBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgc2V0Rm9jdXNlZCghMCk7XG4gICAgfSk7XG4gIH0sIFtzaG91bGRUcmFja1NlbGVjdGlvbkFuZEZvY3VzLCBwYXRoLCBwb3J0YWJsZVRleHRFZGl0b3JdKTtcbiAgY29uc3Qgc2V0U2VsZWN0ZWRGcm9tUmFuZ2UgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NlbGVjdGlvbkFuZEZvY3VzKVxuICAgICAgcmV0dXJuO1xuICAgIGRlYnVnJDIoXCJTZXR0aW5nIHNlbGVjdGlvbiBhbmQgZm9jdXMgZnJvbSByYW5nZVwiKTtcbiAgICBjb25zdCB3aW5TZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCF3aW5TZWxlY3Rpb24pIHtcbiAgICAgIHNldFNlbGVjdGVkKCExKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHdpblNlbGVjdGlvbiAmJiB3aW5TZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDApIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gd2luU2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICBzcGFuUmVmLmN1cnJlbnQgJiYgcmFuZ2UuaW50ZXJzZWN0c05vZGUoc3BhblJlZi5jdXJyZW50KSA/IHNldFNlbGVjdGVkKCEwKSA6IHNldFNlbGVjdGVkKCExKTtcbiAgICB9IGVsc2VcbiAgICAgIHNldFNlbGVjdGVkKCExKTtcbiAgfSwgW3Nob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgb25CbHVyID0gZWRpdG9yQWN0b3Iub24oXCJibHVyXCIsICgpID0+IHtcbiAgICAgIHNldEZvY3VzZWQoITEpLCBzZXRTZWxlY3RlZCghMSk7XG4gICAgfSksIG9uRm9jdXMgPSBlZGl0b3JBY3Rvci5vbihcImZvY3VzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbF8wID0gUG9ydGFibGVUZXh0RWRpdG9yLmdldFNlbGVjdGlvbihwb3J0YWJsZVRleHRFZGl0b3IpO1xuICAgICAgc2VsXzAgJiYgaXNFcXVhbChzZWxfMC5mb2N1cy5wYXRoLCBwYXRoKSAmJiBQb3J0YWJsZVRleHRFZGl0b3IuaXNDb2xsYXBzZWRTZWxlY3Rpb24ocG9ydGFibGVUZXh0RWRpdG9yKSAmJiBzZXRGb2N1c2VkKCEwKSwgc2V0U2VsZWN0ZWRGcm9tUmFuZ2UoKTtcbiAgICB9KSwgb25TZWxlY3Rpb24gPSBlZGl0b3JBY3Rvci5vbihcInNlbGVjdGlvblwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnNlbGVjdGlvbiAmJiBpc0VxdWFsKGV2ZW50LnNlbGVjdGlvbi5mb2N1cy5wYXRoLCBwYXRoKSAmJiBQb3J0YWJsZVRleHRFZGl0b3IuaXNDb2xsYXBzZWRTZWxlY3Rpb24ocG9ydGFibGVUZXh0RWRpdG9yKSA/IHNldEZvY3VzZWQoITApIDogc2V0Rm9jdXNlZCghMSksIHNldFNlbGVjdGVkRnJvbVJhbmdlKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG9uQmx1ci51bnN1YnNjcmliZSgpLCBvbkZvY3VzLnVuc3Vic2NyaWJlKCksIG9uU2VsZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgW2VkaXRvckFjdG9yLCBwYXRoLCBwb3J0YWJsZVRleHRFZGl0b3IsIHNldFNlbGVjdGVkRnJvbVJhbmdlLCBzaG91bGRUcmFja1NlbGVjdGlvbkFuZEZvY3VzXSksIHVzZUVmZmVjdCgoKSA9PiBzZXRTZWxlY3RlZEZyb21SYW5nZSgpLCBbc2V0U2VsZWN0ZWRGcm9tUmFuZ2VdKTtcbiAgY29uc3QgY29udGVudCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCByZXR1cm5lZENoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgaWYgKFRleHQuaXNUZXh0KGxlYWYpICYmIGxlYWYuX3R5cGUgPT09IHNjaGVtYVR5cGVzLnNwYW4ubmFtZSAmJiAobWFya3MuZm9yRWFjaCgobWFya18xKSA9PiB7XG4gICAgICBjb25zdCBzY2hlbWFUeXBlID0gc2NoZW1hVHlwZXMuZGVjb3JhdG9ycy5maW5kKChkZWNfMCkgPT4gZGVjXzAudmFsdWUgPT09IG1hcmtfMSk7XG4gICAgICBpZiAoc2NoZW1hVHlwZSAmJiByZW5kZXJEZWNvcmF0b3IpIHtcbiAgICAgICAgY29uc3QgX3Byb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgICAgICAgICBjaGlsZHJlbjogcmV0dXJuZWRDaGlsZHJlbixcbiAgICAgICAgICBlZGl0b3JFbGVtZW50UmVmOiBzcGFuUmVmLFxuICAgICAgICAgIGZvY3VzZWQsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICBzY2hlbWFUeXBlLFxuICAgICAgICAgIHZhbHVlOiBtYXJrXzFcbiAgICAgICAgfSwgXCJ0eXBlXCIsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiUHJvcGVydHkgJ3R5cGUnIGlzIGRlcHJlY2F0ZWQsIHVzZSAnc2NoZW1hVHlwZScgaW5zdGVhZC5cIiksIHNjaGVtYVR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuZWRDaGlsZHJlbiA9IHJlbmRlckRlY29yYXRvcihfcHJvcHMpO1xuICAgICAgfVxuICAgIH0pLCBibG9jayAmJiBhbm5vdGF0aW9ucy5sZW5ndGggPiAwICYmIGFubm90YXRpb25zLmZvckVhY2goKGFubm90YXRpb24pID0+IHtcbiAgICAgIGNvbnN0IHNjaGVtYVR5cGVfMCA9IHNjaGVtYVR5cGVzLmFubm90YXRpb25zLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gYW5ub3RhdGlvbi5fdHlwZSk7XG4gICAgICBpZiAoc2NoZW1hVHlwZV8wKVxuICAgICAgICBpZiAocmVuZGVyQW5ub3RhdGlvbikge1xuICAgICAgICAgIGNvbnN0IF9wcm9wc18wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICAgY2hpbGRyZW46IHJldHVybmVkQ2hpbGRyZW4sXG4gICAgICAgICAgICBlZGl0b3JFbGVtZW50UmVmOiBzcGFuUmVmLFxuICAgICAgICAgICAgZm9jdXNlZCxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICAgIHNjaGVtYVR5cGU6IHNjaGVtYVR5cGVfMCxcbiAgICAgICAgICAgIHZhbHVlOiBhbm5vdGF0aW9uXG4gICAgICAgICAgfSwgXCJ0eXBlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiUHJvcGVydHkgJ3R5cGUnIGlzIGRlcHJlY2F0ZWQsIHVzZSAnc2NoZW1hVHlwZScgaW5zdGVhZC5cIiksIHNjaGVtYVR5cGVfMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm5lZENoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyByZWY6IHNwYW5SZWYsIGNoaWxkcmVuOiByZW5kZXJBbm5vdGF0aW9uKF9wcm9wc18wKSB9KTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgcmV0dXJuZWRDaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHsgcmVmOiBzcGFuUmVmLCBjaGlsZHJlbjogcmV0dXJuZWRDaGlsZHJlbiB9KTtcbiAgICB9KSwgYmxvY2sgJiYgcmVuZGVyQ2hpbGQpKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGJsb2NrLmNoaWxkcmVuLmZpbmQoKF9jaGlsZCkgPT4gX2NoaWxkLl9rZXkgPT09IGxlYWYuX2tleSk7XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgY29uc3QgX3Byb3BzXzEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiByZXR1cm5lZENoaWxkcmVuIH0pLFxuICAgICAgICAgIGVkaXRvckVsZW1lbnRSZWY6IHNwYW5SZWYsXG4gICAgICAgICAgZm9jdXNlZCxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHNjaGVtYVR5cGU6IHNjaGVtYVR5cGVzLnNwYW4sXG4gICAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgICAgdmFsdWU6IGNoaWxkXG4gICAgICAgIH0sIFwidHlwZVwiLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihcIlByb3BlcnR5ICd0eXBlJyBpcyBkZXByZWNhdGVkLCB1c2UgJ3NjaGVtYVR5cGUnIGluc3RlYWQuXCIpLCBzY2hlbWFUeXBlcy5zcGFuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybmVkQ2hpbGRyZW4gPSByZW5kZXJDaGlsZChfcHJvcHNfMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5lZENoaWxkcmVuO1xuICB9LCBbYW5ub3RhdGlvbnMsIGJsb2NrLCBjaGlsZHJlbiwgZm9jdXNlZCwgbGVhZiwgbWFya3MsIHBhdGgsIHJlbmRlckFubm90YXRpb24sIHJlbmRlckNoaWxkLCByZW5kZXJEZWNvcmF0b3IsIHNjaGVtYVR5cGVzLmFubm90YXRpb25zLCBzY2hlbWFUeXBlcy5kZWNvcmF0b3JzLCBzY2hlbWFUeXBlcy5zcGFuLCBzZWxlY3RlZF0pO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IC4uLmF0dHJpYnV0ZXMsIHJlZjogc3BhblJlZiwgY2hpbGRyZW46IGNvbnRlbnQgfSwgbGVhZi5fa2V5KSwgW2xlYWYsIGF0dHJpYnV0ZXMsIGNvbnRlbnRdKTtcbn07XG5MZWFmLmRpc3BsYXlOYW1lID0gXCJMZWFmXCI7XG5jb25zdCBkZWJ1ZyQxID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoSG90S2V5c1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhIb3RrZXlzKGVkaXRvckFjdG9yLCBwb3J0YWJsZVRleHRFZGl0b3IsIGhvdGtleXNGcm9tT3B0aW9ucykge1xuICBjb25zdCByZXNlcnZlZEhvdGtleXMgPSBbXCJlbnRlclwiLCBcInRhYlwiLCBcInNoaWZ0XCIsIFwiZGVsZXRlXCIsIFwiZW5kXCJdLCBhY3RpdmVIb3RrZXlzID0gaG90a2V5c0Zyb21PcHRpb25zID8/IHt9O1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wdGVXaXRoSG90S2V5cyA9IChldmVudCkgPT4ge1xuICAgICAgT2JqZWN0LmtleXMoYWN0aXZlSG90a2V5cykuZm9yRWFjaCgoY2F0KSA9PiB7XG4gICAgICAgIGlmIChjYXQgPT09IFwibWFya3NcIilcbiAgICAgICAgICBmb3IgKGNvbnN0IGhvdGtleSBpbiBhY3RpdmVIb3RrZXlzW2NhdF0pIHtcbiAgICAgICAgICAgIGlmIChyZXNlcnZlZEhvdGtleXMuaW5jbHVkZXMoaG90a2V5KSlcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgaG90a2V5ICR7aG90a2V5fSBpcyByZXNlcnZlZCFgKTtcbiAgICAgICAgICAgIGlmIChpc0hvdGtleShob3RrZXksIGV2ZW50Lm5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBjb25zdCBwb3NzaWJsZU1hcmsgPSBhY3RpdmVIb3RrZXlzW2NhdF07XG4gICAgICAgICAgICAgIGlmIChwb3NzaWJsZU1hcmspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrID0gcG9zc2libGVNYXJrW2hvdGtleV07XG4gICAgICAgICAgICAgICAgZGVidWckMShgSG90S2V5ICR7aG90a2V5fSB0byB0b2dnbGUgJHttYXJrfWApLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgICAgICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkZWNvcmF0b3IudG9nZ2xlXCIsXG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRvcjogbWFya1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBpZiAoY2F0ID09PSBcImN1c3RvbVwiKVxuICAgICAgICAgIGZvciAoY29uc3QgaG90a2V5IGluIGFjdGl2ZUhvdGtleXNbY2F0XSkge1xuICAgICAgICAgICAgaWYgKHJlc2VydmVkSG90a2V5cy5pbmNsdWRlcyhob3RrZXkpKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBob3RrZXkgJHtob3RrZXl9IGlzIHJlc2VydmVkIWApO1xuICAgICAgICAgICAgaWYgKGlzSG90a2V5KGhvdGtleSwgZXZlbnQubmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlQ29tbWFuZCA9IGFjdGl2ZUhvdGtleXNbY2F0XTtcbiAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlQ29tbWFuZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1hbmQgPSBwb3NzaWJsZUNvbW1hbmRbaG90a2V5XTtcbiAgICAgICAgICAgICAgICBjb21tYW5kKGV2ZW50LCBwb3J0YWJsZVRleHRFZGl0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuZnVuY3Rpb24gd2l0aFN5bmNSYW5nZURlY29yYXRpb25zKHtcbiAgZWRpdG9yQWN0b3IsXG4gIHNsYXRlRWRpdG9yLFxuICBzeW5jUmFuZ2VEZWNvcmF0aW9uc1xufSkge1xuICBjb25zdCBvcmlnaW5hbEFwcGx5ID0gc2xhdGVFZGl0b3IuYXBwbHk7XG4gIHJldHVybiBzbGF0ZUVkaXRvci5hcHBseSA9IChvcCkgPT4ge1xuICAgIG9yaWdpbmFsQXBwbHkob3ApLCAhZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5tYXRjaGVzKHtcbiAgICAgIFwiZWRpdCBtb2RlXCI6IFwicmVhZCBvbmx5XCJcbiAgICB9KSAmJiBvcC50eXBlICE9PSBcInNldF9zZWxlY3Rpb25cIiAmJiBzeW5jUmFuZ2VEZWNvcmF0aW9ucyhvcCk7XG4gIH0sICgpID0+IHtcbiAgICBzbGF0ZUVkaXRvci5hcHBseSA9IG9yaWdpbmFsQXBwbHk7XG4gIH07XG59XG5jb25zdCBkZWJ1ZyA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnQ6RWRpdGFibGVcIiksIFBMQUNFSE9MREVSX1NUWUxFID0ge1xuICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICB1c2VyU2VsZWN0OiBcIm5vbmVcIixcbiAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gIGxlZnQ6IDAsXG4gIHJpZ2h0OiAwXG59LCBQb3J0YWJsZVRleHRFZGl0YWJsZSA9IGZvcndhcmRSZWYoZnVuY3Rpb24ocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICBjb25zdCB7XG4gICAgaG90a2V5cyxcbiAgICBvbkJsdXIsXG4gICAgb25Gb2N1cyxcbiAgICBvbkJlZm9yZUlucHV0LFxuICAgIG9uUGFzdGUsXG4gICAgb25Db3B5LFxuICAgIG9uQ2xpY2ssXG4gICAgcmFuZ2VEZWNvcmF0aW9ucyxcbiAgICByZW5kZXJBbm5vdGF0aW9uLFxuICAgIHJlbmRlckJsb2NrLFxuICAgIHJlbmRlckNoaWxkLFxuICAgIHJlbmRlckRlY29yYXRvcixcbiAgICByZW5kZXJMaXN0SXRlbSxcbiAgICByZW5kZXJQbGFjZWhvbGRlcixcbiAgICByZW5kZXJTdHlsZSxcbiAgICBzZWxlY3Rpb246IHByb3BzU2VsZWN0aW9uLFxuICAgIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3LFxuICAgIHNwZWxsQ2hlY2ssXG4gICAgLi4ucmVzdFByb3BzXG4gIH0gPSBwcm9wcywgcG9ydGFibGVUZXh0RWRpdG9yID0gdXNlUG9ydGFibGVUZXh0RWRpdG9yKCksIHJlZiA9IHVzZVJlZihudWxsKSwgW2VkaXRhYmxlRWxlbWVudCwgc2V0RWRpdGFibGVFbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpLCBbaGFzSW52YWxpZFZhbHVlLCBzZXRIYXNJbnZhbGlkVmFsdWVdID0gdXNlU3RhdGUoITEpLCBbcmFuZ2VEZWNvcmF0aW9uU3RhdGUsIHNldFJhbmdlRGVjb3JhdGlvbnNTdGF0ZV0gPSB1c2VTdGF0ZShbXSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUoZm9yd2FyZGVkUmVmLCAoKSA9PiByZWYuY3VycmVudCk7XG4gIGNvbnN0IHJhbmdlRGVjb3JhdGlvbnNSZWYgPSB1c2VSZWYocmFuZ2VEZWNvcmF0aW9ucyksIGVkaXRvckFjdG9yID0gdXNlQ29udGV4dChFZGl0b3JBY3RvckNvbnRleHQpLCByZWFkT25seSA9IHVzZVNlbGVjdG9yKGVkaXRvckFjdG9yLCAocykgPT4gcy5tYXRjaGVzKHtcbiAgICBcImVkaXQgbW9kZVwiOiBcInJlYWQgb25seVwiXG4gIH0pKSwgc2NoZW1hVHlwZXMgPSB1c2VTZWxlY3RvcihlZGl0b3JBY3RvciwgKHNfMCkgPT4gc18wLmNvbnRleHQuc2NoZW1hKSwgc2xhdGVFZGl0b3IgPSB1c2VTbGF0ZSgpLCBibG9ja1R5cGVOYW1lID0gc2NoZW1hVHlwZXMuYmxvY2submFtZTtcbiAgdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHJlYWRPbmx5KVxuICAgICAgcmV0dXJuIGRlYnVnKFwiRWRpdGFibGUgaXMgaW4gcmVhZCBvbmx5IG1vZGVcIiksIHNsYXRlRWRpdG9yO1xuICAgIGNvbnN0IHdpdGhIb3RLZXlzID0gY3JlYXRlV2l0aEhvdGtleXMoZWRpdG9yQWN0b3IsIHBvcnRhYmxlVGV4dEVkaXRvciwgaG90a2V5cyk7XG4gICAgcmV0dXJuIGRlYnVnKFwiRWRpdGFibGUgaXMgaW4gZWRpdCBtb2RlXCIpLCB3aXRoSG90S2V5cyhzbGF0ZUVkaXRvcik7XG4gIH0sIFtlZGl0b3JBY3RvciwgaG90a2V5cywgcG9ydGFibGVUZXh0RWRpdG9yLCByZWFkT25seSwgc2xhdGVFZGl0b3JdKTtcbiAgY29uc3QgcmVuZGVyRWxlbWVudCA9IHVzZUNhbGxiYWNrKChlUHJvcHMpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goRWxlbWVudCwgeyAuLi5lUHJvcHMsIHJlYWRPbmx5LCByZW5kZXJCbG9jaywgcmVuZGVyQ2hpbGQsIHJlbmRlckxpc3RJdGVtLCByZW5kZXJTdHlsZSwgc2NoZW1hVHlwZXMsIHNwZWxsQ2hlY2sgfSksIFtzY2hlbWFUeXBlcywgc3BlbGxDaGVjaywgcmVhZE9ubHksIHJlbmRlckJsb2NrLCByZW5kZXJDaGlsZCwgcmVuZGVyTGlzdEl0ZW0sIHJlbmRlclN0eWxlXSksIHJlbmRlckxlYWYgPSB1c2VDYWxsYmFjaygobFByb3BzKSA9PiB7XG4gICAgaWYgKGxQcm9wcy5sZWFmLl90eXBlID09PSBcInNwYW5cIikge1xuICAgICAgbGV0IHJlbmRlcmVkID0gLyogQF9fUFVSRV9fICovIGpzeChMZWFmLCB7IC4uLmxQcm9wcywgZWRpdG9yQWN0b3IsIHNjaGVtYVR5cGVzLCByZW5kZXJBbm5vdGF0aW9uLCByZW5kZXJDaGlsZCwgcmVuZGVyRGVjb3JhdG9yLCByZWFkT25seSB9KTtcbiAgICAgIGlmIChyZW5kZXJQbGFjZWhvbGRlciAmJiBsUHJvcHMubGVhZi5wbGFjZWhvbGRlciAmJiBsUHJvcHMudGV4dC50ZXh0ID09PSBcIlwiKVxuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IHN0eWxlOiBQTEFDRUhPTERFUl9TVFlMRSwgY29udGVudEVkaXRhYmxlOiAhMSwgY2hpbGRyZW46IHJlbmRlclBsYWNlaG9sZGVyKCkgfSksXG4gICAgICAgICAgcmVuZGVyZWRcbiAgICAgICAgXSB9KTtcbiAgICAgIGNvbnN0IGRlY29yYXRpb24gPSBsUHJvcHMubGVhZi5yYW5nZURlY29yYXRpb247XG4gICAgICByZXR1cm4gZGVjb3JhdGlvbiAmJiAocmVuZGVyZWQgPSBkZWNvcmF0aW9uLmNvbXBvbmVudCh7XG4gICAgICAgIGNoaWxkcmVuOiByZW5kZXJlZFxuICAgICAgfSkpLCByZW5kZXJlZDtcbiAgICB9XG4gICAgcmV0dXJuIGxQcm9wcy5jaGlsZHJlbjtcbiAgfSwgW2VkaXRvckFjdG9yLCByZWFkT25seSwgcmVuZGVyQW5ub3RhdGlvbiwgcmVuZGVyQ2hpbGQsIHJlbmRlckRlY29yYXRvciwgcmVuZGVyUGxhY2Vob2xkZXIsIHNjaGVtYVR5cGVzXSksIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHByb3BzU2VsZWN0aW9uKSB7XG4gICAgICBkZWJ1ZyhgU2VsZWN0aW9uIGZyb20gcHJvcHMgJHtKU09OLnN0cmluZ2lmeShwcm9wc1NlbGVjdGlvbil9YCk7XG4gICAgICBjb25zdCBub3JtYWxpemVkU2VsZWN0aW9uID0gbm9ybWFsaXplU2VsZWN0aW9uKHByb3BzU2VsZWN0aW9uLCBmcm9tU2xhdGVWYWx1ZShzbGF0ZUVkaXRvci5jaGlsZHJlbiwgYmxvY2tUeXBlTmFtZSkpO1xuICAgICAgaWYgKG5vcm1hbGl6ZWRTZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgZGVidWcoYE5vcm1hbGl6ZWQgc2VsZWN0aW9uIGZyb20gcHJvcHMgJHtKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VsZWN0aW9uKX1gKTtcbiAgICAgICAgY29uc3Qgc2xhdGVSYW5nZSA9IHRvU2xhdGVSYW5nZShub3JtYWxpemVkU2VsZWN0aW9uLCBzbGF0ZUVkaXRvcik7XG4gICAgICAgIHNsYXRlUmFuZ2UgJiYgKFRyYW5zZm9ybXMuc2VsZWN0KHNsYXRlRWRpdG9yLCBzbGF0ZVJhbmdlKSwgc2xhdGVFZGl0b3Iub3BlcmF0aW9ucy5zb21lKChvKSA9PiBvLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiKSB8fCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcIm5vdGlmeS5zZWxlY3Rpb25cIixcbiAgICAgICAgICBzZWxlY3Rpb246IG5vcm1hbGl6ZWRTZWxlY3Rpb25cbiAgICAgICAgfSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2Jsb2NrVHlwZU5hbWUsIGVkaXRvckFjdG9yLCBwcm9wc1NlbGVjdGlvbiwgc2xhdGVFZGl0b3JdKSwgc3luY1JhbmdlRGVjb3JhdGlvbnMgPSB1c2VDYWxsYmFjaygob3BlcmF0aW9uKSA9PiB7XG4gICAgaWYgKHJhbmdlRGVjb3JhdGlvbnMgJiYgcmFuZ2VEZWNvcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBuZXdTbGF0ZVJhbmdlcyA9IFtdO1xuICAgICAgaWYgKHJhbmdlRGVjb3JhdGlvbnMuZm9yRWFjaCgocmFuZ2VEZWNvcmF0aW9uSXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBzbGF0ZVJhbmdlXzAgPSB0b1NsYXRlUmFuZ2UocmFuZ2VEZWNvcmF0aW9uSXRlbS5zZWxlY3Rpb24sIHNsYXRlRWRpdG9yKTtcbiAgICAgICAgaWYgKCFSYW5nZS5pc1JhbmdlKHNsYXRlUmFuZ2VfMCkpIHtcbiAgICAgICAgICByYW5nZURlY29yYXRpb25JdGVtLm9uTW92ZWQgJiYgcmFuZ2VEZWNvcmF0aW9uSXRlbS5vbk1vdmVkKHtcbiAgICAgICAgICAgIG5ld1NlbGVjdGlvbjogbnVsbCxcbiAgICAgICAgICAgIHJhbmdlRGVjb3JhdGlvbjogcmFuZ2VEZWNvcmF0aW9uSXRlbSxcbiAgICAgICAgICAgIG9yaWdpbjogXCJsb2NhbFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdSYW5nZTtcbiAgICAgICAgaWYgKG9wZXJhdGlvbiAmJiAobmV3UmFuZ2UgPSBtb3ZlUmFuZ2VCeU9wZXJhdGlvbihzbGF0ZVJhbmdlXzAsIG9wZXJhdGlvbiksIG5ld1JhbmdlICYmIG5ld1JhbmdlICE9PSBzbGF0ZVJhbmdlXzAgfHwgbmV3UmFuZ2UgPT09IG51bGwgJiYgc2xhdGVSYW5nZV8wKSkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gUG9ydGFibGVUZXh0RWRpdG9yLmdldFZhbHVlKHBvcnRhYmxlVGV4dEVkaXRvciksIG5ld1JhbmdlU2VsZWN0aW9uID0gdG9Qb3J0YWJsZVRleHRSYW5nZSh2YWx1ZSwgbmV3UmFuZ2UsIHNjaGVtYVR5cGVzKTtcbiAgICAgICAgICByYW5nZURlY29yYXRpb25JdGVtLm9uTW92ZWQgJiYgcmFuZ2VEZWNvcmF0aW9uSXRlbS5vbk1vdmVkKHtcbiAgICAgICAgICAgIG5ld1NlbGVjdGlvbjogbmV3UmFuZ2VTZWxlY3Rpb24sXG4gICAgICAgICAgICByYW5nZURlY29yYXRpb246IHJhbmdlRGVjb3JhdGlvbkl0ZW0sXG4gICAgICAgICAgICBvcmlnaW46IFwibG9jYWxcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG5ld1JhbmdlICE9PSBudWxsICYmIG5ld1NsYXRlUmFuZ2VzLnB1c2goe1xuICAgICAgICAgIC4uLm5ld1JhbmdlIHx8IHNsYXRlUmFuZ2VfMCxcbiAgICAgICAgICByYW5nZURlY29yYXRpb246IHJhbmdlRGVjb3JhdGlvbkl0ZW1cbiAgICAgICAgfSk7XG4gICAgICB9KSwgbmV3U2xhdGVSYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBzZXRSYW5nZURlY29yYXRpb25zU3RhdGUobmV3U2xhdGVSYW5nZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHNldFJhbmdlRGVjb3JhdGlvbnNTdGF0ZSgocmFuZ2VEZWNvcmF0aW9uU3RhdGVfMCkgPT4gcmFuZ2VEZWNvcmF0aW9uU3RhdGVfMC5sZW5ndGggPiAwID8gW10gOiByYW5nZURlY29yYXRpb25TdGF0ZV8wKTtcbiAgfSwgW3BvcnRhYmxlVGV4dEVkaXRvciwgcmFuZ2VEZWNvcmF0aW9ucywgc2NoZW1hVHlwZXMsIHNsYXRlRWRpdG9yXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgb25SZWFkeSA9IGVkaXRvckFjdG9yLm9uKFwicmVhZHlcIiwgKCkgPT4ge1xuICAgICAgc3luY1JhbmdlRGVjb3JhdGlvbnMoKSwgcmVzdG9yZVNlbGVjdGlvbkZyb21Qcm9wcygpO1xuICAgIH0pLCBvbkludmFsaWRWYWx1ZSA9IGVkaXRvckFjdG9yLm9uKFwiaW52YWxpZCB2YWx1ZVwiLCAoKSA9PiB7XG4gICAgICBzZXRIYXNJbnZhbGlkVmFsdWUoITApO1xuICAgIH0pLCBvblZhbHVlQ2hhbmdlZCA9IGVkaXRvckFjdG9yLm9uKFwidmFsdWUgY2hhbmdlZFwiLCAoKSA9PiB7XG4gICAgICBzZXRIYXNJbnZhbGlkVmFsdWUoITEpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBvblJlYWR5LnVuc3Vic2NyaWJlKCksIG9uSW52YWxpZFZhbHVlLnVuc3Vic2NyaWJlKCksIG9uVmFsdWVDaGFuZ2VkLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgW2VkaXRvckFjdG9yLCByZXN0b3JlU2VsZWN0aW9uRnJvbVByb3BzLCBzeW5jUmFuZ2VEZWNvcmF0aW9uc10pLCB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHByb3BzU2VsZWN0aW9uICYmICFoYXNJbnZhbGlkVmFsdWUgJiYgcmVzdG9yZVNlbGVjdGlvbkZyb21Qcm9wcygpO1xuICB9LCBbaGFzSW52YWxpZFZhbHVlLCBwcm9wc1NlbGVjdGlvbiwgcmVzdG9yZVNlbGVjdGlvbkZyb21Qcm9wc10pO1xuICBjb25zdCBbc3luY2VkUmFuZ2VEZWNvcmF0aW9ucywgc2V0U3luY2VkUmFuZ2VEZWNvcmF0aW9uc10gPSB1c2VTdGF0ZSghMSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc3luY2VkUmFuZ2VEZWNvcmF0aW9ucyB8fCAoc2V0U3luY2VkUmFuZ2VEZWNvcmF0aW9ucyghMCksIHN5bmNSYW5nZURlY29yYXRpb25zKCkpO1xuICB9LCBbc3luY1JhbmdlRGVjb3JhdGlvbnMsIHN5bmNlZFJhbmdlRGVjb3JhdGlvbnNdKSwgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpc0VxdWFsKHJhbmdlRGVjb3JhdGlvbnMsIHJhbmdlRGVjb3JhdGlvbnNSZWYuY3VycmVudCkgfHwgc3luY1JhbmdlRGVjb3JhdGlvbnMoKSwgcmFuZ2VEZWNvcmF0aW9uc1JlZi5jdXJyZW50ID0gcmFuZ2VEZWNvcmF0aW9ucztcbiAgfSwgW3JhbmdlRGVjb3JhdGlvbnMsIHN5bmNSYW5nZURlY29yYXRpb25zXSksIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgdGVhcmRvd24gPSB3aXRoU3luY1JhbmdlRGVjb3JhdGlvbnMoe1xuICAgICAgZWRpdG9yQWN0b3IsXG4gICAgICBzbGF0ZUVkaXRvcixcbiAgICAgIHN5bmNSYW5nZURlY29yYXRpb25zXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHRlYXJkb3duKCk7XG4gIH0sIFtlZGl0b3JBY3Rvciwgc2xhdGVFZGl0b3IsIHN5bmNSYW5nZURlY29yYXRpb25zXSk7XG4gIGNvbnN0IGhhbmRsZUNvcHkgPSB1c2VDYWxsYmFjaygoZXZlbnQpID0+IHtcbiAgICBvbkNvcHkgPyBvbkNvcHkoZXZlbnQpICE9PSB2b2lkIDAgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKSA6IGV2ZW50Lm5hdGl2ZUV2ZW50LmNsaXBib2FyZERhdGEgJiYgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgIHR5cGU6IFwiY29weVwiLFxuICAgICAgICBkYXRhOiBldmVudC5uYXRpdmVFdmVudC5jbGlwYm9hcmREYXRhXG4gICAgICB9LFxuICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvcixcbiAgICAgIG5hdGl2ZUV2ZW50OiBldmVudFxuICAgIH0pO1xuICB9LCBbb25Db3B5LCBlZGl0b3JBY3Rvciwgc2xhdGVFZGl0b3JdKSwgaGFuZGxlUGFzdGUgPSB1c2VDYWxsYmFjaygoZXZlbnRfMCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlXzAgPSBQb3J0YWJsZVRleHRFZGl0b3IuZ2V0VmFsdWUocG9ydGFibGVUZXh0RWRpdG9yKSwgcGF0aCA9IHRvUG9ydGFibGVUZXh0UmFuZ2UodmFsdWVfMCwgc2xhdGVFZGl0b3Iuc2VsZWN0aW9uLCBzY2hlbWFUeXBlcyk/LmZvY3VzLnBhdGggfHwgW10sIG9uUGFzdGVSZXN1bHQgPSBvblBhc3RlPy4oe1xuICAgICAgZXZlbnQ6IGV2ZW50XzAsXG4gICAgICB2YWx1ZTogdmFsdWVfMCxcbiAgICAgIHBhdGgsXG4gICAgICBzY2hlbWFUeXBlc1xuICAgIH0pO1xuICAgIG9uUGFzdGVSZXN1bHQgfHwgIXNsYXRlRWRpdG9yLnNlbGVjdGlvbiA/IChldmVudF8wLnByZXZlbnREZWZhdWx0KCksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJub3RpZnkubG9hZGluZ1wiXG4gICAgfSksIFByb21pc2UucmVzb2x2ZShvblBhc3RlUmVzdWx0KS50aGVuKChyZXN1bHRfMCkgPT4ge1xuICAgICAgZGVidWcoXCJDdXN0b20gcGFzdGUgZnVuY3Rpb24gZnJvbSBjbGllbnQgcmVzb2x2ZWRcIiwgcmVzdWx0XzApLCAhcmVzdWx0XzAgfHwgIXJlc3VsdF8wLmluc2VydCA/IChkZWJ1ZyhcIk5vIHJlc3VsdCBmcm9tIGN1c3RvbSBwYXN0ZSBoYW5kbGVyLCBwYXN0aW5nIG5vcm1hbGx5XCIpLCBzbGF0ZUVkaXRvci5pbnNlcnREYXRhKGV2ZW50XzAuY2xpcGJvYXJkRGF0YSkpIDogcmVzdWx0XzAuaW5zZXJ0ID8gc2xhdGVFZGl0b3IuaW5zZXJ0RnJhZ21lbnQodG9TbGF0ZVZhbHVlKHJlc3VsdF8wLmluc2VydCwge1xuICAgICAgICBzY2hlbWFUeXBlc1xuICAgICAgfSkpIDogY29uc29sZS53YXJuKFwiWW91ciBvblBhc3RlIGZ1bmN0aW9uIHJldHVybmVkIHNvbWV0aGluZyB1bmV4cGVjdGVkOlwiLCByZXN1bHRfMCk7XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiAoY29uc29sZS5lcnJvcihlcnJvciksIGVycm9yKSkuZmluYWxseSgoKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJub3RpZnkuZG9uZSBsb2FkaW5nXCJcbiAgICAgIH0pO1xuICAgIH0pKSA6IGV2ZW50XzAubmF0aXZlRXZlbnQuY2xpcGJvYXJkRGF0YSAmJiBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgdHlwZTogXCJwYXN0ZVwiLFxuICAgICAgICBkYXRhOiBldmVudF8wLm5hdGl2ZUV2ZW50LmNsaXBib2FyZERhdGFcbiAgICAgIH0sXG4gICAgICBlZGl0b3I6IHNsYXRlRWRpdG9yLFxuICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50XzBcbiAgICB9KSwgZGVidWcoXCJObyByZXN1bHQgZnJvbSBjdXN0b20gcGFzdGUgaGFuZGxlciwgcGFzdGluZyBub3JtYWxseVwiKTtcbiAgfSwgW2VkaXRvckFjdG9yLCBvblBhc3RlLCBwb3J0YWJsZVRleHRFZGl0b3IsIHNjaGVtYVR5cGVzLCBzbGF0ZUVkaXRvcl0pLCBoYW5kbGVPbkZvY3VzID0gdXNlQ2FsbGJhY2soKGV2ZW50XzEpID0+IHtcbiAgICBpZiAob25Gb2N1cyAmJiBvbkZvY3VzKGV2ZW50XzEpLCAhZXZlbnRfMS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gUG9ydGFibGVUZXh0RWRpdG9yLmdldFNlbGVjdGlvbihwb3J0YWJsZVRleHRFZGl0b3IpO1xuICAgICAgc2VsZWN0aW9uID09PSBudWxsICYmIChUcmFuc2Zvcm1zLnNlbGVjdChzbGF0ZUVkaXRvciwgRWRpdG9yLnN0YXJ0KHNsYXRlRWRpdG9yLCBbXSkpLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwibm90aWZ5LmZvY3VzZWRcIixcbiAgICAgICAgZXZlbnQ6IGV2ZW50XzFcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gUG9ydGFibGVUZXh0RWRpdG9yLmdldFNlbGVjdGlvbihwb3J0YWJsZVRleHRFZGl0b3IpO1xuICAgICAgc2VsZWN0aW9uID09PSBuZXdTZWxlY3Rpb24gJiYgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwibm90aWZ5LnNlbGVjdGlvblwiLFxuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2VkaXRvckFjdG9yLCBvbkZvY3VzLCBwb3J0YWJsZVRleHRFZGl0b3IsIHNsYXRlRWRpdG9yXSksIGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soKGV2ZW50XzIpID0+IHtcbiAgICBvbkNsaWNrICYmIG9uQ2xpY2soZXZlbnRfMik7XG4gICAgY29uc3QgZm9jdXNCbG9ja1BhdGggPSBzbGF0ZUVkaXRvci5zZWxlY3Rpb24gPyBzbGF0ZUVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKSA6IHZvaWQgMCwgZm9jdXNCbG9jayA9IGZvY3VzQmxvY2tQYXRoID8gTm9kZS5kZXNjZW5kYW50KHNsYXRlRWRpdG9yLCBmb2N1c0Jsb2NrUGF0aCkgOiB2b2lkIDAsIFtfLCBsYXN0Tm9kZVBhdGhdID0gTm9kZS5sYXN0KHNsYXRlRWRpdG9yLCBbXSksIGxhc3RCbG9ja1BhdGggPSBsYXN0Tm9kZVBhdGguc2xpY2UoMCwgMSksIGxhc3ROb2RlRm9jdXNlZCA9IGZvY3VzQmxvY2tQYXRoID8gUGF0aC5lcXVhbHMobGFzdEJsb2NrUGF0aCwgZm9jdXNCbG9ja1BhdGgpIDogITEsIGxhc3RCbG9ja0lzVm9pZCA9IGZvY3VzQmxvY2sgPyAhc2xhdGVFZGl0b3IuaXNUZXh0QmxvY2soZm9jdXNCbG9jaykgOiAhMTtcbiAgICBzbGF0ZUVkaXRvci5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2xhdGVFZGl0b3Iuc2VsZWN0aW9uKSAmJiBsYXN0Tm9kZUZvY3VzZWQgJiYgbGFzdEJsb2NrSXNWb2lkICYmIChUcmFuc2Zvcm1zLmluc2VydE5vZGVzKHNsYXRlRWRpdG9yLCBzbGF0ZUVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgICAgZGVjb3JhdG9yczogW11cbiAgICB9KSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpO1xuICB9LCBbb25DbGljaywgc2xhdGVFZGl0b3JdKSwgaGFuZGxlT25CbHVyID0gdXNlQ2FsbGJhY2soKGV2ZW50XzMpID0+IHtcbiAgICBvbkJsdXIgJiYgb25CbHVyKGV2ZW50XzMpLCBldmVudF8zLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgfHwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcIm5vdGlmeS5ibHVycmVkXCIsXG4gICAgICBldmVudDogZXZlbnRfM1xuICAgIH0pO1xuICB9LCBbZWRpdG9yQWN0b3IsIG9uQmx1cl0pLCBoYW5kbGVPbkJlZm9yZUlucHV0ID0gdXNlQ2FsbGJhY2soKGV2ZW50XzQpID0+IHtcbiAgICBvbkJlZm9yZUlucHV0ICYmIG9uQmVmb3JlSW5wdXQoZXZlbnRfNCk7XG4gIH0sIFtvbkJlZm9yZUlucHV0XSksIHZhbGlkYXRlU2VsZWN0aW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghc2xhdGVFZGl0b3Iuc2VsZWN0aW9uKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3Qoc2xhdGVFZGl0b3IpLCB7XG4gICAgICBhY3RpdmVFbGVtZW50XG4gICAgfSA9IHJvb3Q7XG4gICAgaWYgKHJlZi5jdXJyZW50ICE9PSBhY3RpdmVFbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhzbGF0ZUVkaXRvcikuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFkb21TZWxlY3Rpb24gfHwgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZXhpc3RpbmdET01SYW5nZSA9IGRvbVNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBuZXdET01SYW5nZSA9IFJlYWN0RWRpdG9yLnRvRE9NUmFuZ2Uoc2xhdGVFZGl0b3IsIHNsYXRlRWRpdG9yLnNlbGVjdGlvbik7XG4gICAgICAobmV3RE9NUmFuZ2Uuc3RhcnRPZmZzZXQgIT09IGV4aXN0aW5nRE9NUmFuZ2Uuc3RhcnRPZmZzZXQgfHwgbmV3RE9NUmFuZ2UuZW5kT2Zmc2V0ICE9PSBleGlzdGluZ0RPTVJhbmdlLmVuZE9mZnNldCkgJiYgKGRlYnVnKFwiRE9NIHJhbmdlIG91dCBvZiBzeW5jLCB2YWxpZGF0aW5nIHNlbGVjdGlvblwiKSwgZG9tU2VsZWN0aW9uPy5yZW1vdmVBbGxSYW5nZXMoKSwgZG9tU2VsZWN0aW9uLmFkZFJhbmdlKG5ld0RPTVJhbmdlKSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBkZWJ1ZyhcIkNvdWxkIG5vdCByZXNvbHZlIHNlbGVjdGlvbiwgc2VsZWN0aW5nIHRvcCBkb2N1bWVudFwiKSwgVHJhbnNmb3Jtcy5kZXNlbGVjdChzbGF0ZUVkaXRvciksIHNsYXRlRWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgVHJhbnNmb3Jtcy5zZWxlY3Qoc2xhdGVFZGl0b3IsIFswLCAwXSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgfVxuICB9LCBbcmVmLCBzbGF0ZUVkaXRvcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlZGl0YWJsZUVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih2YWxpZGF0ZVNlbGVjdGlvbik7XG4gICAgICByZXR1cm4gbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKGVkaXRhYmxlRWxlbWVudCwge1xuICAgICAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogITEsXG4gICAgICAgIGF0dHJpYnV0ZXM6ICExLFxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiAhMSxcbiAgICAgICAgY2hpbGRMaXN0OiAhMCxcbiAgICAgICAgc3VidHJlZTogITBcbiAgICAgIH0pLCAoKSA9PiB7XG4gICAgICAgIG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFt2YWxpZGF0ZVNlbGVjdGlvbiwgZWRpdGFibGVFbGVtZW50XSk7XG4gIGNvbnN0IGhhbmRsZUtleURvd24gPSB1c2VDYWxsYmFjaygoZXZlbnRfNSkgPT4ge1xuICAgIHByb3BzLm9uS2V5RG93biAmJiBwcm9wcy5vbktleURvd24oZXZlbnRfNSksIGV2ZW50XzUuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgc2xhdGVFZGl0b3IucHRlV2l0aEhvdEtleXMoZXZlbnRfNSksIGV2ZW50XzUuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgIHR5cGU6IFwia2V5LmRvd25cIixcbiAgICAgICAga2V5Ym9hcmRFdmVudDoge1xuICAgICAgICAgIGtleTogZXZlbnRfNS5rZXksXG4gICAgICAgICAgY29kZTogZXZlbnRfNS5jb2RlLFxuICAgICAgICAgIGFsdEtleTogZXZlbnRfNS5hbHRLZXksXG4gICAgICAgICAgY3RybEtleTogZXZlbnRfNS5jdHJsS2V5LFxuICAgICAgICAgIG1ldGFLZXk6IGV2ZW50XzUubWV0YUtleSxcbiAgICAgICAgICBzaGlmdEtleTogZXZlbnRfNS5zaGlmdEtleVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvcixcbiAgICAgIG5hdGl2ZUV2ZW50OiBldmVudF81XG4gICAgfSk7XG4gIH0sIFtwcm9wcywgZWRpdG9yQWN0b3IsIHNsYXRlRWRpdG9yXSksIGhhbmRsZUtleVVwID0gdXNlQ2FsbGJhY2soKGV2ZW50XzYpID0+IHtcbiAgICBwcm9wcy5vbktleVVwICYmIHByb3BzLm9uS2V5VXAoZXZlbnRfNiksIGV2ZW50XzYuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgIHR5cGU6IFwia2V5LnVwXCIsXG4gICAgICAgIGtleWJvYXJkRXZlbnQ6IHtcbiAgICAgICAgICBrZXk6IGV2ZW50XzYua2V5LFxuICAgICAgICAgIGNvZGU6IGV2ZW50XzYuY29kZSxcbiAgICAgICAgICBhbHRLZXk6IGV2ZW50XzYuYWx0S2V5LFxuICAgICAgICAgIGN0cmxLZXk6IGV2ZW50XzYuY3RybEtleSxcbiAgICAgICAgICBtZXRhS2V5OiBldmVudF82Lm1ldGFLZXksXG4gICAgICAgICAgc2hpZnRLZXk6IGV2ZW50XzYuc2hpZnRLZXlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVkaXRvcjogc2xhdGVFZGl0b3IsXG4gICAgICBuYXRpdmVFdmVudDogZXZlbnRfNlxuICAgIH0pO1xuICB9LCBbcHJvcHMsIGVkaXRvckFjdG9yLCBzbGF0ZUVkaXRvcl0pLCBzY3JvbGxTZWxlY3Rpb25JbnRvVmlld1RvU2xhdGUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyA9PT0gbnVsbCA/IG5vb3AgOiAoX2VkaXRvciwgZG9tUmFuZ2UpID0+IHtcbiAgICAgICAgc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcocG9ydGFibGVUZXh0RWRpdG9yLCBkb21SYW5nZSk7XG4gICAgICB9O1xuICB9LCBbcG9ydGFibGVUZXh0RWRpdG9yLCBzY3JvbGxTZWxlY3Rpb25JbnRvVmlld10pLCBkZWNvcmF0ZSA9IHVzZUNhbGxiYWNrKChbLCBwYXRoXzBdKSA9PiB7XG4gICAgaWYgKGlzRXF1YWxUb0VtcHR5RWRpdG9yKHNsYXRlRWRpdG9yLmNoaWxkcmVuLCBzY2hlbWFUeXBlcykpXG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgcGF0aDogWzAsIDBdLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBmb2N1czoge1xuICAgICAgICAgIHBhdGg6IFswLCAwXSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgcGxhY2Vob2xkZXI6ICEwXG4gICAgICB9XTtcbiAgICBpZiAocGF0aF8wLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCByZXN1bHRfMSA9IHJhbmdlRGVjb3JhdGlvblN0YXRlLmZpbHRlcigoaXRlbSkgPT4gUmFuZ2UuaXNDb2xsYXBzZWQoaXRlbSkgPyBwYXRoXzAubGVuZ3RoICE9PSAyID8gITEgOiBQYXRoLmVxdWFscyhpdGVtLmZvY3VzLnBhdGgsIHBhdGhfMCkgJiYgUGF0aC5lcXVhbHMoaXRlbS5hbmNob3IucGF0aCwgcGF0aF8wKSA6IFJhbmdlLmludGVyc2VjdGlvbihpdGVtLCB7XG4gICAgICBhbmNob3I6IHtcbiAgICAgICAgcGF0aDogcGF0aF8wLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czoge1xuICAgICAgICBwYXRoOiBwYXRoXzAsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfVxuICAgIH0pIHx8IFJhbmdlLmluY2x1ZGVzKGl0ZW0sIHBhdGhfMCkpO1xuICAgIHJldHVybiByZXN1bHRfMS5sZW5ndGggPiAwID8gcmVzdWx0XzEgOiBbXTtcbiAgfSwgW3NsYXRlRWRpdG9yLCBzY2hlbWFUeXBlcywgcmFuZ2VEZWNvcmF0aW9uU3RhdGVdKTtcbiAgcmV0dXJuIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoc2xhdGVFZGl0b3IsIHNsYXRlRWRpdG9yKSwgc2V0RWRpdGFibGVFbGVtZW50KHJlZi5jdXJyZW50KTtcbiAgfSwgW3NsYXRlRWRpdG9yLCByZWZdKSwgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB3aW5kb3dfMCA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhzbGF0ZUVkaXRvciksIG9uRHJhZ0VuZCA9ICgpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImRyYWdlbmRcIlxuICAgICAgfSk7XG4gICAgfSwgb25Ecm9wID0gKCkgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiZHJvcFwiXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiB3aW5kb3dfMC5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2VuZFwiLCBvbkRyYWdFbmQpLCB3aW5kb3dfMC5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCBvbkRyb3ApLCAoKSA9PiB7XG4gICAgICB3aW5kb3dfMC5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZ2VuZFwiLCBvbkRyYWdFbmQpLCB3aW5kb3dfMC5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJvcFwiLCBvbkRyb3ApO1xuICAgIH07XG4gIH0sIFtzbGF0ZUVkaXRvciwgZWRpdG9yQWN0b3JdKSwgcG9ydGFibGVUZXh0RWRpdG9yID8gaGFzSW52YWxpZFZhbHVlID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgRWRpdGFibGUsXG4gICAge1xuICAgICAgLi4ucmVzdFByb3BzLFxuICAgICAgYXV0b0ZvY3VzOiAhMSxcbiAgICAgIGNsYXNzTmFtZTogcmVzdFByb3BzLmNsYXNzTmFtZSB8fCBcInB0LWVkaXRhYmxlXCIsXG4gICAgICBkZWNvcmF0ZSxcbiAgICAgIG9uQmx1cjogaGFuZGxlT25CbHVyLFxuICAgICAgb25Db3B5OiBoYW5kbGVDb3B5LFxuICAgICAgb25DbGljazogaGFuZGxlQ2xpY2ssXG4gICAgICBvbkRPTUJlZm9yZUlucHV0OiBoYW5kbGVPbkJlZm9yZUlucHV0LFxuICAgICAgb25EcmFnU3RhcnQ6IChldmVudF83KSA9PiB7XG4gICAgICAgIHByb3BzLm9uRHJhZ1N0YXJ0Py4oZXZlbnRfNyksICFldmVudF83LmlzRGVmYXVsdFByZXZlbnRlZCgpICYmICFldmVudF83LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgJiYgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJkcmFnc3RhcnRcIlxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbkZvY3VzOiBoYW5kbGVPbkZvY3VzLFxuICAgICAgb25LZXlEb3duOiBoYW5kbGVLZXlEb3duLFxuICAgICAgb25LZXlVcDogaGFuZGxlS2V5VXAsXG4gICAgICBvblBhc3RlOiBoYW5kbGVQYXN0ZSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcmVuZGVyUGxhY2Vob2xkZXI6IHZvaWQgMCxcbiAgICAgIHJlbmRlckVsZW1lbnQsXG4gICAgICByZW5kZXJMZWFmLFxuICAgICAgc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXc6IHNjcm9sbFNlbGVjdGlvbkludG9WaWV3VG9TbGF0ZVxuICAgIH1cbiAgKSA6IG51bGw7XG59KTtcblBvcnRhYmxlVGV4dEVkaXRhYmxlLmRpc3BsYXlOYW1lID0gXCJGb3J3YXJkUmVmKFBvcnRhYmxlVGV4dEVkaXRhYmxlKVwiO1xuZnVuY3Rpb24gRWRpdG9yRXZlbnRMaXN0ZW5lcihwcm9wcykge1xuICBjb25zdCAkID0gYyg1KSwgZWRpdG9yID0gdXNlRWRpdG9yKCksIG9uID0gdXNlRWZmZWN0RXZlbnQocHJvcHMub24pO1xuICBsZXQgdDA7XG4gICRbMF0gIT09IGVkaXRvciB8fCAkWzFdICE9PSBvbiA/ICh0MCA9ICgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBlZGl0b3Iub24oXCIqXCIsIG9uKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgJFswXSA9IGVkaXRvciwgJFsxXSA9IG9uLCAkWzJdID0gdDApIDogdDAgPSAkWzJdO1xuICBsZXQgdDE7XG4gIHJldHVybiAkWzNdICE9PSBlZGl0b3IgPyAodDEgPSBbZWRpdG9yXSwgJFszXSA9IGVkaXRvciwgJFs0XSA9IHQxKSA6IHQxID0gJFs0XSwgdXNlRWZmZWN0KHQwLCB0MSksIG51bGw7XG59XG5leHBvcnQge1xuICBFZGl0b3JFdmVudExpc3RlbmVyLFxuICBFZGl0b3JQcm92aWRlcixcbiAgUG9ydGFibGVUZXh0RWRpdGFibGUsXG4gIFBvcnRhYmxlVGV4dEVkaXRvcixcbiAgZGVmaW5lU2NoZW1hLFxuICBkZWZhdWx0S2V5R2VuZXJhdG9yIGFzIGtleUdlbmVyYXRvcixcbiAgdXNlRWRpdG9yLFxuICB1c2VFZGl0b3JTZWxlY3RvcixcbiAgdXNlUG9ydGFibGVUZXh0RWRpdG9yLFxuICB1c2VQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/plugins/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/plugins/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BehaviorPlugin: () => (/* binding */ BehaviorPlugin),\n/* harmony export */   EditorRefPlugin: () => (/* binding */ EditorRefPlugin),\n/* harmony export */   EventListenerPlugin: () => (/* binding */ EventListenerPlugin),\n/* harmony export */   MarkdownPlugin: () => (/* binding */ MarkdownPlugin),\n/* harmony export */   OneLinePlugin: () => (/* binding */ OneLinePlugin)\n/* harmony export */ });\n/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-compiler-runtime */ \"(ssr)/./node_modules/react-compiler-runtime/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../_chunks-es/editor-provider.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/editor-provider.js\");\n/* harmony import */ var use_effect_event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! use-effect-event */ \"(ssr)/./node_modules/use-effect-event/dist/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _chunks_es_behavior_markdown_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../_chunks-es/behavior.markdown.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/behavior.markdown.js\");\n/* harmony import */ var _xstate_react__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @xstate/react */ \"(ssr)/./node_modules/@xstate/react/dist/xstate-react.development.esm.js\");\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/./node_modules/lodash/isEqual.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/xstate.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/log-0acd9069.development.esm.js\");\n/* harmony import */ var _chunks_es_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../_chunks-es/selector.is-at-the-start-of-block.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-at-the-start-of-block.js\");\n/* harmony import */ var _chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../_chunks-es/util.slice-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\");\n/* harmony import */ var _chunks_es_util_block_offsets_to_selection_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../_chunks-es/util.block-offsets-to-selection.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.block-offsets-to-selection.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/utils/index.js\");\n/* harmony import */ var _chunks_es_selector_get_text_before_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../_chunks-es/selector.get-text-before.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.get-text-before.js\");\n/* harmony import */ var _chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../_chunks-es/behavior.core.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/behavior.core.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction BehaviorPlugin(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(4), editor = (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_4__.useEditor)();\n  let t0, t1;\n  return $[0] !== editor || $[1] !== props.behaviors ? (t0 = () => {\n    const unregisterBehaviors = props.behaviors.map((behavior) => editor.registerBehavior({\n      behavior\n    }));\n    return () => {\n      unregisterBehaviors.forEach(_temp);\n    };\n  }, t1 = [editor, props.behaviors], $[0] = editor, $[1] = props.behaviors, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t0, t1), null;\n}\nfunction _temp(unregister) {\n  return unregister();\n}\nfunction EventListenerPlugin(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(5), editor = (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_4__.useEditor)(), on = (0,use_effect_event__WEBPACK_IMPORTED_MODULE_5__.useEffectEvent)(props.on);\n  let t0;\n  $[0] !== editor || $[1] !== on ? (t0 = () => {\n    const subscription = editor.on(\"*\", on);\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, $[0] = editor, $[1] = on, $[2] = t0) : t0 = $[2];\n  let t1;\n  return $[3] !== editor ? (t1 = [editor], $[3] = editor, $[4] = t1) : t1 = $[4], (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t0, t1), null;\n}\nconst EditorRefPlugin = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((_, ref) => {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(2), editor = (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_4__.useEditor)(), portableTextEditorRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(editor);\n  let t0, t1;\n  return $[0] === Symbol.for(\"react.memo_cache_sentinel\") ? (t0 = () => portableTextEditorRef.current, t1 = [], $[0] = t0, $[1] = t1) : (t0 = $[0], t1 = $[1]), react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(ref, t0, t1), null;\n});\nEditorRefPlugin.displayName = \"EditorRefPlugin\";\nfunction createPairRegex(char, amount) {\n  const prePrefix = `(?<!\\\\${char})`, prefix = `\\\\${char}`.repeat(Math.max(amount, 1)), postPrefix = \"(?!\\\\s)\", content = `([^${char}\\\\n]+?)`, preSuffix = \"(?<!\\\\s)\", suffix = `\\\\${char}`.repeat(Math.max(amount, 1)), postSuffix = `(?!\\\\${char})`;\n  return `${prePrefix}${prefix}${postPrefix}${content}${preSuffix}${suffix}${postSuffix}`;\n}\nfunction createDecoratorPairBehavior(config) {\n  config.pair.amount < 1 && console.warn(\"The amount of characters in the pair should be greater than 0\");\n  const pairRegex = createPairRegex(config.pair.char, config.pair.amount), regEx = new RegExp(`(${pairRegex})$`);\n  return (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_6__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if (config.pair.amount < 1)\n        return !1;\n      const decorator = config.decorator({\n        schema: snapshot.context.schema\n      });\n      if (decorator === void 0)\n        return !1;\n      const focusTextBlock = (0,_chunks_es_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_7__.getFocusTextBlock)(snapshot), selectionStartPoint = (0,_chunks_es_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_7__.getSelectionStartPoint)(snapshot), selectionStartOffset = selectionStartPoint ? (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_8__.spanSelectionPointToBlockOffset)({\n        value: snapshot.context.value,\n        selectionPoint: selectionStartPoint\n      }) : void 0;\n      if (!focusTextBlock || !selectionStartOffset)\n        return !1;\n      const newText = `${(0,_chunks_es_selector_get_text_before_js__WEBPACK_IMPORTED_MODULE_9__.getBlockTextBefore)(snapshot)}${event.text}`, textToDecorate = newText.match(regEx)?.at(0);\n      if (textToDecorate === void 0)\n        return !1;\n      const prefixOffsets = {\n        anchor: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar**\".length - \"**bar**\".length = 4\n          offset: newText.length - textToDecorate.length\n        },\n        focus: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar**\".length - \"**bar**\".length + \"*\".length * 2 = 6\n          offset: newText.length - textToDecorate.length + config.pair.char.length * config.pair.amount\n        }\n      }, suffixOffsets = {\n        anchor: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar*|\" (10) + \"*\".length - 2 = 9\n          offset: selectionStartOffset.offset + event.text.length - config.pair.char.length * config.pair.amount\n        },\n        focus: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar*|\" (10) + \"*\".length = 11\n          offset: selectionStartOffset.offset + event.text.length\n        }\n      };\n      if (prefixOffsets.focus.offset - prefixOffsets.anchor.offset > 1) {\n        const prefixSelection = (0,_chunks_es_util_block_offsets_to_selection_js__WEBPACK_IMPORTED_MODULE_10__.blockOffsetsToSelection)({\n          value: snapshot.context.value,\n          offsets: prefixOffsets\n        }), inlineObjectBeforePrefixFocus = (0,_chunks_es_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_7__.getPreviousInlineObject)({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: prefixSelection ? {\n              anchor: prefixSelection.focus,\n              focus: prefixSelection.focus\n            } : null\n          }\n        }), inlineObjectBeforePrefixFocusOffset = inlineObjectBeforePrefixFocus ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.childSelectionPointToBlockOffset)({\n          value: snapshot.context.value,\n          selectionPoint: {\n            path: inlineObjectBeforePrefixFocus.path,\n            offset: 0\n          }\n        }) : void 0;\n        if (inlineObjectBeforePrefixFocusOffset && inlineObjectBeforePrefixFocusOffset.offset > prefixOffsets.anchor.offset && inlineObjectBeforePrefixFocusOffset.offset < prefixOffsets.focus.offset)\n          return !1;\n      }\n      if (suffixOffsets.focus.offset - suffixOffsets.anchor.offset > 1) {\n        const previousInlineObject = (0,_chunks_es_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_7__.getPreviousInlineObject)(snapshot), previousInlineObjectOffset = previousInlineObject ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.childSelectionPointToBlockOffset)({\n          value: snapshot.context.value,\n          selectionPoint: {\n            path: previousInlineObject.path,\n            offset: 0\n          }\n        }) : void 0;\n        if (previousInlineObjectOffset && previousInlineObjectOffset.offset > suffixOffsets.anchor.offset && previousInlineObjectOffset.offset < suffixOffsets.focus.offset)\n          return !1;\n      }\n      return {\n        prefixOffsets,\n        suffixOffsets,\n        decorator\n      };\n    },\n    actions: [\n      // Insert the text as usual in its own undo step\n      ({\n        event\n      }) => [event],\n      (_, {\n        prefixOffsets,\n        suffixOffsets,\n        decorator\n      }) => [\n        // Decorate the text between the prefix and suffix\n        {\n          type: \"decorator.add\",\n          decorator,\n          offsets: {\n            anchor: prefixOffsets.focus,\n            focus: suffixOffsets.anchor\n          }\n        },\n        // Delete the suffix\n        {\n          type: \"delete.text\",\n          ...suffixOffsets\n        },\n        // Delete the prefix\n        {\n          type: \"delete.text\",\n          ...prefixOffsets\n        },\n        // Toggle the decorator off so the next inserted text isn't emphasized\n        {\n          type: \"decorator.remove\",\n          decorator\n        },\n        {\n          type: \"effect\",\n          effect: () => {\n            config.onDecorate({\n              ...suffixOffsets.anchor,\n              offset: suffixOffsets.anchor.offset - (prefixOffsets.focus.offset - prefixOffsets.anchor.offset)\n            });\n          }\n        }\n      ]\n    ]\n  });\n}\nfunction DecoratorShortcutPlugin(config) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(4), editor = (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_4__.useEditor)();\n  let t0;\n  return $[0] !== config.decorator || $[1] !== config.pair || $[2] !== editor ? (t0 = {\n    input: {\n      editor,\n      decorator: config.decorator,\n      pair: config.pair\n    }\n  }, $[0] = config.decorator, $[1] = config.pair, $[2] = editor, $[3] = t0) : t0 = $[3], (0,_xstate_react__WEBPACK_IMPORTED_MODULE_12__.useActorRef)(decoratorPairMachine, t0), null;\n}\nconst emphasisListener = ({\n  sendBack,\n  input\n}) => input.editor.registerBehavior({\n  behavior: createDecoratorPairBehavior({\n    decorator: input.decorator,\n    pair: input.pair,\n    onDecorate: (offset) => {\n      sendBack({\n        type: \"emphasis.add\",\n        blockOffset: offset\n      });\n    }\n  })\n}), selectionListenerCallback = ({\n  sendBack,\n  input\n}) => input.editor.registerBehavior({\n  behavior: (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_6__.defineBehavior)({\n    on: \"select\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if (!event.selection)\n        return {\n          blockOffsets: void 0\n        };\n      const anchor = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_8__.spanSelectionPointToBlockOffset)({\n        value: snapshot.context.value,\n        selectionPoint: event.selection.anchor\n      }), focus = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_8__.spanSelectionPointToBlockOffset)({\n        value: snapshot.context.value,\n        selectionPoint: event.selection.focus\n      });\n      return !anchor || !focus ? {\n        blockOffsets: void 0\n      } : {\n        blockOffsets: {\n          anchor,\n          focus\n        }\n      };\n    },\n    actions: [(_, {\n      blockOffsets\n    }) => [{\n      type: \"effect\",\n      effect: () => {\n        sendBack({\n          type: \"selection\",\n          blockOffsets\n        });\n      }\n    }]]\n  })\n}), deleteBackwardListenerCallback = ({\n  sendBack,\n  input\n}) => input.editor.registerBehavior({\n  behavior: (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_6__.defineBehavior)({\n    on: \"delete.backward\",\n    actions: [() => [{\n      type: \"history.undo\"\n    }, {\n      type: \"effect\",\n      effect: () => {\n        sendBack({\n          type: \"delete.backward\"\n        });\n      }\n    }]]\n  })\n}), decoratorPairMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_13__.setup)({\n  types: {\n    context: {},\n    input: {},\n    events: {}\n  },\n  actors: {\n    \"emphasis listener\": (0,xstate__WEBPACK_IMPORTED_MODULE_14__.fromCallback)(emphasisListener),\n    \"delete.backward listener\": (0,xstate__WEBPACK_IMPORTED_MODULE_14__.fromCallback)(deleteBackwardListenerCallback),\n    \"selection listener\": (0,xstate__WEBPACK_IMPORTED_MODULE_14__.fromCallback)(selectionListenerCallback)\n  }\n}).createMachine({\n  id: \"decorator pair\",\n  context: ({\n    input\n  }) => ({\n    decorator: input.decorator,\n    editor: input.editor,\n    pair: input.pair\n  }),\n  initial: \"idle\",\n  states: {\n    idle: {\n      invoke: [{\n        src: \"emphasis listener\",\n        input: ({\n          context\n        }) => ({\n          decorator: context.decorator,\n          editor: context.editor,\n          pair: context.pair\n        })\n      }],\n      on: {\n        \"emphasis.add\": {\n          target: \"emphasis added\",\n          actions: (0,xstate__WEBPACK_IMPORTED_MODULE_15__.a)({\n            offsetAfterEmphasis: ({\n              event\n            }) => event.blockOffset\n          })\n        }\n      }\n    },\n    \"emphasis added\": {\n      exit: [(0,xstate__WEBPACK_IMPORTED_MODULE_15__.a)({\n        offsetAfterEmphasis: void 0\n      })],\n      invoke: [{\n        src: \"selection listener\",\n        input: ({\n          context\n        }) => ({\n          editor: context.editor\n        })\n      }, {\n        src: \"delete.backward listener\",\n        input: ({\n          context\n        }) => ({\n          editor: context.editor\n        })\n      }],\n      on: {\n        selection: {\n          target: \"idle\",\n          guard: ({\n            context,\n            event\n          }) => !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_3__({\n            anchor: context.offsetAfterEmphasis,\n            focus: context.offsetAfterEmphasis\n          }, event.blockOffsets)\n        },\n        \"delete.backward\": {\n          target: \"idle\"\n        }\n      }\n    }\n  }\n});\nfunction MarkdownPlugin(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(17), editor = (0,_chunks_es_editor_provider_js__WEBPACK_IMPORTED_MODULE_4__.useEditor)();\n  let t0, t1;\n  $[0] !== editor || $[1] !== props.config ? (t0 = () => {\n    const unregisterBehaviors = (0,_chunks_es_behavior_markdown_js__WEBPACK_IMPORTED_MODULE_16__.createMarkdownBehaviors)(props.config).map((behavior) => editor.registerBehavior({\n      behavior\n    }));\n    return () => {\n      for (const unregisterBehavior of unregisterBehaviors)\n        unregisterBehavior();\n    };\n  }, t1 = [editor, props.config], $[0] = editor, $[1] = props.config, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t0, t1);\n  let t2;\n  $[4] !== props.config.boldDecorator ? (t2 = props.config.boldDecorator ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DecoratorShortcutPlugin, { decorator: props.config.boldDecorator, pair: {\n      char: \"*\",\n      amount: 2\n    } }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DecoratorShortcutPlugin, { decorator: props.config.boldDecorator, pair: {\n      char: \"_\",\n      amount: 2\n    } })\n  ] }) : null, $[4] = props.config.boldDecorator, $[5] = t2) : t2 = $[5];\n  let t3;\n  $[6] !== props.config.codeDecorator ? (t3 = props.config.codeDecorator ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DecoratorShortcutPlugin, { decorator: props.config.codeDecorator, pair: {\n    char: \"`\",\n    amount: 1\n  } }) : null, $[6] = props.config.codeDecorator, $[7] = t3) : t3 = $[7];\n  let t4;\n  $[8] !== props.config.italicDecorator ? (t4 = props.config.italicDecorator ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DecoratorShortcutPlugin, { decorator: props.config.italicDecorator, pair: {\n      char: \"*\",\n      amount: 1\n    } }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DecoratorShortcutPlugin, { decorator: props.config.italicDecorator, pair: {\n      char: \"_\",\n      amount: 1\n    } })\n  ] }) : null, $[8] = props.config.italicDecorator, $[9] = t4) : t4 = $[9];\n  let t5;\n  $[10] !== props.config.strikeThroughDecorator ? (t5 = props.config.strikeThroughDecorator ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DecoratorShortcutPlugin, { decorator: props.config.strikeThroughDecorator, pair: {\n    char: \"~\",\n    amount: 2\n  } }) : null, $[10] = props.config.strikeThroughDecorator, $[11] = t5) : t5 = $[11];\n  let t6;\n  return $[12] !== t2 || $[13] !== t3 || $[14] !== t4 || $[15] !== t5 ? (t6 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [\n    t2,\n    t3,\n    t4,\n    t5\n  ] }), $[12] = t2, $[13] = t3, $[14] = t4, $[15] = t5, $[16] = t6) : t6 = $[16], t6;\n}\nconst oneLineBehaviors = [\n  /**\n   * Hitting Enter on an expanded selection should just delete that selection\n   * without causing a line break.\n   */\n  (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_6__.defineBehavior)({\n    on: \"insert.break\",\n    guard: ({\n      snapshot\n    }) => snapshot.context.selection && (0,_chunks_es_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_7__.isSelectionExpanded)(snapshot) ? {\n      selection: snapshot.context.selection\n    } : !1,\n    actions: [(_, {\n      selection\n    }) => [{\n      type: \"delete\",\n      selection\n    }]]\n  }),\n  /**\n   * All other cases of `insert.break` should be aborted.\n   */\n  (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_6__.defineBehavior)({\n    on: \"insert.break\",\n    actions: [() => [{\n      type: \"noop\"\n    }]]\n  }),\n  /**\n   * `insert.block` `before` or `after` is not allowed in a one-line editor.\n   */\n  (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_6__.defineBehavior)({\n    on: \"insert.block\",\n    guard: ({\n      event\n    }) => event.placement === \"before\" || event.placement === \"after\",\n    actions: [() => [{\n      type: \"noop\"\n    }]]\n  }),\n  /**\n   * Other cases of `insert.block` are allowed.\n   *\n   * If a text block is inserted and the focus block is fully selected, then\n   * the focus block can be replaced with the inserted block.\n   */\n  (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_6__.defineBehavior)({\n    on: \"insert.block\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      const focusTextBlock = (0,_chunks_es_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_7__.getFocusTextBlock)(snapshot), selectionStartPoint = (0,_chunks_es_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_7__.getSelectionStartPoint)(snapshot), selectionEndPoint = (0,_chunks_es_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_7__.getSelectionEndPoint)(snapshot);\n      if (!focusTextBlock || !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.isTextBlock)(snapshot.context, event.block) || !selectionStartPoint || !selectionEndPoint)\n        return !1;\n      const blockStartPoint = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_8__.getBlockStartPoint)(focusTextBlock), blockEndPoint = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_8__.getBlockEndPoint)(focusTextBlock), newFocus = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_8__.getBlockEndPoint)({\n        node: event.block,\n        path: [{\n          _key: event.block._key\n        }]\n      });\n      return (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_8__.isEqualSelectionPoints)(blockStartPoint, selectionStartPoint) && (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_8__.isEqualSelectionPoints)(blockEndPoint, selectionEndPoint) ? {\n        focusTextBlock,\n        newFocus\n      } : !1;\n    },\n    actions: [({\n      event\n    }, {\n      focusTextBlock,\n      newFocus\n    }) => [{\n      type: \"delete.block\",\n      blockPath: focusTextBlock.path\n    }, {\n      type: \"insert.block\",\n      block: event.block,\n      placement: \"auto\"\n    }, {\n      type: \"select\",\n      selection: {\n        anchor: newFocus,\n        focus: newFocus\n      }\n    }]]\n  }),\n  /**\n   * An ordinary `insert.block` is acceptable if it's a text block. In that\n   * case it will get merged into the existing text block.\n   */\n  (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_6__.defineBehavior)({\n    on: \"insert.block\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      const focusTextBlock = (0,_chunks_es_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_7__.getFocusTextBlock)(snapshot), selectionStartPoint = (0,_chunks_es_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_7__.getSelectionStartPoint)(snapshot), selectionEndPoint = (0,_chunks_es_selector_is_at_the_start_of_block_js__WEBPACK_IMPORTED_MODULE_7__.getSelectionEndPoint)(snapshot);\n      if (!focusTextBlock || !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.isTextBlock)(snapshot.context, event.block) || !selectionStartPoint || !selectionEndPoint)\n        return !1;\n      const blockBeforeStartPoint = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.splitTextBlock)({\n        context: snapshot.context,\n        block: focusTextBlock.node,\n        point: selectionStartPoint\n      })?.before, blockAfterEndPoint = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.splitTextBlock)({\n        context: snapshot.context,\n        block: focusTextBlock.node,\n        point: selectionEndPoint\n      })?.after;\n      if (!blockBeforeStartPoint || !blockAfterEndPoint)\n        return !1;\n      const targetBlock = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.mergeTextBlocks)({\n        context: snapshot.context,\n        targetBlock: blockBeforeStartPoint,\n        incomingBlock: event.block\n      }), newFocus = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_8__.getBlockEndPoint)({\n        node: targetBlock,\n        path: [{\n          _key: targetBlock._key\n        }]\n      }), mergedBlock = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.mergeTextBlocks)({\n        context: snapshot.context,\n        targetBlock,\n        incomingBlock: blockAfterEndPoint\n      });\n      return {\n        focusTextBlock,\n        mergedBlock,\n        newFocus\n      };\n    },\n    actions: [(_, {\n      focusTextBlock,\n      mergedBlock,\n      newFocus\n    }) => [{\n      type: \"delete.block\",\n      blockPath: focusTextBlock.path\n    }, {\n      type: \"insert.block\",\n      block: mergedBlock,\n      placement: \"auto\"\n    }, {\n      type: \"select\",\n      selection: {\n        anchor: newFocus,\n        focus: newFocus\n      }\n    }]]\n  }),\n  /**\n   * Fallback Behavior to avoid `insert.block` in case the Behaviors above all\n   * end up with a falsy guard.\n   */\n  (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_6__.defineBehavior)({\n    on: \"insert.block\",\n    actions: [() => [{\n      type: \"noop\"\n    }]]\n  }),\n  /**\n   * If multiple blocks are inserted, then the non-text blocks are filtered out\n   * and the text blocks are merged into one block\n   */\n  (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_6__.defineBehavior)({\n    on: \"insert.blocks\",\n    guard: ({\n      context,\n      event\n    }) => event.blocks.filter((block) => (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.isTextBlock)(context, block)).reduce((targetBlock, incomingBlock) => (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.mergeTextBlocks)({\n      context,\n      targetBlock,\n      incomingBlock\n    })),\n    actions: [\n      // `insert.block` is raised so the Behavior above can handle the\n      // insertion\n      (_, block) => [(0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_6__.raise)({\n        type: \"insert.block\",\n        block,\n        placement: \"auto\"\n      })]\n    ]\n  }),\n  /**\n   * Block objects do not fit in a one-line editor\n   */\n  (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_6__.defineBehavior)({\n    on: \"insert.block object\",\n    actions: [() => [{\n      type: \"noop\"\n    }]]\n  }),\n  /**\n   * `insert.text block` is raised as an `insert.block` so it can be handled\n   * by the Behaviors above.\n   */\n  (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_6__.defineBehavior)({\n    on: \"insert.text block\",\n    actions: [({\n      context,\n      event\n    }) => [(0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_6__.raise)({\n      type: \"insert.block\",\n      block: {\n        _key: context.keyGenerator(),\n        _type: context.schema.block.name,\n        children: event.textBlock?.children ?? []\n      },\n      placement: event.placement\n    })]]\n  })\n];\nfunction OneLinePlugin() {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(1);\n  let t0;\n  return $[0] === Symbol.for(\"react.memo_cache_sentinel\") ? (t0 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(BehaviorPlugin, { behaviors: oneLineBehaviors }), $[0] = t0) : t0 = $[0], t0;\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL3BsdWdpbnMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEyQztBQUNGO0FBQ29CO0FBQ1g7QUFDTTtBQUNxQjtBQUNqQztBQUNKO0FBQ2E7QUFDOEg7QUFDaEM7QUFDeEQ7QUFDd0I7QUFDcEM7QUFDUjtBQUN2RTtBQUNBLFlBQVkseURBQUMsY0FBYyx3RUFBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHLHlIQUF5SCxnREFBUztBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBQyxjQUFjLHdFQUFTLFNBQVMsZ0VBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0ZBQWtGLGdEQUFTO0FBQzNGO0FBQ0Esd0JBQXdCLDZDQUFnQjtBQUN4QyxZQUFZLHlEQUFDLGNBQWMsd0VBQVMsNEJBQTRCLHlDQUFZO0FBQzVFO0FBQ0EsZ0tBQWdLLHNEQUF5QjtBQUN6TCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDZCQUE2QixLQUFLLGtCQUFrQixLQUFLLHVFQUF1RSxLQUFLLGdEQUFnRCxLQUFLLG9EQUFvRCxLQUFLO0FBQ25QLFlBQVksVUFBVSxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsV0FBVztBQUN4RjtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csVUFBVTtBQUM1RyxTQUFTLDJFQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw2QkFBNkIsa0dBQWlCLGtDQUFrQyx1R0FBc0IseURBQXlELGdHQUErQjtBQUM5TDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx5QkFBeUIs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VCxPQUFPLGlCQUFpQixpRUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMkVBQWM7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMkVBQWM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG9DQUFvQyw2REFBVyx5REFBeUQsaUVBQWU7QUFDNUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrRUFBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRSwyRUFBYztBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSwyRUFBYztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssTUFBTSxrRUFBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSx5REFBQztBQUNiO0FBQ0Esa0ZBQWtGLHNEQUFHLG1CQUFtQiw2QkFBNkI7QUFDckk7QUFPRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbWFjYm9va3Byby9Eb3dubG9hZHMvY29uaWNhcHBzL2lnZW5lL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvcGx1Z2lucy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjIH0gZnJvbSBcInJlYWN0LWNvbXBpbGVyLXJ1bnRpbWVcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUVkaXRvciB9IGZyb20gXCIuLi9fY2h1bmtzLWVzL2VkaXRvci1wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgdXNlRWZmZWN0RXZlbnQgfSBmcm9tIFwidXNlLWVmZmVjdC1ldmVudFwiO1xuaW1wb3J0IHsganN4cywgRnJhZ21lbnQsIGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgY3JlYXRlTWFya2Rvd25CZWhhdmlvcnMgfSBmcm9tIFwiLi4vX2NodW5rcy1lcy9iZWhhdmlvci5tYXJrZG93bi5qc1wiO1xuaW1wb3J0IHsgdXNlQWN0b3JSZWYgfSBmcm9tIFwiQHhzdGF0ZS9yZWFjdFwiO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSBcImxvZGFzaC9pc0VxdWFsLmpzXCI7XG5pbXBvcnQgeyBzZXR1cCwgZnJvbUNhbGxiYWNrLCBhc3NpZ24gfSBmcm9tIFwieHN0YXRlXCI7XG5pbXBvcnQgeyBnZXRGb2N1c1RleHRCbG9jaywgZ2V0UHJldmlvdXNJbmxpbmVPYmplY3QsIGdldFNlbGVjdGlvblN0YXJ0UG9pbnQsIGlzU2VsZWN0aW9uRXhwYW5kZWQsIGdldFNlbGVjdGlvbkVuZFBvaW50IH0gZnJvbSBcIi4uL19jaHVua3MtZXMvc2VsZWN0b3IuaXMtYXQtdGhlLXN0YXJ0LW9mLWJsb2NrLmpzXCI7XG5pbXBvcnQgeyBzcGFuU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0LCBnZXRCbG9ja1N0YXJ0UG9pbnQsIGdldEJsb2NrRW5kUG9pbnQsIGlzRXF1YWxTZWxlY3Rpb25Qb2ludHMgfSBmcm9tIFwiLi4vX2NodW5rcy1lcy91dGlsLnNsaWNlLWJsb2Nrcy5qc1wiO1xuaW1wb3J0IHsgYmxvY2tPZmZzZXRzVG9TZWxlY3Rpb24gfSBmcm9tIFwiLi4vX2NodW5rcy1lcy91dGlsLmJsb2NrLW9mZnNldHMtdG8tc2VsZWN0aW9uLmpzXCI7XG5pbXBvcnQgeyBjaGlsZFNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCwgaXNUZXh0QmxvY2ssIHNwbGl0VGV4dEJsb2NrLCBtZXJnZVRleHRCbG9ja3MgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJsb2NrVGV4dEJlZm9yZSB9IGZyb20gXCIuLi9fY2h1bmtzLWVzL3NlbGVjdG9yLmdldC10ZXh0LWJlZm9yZS5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lQmVoYXZpb3IsIHJhaXNlIH0gZnJvbSBcIi4uL19jaHVua3MtZXMvYmVoYXZpb3IuY29yZS5qc1wiO1xuZnVuY3Rpb24gQmVoYXZpb3JQbHVnaW4ocHJvcHMpIHtcbiAgY29uc3QgJCA9IGMoNCksIGVkaXRvciA9IHVzZUVkaXRvcigpO1xuICBsZXQgdDAsIHQxO1xuICByZXR1cm4gJFswXSAhPT0gZWRpdG9yIHx8ICRbMV0gIT09IHByb3BzLmJlaGF2aW9ycyA/ICh0MCA9ICgpID0+IHtcbiAgICBjb25zdCB1bnJlZ2lzdGVyQmVoYXZpb3JzID0gcHJvcHMuYmVoYXZpb3JzLm1hcCgoYmVoYXZpb3IpID0+IGVkaXRvci5yZWdpc3RlckJlaGF2aW9yKHtcbiAgICAgIGJlaGF2aW9yXG4gICAgfSkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnJlZ2lzdGVyQmVoYXZpb3JzLmZvckVhY2goX3RlbXApO1xuICAgIH07XG4gIH0sIHQxID0gW2VkaXRvciwgcHJvcHMuYmVoYXZpb3JzXSwgJFswXSA9IGVkaXRvciwgJFsxXSA9IHByb3BzLmJlaGF2aW9ycywgJFsyXSA9IHQwLCAkWzNdID0gdDEpIDogKHQwID0gJFsyXSwgdDEgPSAkWzNdKSwgdXNlRWZmZWN0KHQwLCB0MSksIG51bGw7XG59XG5mdW5jdGlvbiBfdGVtcCh1bnJlZ2lzdGVyKSB7XG4gIHJldHVybiB1bnJlZ2lzdGVyKCk7XG59XG5mdW5jdGlvbiBFdmVudExpc3RlbmVyUGx1Z2luKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDUpLCBlZGl0b3IgPSB1c2VFZGl0b3IoKSwgb24gPSB1c2VFZmZlY3RFdmVudChwcm9wcy5vbik7XG4gIGxldCB0MDtcbiAgJFswXSAhPT0gZWRpdG9yIHx8ICRbMV0gIT09IG9uID8gKHQwID0gKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGVkaXRvci5vbihcIipcIiwgb24pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCAkWzBdID0gZWRpdG9yLCAkWzFdID0gb24sICRbMl0gPSB0MCkgOiB0MCA9ICRbMl07XG4gIGxldCB0MTtcbiAgcmV0dXJuICRbM10gIT09IGVkaXRvciA/ICh0MSA9IFtlZGl0b3JdLCAkWzNdID0gZWRpdG9yLCAkWzRdID0gdDEpIDogdDEgPSAkWzRdLCB1c2VFZmZlY3QodDAsIHQxKSwgbnVsbDtcbn1cbmNvbnN0IEVkaXRvclJlZlBsdWdpbiA9IFJlYWN0LmZvcndhcmRSZWYoKF8sIHJlZikgPT4ge1xuICBjb25zdCAkID0gYygyKSwgZWRpdG9yID0gdXNlRWRpdG9yKCksIHBvcnRhYmxlVGV4dEVkaXRvclJlZiA9IFJlYWN0LnVzZVJlZihlZGl0b3IpO1xuICBsZXQgdDAsIHQxO1xuICByZXR1cm4gJFswXSA9PT0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWxcIikgPyAodDAgPSAoKSA9PiBwb3J0YWJsZVRleHRFZGl0b3JSZWYuY3VycmVudCwgdDEgPSBbXSwgJFswXSA9IHQwLCAkWzFdID0gdDEpIDogKHQwID0gJFswXSwgdDEgPSAkWzFdKSwgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIHQwLCB0MSksIG51bGw7XG59KTtcbkVkaXRvclJlZlBsdWdpbi5kaXNwbGF5TmFtZSA9IFwiRWRpdG9yUmVmUGx1Z2luXCI7XG5mdW5jdGlvbiBjcmVhdGVQYWlyUmVnZXgoY2hhciwgYW1vdW50KSB7XG4gIGNvbnN0IHByZVByZWZpeCA9IGAoPzwhXFxcXCR7Y2hhcn0pYCwgcHJlZml4ID0gYFxcXFwke2NoYXJ9YC5yZXBlYXQoTWF0aC5tYXgoYW1vdW50LCAxKSksIHBvc3RQcmVmaXggPSBcIig/IVxcXFxzKVwiLCBjb250ZW50ID0gYChbXiR7Y2hhcn1cXFxcbl0rPylgLCBwcmVTdWZmaXggPSBcIig/PCFcXFxccylcIiwgc3VmZml4ID0gYFxcXFwke2NoYXJ9YC5yZXBlYXQoTWF0aC5tYXgoYW1vdW50LCAxKSksIHBvc3RTdWZmaXggPSBgKD8hXFxcXCR7Y2hhcn0pYDtcbiAgcmV0dXJuIGAke3ByZVByZWZpeH0ke3ByZWZpeH0ke3Bvc3RQcmVmaXh9JHtjb250ZW50fSR7cHJlU3VmZml4fSR7c3VmZml4fSR7cG9zdFN1ZmZpeH1gO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVjb3JhdG9yUGFpckJlaGF2aW9yKGNvbmZpZykge1xuICBjb25maWcucGFpci5hbW91bnQgPCAxICYmIGNvbnNvbGUud2FybihcIlRoZSBhbW91bnQgb2YgY2hhcmFjdGVycyBpbiB0aGUgcGFpciBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIDBcIik7XG4gIGNvbnN0IHBhaXJSZWdleCA9IGNyZWF0ZVBhaXJSZWdleChjb25maWcucGFpci5jaGFyLCBjb25maWcucGFpci5hbW91bnQpLCByZWdFeCA9IG5ldyBSZWdFeHAoYCgke3BhaXJSZWdleH0pJGApO1xuICByZXR1cm4gZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImluc2VydC50ZXh0XCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGNvbmZpZy5wYWlyLmFtb3VudCA8IDEpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGRlY29yYXRvciA9IGNvbmZpZy5kZWNvcmF0b3Ioe1xuICAgICAgICBzY2hlbWE6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hXG4gICAgICB9KTtcbiAgICAgIGlmIChkZWNvcmF0b3IgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCksIHNlbGVjdGlvblN0YXJ0UG9pbnQgPSBnZXRTZWxlY3Rpb25TdGFydFBvaW50KHNuYXBzaG90KSwgc2VsZWN0aW9uU3RhcnRPZmZzZXQgPSBzZWxlY3Rpb25TdGFydFBvaW50ID8gc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCh7XG4gICAgICAgIHZhbHVlOiBzbmFwc2hvdC5jb250ZXh0LnZhbHVlLFxuICAgICAgICBzZWxlY3Rpb25Qb2ludDogc2VsZWN0aW9uU3RhcnRQb2ludFxuICAgICAgfSkgOiB2b2lkIDA7XG4gICAgICBpZiAoIWZvY3VzVGV4dEJsb2NrIHx8ICFzZWxlY3Rpb25TdGFydE9mZnNldClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgbmV3VGV4dCA9IGAke2dldEJsb2NrVGV4dEJlZm9yZShzbmFwc2hvdCl9JHtldmVudC50ZXh0fWAsIHRleHRUb0RlY29yYXRlID0gbmV3VGV4dC5tYXRjaChyZWdFeCk/LmF0KDApO1xuICAgICAgaWYgKHRleHRUb0RlY29yYXRlID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHByZWZpeE9mZnNldHMgPSB7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGgsXG4gICAgICAgICAgLy8gRXhhbXBsZTogXCJmb28gKipiYXIqKlwiLmxlbmd0aCAtIFwiKipiYXIqKlwiLmxlbmd0aCA9IDRcbiAgICAgICAgICBvZmZzZXQ6IG5ld1RleHQubGVuZ3RoIC0gdGV4dFRvRGVjb3JhdGUubGVuZ3RoXG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgcGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aCxcbiAgICAgICAgICAvLyBFeGFtcGxlOiBcImZvbyAqKmJhcioqXCIubGVuZ3RoIC0gXCIqKmJhcioqXCIubGVuZ3RoICsgXCIqXCIubGVuZ3RoICogMiA9IDZcbiAgICAgICAgICBvZmZzZXQ6IG5ld1RleHQubGVuZ3RoIC0gdGV4dFRvRGVjb3JhdGUubGVuZ3RoICsgY29uZmlnLnBhaXIuY2hhci5sZW5ndGggKiBjb25maWcucGFpci5hbW91bnRcbiAgICAgICAgfVxuICAgICAgfSwgc3VmZml4T2Zmc2V0cyA9IHtcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgcGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aCxcbiAgICAgICAgICAvLyBFeGFtcGxlOiBcImZvbyAqKmJhcip8XCIgKDEwKSArIFwiKlwiLmxlbmd0aCAtIDIgPSA5XG4gICAgICAgICAgb2Zmc2V0OiBzZWxlY3Rpb25TdGFydE9mZnNldC5vZmZzZXQgKyBldmVudC50ZXh0Lmxlbmd0aCAtIGNvbmZpZy5wYWlyLmNoYXIubGVuZ3RoICogY29uZmlnLnBhaXIuYW1vdW50XG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgcGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aCxcbiAgICAgICAgICAvLyBFeGFtcGxlOiBcImZvbyAqKmJhcip8XCIgKDEwKSArIFwiKlwiLmxlbmd0aCA9IDExXG4gICAgICAgICAgb2Zmc2V0OiBzZWxlY3Rpb25TdGFydE9mZnNldC5vZmZzZXQgKyBldmVudC50ZXh0Lmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHByZWZpeE9mZnNldHMuZm9jdXMub2Zmc2V0IC0gcHJlZml4T2Zmc2V0cy5hbmNob3Iub2Zmc2V0ID4gMSkge1xuICAgICAgICBjb25zdCBwcmVmaXhTZWxlY3Rpb24gPSBibG9ja09mZnNldHNUb1NlbGVjdGlvbih7XG4gICAgICAgICAgdmFsdWU6IHNuYXBzaG90LmNvbnRleHQudmFsdWUsXG4gICAgICAgICAgb2Zmc2V0czogcHJlZml4T2Zmc2V0c1xuICAgICAgICB9KSwgaW5saW5lT2JqZWN0QmVmb3JlUHJlZml4Rm9jdXMgPSBnZXRQcmV2aW91c0lubGluZU9iamVjdCh7XG4gICAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogcHJlZml4U2VsZWN0aW9uID8ge1xuICAgICAgICAgICAgICBhbmNob3I6IHByZWZpeFNlbGVjdGlvbi5mb2N1cyxcbiAgICAgICAgICAgICAgZm9jdXM6IHByZWZpeFNlbGVjdGlvbi5mb2N1c1xuICAgICAgICAgICAgfSA6IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBpbmxpbmVPYmplY3RCZWZvcmVQcmVmaXhGb2N1c09mZnNldCA9IGlubGluZU9iamVjdEJlZm9yZVByZWZpeEZvY3VzID8gY2hpbGRTZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQoe1xuICAgICAgICAgIHZhbHVlOiBzbmFwc2hvdC5jb250ZXh0LnZhbHVlLFxuICAgICAgICAgIHNlbGVjdGlvblBvaW50OiB7XG4gICAgICAgICAgICBwYXRoOiBpbmxpbmVPYmplY3RCZWZvcmVQcmVmaXhGb2N1cy5wYXRoLFxuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgfVxuICAgICAgICB9KSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKGlubGluZU9iamVjdEJlZm9yZVByZWZpeEZvY3VzT2Zmc2V0ICYmIGlubGluZU9iamVjdEJlZm9yZVByZWZpeEZvY3VzT2Zmc2V0Lm9mZnNldCA+IHByZWZpeE9mZnNldHMuYW5jaG9yLm9mZnNldCAmJiBpbmxpbmVPYmplY3RCZWZvcmVQcmVmaXhGb2N1c09mZnNldC5vZmZzZXQgPCBwcmVmaXhPZmZzZXRzLmZvY3VzLm9mZnNldClcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICBpZiAoc3VmZml4T2Zmc2V0cy5mb2N1cy5vZmZzZXQgLSBzdWZmaXhPZmZzZXRzLmFuY2hvci5vZmZzZXQgPiAxKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzSW5saW5lT2JqZWN0ID0gZ2V0UHJldmlvdXNJbmxpbmVPYmplY3Qoc25hcHNob3QpLCBwcmV2aW91c0lubGluZU9iamVjdE9mZnNldCA9IHByZXZpb3VzSW5saW5lT2JqZWN0ID8gY2hpbGRTZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQoe1xuICAgICAgICAgIHZhbHVlOiBzbmFwc2hvdC5jb250ZXh0LnZhbHVlLFxuICAgICAgICAgIHNlbGVjdGlvblBvaW50OiB7XG4gICAgICAgICAgICBwYXRoOiBwcmV2aW91c0lubGluZU9iamVjdC5wYXRoLFxuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgfVxuICAgICAgICB9KSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKHByZXZpb3VzSW5saW5lT2JqZWN0T2Zmc2V0ICYmIHByZXZpb3VzSW5saW5lT2JqZWN0T2Zmc2V0Lm9mZnNldCA+IHN1ZmZpeE9mZnNldHMuYW5jaG9yLm9mZnNldCAmJiBwcmV2aW91c0lubGluZU9iamVjdE9mZnNldC5vZmZzZXQgPCBzdWZmaXhPZmZzZXRzLmZvY3VzLm9mZnNldClcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmVmaXhPZmZzZXRzLFxuICAgICAgICBzdWZmaXhPZmZzZXRzLFxuICAgICAgICBkZWNvcmF0b3JcbiAgICAgIH07XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbXG4gICAgICAvLyBJbnNlcnQgdGhlIHRleHQgYXMgdXN1YWwgaW4gaXRzIG93biB1bmRvIHN0ZXBcbiAgICAgICh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiBbZXZlbnRdLFxuICAgICAgKF8sIHtcbiAgICAgICAgcHJlZml4T2Zmc2V0cyxcbiAgICAgICAgc3VmZml4T2Zmc2V0cyxcbiAgICAgICAgZGVjb3JhdG9yXG4gICAgICB9KSA9PiBbXG4gICAgICAgIC8vIERlY29yYXRlIHRoZSB0ZXh0IGJldHdlZW4gdGhlIHByZWZpeCBhbmQgc3VmZml4XG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImRlY29yYXRvci5hZGRcIixcbiAgICAgICAgICBkZWNvcmF0b3IsXG4gICAgICAgICAgb2Zmc2V0czoge1xuICAgICAgICAgICAgYW5jaG9yOiBwcmVmaXhPZmZzZXRzLmZvY3VzLFxuICAgICAgICAgICAgZm9jdXM6IHN1ZmZpeE9mZnNldHMuYW5jaG9yXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBEZWxldGUgdGhlIHN1ZmZpeFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJkZWxldGUudGV4dFwiLFxuICAgICAgICAgIC4uLnN1ZmZpeE9mZnNldHNcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRGVsZXRlIHRoZSBwcmVmaXhcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiZGVsZXRlLnRleHRcIixcbiAgICAgICAgICAuLi5wcmVmaXhPZmZzZXRzXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRvZ2dsZSB0aGUgZGVjb3JhdG9yIG9mZiBzbyB0aGUgbmV4dCBpbnNlcnRlZCB0ZXh0IGlzbid0IGVtcGhhc2l6ZWRcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiZGVjb3JhdG9yLnJlbW92ZVwiLFxuICAgICAgICAgIGRlY29yYXRvclxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJlZmZlY3RcIixcbiAgICAgICAgICBlZmZlY3Q6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbmZpZy5vbkRlY29yYXRlKHtcbiAgICAgICAgICAgICAgLi4uc3VmZml4T2Zmc2V0cy5hbmNob3IsXG4gICAgICAgICAgICAgIG9mZnNldDogc3VmZml4T2Zmc2V0cy5hbmNob3Iub2Zmc2V0IC0gKHByZWZpeE9mZnNldHMuZm9jdXMub2Zmc2V0IC0gcHJlZml4T2Zmc2V0cy5hbmNob3Iub2Zmc2V0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgXVxuICB9KTtcbn1cbmZ1bmN0aW9uIERlY29yYXRvclNob3J0Y3V0UGx1Z2luKGNvbmZpZykge1xuICBjb25zdCAkID0gYyg0KSwgZWRpdG9yID0gdXNlRWRpdG9yKCk7XG4gIGxldCB0MDtcbiAgcmV0dXJuICRbMF0gIT09IGNvbmZpZy5kZWNvcmF0b3IgfHwgJFsxXSAhPT0gY29uZmlnLnBhaXIgfHwgJFsyXSAhPT0gZWRpdG9yID8gKHQwID0ge1xuICAgIGlucHV0OiB7XG4gICAgICBlZGl0b3IsXG4gICAgICBkZWNvcmF0b3I6IGNvbmZpZy5kZWNvcmF0b3IsXG4gICAgICBwYWlyOiBjb25maWcucGFpclxuICAgIH1cbiAgfSwgJFswXSA9IGNvbmZpZy5kZWNvcmF0b3IsICRbMV0gPSBjb25maWcucGFpciwgJFsyXSA9IGVkaXRvciwgJFszXSA9IHQwKSA6IHQwID0gJFszXSwgdXNlQWN0b3JSZWYoZGVjb3JhdG9yUGFpck1hY2hpbmUsIHQwKSwgbnVsbDtcbn1cbmNvbnN0IGVtcGhhc2lzTGlzdGVuZXIgPSAoe1xuICBzZW5kQmFjayxcbiAgaW5wdXRcbn0pID0+IGlucHV0LmVkaXRvci5yZWdpc3RlckJlaGF2aW9yKHtcbiAgYmVoYXZpb3I6IGNyZWF0ZURlY29yYXRvclBhaXJCZWhhdmlvcih7XG4gICAgZGVjb3JhdG9yOiBpbnB1dC5kZWNvcmF0b3IsXG4gICAgcGFpcjogaW5wdXQucGFpcixcbiAgICBvbkRlY29yYXRlOiAob2Zmc2V0KSA9PiB7XG4gICAgICBzZW5kQmFjayh7XG4gICAgICAgIHR5cGU6IFwiZW1waGFzaXMuYWRkXCIsXG4gICAgICAgIGJsb2NrT2Zmc2V0OiBvZmZzZXRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSlcbn0pLCBzZWxlY3Rpb25MaXN0ZW5lckNhbGxiYWNrID0gKHtcbiAgc2VuZEJhY2ssXG4gIGlucHV0XG59KSA9PiBpbnB1dC5lZGl0b3IucmVnaXN0ZXJCZWhhdmlvcih7XG4gIGJlaGF2aW9yOiBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwic2VsZWN0XCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKCFldmVudC5zZWxlY3Rpb24pXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYmxvY2tPZmZzZXRzOiB2b2lkIDBcbiAgICAgICAgfTtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHNwYW5TZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQoe1xuICAgICAgICB2YWx1ZTogc25hcHNob3QuY29udGV4dC52YWx1ZSxcbiAgICAgICAgc2VsZWN0aW9uUG9pbnQ6IGV2ZW50LnNlbGVjdGlvbi5hbmNob3JcbiAgICAgIH0pLCBmb2N1cyA9IHNwYW5TZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQoe1xuICAgICAgICB2YWx1ZTogc25hcHNob3QuY29udGV4dC52YWx1ZSxcbiAgICAgICAgc2VsZWN0aW9uUG9pbnQ6IGV2ZW50LnNlbGVjdGlvbi5mb2N1c1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gIWFuY2hvciB8fCAhZm9jdXMgPyB7XG4gICAgICAgIGJsb2NrT2Zmc2V0czogdm9pZCAwXG4gICAgICB9IDoge1xuICAgICAgICBibG9ja09mZnNldHM6IHtcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgZm9jdXNcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoXywge1xuICAgICAgYmxvY2tPZmZzZXRzXG4gICAgfSkgPT4gW3tcbiAgICAgIHR5cGU6IFwiZWZmZWN0XCIsXG4gICAgICBlZmZlY3Q6ICgpID0+IHtcbiAgICAgICAgc2VuZEJhY2soe1xuICAgICAgICAgIHR5cGU6IFwic2VsZWN0aW9uXCIsXG4gICAgICAgICAgYmxvY2tPZmZzZXRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dXVxuICB9KVxufSksIGRlbGV0ZUJhY2t3YXJkTGlzdGVuZXJDYWxsYmFjayA9ICh7XG4gIHNlbmRCYWNrLFxuICBpbnB1dFxufSkgPT4gaW5wdXQuZWRpdG9yLnJlZ2lzdGVyQmVoYXZpb3Ioe1xuICBiZWhhdmlvcjogZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImRlbGV0ZS5iYWNrd2FyZFwiLFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbe1xuICAgICAgdHlwZTogXCJoaXN0b3J5LnVuZG9cIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiZWZmZWN0XCIsXG4gICAgICBlZmZlY3Q6ICgpID0+IHtcbiAgICAgICAgc2VuZEJhY2soe1xuICAgICAgICAgIHR5cGU6IFwiZGVsZXRlLmJhY2t3YXJkXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfV1dXG4gIH0pXG59KSwgZGVjb3JhdG9yUGFpck1hY2hpbmUgPSBzZXR1cCh7XG4gIHR5cGVzOiB7XG4gICAgY29udGV4dDoge30sXG4gICAgaW5wdXQ6IHt9LFxuICAgIGV2ZW50czoge31cbiAgfSxcbiAgYWN0b3JzOiB7XG4gICAgXCJlbXBoYXNpcyBsaXN0ZW5lclwiOiBmcm9tQ2FsbGJhY2soZW1waGFzaXNMaXN0ZW5lciksXG4gICAgXCJkZWxldGUuYmFja3dhcmQgbGlzdGVuZXJcIjogZnJvbUNhbGxiYWNrKGRlbGV0ZUJhY2t3YXJkTGlzdGVuZXJDYWxsYmFjayksXG4gICAgXCJzZWxlY3Rpb24gbGlzdGVuZXJcIjogZnJvbUNhbGxiYWNrKHNlbGVjdGlvbkxpc3RlbmVyQ2FsbGJhY2spXG4gIH1cbn0pLmNyZWF0ZU1hY2hpbmUoe1xuICBpZDogXCJkZWNvcmF0b3IgcGFpclwiLFxuICBjb250ZXh0OiAoe1xuICAgIGlucHV0XG4gIH0pID0+ICh7XG4gICAgZGVjb3JhdG9yOiBpbnB1dC5kZWNvcmF0b3IsXG4gICAgZWRpdG9yOiBpbnB1dC5lZGl0b3IsXG4gICAgcGFpcjogaW5wdXQucGFpclxuICB9KSxcbiAgaW5pdGlhbDogXCJpZGxlXCIsXG4gIHN0YXRlczoge1xuICAgIGlkbGU6IHtcbiAgICAgIGludm9rZTogW3tcbiAgICAgICAgc3JjOiBcImVtcGhhc2lzIGxpc3RlbmVyXCIsXG4gICAgICAgIGlucHV0OiAoe1xuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSkgPT4gKHtcbiAgICAgICAgICBkZWNvcmF0b3I6IGNvbnRleHQuZGVjb3JhdG9yLFxuICAgICAgICAgIGVkaXRvcjogY29udGV4dC5lZGl0b3IsXG4gICAgICAgICAgcGFpcjogY29udGV4dC5wYWlyXG4gICAgICAgIH0pXG4gICAgICB9XSxcbiAgICAgIG9uOiB7XG4gICAgICAgIFwiZW1waGFzaXMuYWRkXCI6IHtcbiAgICAgICAgICB0YXJnZXQ6IFwiZW1waGFzaXMgYWRkZWRcIixcbiAgICAgICAgICBhY3Rpb25zOiBhc3NpZ24oe1xuICAgICAgICAgICAgb2Zmc2V0QWZ0ZXJFbXBoYXNpczogKHtcbiAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgIH0pID0+IGV2ZW50LmJsb2NrT2Zmc2V0XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJlbXBoYXNpcyBhZGRlZFwiOiB7XG4gICAgICBleGl0OiBbYXNzaWduKHtcbiAgICAgICAgb2Zmc2V0QWZ0ZXJFbXBoYXNpczogdm9pZCAwXG4gICAgICB9KV0sXG4gICAgICBpbnZva2U6IFt7XG4gICAgICAgIHNyYzogXCJzZWxlY3Rpb24gbGlzdGVuZXJcIixcbiAgICAgICAgaW5wdXQ6ICh7XG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9KSA9PiAoe1xuICAgICAgICAgIGVkaXRvcjogY29udGV4dC5lZGl0b3JcbiAgICAgICAgfSlcbiAgICAgIH0sIHtcbiAgICAgICAgc3JjOiBcImRlbGV0ZS5iYWNrd2FyZCBsaXN0ZW5lclwiLFxuICAgICAgICBpbnB1dDogKHtcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgIH0pID0+ICh7XG4gICAgICAgICAgZWRpdG9yOiBjb250ZXh0LmVkaXRvclxuICAgICAgICB9KVxuICAgICAgfV0sXG4gICAgICBvbjoge1xuICAgICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiLFxuICAgICAgICAgIGd1YXJkOiAoe1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgfSkgPT4gIWlzRXF1YWwoe1xuICAgICAgICAgICAgYW5jaG9yOiBjb250ZXh0Lm9mZnNldEFmdGVyRW1waGFzaXMsXG4gICAgICAgICAgICBmb2N1czogY29udGV4dC5vZmZzZXRBZnRlckVtcGhhc2lzXG4gICAgICAgICAgfSwgZXZlbnQuYmxvY2tPZmZzZXRzKVxuICAgICAgICB9LFxuICAgICAgICBcImRlbGV0ZS5iYWNrd2FyZFwiOiB7XG4gICAgICAgICAgdGFyZ2V0OiBcImlkbGVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbmZ1bmN0aW9uIE1hcmtkb3duUGx1Z2luKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDE3KSwgZWRpdG9yID0gdXNlRWRpdG9yKCk7XG4gIGxldCB0MCwgdDE7XG4gICRbMF0gIT09IGVkaXRvciB8fCAkWzFdICE9PSBwcm9wcy5jb25maWcgPyAodDAgPSAoKSA9PiB7XG4gICAgY29uc3QgdW5yZWdpc3RlckJlaGF2aW9ycyA9IGNyZWF0ZU1hcmtkb3duQmVoYXZpb3JzKHByb3BzLmNvbmZpZykubWFwKChiZWhhdmlvcikgPT4gZWRpdG9yLnJlZ2lzdGVyQmVoYXZpb3Ioe1xuICAgICAgYmVoYXZpb3JcbiAgICB9KSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdW5yZWdpc3RlckJlaGF2aW9yIG9mIHVucmVnaXN0ZXJCZWhhdmlvcnMpXG4gICAgICAgIHVucmVnaXN0ZXJCZWhhdmlvcigpO1xuICAgIH07XG4gIH0sIHQxID0gW2VkaXRvciwgcHJvcHMuY29uZmlnXSwgJFswXSA9IGVkaXRvciwgJFsxXSA9IHByb3BzLmNvbmZpZywgJFsyXSA9IHQwLCAkWzNdID0gdDEpIDogKHQwID0gJFsyXSwgdDEgPSAkWzNdKSwgdXNlRWZmZWN0KHQwLCB0MSk7XG4gIGxldCB0MjtcbiAgJFs0XSAhPT0gcHJvcHMuY29uZmlnLmJvbGREZWNvcmF0b3IgPyAodDIgPSBwcm9wcy5jb25maWcuYm9sZERlY29yYXRvciA/IC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIGpzeChEZWNvcmF0b3JTaG9ydGN1dFBsdWdpbiwgeyBkZWNvcmF0b3I6IHByb3BzLmNvbmZpZy5ib2xkRGVjb3JhdG9yLCBwYWlyOiB7XG4gICAgICBjaGFyOiBcIipcIixcbiAgICAgIGFtb3VudDogMlxuICAgIH0gfSksXG4gICAgLyogQF9fUFVSRV9fICovIGpzeChEZWNvcmF0b3JTaG9ydGN1dFBsdWdpbiwgeyBkZWNvcmF0b3I6IHByb3BzLmNvbmZpZy5ib2xkRGVjb3JhdG9yLCBwYWlyOiB7XG4gICAgICBjaGFyOiBcIl9cIixcbiAgICAgIGFtb3VudDogMlxuICAgIH0gfSlcbiAgXSB9KSA6IG51bGwsICRbNF0gPSBwcm9wcy5jb25maWcuYm9sZERlY29yYXRvciwgJFs1XSA9IHQyKSA6IHQyID0gJFs1XTtcbiAgbGV0IHQzO1xuICAkWzZdICE9PSBwcm9wcy5jb25maWcuY29kZURlY29yYXRvciA/ICh0MyA9IHByb3BzLmNvbmZpZy5jb2RlRGVjb3JhdG9yID8gLyogQF9fUFVSRV9fICovIGpzeChEZWNvcmF0b3JTaG9ydGN1dFBsdWdpbiwgeyBkZWNvcmF0b3I6IHByb3BzLmNvbmZpZy5jb2RlRGVjb3JhdG9yLCBwYWlyOiB7XG4gICAgY2hhcjogXCJgXCIsXG4gICAgYW1vdW50OiAxXG4gIH0gfSkgOiBudWxsLCAkWzZdID0gcHJvcHMuY29uZmlnLmNvZGVEZWNvcmF0b3IsICRbN10gPSB0MykgOiB0MyA9ICRbN107XG4gIGxldCB0NDtcbiAgJFs4XSAhPT0gcHJvcHMuY29uZmlnLml0YWxpY0RlY29yYXRvciA/ICh0NCA9IHByb3BzLmNvbmZpZy5pdGFsaWNEZWNvcmF0b3IgPyAvKiBAX19QVVJFX18gKi8ganN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goRGVjb3JhdG9yU2hvcnRjdXRQbHVnaW4sIHsgZGVjb3JhdG9yOiBwcm9wcy5jb25maWcuaXRhbGljRGVjb3JhdG9yLCBwYWlyOiB7XG4gICAgICBjaGFyOiBcIipcIixcbiAgICAgIGFtb3VudDogMVxuICAgIH0gfSksXG4gICAgLyogQF9fUFVSRV9fICovIGpzeChEZWNvcmF0b3JTaG9ydGN1dFBsdWdpbiwgeyBkZWNvcmF0b3I6IHByb3BzLmNvbmZpZy5pdGFsaWNEZWNvcmF0b3IsIHBhaXI6IHtcbiAgICAgIGNoYXI6IFwiX1wiLFxuICAgICAgYW1vdW50OiAxXG4gICAgfSB9KVxuICBdIH0pIDogbnVsbCwgJFs4XSA9IHByb3BzLmNvbmZpZy5pdGFsaWNEZWNvcmF0b3IsICRbOV0gPSB0NCkgOiB0NCA9ICRbOV07XG4gIGxldCB0NTtcbiAgJFsxMF0gIT09IHByb3BzLmNvbmZpZy5zdHJpa2VUaHJvdWdoRGVjb3JhdG9yID8gKHQ1ID0gcHJvcHMuY29uZmlnLnN0cmlrZVRocm91Z2hEZWNvcmF0b3IgPyAvKiBAX19QVVJFX18gKi8ganN4KERlY29yYXRvclNob3J0Y3V0UGx1Z2luLCB7IGRlY29yYXRvcjogcHJvcHMuY29uZmlnLnN0cmlrZVRocm91Z2hEZWNvcmF0b3IsIHBhaXI6IHtcbiAgICBjaGFyOiBcIn5cIixcbiAgICBhbW91bnQ6IDJcbiAgfSB9KSA6IG51bGwsICRbMTBdID0gcHJvcHMuY29uZmlnLnN0cmlrZVRocm91Z2hEZWNvcmF0b3IsICRbMTFdID0gdDUpIDogdDUgPSAkWzExXTtcbiAgbGV0IHQ2O1xuICByZXR1cm4gJFsxMl0gIT09IHQyIHx8ICRbMTNdICE9PSB0MyB8fCAkWzE0XSAhPT0gdDQgfHwgJFsxNV0gIT09IHQ1ID8gKHQ2ID0gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICB0MixcbiAgICB0MyxcbiAgICB0NCxcbiAgICB0NVxuICBdIH0pLCAkWzEyXSA9IHQyLCAkWzEzXSA9IHQzLCAkWzE0XSA9IHQ0LCAkWzE1XSA9IHQ1LCAkWzE2XSA9IHQ2KSA6IHQ2ID0gJFsxNl0sIHQ2O1xufVxuY29uc3Qgb25lTGluZUJlaGF2aW9ycyA9IFtcbiAgLyoqXG4gICAqIEhpdHRpbmcgRW50ZXIgb24gYW4gZXhwYW5kZWQgc2VsZWN0aW9uIHNob3VsZCBqdXN0IGRlbGV0ZSB0aGF0IHNlbGVjdGlvblxuICAgKiB3aXRob3V0IGNhdXNpbmcgYSBsaW5lIGJyZWFrLlxuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImluc2VydC5icmVha1wiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3RcbiAgICB9KSA9PiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiAmJiBpc1NlbGVjdGlvbkV4cGFuZGVkKHNuYXBzaG90KSA/IHtcbiAgICAgIHNlbGVjdGlvbjogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb25cbiAgICB9IDogITEsXG4gICAgYWN0aW9uczogWyhfLCB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9KSA9PiBbe1xuICAgICAgdHlwZTogXCJkZWxldGVcIixcbiAgICAgIHNlbGVjdGlvblxuICAgIH1dXVxuICB9KSxcbiAgLyoqXG4gICAqIEFsbCBvdGhlciBjYXNlcyBvZiBgaW5zZXJ0LmJyZWFrYCBzaG91bGQgYmUgYWJvcnRlZC5cbiAgICovXG4gIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJpbnNlcnQuYnJlYWtcIixcbiAgICBhY3Rpb25zOiBbKCkgPT4gW3tcbiAgICAgIHR5cGU6IFwibm9vcFwiXG4gICAgfV1dXG4gIH0pLFxuICAvKipcbiAgICogYGluc2VydC5ibG9ja2AgYGJlZm9yZWAgb3IgYGFmdGVyYCBpcyBub3QgYWxsb3dlZCBpbiBhIG9uZS1saW5lIGVkaXRvci5cbiAgICovXG4gIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJpbnNlcnQuYmxvY2tcIixcbiAgICBndWFyZDogKHtcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gZXZlbnQucGxhY2VtZW50ID09PSBcImJlZm9yZVwiIHx8IGV2ZW50LnBsYWNlbWVudCA9PT0gXCJhZnRlclwiLFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbe1xuICAgICAgdHlwZTogXCJub29wXCJcbiAgICB9XV1cbiAgfSksXG4gIC8qKlxuICAgKiBPdGhlciBjYXNlcyBvZiBgaW5zZXJ0LmJsb2NrYCBhcmUgYWxsb3dlZC5cbiAgICpcbiAgICogSWYgYSB0ZXh0IGJsb2NrIGlzIGluc2VydGVkIGFuZCB0aGUgZm9jdXMgYmxvY2sgaXMgZnVsbHkgc2VsZWN0ZWQsIHRoZW5cbiAgICogdGhlIGZvY3VzIGJsb2NrIGNhbiBiZSByZXBsYWNlZCB3aXRoIHRoZSBpbnNlcnRlZCBibG9jay5cbiAgICovXG4gIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJpbnNlcnQuYmxvY2tcIixcbiAgICBndWFyZDogKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSwgc2VsZWN0aW9uU3RhcnRQb2ludCA9IGdldFNlbGVjdGlvblN0YXJ0UG9pbnQoc25hcHNob3QpLCBzZWxlY3Rpb25FbmRQb2ludCA9IGdldFNlbGVjdGlvbkVuZFBvaW50KHNuYXBzaG90KTtcbiAgICAgIGlmICghZm9jdXNUZXh0QmxvY2sgfHwgIWlzVGV4dEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIGV2ZW50LmJsb2NrKSB8fCAhc2VsZWN0aW9uU3RhcnRQb2ludCB8fCAhc2VsZWN0aW9uRW5kUG9pbnQpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGJsb2NrU3RhcnRQb2ludCA9IGdldEJsb2NrU3RhcnRQb2ludChmb2N1c1RleHRCbG9jayksIGJsb2NrRW5kUG9pbnQgPSBnZXRCbG9ja0VuZFBvaW50KGZvY3VzVGV4dEJsb2NrKSwgbmV3Rm9jdXMgPSBnZXRCbG9ja0VuZFBvaW50KHtcbiAgICAgICAgbm9kZTogZXZlbnQuYmxvY2ssXG4gICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgX2tleTogZXZlbnQuYmxvY2suX2tleVxuICAgICAgICB9XVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaXNFcXVhbFNlbGVjdGlvblBvaW50cyhibG9ja1N0YXJ0UG9pbnQsIHNlbGVjdGlvblN0YXJ0UG9pbnQpICYmIGlzRXF1YWxTZWxlY3Rpb25Qb2ludHMoYmxvY2tFbmRQb2ludCwgc2VsZWN0aW9uRW5kUG9pbnQpID8ge1xuICAgICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgICAgbmV3Rm9jdXNcbiAgICAgIH0gOiAhMTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoe1xuICAgICAgZXZlbnRcbiAgICB9LCB7XG4gICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgIG5ld0ZvY3VzXG4gICAgfSkgPT4gW3tcbiAgICAgIHR5cGU6IFwiZGVsZXRlLmJsb2NrXCIsXG4gICAgICBibG9ja1BhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGhcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcImluc2VydC5ibG9ja1wiLFxuICAgICAgYmxvY2s6IGV2ZW50LmJsb2NrLFxuICAgICAgcGxhY2VtZW50OiBcImF1dG9cIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgYW5jaG9yOiBuZXdGb2N1cyxcbiAgICAgICAgZm9jdXM6IG5ld0ZvY3VzXG4gICAgICB9XG4gICAgfV1dXG4gIH0pLFxuICAvKipcbiAgICogQW4gb3JkaW5hcnkgYGluc2VydC5ibG9ja2AgaXMgYWNjZXB0YWJsZSBpZiBpdCdzIGEgdGV4dCBibG9jay4gSW4gdGhhdFxuICAgKiBjYXNlIGl0IHdpbGwgZ2V0IG1lcmdlZCBpbnRvIHRoZSBleGlzdGluZyB0ZXh0IGJsb2NrLlxuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImluc2VydC5ibG9ja1wiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soc25hcHNob3QpLCBzZWxlY3Rpb25TdGFydFBvaW50ID0gZ2V0U2VsZWN0aW9uU3RhcnRQb2ludChzbmFwc2hvdCksIHNlbGVjdGlvbkVuZFBvaW50ID0gZ2V0U2VsZWN0aW9uRW5kUG9pbnQoc25hcHNob3QpO1xuICAgICAgaWYgKCFmb2N1c1RleHRCbG9jayB8fCAhaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgZXZlbnQuYmxvY2spIHx8ICFzZWxlY3Rpb25TdGFydFBvaW50IHx8ICFzZWxlY3Rpb25FbmRQb2ludClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgYmxvY2tCZWZvcmVTdGFydFBvaW50ID0gc3BsaXRUZXh0QmxvY2soe1xuICAgICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICBibG9jazogZm9jdXNUZXh0QmxvY2subm9kZSxcbiAgICAgICAgcG9pbnQ6IHNlbGVjdGlvblN0YXJ0UG9pbnRcbiAgICAgIH0pPy5iZWZvcmUsIGJsb2NrQWZ0ZXJFbmRQb2ludCA9IHNwbGl0VGV4dEJsb2NrKHtcbiAgICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgYmxvY2s6IGZvY3VzVGV4dEJsb2NrLm5vZGUsXG4gICAgICAgIHBvaW50OiBzZWxlY3Rpb25FbmRQb2ludFxuICAgICAgfSk/LmFmdGVyO1xuICAgICAgaWYgKCFibG9ja0JlZm9yZVN0YXJ0UG9pbnQgfHwgIWJsb2NrQWZ0ZXJFbmRQb2ludClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgdGFyZ2V0QmxvY2sgPSBtZXJnZVRleHRCbG9ja3Moe1xuICAgICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICB0YXJnZXRCbG9jazogYmxvY2tCZWZvcmVTdGFydFBvaW50LFxuICAgICAgICBpbmNvbWluZ0Jsb2NrOiBldmVudC5ibG9ja1xuICAgICAgfSksIG5ld0ZvY3VzID0gZ2V0QmxvY2tFbmRQb2ludCh7XG4gICAgICAgIG5vZGU6IHRhcmdldEJsb2NrLFxuICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgIF9rZXk6IHRhcmdldEJsb2NrLl9rZXlcbiAgICAgICAgfV1cbiAgICAgIH0pLCBtZXJnZWRCbG9jayA9IG1lcmdlVGV4dEJsb2Nrcyh7XG4gICAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHRhcmdldEJsb2NrLFxuICAgICAgICBpbmNvbWluZ0Jsb2NrOiBibG9ja0FmdGVyRW5kUG9pbnRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICAgIG1lcmdlZEJsb2NrLFxuICAgICAgICBuZXdGb2N1c1xuICAgICAgfTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoXywge1xuICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICBtZXJnZWRCbG9jayxcbiAgICAgIG5ld0ZvY3VzXG4gICAgfSkgPT4gW3tcbiAgICAgIHR5cGU6IFwiZGVsZXRlLmJsb2NrXCIsXG4gICAgICBibG9ja1BhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGhcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcImluc2VydC5ibG9ja1wiLFxuICAgICAgYmxvY2s6IG1lcmdlZEJsb2NrLFxuICAgICAgcGxhY2VtZW50OiBcImF1dG9cIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgYW5jaG9yOiBuZXdGb2N1cyxcbiAgICAgICAgZm9jdXM6IG5ld0ZvY3VzXG4gICAgICB9XG4gICAgfV1dXG4gIH0pLFxuICAvKipcbiAgICogRmFsbGJhY2sgQmVoYXZpb3IgdG8gYXZvaWQgYGluc2VydC5ibG9ja2AgaW4gY2FzZSB0aGUgQmVoYXZpb3JzIGFib3ZlIGFsbFxuICAgKiBlbmQgdXAgd2l0aCBhIGZhbHN5IGd1YXJkLlxuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImluc2VydC5ibG9ja1wiLFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbe1xuICAgICAgdHlwZTogXCJub29wXCJcbiAgICB9XV1cbiAgfSksXG4gIC8qKlxuICAgKiBJZiBtdWx0aXBsZSBibG9ja3MgYXJlIGluc2VydGVkLCB0aGVuIHRoZSBub24tdGV4dCBibG9ja3MgYXJlIGZpbHRlcmVkIG91dFxuICAgKiBhbmQgdGhlIHRleHQgYmxvY2tzIGFyZSBtZXJnZWQgaW50byBvbmUgYmxvY2tcbiAgICovXG4gIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJpbnNlcnQuYmxvY2tzXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiBldmVudC5ibG9ja3MuZmlsdGVyKChibG9jaykgPT4gaXNUZXh0QmxvY2soY29udGV4dCwgYmxvY2spKS5yZWR1Y2UoKHRhcmdldEJsb2NrLCBpbmNvbWluZ0Jsb2NrKSA9PiBtZXJnZVRleHRCbG9ja3Moe1xuICAgICAgY29udGV4dCxcbiAgICAgIHRhcmdldEJsb2NrLFxuICAgICAgaW5jb21pbmdCbG9ja1xuICAgIH0pKSxcbiAgICBhY3Rpb25zOiBbXG4gICAgICAvLyBgaW5zZXJ0LmJsb2NrYCBpcyByYWlzZWQgc28gdGhlIEJlaGF2aW9yIGFib3ZlIGNhbiBoYW5kbGUgdGhlXG4gICAgICAvLyBpbnNlcnRpb25cbiAgICAgIChfLCBibG9jaykgPT4gW3JhaXNlKHtcbiAgICAgICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICAgICAgYmxvY2ssXG4gICAgICAgIHBsYWNlbWVudDogXCJhdXRvXCJcbiAgICAgIH0pXVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBCbG9jayBvYmplY3RzIGRvIG5vdCBmaXQgaW4gYSBvbmUtbGluZSBlZGl0b3JcbiAgICovXG4gIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJpbnNlcnQuYmxvY2sgb2JqZWN0XCIsXG4gICAgYWN0aW9uczogWygpID0+IFt7XG4gICAgICB0eXBlOiBcIm5vb3BcIlxuICAgIH1dXVxuICB9KSxcbiAgLyoqXG4gICAqIGBpbnNlcnQudGV4dCBibG9ja2AgaXMgcmFpc2VkIGFzIGFuIGBpbnNlcnQuYmxvY2tgIHNvIGl0IGNhbiBiZSBoYW5kbGVkXG4gICAqIGJ5IHRoZSBCZWhhdmlvcnMgYWJvdmUuXG4gICAqL1xuICBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiaW5zZXJ0LnRleHQgYmxvY2tcIixcbiAgICBhY3Rpb25zOiBbKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBldmVudFxuICAgIH0pID0+IFtyYWlzZSh7XG4gICAgICB0eXBlOiBcImluc2VydC5ibG9ja1wiLFxuICAgICAgYmxvY2s6IHtcbiAgICAgICAgX2tleTogY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgX3R5cGU6IGNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsXG4gICAgICAgIGNoaWxkcmVuOiBldmVudC50ZXh0QmxvY2s/LmNoaWxkcmVuID8/IFtdXG4gICAgICB9LFxuICAgICAgcGxhY2VtZW50OiBldmVudC5wbGFjZW1lbnRcbiAgICB9KV1dXG4gIH0pXG5dO1xuZnVuY3Rpb24gT25lTGluZVBsdWdpbigpIHtcbiAgY29uc3QgJCA9IGMoMSk7XG4gIGxldCB0MDtcbiAgcmV0dXJuICRbMF0gPT09IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpID8gKHQwID0gLyogQF9fUFVSRV9fICovIGpzeChCZWhhdmlvclBsdWdpbiwgeyBiZWhhdmlvcnM6IG9uZUxpbmVCZWhhdmlvcnMgfSksICRbMF0gPSB0MCkgOiB0MCA9ICRbMF0sIHQwO1xufVxuZXhwb3J0IHtcbiAgQmVoYXZpb3JQbHVnaW4sXG4gIEVkaXRvclJlZlBsdWdpbixcbiAgRXZlbnRMaXN0ZW5lclBsdWdpbixcbiAgTWFya2Rvd25QbHVnaW4sXG4gIE9uZUxpbmVQbHVnaW5cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/plugins/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/utils/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/utils/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blockOffsetToSpanSelectionPoint: () => (/* reexport safe */ _chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.blockOffsetToSpanSelectionPoint),\n/* harmony export */   blockOffsetsToSelection: () => (/* reexport safe */ _chunks_es_util_block_offsets_to_selection_js__WEBPACK_IMPORTED_MODULE_2__.blockOffsetsToSelection),\n/* harmony export */   childSelectionPointToBlockOffset: () => (/* binding */ childSelectionPointToBlockOffset),\n/* harmony export */   getBlockEndPoint: () => (/* reexport safe */ _chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.getBlockEndPoint),\n/* harmony export */   getBlockStartPoint: () => (/* reexport safe */ _chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.getBlockStartPoint),\n/* harmony export */   getTextBlockText: () => (/* reexport safe */ _chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.getTextBlockText),\n/* harmony export */   isEmptyTextBlock: () => (/* reexport safe */ _chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isEmptyTextBlock),\n/* harmony export */   isEqualSelectionPoints: () => (/* reexport safe */ _chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isEqualSelectionPoints),\n/* harmony export */   isKeyedSegment: () => (/* reexport safe */ _chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment),\n/* harmony export */   isSpan: () => (/* reexport safe */ _chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isSpan),\n/* harmony export */   isTextBlock: () => (/* binding */ isTextBlock),\n/* harmony export */   mergeTextBlocks: () => (/* binding */ mergeTextBlocks),\n/* harmony export */   reverseSelection: () => (/* reexport safe */ _chunks_es_util_reverse_selection_js__WEBPACK_IMPORTED_MODULE_3__.reverseSelection),\n/* harmony export */   sliceBlocks: () => (/* reexport safe */ _chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.sliceBlocks),\n/* harmony export */   spanSelectionPointToBlockOffset: () => (/* reexport safe */ _chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.spanSelectionPointToBlockOffset),\n/* harmony export */   splitTextBlock: () => (/* binding */ splitTextBlock)\n/* harmony export */ });\n/* harmony import */ var _chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_chunks-es/util.slice-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\");\n/* harmony import */ var _chunks_es_util_block_offsets_to_selection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_chunks-es/util.block-offsets-to-selection.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.block-offsets-to-selection.js\");\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var _chunks_es_util_reverse_selection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../_chunks-es/util.reverse-selection.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.reverse-selection.js\");\n\n\n\n\n\n\nfunction childSelectionPointToBlockOffset({\n  value,\n  selectionPoint\n}) {\n  let offset = 0;\n  const blockKey = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(selectionPoint.path[0]) ? selectionPoint.path[0]._key : void 0, childKey = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(selectionPoint.path[2]) ? selectionPoint.path[2]._key : void 0;\n  if (!(!blockKey || !childKey)) {\n    for (const block of value)\n      if (block._key === blockKey && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_1__.isPortableTextTextBlock)(block))\n        for (const child of block.children) {\n          if (child._key === childKey)\n            return {\n              path: [{\n                _key: block._key\n              }],\n              offset: offset + selectionPoint.offset\n            };\n          (0,_sanity_types__WEBPACK_IMPORTED_MODULE_1__.isPortableTextSpan)(child) && (offset += child.text.length);\n        }\n  }\n}\nfunction isTextBlock(context, block) {\n  return block._type === context.schema.block.name;\n}\nfunction mergeTextBlocks({\n  context,\n  targetBlock,\n  incomingBlock\n}) {\n  const parsedIncomingBlock = (0,_chunks_es_util_block_offsets_to_selection_js__WEBPACK_IMPORTED_MODULE_2__.parseBlock)({\n    context,\n    block: incomingBlock,\n    options: {\n      refreshKeys: !0\n    }\n  });\n  return !parsedIncomingBlock || !isTextBlock(context, parsedIncomingBlock) ? targetBlock : {\n    ...targetBlock,\n    children: [...targetBlock.children, ...parsedIncomingBlock.children],\n    markDefs: [...targetBlock.markDefs ?? [], ...parsedIncomingBlock.markDefs ?? []]\n  };\n}\nfunction splitTextBlock({\n  context,\n  block,\n  point\n}) {\n  const firstChild = block.children.at(0), lastChild = block.children.at(block.children.length - 1);\n  if (!firstChild || !lastChild)\n    return;\n  const before = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.sliceBlocks)({\n    blocks: [block],\n    selection: {\n      anchor: {\n        path: [{\n          _key: block._key\n        }, \"children\", {\n          _key: firstChild._key\n        }],\n        offset: 0\n      },\n      focus: point\n    }\n  }).at(0), after = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.sliceBlocks)({\n    blocks: [block],\n    selection: {\n      anchor: point,\n      focus: {\n        path: [{\n          _key: block._key\n        }, \"children\", {\n          _key: lastChild._key\n        }],\n        offset: (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isSpan)(context, lastChild) ? lastChild.text.length : 0\n      }\n    }\n  }).at(0);\n  if (!(!before || !after) && !(!isTextBlock(context, before) || !isTextBlock(context, after)))\n    return {\n      before,\n      after\n    };\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL3V0aWxzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlGO0FBQytIO0FBQzFJO0FBQ2E7QUFDZjtBQUNEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG1CQUFtQiwrRUFBYyw0RUFBNEUsK0VBQWM7QUFDM0g7QUFDQTtBQUNBLHFDQUFxQyxzRUFBdUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsVUFBVSxpRUFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOEJBQThCLHlGQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDRFQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUcsaUJBQWlCLDRFQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsdUVBQU07QUFDdEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFrQkU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL21hY2Jvb2twcm8vRG93bmxvYWRzL2NvbmljYXBwcy9pZ2VuZS9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL3V0aWxzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzS2V5ZWRTZWdtZW50LCBzbGljZUJsb2NrcywgaXNTcGFuIH0gZnJvbSBcIi4uL19jaHVua3MtZXMvdXRpbC5zbGljZS1ibG9ja3MuanNcIjtcbmltcG9ydCB7IGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQsIGdldEJsb2NrRW5kUG9pbnQsIGdldEJsb2NrU3RhcnRQb2ludCwgZ2V0VGV4dEJsb2NrVGV4dCwgaXNFbXB0eVRleHRCbG9jaywgaXNFcXVhbFNlbGVjdGlvblBvaW50cywgc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCB9IGZyb20gXCIuLi9fY2h1bmtzLWVzL3V0aWwuc2xpY2UtYmxvY2tzLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUJsb2NrIH0gZnJvbSBcIi4uL19jaHVua3MtZXMvdXRpbC5ibG9jay1vZmZzZXRzLXRvLXNlbGVjdGlvbi5qc1wiO1xuaW1wb3J0IHsgYmxvY2tPZmZzZXRzVG9TZWxlY3Rpb24gfSBmcm9tIFwiLi4vX2NodW5rcy1lcy91dGlsLmJsb2NrLW9mZnNldHMtdG8tc2VsZWN0aW9uLmpzXCI7XG5pbXBvcnQgeyBpc1BvcnRhYmxlVGV4dFRleHRCbG9jaywgaXNQb3J0YWJsZVRleHRTcGFuIH0gZnJvbSBcIkBzYW5pdHkvdHlwZXNcIjtcbmltcG9ydCB7IHJldmVyc2VTZWxlY3Rpb24gfSBmcm9tIFwiLi4vX2NodW5rcy1lcy91dGlsLnJldmVyc2Utc2VsZWN0aW9uLmpzXCI7XG5mdW5jdGlvbiBjaGlsZFNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCh7XG4gIHZhbHVlLFxuICBzZWxlY3Rpb25Qb2ludFxufSkge1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY29uc3QgYmxvY2tLZXkgPSBpc0tleWVkU2VnbWVudChzZWxlY3Rpb25Qb2ludC5wYXRoWzBdKSA/IHNlbGVjdGlvblBvaW50LnBhdGhbMF0uX2tleSA6IHZvaWQgMCwgY2hpbGRLZXkgPSBpc0tleWVkU2VnbWVudChzZWxlY3Rpb25Qb2ludC5wYXRoWzJdKSA/IHNlbGVjdGlvblBvaW50LnBhdGhbMl0uX2tleSA6IHZvaWQgMDtcbiAgaWYgKCEoIWJsb2NrS2V5IHx8ICFjaGlsZEtleSkpIHtcbiAgICBmb3IgKGNvbnN0IGJsb2NrIG9mIHZhbHVlKVxuICAgICAgaWYgKGJsb2NrLl9rZXkgPT09IGJsb2NrS2V5ICYmIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKGJsb2NrKSlcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBibG9jay5jaGlsZHJlbikge1xuICAgICAgICAgIGlmIChjaGlsZC5fa2V5ID09PSBjaGlsZEtleSlcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgKyBzZWxlY3Rpb25Qb2ludC5vZmZzZXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgaXNQb3J0YWJsZVRleHRTcGFuKGNoaWxkKSAmJiAob2Zmc2V0ICs9IGNoaWxkLnRleHQubGVuZ3RoKTtcbiAgICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc1RleHRCbG9jayhjb250ZXh0LCBibG9jaykge1xuICByZXR1cm4gYmxvY2suX3R5cGUgPT09IGNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWU7XG59XG5mdW5jdGlvbiBtZXJnZVRleHRCbG9ja3Moe1xuICBjb250ZXh0LFxuICB0YXJnZXRCbG9jayxcbiAgaW5jb21pbmdCbG9ja1xufSkge1xuICBjb25zdCBwYXJzZWRJbmNvbWluZ0Jsb2NrID0gcGFyc2VCbG9jayh7XG4gICAgY29udGV4dCxcbiAgICBibG9jazogaW5jb21pbmdCbG9jayxcbiAgICBvcHRpb25zOiB7XG4gICAgICByZWZyZXNoS2V5czogITBcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gIXBhcnNlZEluY29taW5nQmxvY2sgfHwgIWlzVGV4dEJsb2NrKGNvbnRleHQsIHBhcnNlZEluY29taW5nQmxvY2spID8gdGFyZ2V0QmxvY2sgOiB7XG4gICAgLi4udGFyZ2V0QmxvY2ssXG4gICAgY2hpbGRyZW46IFsuLi50YXJnZXRCbG9jay5jaGlsZHJlbiwgLi4ucGFyc2VkSW5jb21pbmdCbG9jay5jaGlsZHJlbl0sXG4gICAgbWFya0RlZnM6IFsuLi50YXJnZXRCbG9jay5tYXJrRGVmcyA/PyBbXSwgLi4ucGFyc2VkSW5jb21pbmdCbG9jay5tYXJrRGVmcyA/PyBbXV1cbiAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0VGV4dEJsb2NrKHtcbiAgY29udGV4dCxcbiAgYmxvY2ssXG4gIHBvaW50XG59KSB7XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBibG9jay5jaGlsZHJlbi5hdCgwKSwgbGFzdENoaWxkID0gYmxvY2suY2hpbGRyZW4uYXQoYmxvY2suY2hpbGRyZW4ubGVuZ3RoIC0gMSk7XG4gIGlmICghZmlyc3RDaGlsZCB8fCAhbGFzdENoaWxkKVxuICAgIHJldHVybjtcbiAgY29uc3QgYmVmb3JlID0gc2xpY2VCbG9ja3Moe1xuICAgIGJsb2NrczogW2Jsb2NrXSxcbiAgICBzZWxlY3Rpb246IHtcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgX2tleTogZmlyc3RDaGlsZC5fa2V5XG4gICAgICAgIH1dLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czogcG9pbnRcbiAgICB9XG4gIH0pLmF0KDApLCBhZnRlciA9IHNsaWNlQmxvY2tzKHtcbiAgICBibG9ja3M6IFtibG9ja10sXG4gICAgc2VsZWN0aW9uOiB7XG4gICAgICBhbmNob3I6IHBvaW50LFxuICAgICAgZm9jdXM6IHtcbiAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgIF9rZXk6IGxhc3RDaGlsZC5fa2V5XG4gICAgICAgIH1dLFxuICAgICAgICBvZmZzZXQ6IGlzU3Bhbihjb250ZXh0LCBsYXN0Q2hpbGQpID8gbGFzdENoaWxkLnRleHQubGVuZ3RoIDogMFxuICAgICAgfVxuICAgIH1cbiAgfSkuYXQoMCk7XG4gIGlmICghKCFiZWZvcmUgfHwgIWFmdGVyKSAmJiAhKCFpc1RleHRCbG9jayhjb250ZXh0LCBiZWZvcmUpIHx8ICFpc1RleHRCbG9jayhjb250ZXh0LCBhZnRlcikpKVxuICAgIHJldHVybiB7XG4gICAgICBiZWZvcmUsXG4gICAgICBhZnRlclxuICAgIH07XG59XG5leHBvcnQge1xuICBibG9ja09mZnNldFRvU3BhblNlbGVjdGlvblBvaW50LFxuICBibG9ja09mZnNldHNUb1NlbGVjdGlvbixcbiAgY2hpbGRTZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQsXG4gIGdldEJsb2NrRW5kUG9pbnQsXG4gIGdldEJsb2NrU3RhcnRQb2ludCxcbiAgZ2V0VGV4dEJsb2NrVGV4dCxcbiAgaXNFbXB0eVRleHRCbG9jayxcbiAgaXNFcXVhbFNlbGVjdGlvblBvaW50cyxcbiAgaXNLZXllZFNlZ21lbnQsXG4gIGlzU3BhbixcbiAgaXNUZXh0QmxvY2ssXG4gIG1lcmdlVGV4dEJsb2NrcyxcbiAgcmV2ZXJzZVNlbGVjdGlvbixcbiAgc2xpY2VCbG9ja3MsXG4gIHNwYW5TZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQsXG4gIHNwbGl0VGV4dEJsb2NrXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/utils/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/patches/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@portabletext/patches/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyAll: () => (/* binding */ applyAll),\n/* harmony export */   diffMatchPatch: () => (/* binding */ diffMatchPatch),\n/* harmony export */   insert: () => (/* binding */ insert),\n/* harmony export */   prefixPath: () => (/* binding */ prefixPath),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setIfMissing: () => (/* binding */ setIfMissing),\n/* harmony export */   unset: () => (/* binding */ unset)\n/* harmony export */ });\n/* harmony import */ var lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isObject.js */ \"(ssr)/./node_modules/lodash/isObject.js\");\n/* harmony import */ var lodash_isString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isString.js */ \"(ssr)/./node_modules/lodash/isString.js\");\n/* harmony import */ var lodash_findIndex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/findIndex.js */ \"(ssr)/./node_modules/lodash/findIndex.js\");\n/* harmony import */ var lodash_clone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/clone.js */ \"(ssr)/./node_modules/lodash/clone.js\");\n/* harmony import */ var lodash_omit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/omit.js */ \"(ssr)/./node_modules/lodash/omit.js\");\n/* harmony import */ var _sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sanity/diff-match-patch */ \"(ssr)/./node_modules/@sanity/diff-match-patch/dist/index.js\");\n\n\n\n\n\n\nconst BEFORE = \"before\", AFTER = \"after\";\nfunction insert$1(array, position, index, ...args) {\n  if (position !== BEFORE && position !== AFTER)\n    throw new Error(\n      `Invalid position \"${position}\", must be either ${BEFORE} or ${AFTER}`\n    );\n  const items = flatten(...args);\n  if (array.length === 0)\n    return items;\n  const len = array.length, idx = Math.abs((len + index) % len) % len, normalizedIdx = position === \"after\" ? idx + 1 : idx, copy = array.slice();\n  return copy.splice(normalizedIdx, 0, ...flatten(items)), copy;\n}\nfunction flatten(...values) {\n  return values.reduce((prev, item) => prev.concat(item), []);\n}\nconst hasOwn = Object.prototype.hasOwnProperty.call.bind(\n  Object.prototype.hasOwnProperty\n);\nfunction move(arr, from, to) {\n  const nextValue = arr.slice(), val = nextValue[from];\n  return nextValue.splice(from, 1), nextValue.splice(to, 0, val), nextValue;\n}\nfunction findTargetIndex(array, pathSegment) {\n  if (typeof pathSegment == \"number\")\n    return pathSegment;\n  const index = lodash_findIndex_js__WEBPACK_IMPORTED_MODULE_2__(array, pathSegment);\n  return index === -1 ? !1 : index;\n}\nfunction apply$3(value, patch) {\n  const nextValue = value.slice();\n  if (patch.path.length === 0) {\n    if (patch.type === \"setIfMissing\") {\n      if (!Array.isArray(patch.value))\n        throw new Error(\"Cannot set value of an array to a non-array\");\n      return value === void 0 ? patch.value : value;\n    } else if (patch.type === \"set\") {\n      if (!Array.isArray(patch.value))\n        throw new Error(\"Cannot set value of an array to a non-array\");\n      return patch.value;\n    } else {\n      if (patch.type === \"unset\")\n        return;\n      if (patch.type === \"move\") {\n        if (!patch.value || !hasOwn(patch.value, \"from\") || !hasOwn(patch.value, \"to\"))\n          throw new Error(\n            `Invalid value of 'move' patch. Expected a value with \"from\" and \"to\" indexes, instead got: ${JSON.stringify(\n              patch.value\n            )}`\n          );\n        return move(nextValue, patch.value.from, patch.value.to);\n      }\n    }\n    throw new Error(`Invalid array operation: ${patch.type}`);\n  }\n  const [head, ...tail] = patch.path, index = findTargetIndex(value, head);\n  if (index === !1)\n    return nextValue;\n  if (tail.length === 0) {\n    if (patch.type === \"insert\") {\n      const { position, items } = patch;\n      return insert$1(value, position, index, items);\n    } else if (patch.type === \"unset\") {\n      if (typeof index != \"number\")\n        throw new Error(\n          `Expected array index to be a number, instead got \"${index}\"`\n        );\n      return nextValue.splice(index, 1), nextValue;\n    }\n  }\n  return nextValue[index] = _apply(nextValue[index], {\n    ...patch,\n    path: tail\n  }), nextValue;\n}\nfunction apply$2(value, patch) {\n  const nextValue = lodash_clone_js__WEBPACK_IMPORTED_MODULE_3__(value);\n  if (patch.path.length === 0) {\n    if (patch.type === \"set\") {\n      if (!lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__(patch.value))\n        throw new Error(\"Cannot set value of an object to a non-object\");\n      return patch.value;\n    } else {\n      if (patch.type === \"unset\")\n        return;\n      if (patch.type === \"setIfMissing\")\n        return value === void 0 ? patch.value : value;\n    }\n    throw new Error(`Invalid object operation: ${patch.type}`);\n  }\n  const [head, ...tail] = patch.path;\n  if (typeof head != \"string\")\n    throw new Error(`Expected field name to be a string, instad got: ${head}`);\n  return tail.length === 0 && patch.type === \"unset\" ? lodash_omit_js__WEBPACK_IMPORTED_MODULE_4__(nextValue, head) : (nextValue[head] = _apply(nextValue[head], {\n    ...patch,\n    path: tail\n  }), nextValue);\n}\nconst OPERATIONS$1 = {\n  replace(_currentValue, nextValue) {\n    return nextValue;\n  },\n  set(_currentValue, nextValue) {\n    return nextValue;\n  },\n  setIfMissing(currentValue, nextValue) {\n    return currentValue === void 0 ? nextValue : currentValue;\n  },\n  unset(_currentValue, _nextValue) {\n  },\n  inc(currentValue, nextValue) {\n    return currentValue + nextValue;\n  },\n  dec(currentValue, nextValue) {\n    return currentValue - nextValue;\n  }\n}, SUPPORTED_PATCH_TYPES$1 = Object.keys(OPERATIONS$1);\nfunction apply$1(value, patch) {\n  if (!SUPPORTED_PATCH_TYPES$1.includes(patch.type))\n    throw new Error(\n      `Received patch of unsupported type: \"${JSON.stringify(\n        patch.type\n      )}\" for primitives. This is most likely a bug.`\n    );\n  if (patch.path.length > 0)\n    throw new Error(\n      `Cannot apply deep operations on primitive values. Received patch with type \"${patch.type}\" and path \"${patch.path.map((path) => JSON.stringify(path)).join(\".\")} that targeted the value \"${JSON.stringify(value)}\"`\n    );\n  return OPERATIONS$1[patch.type](value, patch.value);\n}\nconst OPERATIONS = {\n  replace(_currentValue, nextValue) {\n    return nextValue;\n  },\n  set(_currentValue, nextValue) {\n    return nextValue;\n  },\n  setIfMissing(currentValue, nextValue) {\n    return currentValue === void 0 ? nextValue : currentValue;\n  },\n  unset(_currentValue, _nextValue) {\n  },\n  diffMatchPatch(currentValue, nextValue) {\n    const [result] = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.applyPatches)((0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.parsePatch)(nextValue), currentValue, {\n      allowExceedingIndices: !0\n    });\n    return result;\n  }\n}, SUPPORTED_PATCH_TYPES = Object.keys(OPERATIONS);\nfunction apply(value, patch) {\n  if (!SUPPORTED_PATCH_TYPES.includes(patch.type))\n    throw new Error(\n      `Received patch of unsupported type: \"${JSON.stringify(\n        patch.type\n      )}\" for string. This is most likely a bug.`\n    );\n  if (patch.path.length > 0)\n    throw new Error(\n      `Cannot apply deep operations on string values. Received patch with type \"${patch.type}\" and path \"${patch.path.join(\".\")} that targeted the value \"${JSON.stringify(value)}\"`\n    );\n  const func = OPERATIONS[patch.type];\n  if (func)\n    return func(value, patch.value);\n  throw new Error(\"Unknown patch type\");\n}\nfunction applyAll(value, patches) {\n  return patches.reduce(_apply, value);\n}\nfunction applyPatch(value, patch) {\n  return Array.isArray(value) ? apply$3(value, patch) : lodash_isString_js__WEBPACK_IMPORTED_MODULE_1__(value) ? apply(value, patch) : lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__(value) ? apply$2(value, patch) : apply$1(value, patch);\n}\nfunction _apply(value, patch) {\n  return applyPatch(value, patch);\n}\nfunction setIfMissing(value, path = []) {\n  return {\n    type: \"setIfMissing\",\n    path,\n    value\n  };\n}\nfunction diffMatchPatch(currentValue, nextValue, path = []) {\n  const patches = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.makePatches)(currentValue, nextValue), patch = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.stringifyPatches)(patches);\n  return { type: \"diffMatchPatch\", path, value: patch };\n}\nfunction insert(items, position, path = []) {\n  return {\n    type: \"insert\",\n    path,\n    position,\n    items\n  };\n}\nfunction set(value, path = []) {\n  return { type: \"set\", path, value };\n}\nfunction unset(path = []) {\n  return { type: \"unset\", path };\n}\nfunction prefixPath(patch, segment) {\n  return {\n    ...patch,\n    path: [segment, ...patch.path]\n  };\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9wYXRjaGVzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQztBQUNBO0FBQ0U7QUFDUjtBQUNGO0FBQ2lFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVMsb0JBQW9CLFFBQVEsS0FBSyxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLCtEQUErRCxNQUFNO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsNENBQUs7QUFDekI7QUFDQTtBQUNBLFdBQVcsK0NBQVE7QUFDbkI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLEtBQUs7QUFDNUUsdURBQXVELDJDQUFJO0FBQzNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsV0FBVyxjQUFjLDBEQUEwRCwyQkFBMkIsc0JBQXNCO0FBQ3pOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUIsc0VBQVksQ0FBQyxvRUFBVTtBQUM1QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsV0FBVyxjQUFjLHNCQUFzQiwyQkFBMkIsc0JBQXNCO0FBQ2xMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELCtDQUFRLGdDQUFnQywrQ0FBUTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUVBQVcsbUNBQW1DLDBFQUFnQjtBQUNoRixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNib29rcHJvL0Rvd25sb2Fkcy9jb25pY2FwcHMvaWdlbmUvbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvcGF0Y2hlcy9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBpc09iamVjdCBmcm9tIFwibG9kYXNoL2lzT2JqZWN0LmpzXCI7XG5pbXBvcnQgaXNTdHJpbmcgZnJvbSBcImxvZGFzaC9pc1N0cmluZy5qc1wiO1xuaW1wb3J0IGZpbmRJbmRleCBmcm9tIFwibG9kYXNoL2ZpbmRJbmRleC5qc1wiO1xuaW1wb3J0IGNsb25lIGZyb20gXCJsb2Rhc2gvY2xvbmUuanNcIjtcbmltcG9ydCBvbWl0IGZyb20gXCJsb2Rhc2gvb21pdC5qc1wiO1xuaW1wb3J0IHsgYXBwbHlQYXRjaGVzLCBwYXJzZVBhdGNoLCBtYWtlUGF0Y2hlcywgc3RyaW5naWZ5UGF0Y2hlcyB9IGZyb20gXCJAc2FuaXR5L2RpZmYtbWF0Y2gtcGF0Y2hcIjtcbmNvbnN0IEJFRk9SRSA9IFwiYmVmb3JlXCIsIEFGVEVSID0gXCJhZnRlclwiO1xuZnVuY3Rpb24gaW5zZXJ0JDEoYXJyYXksIHBvc2l0aW9uLCBpbmRleCwgLi4uYXJncykge1xuICBpZiAocG9zaXRpb24gIT09IEJFRk9SRSAmJiBwb3NpdGlvbiAhPT0gQUZURVIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgcG9zaXRpb24gXCIke3Bvc2l0aW9ufVwiLCBtdXN0IGJlIGVpdGhlciAke0JFRk9SRX0gb3IgJHtBRlRFUn1gXG4gICAgKTtcbiAgY29uc3QgaXRlbXMgPSBmbGF0dGVuKC4uLmFyZ3MpO1xuICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBpdGVtcztcbiAgY29uc3QgbGVuID0gYXJyYXkubGVuZ3RoLCBpZHggPSBNYXRoLmFicygobGVuICsgaW5kZXgpICUgbGVuKSAlIGxlbiwgbm9ybWFsaXplZElkeCA9IHBvc2l0aW9uID09PSBcImFmdGVyXCIgPyBpZHggKyAxIDogaWR4LCBjb3B5ID0gYXJyYXkuc2xpY2UoKTtcbiAgcmV0dXJuIGNvcHkuc3BsaWNlKG5vcm1hbGl6ZWRJZHgsIDAsIC4uLmZsYXR0ZW4oaXRlbXMpKSwgY29weTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW4oLi4udmFsdWVzKSB7XG4gIHJldHVybiB2YWx1ZXMucmVkdWNlKChwcmV2LCBpdGVtKSA9PiBwcmV2LmNvbmNhdChpdGVtKSwgW10pO1xufVxuY29uc3QgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsLmJpbmQoXG4gIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbik7XG5mdW5jdGlvbiBtb3ZlKGFyciwgZnJvbSwgdG8pIHtcbiAgY29uc3QgbmV4dFZhbHVlID0gYXJyLnNsaWNlKCksIHZhbCA9IG5leHRWYWx1ZVtmcm9tXTtcbiAgcmV0dXJuIG5leHRWYWx1ZS5zcGxpY2UoZnJvbSwgMSksIG5leHRWYWx1ZS5zcGxpY2UodG8sIDAsIHZhbCksIG5leHRWYWx1ZTtcbn1cbmZ1bmN0aW9uIGZpbmRUYXJnZXRJbmRleChhcnJheSwgcGF0aFNlZ21lbnQpIHtcbiAgaWYgKHR5cGVvZiBwYXRoU2VnbWVudCA9PSBcIm51bWJlclwiKVxuICAgIHJldHVybiBwYXRoU2VnbWVudDtcbiAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXgoYXJyYXksIHBhdGhTZWdtZW50KTtcbiAgcmV0dXJuIGluZGV4ID09PSAtMSA/ICExIDogaW5kZXg7XG59XG5mdW5jdGlvbiBhcHBseSQzKHZhbHVlLCBwYXRjaCkge1xuICBjb25zdCBuZXh0VmFsdWUgPSB2YWx1ZS5zbGljZSgpO1xuICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJzZXRJZk1pc3NpbmdcIikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGNoLnZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCB2YWx1ZSBvZiBhbiBhcnJheSB0byBhIG5vbi1hcnJheVwiKTtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gcGF0Y2gudmFsdWUgOiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHBhdGNoLnR5cGUgPT09IFwic2V0XCIpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRjaC52YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdmFsdWUgb2YgYW4gYXJyYXkgdG8gYSBub24tYXJyYXlcIik7XG4gICAgICByZXR1cm4gcGF0Y2gudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChwYXRjaC50eXBlID09PSBcIm1vdmVcIikge1xuICAgICAgICBpZiAoIXBhdGNoLnZhbHVlIHx8ICFoYXNPd24ocGF0Y2gudmFsdWUsIFwiZnJvbVwiKSB8fCAhaGFzT3duKHBhdGNoLnZhbHVlLCBcInRvXCIpKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIG9mICdtb3ZlJyBwYXRjaC4gRXhwZWN0ZWQgYSB2YWx1ZSB3aXRoIFwiZnJvbVwiIGFuZCBcInRvXCIgaW5kZXhlcywgaW5zdGVhZCBnb3Q6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgIHBhdGNoLnZhbHVlXG4gICAgICAgICAgICApfWBcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gbW92ZShuZXh0VmFsdWUsIHBhdGNoLnZhbHVlLmZyb20sIHBhdGNoLnZhbHVlLnRvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFycmF5IG9wZXJhdGlvbjogJHtwYXRjaC50eXBlfWApO1xuICB9XG4gIGNvbnN0IFtoZWFkLCAuLi50YWlsXSA9IHBhdGNoLnBhdGgsIGluZGV4ID0gZmluZFRhcmdldEluZGV4KHZhbHVlLCBoZWFkKTtcbiAgaWYgKGluZGV4ID09PSAhMSlcbiAgICByZXR1cm4gbmV4dFZhbHVlO1xuICBpZiAodGFpbC5sZW5ndGggPT09IDApIHtcbiAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJpbnNlcnRcIikge1xuICAgICAgY29uc3QgeyBwb3NpdGlvbiwgaXRlbXMgfSA9IHBhdGNoO1xuICAgICAgcmV0dXJuIGluc2VydCQxKHZhbHVlLCBwb3NpdGlvbiwgaW5kZXgsIGl0ZW1zKTtcbiAgICB9IGVsc2UgaWYgKHBhdGNoLnR5cGUgPT09IFwidW5zZXRcIikge1xuICAgICAgaWYgKHR5cGVvZiBpbmRleCAhPSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEV4cGVjdGVkIGFycmF5IGluZGV4IHRvIGJlIGEgbnVtYmVyLCBpbnN0ZWFkIGdvdCBcIiR7aW5kZXh9XCJgXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gbmV4dFZhbHVlLnNwbGljZShpbmRleCwgMSksIG5leHRWYWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5leHRWYWx1ZVtpbmRleF0gPSBfYXBwbHkobmV4dFZhbHVlW2luZGV4XSwge1xuICAgIC4uLnBhdGNoLFxuICAgIHBhdGg6IHRhaWxcbiAgfSksIG5leHRWYWx1ZTtcbn1cbmZ1bmN0aW9uIGFwcGx5JDIodmFsdWUsIHBhdGNoKSB7XG4gIGNvbnN0IG5leHRWYWx1ZSA9IGNsb25lKHZhbHVlKTtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHBhdGNoLnR5cGUgPT09IFwic2V0XCIpIHtcbiAgICAgIGlmICghaXNPYmplY3QocGF0Y2gudmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHZhbHVlIG9mIGFuIG9iamVjdCB0byBhIG5vbi1vYmplY3RcIik7XG4gICAgICByZXR1cm4gcGF0Y2gudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChwYXRjaC50eXBlID09PSBcInNldElmTWlzc2luZ1wiKVxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHBhdGNoLnZhbHVlIDogdmFsdWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvYmplY3Qgb3BlcmF0aW9uOiAke3BhdGNoLnR5cGV9YCk7XG4gIH1cbiAgY29uc3QgW2hlYWQsIC4uLnRhaWxdID0gcGF0Y2gucGF0aDtcbiAgaWYgKHR5cGVvZiBoZWFkICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBmaWVsZCBuYW1lIHRvIGJlIGEgc3RyaW5nLCBpbnN0YWQgZ290OiAke2hlYWR9YCk7XG4gIHJldHVybiB0YWlsLmxlbmd0aCA9PT0gMCAmJiBwYXRjaC50eXBlID09PSBcInVuc2V0XCIgPyBvbWl0KG5leHRWYWx1ZSwgaGVhZCkgOiAobmV4dFZhbHVlW2hlYWRdID0gX2FwcGx5KG5leHRWYWx1ZVtoZWFkXSwge1xuICAgIC4uLnBhdGNoLFxuICAgIHBhdGg6IHRhaWxcbiAgfSksIG5leHRWYWx1ZSk7XG59XG5jb25zdCBPUEVSQVRJT05TJDEgPSB7XG4gIHJlcGxhY2UoX2N1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgfSxcbiAgc2V0KF9jdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBuZXh0VmFsdWU7XG4gIH0sXG4gIHNldElmTWlzc2luZyhjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBjdXJyZW50VmFsdWUgPT09IHZvaWQgMCA/IG5leHRWYWx1ZSA6IGN1cnJlbnRWYWx1ZTtcbiAgfSxcbiAgdW5zZXQoX2N1cnJlbnRWYWx1ZSwgX25leHRWYWx1ZSkge1xuICB9LFxuICBpbmMoY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICByZXR1cm4gY3VycmVudFZhbHVlICsgbmV4dFZhbHVlO1xuICB9LFxuICBkZWMoY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICByZXR1cm4gY3VycmVudFZhbHVlIC0gbmV4dFZhbHVlO1xuICB9XG59LCBTVVBQT1JURURfUEFUQ0hfVFlQRVMkMSA9IE9iamVjdC5rZXlzKE9QRVJBVElPTlMkMSk7XG5mdW5jdGlvbiBhcHBseSQxKHZhbHVlLCBwYXRjaCkge1xuICBpZiAoIVNVUFBPUlRFRF9QQVRDSF9UWVBFUyQxLmluY2x1ZGVzKHBhdGNoLnR5cGUpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBSZWNlaXZlZCBwYXRjaCBvZiB1bnN1cHBvcnRlZCB0eXBlOiBcIiR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIHBhdGNoLnR5cGVcbiAgICAgICl9XCIgZm9yIHByaW1pdGl2ZXMuIFRoaXMgaXMgbW9zdCBsaWtlbHkgYSBidWcuYFxuICAgICk7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBhcHBseSBkZWVwIG9wZXJhdGlvbnMgb24gcHJpbWl0aXZlIHZhbHVlcy4gUmVjZWl2ZWQgcGF0Y2ggd2l0aCB0eXBlIFwiJHtwYXRjaC50eXBlfVwiIGFuZCBwYXRoIFwiJHtwYXRjaC5wYXRoLm1hcCgocGF0aCkgPT4gSlNPTi5zdHJpbmdpZnkocGF0aCkpLmpvaW4oXCIuXCIpfSB0aGF0IHRhcmdldGVkIHRoZSB2YWx1ZSBcIiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfVwiYFxuICAgICk7XG4gIHJldHVybiBPUEVSQVRJT05TJDFbcGF0Y2gudHlwZV0odmFsdWUsIHBhdGNoLnZhbHVlKTtcbn1cbmNvbnN0IE9QRVJBVElPTlMgPSB7XG4gIHJlcGxhY2UoX2N1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgfSxcbiAgc2V0KF9jdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBuZXh0VmFsdWU7XG4gIH0sXG4gIHNldElmTWlzc2luZyhjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBjdXJyZW50VmFsdWUgPT09IHZvaWQgMCA/IG5leHRWYWx1ZSA6IGN1cnJlbnRWYWx1ZTtcbiAgfSxcbiAgdW5zZXQoX2N1cnJlbnRWYWx1ZSwgX25leHRWYWx1ZSkge1xuICB9LFxuICBkaWZmTWF0Y2hQYXRjaChjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIGNvbnN0IFtyZXN1bHRdID0gYXBwbHlQYXRjaGVzKHBhcnNlUGF0Y2gobmV4dFZhbHVlKSwgY3VycmVudFZhbHVlLCB7XG4gICAgICBhbGxvd0V4Y2VlZGluZ0luZGljZXM6ICEwXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSwgU1VQUE9SVEVEX1BBVENIX1RZUEVTID0gT2JqZWN0LmtleXMoT1BFUkFUSU9OUyk7XG5mdW5jdGlvbiBhcHBseSh2YWx1ZSwgcGF0Y2gpIHtcbiAgaWYgKCFTVVBQT1JURURfUEFUQ0hfVFlQRVMuaW5jbHVkZXMocGF0Y2gudHlwZSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFJlY2VpdmVkIHBhdGNoIG9mIHVuc3VwcG9ydGVkIHR5cGU6IFwiJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgcGF0Y2gudHlwZVxuICAgICAgKX1cIiBmb3Igc3RyaW5nLiBUaGlzIGlzIG1vc3QgbGlrZWx5IGEgYnVnLmBcbiAgICApO1xuICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPiAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3QgYXBwbHkgZGVlcCBvcGVyYXRpb25zIG9uIHN0cmluZyB2YWx1ZXMuIFJlY2VpdmVkIHBhdGNoIHdpdGggdHlwZSBcIiR7cGF0Y2gudHlwZX1cIiBhbmQgcGF0aCBcIiR7cGF0Y2gucGF0aC5qb2luKFwiLlwiKX0gdGhhdCB0YXJnZXRlZCB0aGUgdmFsdWUgXCIke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cImBcbiAgICApO1xuICBjb25zdCBmdW5jID0gT1BFUkFUSU9OU1twYXRjaC50eXBlXTtcbiAgaWYgKGZ1bmMpXG4gICAgcmV0dXJuIGZ1bmModmFsdWUsIHBhdGNoLnZhbHVlKTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBwYXRjaCB0eXBlXCIpO1xufVxuZnVuY3Rpb24gYXBwbHlBbGwodmFsdWUsIHBhdGNoZXMpIHtcbiAgcmV0dXJuIHBhdGNoZXMucmVkdWNlKF9hcHBseSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gYXBwbHlQYXRjaCh2YWx1ZSwgcGF0Y2gpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gYXBwbHkkMyh2YWx1ZSwgcGF0Y2gpIDogaXNTdHJpbmcodmFsdWUpID8gYXBwbHkodmFsdWUsIHBhdGNoKSA6IGlzT2JqZWN0KHZhbHVlKSA/IGFwcGx5JDIodmFsdWUsIHBhdGNoKSA6IGFwcGx5JDEodmFsdWUsIHBhdGNoKTtcbn1cbmZ1bmN0aW9uIF9hcHBseSh2YWx1ZSwgcGF0Y2gpIHtcbiAgcmV0dXJuIGFwcGx5UGF0Y2godmFsdWUsIHBhdGNoKTtcbn1cbmZ1bmN0aW9uIHNldElmTWlzc2luZyh2YWx1ZSwgcGF0aCA9IFtdKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzZXRJZk1pc3NpbmdcIixcbiAgICBwYXRoLFxuICAgIHZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBkaWZmTWF0Y2hQYXRjaChjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSwgcGF0aCA9IFtdKSB7XG4gIGNvbnN0IHBhdGNoZXMgPSBtYWtlUGF0Y2hlcyhjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSksIHBhdGNoID0gc3RyaW5naWZ5UGF0Y2hlcyhwYXRjaGVzKTtcbiAgcmV0dXJuIHsgdHlwZTogXCJkaWZmTWF0Y2hQYXRjaFwiLCBwYXRoLCB2YWx1ZTogcGF0Y2ggfTtcbn1cbmZ1bmN0aW9uIGluc2VydChpdGVtcywgcG9zaXRpb24sIHBhdGggPSBbXSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaW5zZXJ0XCIsXG4gICAgcGF0aCxcbiAgICBwb3NpdGlvbixcbiAgICBpdGVtc1xuICB9O1xufVxuZnVuY3Rpb24gc2V0KHZhbHVlLCBwYXRoID0gW10pIHtcbiAgcmV0dXJuIHsgdHlwZTogXCJzZXRcIiwgcGF0aCwgdmFsdWUgfTtcbn1cbmZ1bmN0aW9uIHVuc2V0KHBhdGggPSBbXSkge1xuICByZXR1cm4geyB0eXBlOiBcInVuc2V0XCIsIHBhdGggfTtcbn1cbmZ1bmN0aW9uIHByZWZpeFBhdGgocGF0Y2gsIHNlZ21lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5wYXRjaCxcbiAgICBwYXRoOiBbc2VnbWVudCwgLi4ucGF0Y2gucGF0aF1cbiAgfTtcbn1cbmV4cG9ydCB7XG4gIGFwcGx5QWxsLFxuICBkaWZmTWF0Y2hQYXRjaCxcbiAgaW5zZXJ0LFxuICBwcmVmaXhQYXRoLFxuICBzZXQsXG4gIHNldElmTWlzc2luZyxcbiAgdW5zZXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/patches/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/react/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@portabletext/react/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PortableText: () => (/* binding */ PortableText),\n/* harmony export */   defaultComponents: () => (/* binding */ defaultComponents),\n/* harmony export */   mergeComponents: () => (/* binding */ mergeComponents),\n/* harmony export */   toPlainText: () => (/* reexport safe */ _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.toPlainText)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @portabletext/toolkit */ \"(ssr)/./node_modules/@portabletext/toolkit/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\nconst _excluded = [\"block\", \"list\", \"listItem\", \"marks\", \"types\"],\n  _excluded2 = [\"listItem\"],\n  _excluded3 = [\"_key\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }\n\n\n\n\nconst defaultLists = {\n    number: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ol\", {\n      children\n    }),\n    bullet: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", {\n      children\n    })\n  },\n  DefaultListItem = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n    children\n  }),\n  link = ({\n    children,\n    value\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n    href: value?.href,\n    children\n  }),\n  underlineStyle = {\n    textDecoration: \"underline\"\n  },\n  defaultMarks = {\n    em: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"em\", {\n      children\n    }),\n    strong: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"strong\", {\n      children\n    }),\n    code: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"code\", {\n      children\n    }),\n    underline: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n      style: underlineStyle,\n      children\n    }),\n    \"strike-through\": ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"del\", {\n      children\n    }),\n    link\n  },\n  getTemplate = (type, prop) => `[@portabletext/react] Unknown ${type}, specify a component for it in the \\`components.${prop}\\` prop`,\n  unknownTypeWarning = typeName => getTemplate(`block type \"${typeName}\"`, \"types\"),\n  unknownMarkWarning = markType => getTemplate(`mark type \"${markType}\"`, \"marks\"),\n  unknownBlockStyleWarning = blockStyle => getTemplate(`block style \"${blockStyle}\"`, \"block\"),\n  unknownListStyleWarning = listStyle => getTemplate(`list style \"${listStyle}\"`, \"list\"),\n  unknownListItemStyleWarning = listStyle => getTemplate(`list item style \"${listStyle}\"`, \"listItem\");\nfunction printWarning(message) {\n  console.warn(message);\n}\nconst hidden = {\n    display: \"none\"\n  },\n  DefaultUnknownType = ({\n    value,\n    isInline\n  }) => {\n    const warning = unknownTypeWarning(value._type);\n    return isInline ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n      style: hidden,\n      children: warning\n    }) : /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n      style: hidden,\n      children: warning\n    });\n  },\n  DefaultUnknownMark = ({\n    markType,\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n    className: `unknown__pt__mark__${markType}`,\n    children\n  }),\n  DefaultUnknownBlockStyle = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n    children\n  }),\n  DefaultUnknownList = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", {\n    children\n  }),\n  DefaultUnknownListItem = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n    children\n  }),\n  DefaultHardBreak = () => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"br\", {}),\n  defaultBlockStyles = {\n    normal: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n      children\n    }),\n    blockquote: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"blockquote\", {\n      children\n    }),\n    h1: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h1\", {\n      children\n    }),\n    h2: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h2\", {\n      children\n    }),\n    h3: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", {\n      children\n    }),\n    h4: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h4\", {\n      children\n    }),\n    h5: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h5\", {\n      children\n    }),\n    h6: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h6\", {\n      children\n    })\n  },\n  defaultComponents = {\n    types: {},\n    block: defaultBlockStyles,\n    marks: defaultMarks,\n    list: defaultLists,\n    listItem: DefaultListItem,\n    hardBreak: DefaultHardBreak,\n    unknownType: DefaultUnknownType,\n    unknownMark: DefaultUnknownMark,\n    unknownList: DefaultUnknownList,\n    unknownListItem: DefaultUnknownListItem,\n    unknownBlockStyle: DefaultUnknownBlockStyle\n  };\nfunction mergeComponents(parent, overrides) {\n  const {\n      block,\n      list,\n      listItem,\n      marks,\n      types\n    } = overrides,\n    rest = _objectWithoutProperties(overrides, _excluded);\n  return _objectSpread(_objectSpread({}, parent), {}, {\n    block: mergeDeeply(parent, overrides, \"block\"),\n    list: mergeDeeply(parent, overrides, \"list\"),\n    listItem: mergeDeeply(parent, overrides, \"listItem\"),\n    marks: mergeDeeply(parent, overrides, \"marks\"),\n    types: mergeDeeply(parent, overrides, \"types\")\n  }, rest);\n}\nfunction mergeDeeply(parent, overrides, key) {\n  const override = overrides[key],\n    parentVal = parent[key];\n  return typeof override == \"function\" || override && typeof parentVal == \"function\" ? override : override ? _objectSpread(_objectSpread({}, parentVal), override) : parentVal;\n}\nfunction PortableText({\n  value: input,\n  components: componentOverrides,\n  listNestingMode,\n  onMissingComponent: missingComponentHandler = printWarning\n}) {\n  const handleMissingComponent = missingComponentHandler || noop,\n    blocks = Array.isArray(input) ? input : [input],\n    nested = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.nestLists)(blocks, listNestingMode || _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.LIST_NEST_MODE_HTML),\n    components = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents, [componentOverrides]),\n    renderNode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => getNodeRenderer(components, handleMissingComponent), [components, handleMissingComponent]),\n    rendered = nested.map((node, index) => renderNode({\n      node,\n      index,\n      isInline: !1,\n      renderNode\n    }));\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: rendered\n  });\n}\nconst getNodeRenderer = (components, handleMissingComponent) => {\n  function renderNode(options) {\n    const {\n        node,\n        index,\n        isInline\n      } = options,\n      key = node._key || `node-${index}`;\n    return (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitList)(node) ? renderList(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextListItemBlock)(node) ? renderListItem(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitSpan)(node) ? renderSpan(node, index, key) : hasCustomComponentForNode(node) ? renderCustomBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextBlock)(node) ? renderBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitTextNode)(node) ? renderText(node, key) : renderUnknownType(node, index, key, isInline);\n  }\n  function hasCustomComponentForNode(node) {\n    return node._type in components.types;\n  }\n  function renderListItem(node, index, key) {\n    const tree = serializeBlock({\n        node,\n        index,\n        isInline: !1,\n        renderNode\n      }),\n      renderer = components.listItem,\n      Li = (typeof renderer == \"function\" ? renderer : renderer[node.listItem]) || components.unknownListItem;\n    if (Li === components.unknownListItem) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: \"listItemStyle\"\n      });\n    }\n    let children = tree.children;\n    if (node.style && node.style !== \"normal\") {\n      const {\n          listItem\n        } = node,\n        blockNode = _objectWithoutProperties(node, _excluded2);\n      children = renderNode({\n        node: blockNode,\n        index,\n        isInline: !1,\n        renderNode\n      });\n    }\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Li, {\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderList(node, index, key) {\n    const children = node.children.map((child, childIndex) => renderNode({\n        node: child._key ? child : _objectSpread(_objectSpread({}, child), {}, {\n          _key: `li-${index}-${childIndex}`\n        }),\n        index: childIndex,\n        isInline: !1,\n        renderNode\n      })),\n      component = components.list,\n      List = (typeof component == \"function\" ? component : component[node.listItem]) || components.unknownList;\n    if (List === components.unknownList) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListStyleWarning(style), {\n        nodeType: \"listStyle\",\n        type: style\n      });\n    }\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(List, {\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderSpan(node, _index, key) {\n    const {\n        markDef,\n        markType,\n        markKey\n      } = node,\n      Span = components.marks[markType] || components.unknownMark,\n      children = node.children.map((child, childIndex) => renderNode({\n        node: child,\n        index: childIndex,\n        isInline: !0,\n        renderNode\n      }));\n    return Span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), {\n      nodeType: \"mark\",\n      type: markType\n    }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Span, {\n      text: (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.spanToPlainText)(node),\n      value: markDef,\n      markType,\n      markKey,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderBlock(node, index, key, isInline) {\n    const _serializeBlock = serializeBlock({\n        node,\n        index,\n        isInline,\n        renderNode\n      }),\n      {\n        _key\n      } = _serializeBlock,\n      props = _objectWithoutProperties(_serializeBlock, _excluded3),\n      style = props.node.style || \"normal\",\n      Block = (typeof components.block == \"function\" ? components.block : components.block[style]) || components.unknownBlockStyle;\n    return Block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {\n      nodeType: \"blockStyle\",\n      type: style\n    }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Block, _objectSpread(_objectSpread({}, props), {}, {\n      value: props.node,\n      renderNode\n    }), key);\n  }\n  function renderText(node, key) {\n    if (node.text === `\n`) {\n      const HardBreak = components.hardBreak;\n      return HardBreak ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(HardBreak, {}, key) : `\n`;\n    }\n    return node.text;\n  }\n  function renderUnknownType(node, index, key, isInline) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode\n    };\n    handleMissingComponent(unknownTypeWarning(node._type), {\n      nodeType: \"block\",\n      type: node._type\n    });\n    const UnknownType = components.unknownType;\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnknownType, _objectSpread({}, nodeOptions), key);\n  }\n  function renderCustomBlock(node, index, key, isInline) {\n    const nodeOptions = {\n        value: node,\n        isInline,\n        index,\n        renderNode\n      },\n      Node = components.types[node._type];\n    return Node ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Node, _objectSpread({}, nodeOptions), key) : null;\n  }\n  return renderNode;\n};\nfunction serializeBlock(options) {\n  const {\n      node,\n      index,\n      isInline,\n      renderNode\n    } = options,\n    children = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.buildMarksTree)(node).map((child, i) => renderNode({\n      node: child,\n      isInline: !0,\n      index: i,\n      renderNode\n    }));\n  return {\n    _key: node._key || `block-${index}`,\n    children,\n    index,\n    isInline,\n    node\n  };\n}\nfunction noop() {}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDcFAsNEJBQTRCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsc0RBQXNELDhCQUE4QixtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWEsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUU7QUFDelEsMENBQTBDLDBCQUEwQixtREFBbUQsb0NBQW9DLHlDQUF5QyxZQUFZLGNBQWMsa0NBQWtDLHFEQUFxRDtBQUNyVCwrQ0FBK0MsMEJBQTBCLFlBQVksdUJBQXVCLDhCQUE4Qiw2QkFBNkIsZUFBZTtBQUNwSTtBQUM2TDtBQUMzTDtBQUNwQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQixzREFBRztBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxvQkFBb0Isc0RBQUc7QUFDNUI7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixzREFBRztBQUMxQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixzREFBRztBQUMxQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0Isc0RBQUc7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUssb0JBQW9CLHNEQUFHO0FBQzVCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQixzREFBRztBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxvQkFB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O0FBQ0E7QUFDQTtBQUN5RTtBQUN6RSIsInNvdXJjZXMiOlsiL1VzZXJzL21hY2Jvb2twcm8vRG93bmxvYWRzL2NvbmljYXBwcy9pZ2VuZS9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9yZWFjdC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IF9leGNsdWRlZCA9IFtcImJsb2NrXCIsIFwibGlzdFwiLCBcImxpc3RJdGVtXCIsIFwibWFya3NcIiwgXCJ0eXBlc1wiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcImxpc3RJdGVtXCJdLFxuICBfZXhjbHVkZWQzID0gW1wiX2tleVwiXTtcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGUsIHQpIHsgaWYgKG51bGwgPT0gZSkgcmV0dXJuIHt9OyB2YXIgbywgciwgaSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKGUsIHQpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IGZvciAociA9IDA7IHIgPCBzLmxlbmd0aDsgcisrKSBvID0gc1tyXSwgdC5pbmNsdWRlcyhvKSB8fCB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIG8pICYmIChpW29dID0gZVtvXSk7IH0gcmV0dXJuIGk7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHIsIGUpIHsgaWYgKG51bGwgPT0gcikgcmV0dXJuIHt9OyB2YXIgdCA9IHt9OyBmb3IgKHZhciBuIGluIHIpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsIG4pKSB7IGlmIChlLmluY2x1ZGVzKG4pKSBjb250aW51ZTsgdFtuXSA9IHJbbl07IH0gcmV0dXJuIHQ7IH1cbmltcG9ydCB7IGpzeCwgRnJhZ21lbnQgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IG5lc3RMaXN0cywgTElTVF9ORVNUX01PREVfSFRNTCwgaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdCwgaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuLCBpc1BvcnRhYmxlVGV4dEJsb2NrLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZSwgc3BhblRvUGxhaW5UZXh0LCBidWlsZE1hcmtzVHJlZSB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3Rvb2xraXRcIjtcbmltcG9ydCB7IHRvUGxhaW5UZXh0IH0gZnJvbSBcIkBwb3J0YWJsZXRleHQvdG9vbGtpdFwiO1xuaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuY29uc3QgZGVmYXVsdExpc3RzID0ge1xuICAgIG51bWJlcjogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwib2xcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBidWxsZXQ6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcInVsXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSlcbiAgfSxcbiAgRGVmYXVsdExpc3RJdGVtID0gKHtcbiAgICBjaGlsZHJlblxuICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJsaVwiLCB7XG4gICAgY2hpbGRyZW5cbiAgfSksXG4gIGxpbmsgPSAoe1xuICAgIGNoaWxkcmVuLFxuICAgIHZhbHVlXG4gIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImFcIiwge1xuICAgIGhyZWY6IHZhbHVlPy5ocmVmLFxuICAgIGNoaWxkcmVuXG4gIH0pLFxuICB1bmRlcmxpbmVTdHlsZSA9IHtcbiAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIlxuICB9LFxuICBkZWZhdWx0TWFya3MgPSB7XG4gICAgZW06ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImVtXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgc3Ryb25nOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJzdHJvbmdcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBjb2RlOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJjb2RlXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgdW5kZXJsaW5lOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJzcGFuXCIsIHtcbiAgICAgIHN0eWxlOiB1bmRlcmxpbmVTdHlsZSxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgXCJzdHJpa2UtdGhyb3VnaFwiOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJkZWxcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBsaW5rXG4gIH0sXG4gIGdldFRlbXBsYXRlID0gKHR5cGUsIHByb3ApID0+IGBbQHBvcnRhYmxldGV4dC9yZWFjdF0gVW5rbm93biAke3R5cGV9LCBzcGVjaWZ5IGEgY29tcG9uZW50IGZvciBpdCBpbiB0aGUgXFxgY29tcG9uZW50cy4ke3Byb3B9XFxgIHByb3BgLFxuICB1bmtub3duVHlwZVdhcm5pbmcgPSB0eXBlTmFtZSA9PiBnZXRUZW1wbGF0ZShgYmxvY2sgdHlwZSBcIiR7dHlwZU5hbWV9XCJgLCBcInR5cGVzXCIpLFxuICB1bmtub3duTWFya1dhcm5pbmcgPSBtYXJrVHlwZSA9PiBnZXRUZW1wbGF0ZShgbWFyayB0eXBlIFwiJHttYXJrVHlwZX1cImAsIFwibWFya3NcIiksXG4gIHVua25vd25CbG9ja1N0eWxlV2FybmluZyA9IGJsb2NrU3R5bGUgPT4gZ2V0VGVtcGxhdGUoYGJsb2NrIHN0eWxlIFwiJHtibG9ja1N0eWxlfVwiYCwgXCJibG9ja1wiKSxcbiAgdW5rbm93bkxpc3RTdHlsZVdhcm5pbmcgPSBsaXN0U3R5bGUgPT4gZ2V0VGVtcGxhdGUoYGxpc3Qgc3R5bGUgXCIke2xpc3RTdHlsZX1cImAsIFwibGlzdFwiKSxcbiAgdW5rbm93bkxpc3RJdGVtU3R5bGVXYXJuaW5nID0gbGlzdFN0eWxlID0+IGdldFRlbXBsYXRlKGBsaXN0IGl0ZW0gc3R5bGUgXCIke2xpc3RTdHlsZX1cImAsIFwibGlzdEl0ZW1cIik7XG5mdW5jdGlvbiBwcmludFdhcm5pbmcobWVzc2FnZSkge1xuICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG59XG5jb25zdCBoaWRkZW4gPSB7XG4gICAgZGlzcGxheTogXCJub25lXCJcbiAgfSxcbiAgRGVmYXVsdFVua25vd25UeXBlID0gKHtcbiAgICB2YWx1ZSxcbiAgICBpc0lubGluZVxuICB9KSA9PiB7XG4gICAgY29uc3Qgd2FybmluZyA9IHVua25vd25UeXBlV2FybmluZyh2YWx1ZS5fdHlwZSk7XG4gICAgcmV0dXJuIGlzSW5saW5lID8gLyogQF9fUFVSRV9fICovanN4KFwic3BhblwiLCB7XG4gICAgICBzdHlsZTogaGlkZGVuLFxuICAgICAgY2hpbGRyZW46IHdhcm5pbmdcbiAgICB9KSA6IC8qIEBfX1BVUkVfXyAqL2pzeChcImRpdlwiLCB7XG4gICAgICBzdHlsZTogaGlkZGVuLFxuICAgICAgY2hpbGRyZW46IHdhcm5pbmdcbiAgICB9KTtcbiAgfSxcbiAgRGVmYXVsdFVua25vd25NYXJrID0gKHtcbiAgICBtYXJrVHlwZSxcbiAgICBjaGlsZHJlblxuICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJzcGFuXCIsIHtcbiAgICBjbGFzc05hbWU6IGB1bmtub3duX19wdF9fbWFya19fJHttYXJrVHlwZX1gLFxuICAgIGNoaWxkcmVuXG4gIH0pLFxuICBEZWZhdWx0VW5rbm93bkJsb2NrU3R5bGUgPSAoe1xuICAgIGNoaWxkcmVuXG4gIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcInBcIiwge1xuICAgIGNoaWxkcmVuXG4gIH0pLFxuICBEZWZhdWx0VW5rbm93bkxpc3QgPSAoe1xuICAgIGNoaWxkcmVuXG4gIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcInVsXCIsIHtcbiAgICBjaGlsZHJlblxuICB9KSxcbiAgRGVmYXVsdFVua25vd25MaXN0SXRlbSA9ICh7XG4gICAgY2hpbGRyZW5cbiAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwibGlcIiwge1xuICAgIGNoaWxkcmVuXG4gIH0pLFxuICBEZWZhdWx0SGFyZEJyZWFrID0gKCkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiYnJcIiwge30pLFxuICBkZWZhdWx0QmxvY2tTdHlsZXMgPSB7XG4gICAgbm9ybWFsOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJwXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgYmxvY2txdW90ZTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiYmxvY2txdW90ZVwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGgxOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJoMVwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGgyOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJoMlwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGgzOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJoM1wiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGg0OiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJoNFwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGg1OiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJoNVwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGg2OiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJoNlwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pXG4gIH0sXG4gIGRlZmF1bHRDb21wb25lbnRzID0ge1xuICAgIHR5cGVzOiB7fSxcbiAgICBibG9jazogZGVmYXVsdEJsb2NrU3R5bGVzLFxuICAgIG1hcmtzOiBkZWZhdWx0TWFya3MsXG4gICAgbGlzdDogZGVmYXVsdExpc3RzLFxuICAgIGxpc3RJdGVtOiBEZWZhdWx0TGlzdEl0ZW0sXG4gICAgaGFyZEJyZWFrOiBEZWZhdWx0SGFyZEJyZWFrLFxuICAgIHVua25vd25UeXBlOiBEZWZhdWx0VW5rbm93blR5cGUsXG4gICAgdW5rbm93bk1hcms6IERlZmF1bHRVbmtub3duTWFyayxcbiAgICB1bmtub3duTGlzdDogRGVmYXVsdFVua25vd25MaXN0LFxuICAgIHVua25vd25MaXN0SXRlbTogRGVmYXVsdFVua25vd25MaXN0SXRlbSxcbiAgICB1bmtub3duQmxvY2tTdHlsZTogRGVmYXVsdFVua25vd25CbG9ja1N0eWxlXG4gIH07XG5mdW5jdGlvbiBtZXJnZUNvbXBvbmVudHMocGFyZW50LCBvdmVycmlkZXMpIHtcbiAgY29uc3Qge1xuICAgICAgYmxvY2ssXG4gICAgICBsaXN0LFxuICAgICAgbGlzdEl0ZW0sXG4gICAgICBtYXJrcyxcbiAgICAgIHR5cGVzXG4gICAgfSA9IG92ZXJyaWRlcyxcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG92ZXJyaWRlcywgX2V4Y2x1ZGVkKTtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGFyZW50KSwge30sIHtcbiAgICBibG9jazogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwiYmxvY2tcIiksXG4gICAgbGlzdDogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwibGlzdFwiKSxcbiAgICBsaXN0SXRlbTogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwibGlzdEl0ZW1cIiksXG4gICAgbWFya3M6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcIm1hcmtzXCIpLFxuICAgIHR5cGVzOiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJ0eXBlc1wiKVxuICB9LCByZXN0KTtcbn1cbmZ1bmN0aW9uIG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBrZXkpIHtcbiAgY29uc3Qgb3ZlcnJpZGUgPSBvdmVycmlkZXNba2V5XSxcbiAgICBwYXJlbnRWYWwgPSBwYXJlbnRba2V5XTtcbiAgcmV0dXJuIHR5cGVvZiBvdmVycmlkZSA9PSBcImZ1bmN0aW9uXCIgfHwgb3ZlcnJpZGUgJiYgdHlwZW9mIHBhcmVudFZhbCA9PSBcImZ1bmN0aW9uXCIgPyBvdmVycmlkZSA6IG92ZXJyaWRlID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwYXJlbnRWYWwpLCBvdmVycmlkZSkgOiBwYXJlbnRWYWw7XG59XG5mdW5jdGlvbiBQb3J0YWJsZVRleHQoe1xuICB2YWx1ZTogaW5wdXQsXG4gIGNvbXBvbmVudHM6IGNvbXBvbmVudE92ZXJyaWRlcyxcbiAgbGlzdE5lc3RpbmdNb2RlLFxuICBvbk1pc3NpbmdDb21wb25lbnQ6IG1pc3NpbmdDb21wb25lbnRIYW5kbGVyID0gcHJpbnRXYXJuaW5nXG59KSB7XG4gIGNvbnN0IGhhbmRsZU1pc3NpbmdDb21wb25lbnQgPSBtaXNzaW5nQ29tcG9uZW50SGFuZGxlciB8fCBub29wLFxuICAgIGJsb2NrcyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdLFxuICAgIG5lc3RlZCA9IG5lc3RMaXN0cyhibG9ja3MsIGxpc3ROZXN0aW5nTW9kZSB8fCBMSVNUX05FU1RfTU9ERV9IVE1MKSxcbiAgICBjb21wb25lbnRzID0gdXNlTWVtbygoKSA9PiBjb21wb25lbnRPdmVycmlkZXMgPyBtZXJnZUNvbXBvbmVudHMoZGVmYXVsdENvbXBvbmVudHMsIGNvbXBvbmVudE92ZXJyaWRlcykgOiBkZWZhdWx0Q29tcG9uZW50cywgW2NvbXBvbmVudE92ZXJyaWRlc10pLFxuICAgIHJlbmRlck5vZGUgPSB1c2VNZW1vKCgpID0+IGdldE5vZGVSZW5kZXJlcihjb21wb25lbnRzLCBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KSwgW2NvbXBvbmVudHMsIGhhbmRsZU1pc3NpbmdDb21wb25lbnRdKSxcbiAgICByZW5kZXJlZCA9IG5lc3RlZC5tYXAoKG5vZGUsIGluZGV4KSA9PiByZW5kZXJOb2RlKHtcbiAgICAgIG5vZGUsXG4gICAgICBpbmRleCxcbiAgICAgIGlzSW5saW5lOiAhMSxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9KSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogcmVuZGVyZWRcbiAgfSk7XG59XG5jb25zdCBnZXROb2RlUmVuZGVyZXIgPSAoY29tcG9uZW50cywgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCkgPT4ge1xuICBmdW5jdGlvbiByZW5kZXJOb2RlKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBpc0lubGluZVxuICAgICAgfSA9IG9wdGlvbnMsXG4gICAgICBrZXkgPSBub2RlLl9rZXkgfHwgYG5vZGUtJHtpbmRleH1gO1xuICAgIHJldHVybiBpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0KG5vZGUpID8gcmVuZGVyTGlzdChub2RlLCBpbmRleCwga2V5KSA6IGlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jayhub2RlKSA/IHJlbmRlckxpc3RJdGVtKG5vZGUsIGluZGV4LCBrZXkpIDogaXNQb3J0YWJsZVRleHRUb29sa2l0U3Bhbihub2RlKSA/IHJlbmRlclNwYW4obm9kZSwgaW5kZXgsIGtleSkgOiBoYXNDdXN0b21Db21wb25lbnRGb3JOb2RlKG5vZGUpID8gcmVuZGVyQ3VzdG9tQmxvY2sobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpIDogaXNQb3J0YWJsZVRleHRCbG9jayhub2RlKSA/IHJlbmRlckJsb2NrKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKSA6IGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlKG5vZGUpID8gcmVuZGVyVGV4dChub2RlLCBrZXkpIDogcmVuZGVyVW5rbm93blR5cGUobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpO1xuICB9XG4gIGZ1bmN0aW9uIGhhc0N1c3RvbUNvbXBvbmVudEZvck5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLl90eXBlIGluIGNvbXBvbmVudHMudHlwZXM7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyTGlzdEl0ZW0obm9kZSwgaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IHRyZWUgPSBzZXJpYWxpemVCbG9jayh7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBpc0lubGluZTogITEsXG4gICAgICAgIHJlbmRlck5vZGVcbiAgICAgIH0pLFxuICAgICAgcmVuZGVyZXIgPSBjb21wb25lbnRzLmxpc3RJdGVtLFxuICAgICAgTGkgPSAodHlwZW9mIHJlbmRlcmVyID09IFwiZnVuY3Rpb25cIiA/IHJlbmRlcmVyIDogcmVuZGVyZXJbbm9kZS5saXN0SXRlbV0pIHx8IGNvbXBvbmVudHMudW5rbm93bkxpc3RJdGVtO1xuICAgIGlmIChMaSA9PT0gY29tcG9uZW50cy51bmtub3duTGlzdEl0ZW0pIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gbm9kZS5saXN0SXRlbSB8fCBcImJ1bGxldFwiO1xuICAgICAgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duTGlzdEl0ZW1TdHlsZVdhcm5pbmcoc3R5bGUpLCB7XG4gICAgICAgIHR5cGU6IHN0eWxlLFxuICAgICAgICBub2RlVHlwZTogXCJsaXN0SXRlbVN0eWxlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgY2hpbGRyZW4gPSB0cmVlLmNoaWxkcmVuO1xuICAgIGlmIChub2RlLnN0eWxlICYmIG5vZGUuc3R5bGUgIT09IFwibm9ybWFsXCIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgICBsaXN0SXRlbVxuICAgICAgICB9ID0gbm9kZSxcbiAgICAgICAgYmxvY2tOb2RlID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZDIpO1xuICAgICAgY2hpbGRyZW4gPSByZW5kZXJOb2RlKHtcbiAgICAgICAgbm9kZTogYmxvY2tOb2RlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChMaSwge1xuICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICBpbmRleCxcbiAgICAgIGlzSW5saW5lOiAhMSxcbiAgICAgIHJlbmRlck5vZGUsXG4gICAgICBjaGlsZHJlblxuICAgIH0sIGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyTGlzdChub2RlLCBpbmRleCwga2V5KSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcCgoY2hpbGQsIGNoaWxkSW5kZXgpID0+IHJlbmRlck5vZGUoe1xuICAgICAgICBub2RlOiBjaGlsZC5fa2V5ID8gY2hpbGQgOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNoaWxkKSwge30sIHtcbiAgICAgICAgICBfa2V5OiBgbGktJHtpbmRleH0tJHtjaGlsZEluZGV4fWBcbiAgICAgICAgfSksXG4gICAgICAgIGluZGV4OiBjaGlsZEluZGV4LFxuICAgICAgICBpc0lubGluZTogITEsXG4gICAgICAgIHJlbmRlck5vZGVcbiAgICAgIH0pKSxcbiAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHMubGlzdCxcbiAgICAgIExpc3QgPSAodHlwZW9mIGNvbXBvbmVudCA9PSBcImZ1bmN0aW9uXCIgPyBjb21wb25lbnQgOiBjb21wb25lbnRbbm9kZS5saXN0SXRlbV0pIHx8IGNvbXBvbmVudHMudW5rbm93bkxpc3Q7XG4gICAgaWYgKExpc3QgPT09IGNvbXBvbmVudHMudW5rbm93bkxpc3QpIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gbm9kZS5saXN0SXRlbSB8fCBcImJ1bGxldFwiO1xuICAgICAgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duTGlzdFN0eWxlV2FybmluZyhzdHlsZSksIHtcbiAgICAgICAgbm9kZVR5cGU6IFwibGlzdFN0eWxlXCIsXG4gICAgICAgIHR5cGU6IHN0eWxlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChMaXN0LCB7XG4gICAgICB2YWx1ZTogbm9kZSxcbiAgICAgIGluZGV4LFxuICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgcmVuZGVyTm9kZSxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJTcGFuKG5vZGUsIF9pbmRleCwga2V5KSB7XG4gICAgY29uc3Qge1xuICAgICAgICBtYXJrRGVmLFxuICAgICAgICBtYXJrVHlwZSxcbiAgICAgICAgbWFya0tleVxuICAgICAgfSA9IG5vZGUsXG4gICAgICBTcGFuID0gY29tcG9uZW50cy5tYXJrc1ttYXJrVHlwZV0gfHwgY29tcG9uZW50cy51bmtub3duTWFyayxcbiAgICAgIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAoKGNoaWxkLCBjaGlsZEluZGV4KSA9PiByZW5kZXJOb2RlKHtcbiAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgIGluZGV4OiBjaGlsZEluZGV4LFxuICAgICAgICBpc0lubGluZTogITAsXG4gICAgICAgIHJlbmRlck5vZGVcbiAgICAgIH0pKTtcbiAgICByZXR1cm4gU3BhbiA9PT0gY29tcG9uZW50cy51bmtub3duTWFyayAmJiBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25NYXJrV2FybmluZyhtYXJrVHlwZSksIHtcbiAgICAgIG5vZGVUeXBlOiBcIm1hcmtcIixcbiAgICAgIHR5cGU6IG1hcmtUeXBlXG4gICAgfSksIC8qIEBfX1BVUkVfXyAqL2pzeChTcGFuLCB7XG4gICAgICB0ZXh0OiBzcGFuVG9QbGFpblRleHQobm9kZSksXG4gICAgICB2YWx1ZTogbWFya0RlZixcbiAgICAgIG1hcmtUeXBlLFxuICAgICAgbWFya0tleSxcbiAgICAgIHJlbmRlck5vZGUsXG4gICAgICBjaGlsZHJlblxuICAgIH0sIGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyQmxvY2sobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpIHtcbiAgICBjb25zdCBfc2VyaWFsaXplQmxvY2sgPSBzZXJpYWxpemVCbG9jayh7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBpc0lubGluZSxcbiAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIF9rZXlcbiAgICAgIH0gPSBfc2VyaWFsaXplQmxvY2ssXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfc2VyaWFsaXplQmxvY2ssIF9leGNsdWRlZDMpLFxuICAgICAgc3R5bGUgPSBwcm9wcy5ub2RlLnN0eWxlIHx8IFwibm9ybWFsXCIsXG4gICAgICBCbG9jayA9ICh0eXBlb2YgY29tcG9uZW50cy5ibG9jayA9PSBcImZ1bmN0aW9uXCIgPyBjb21wb25lbnRzLmJsb2NrIDogY29tcG9uZW50cy5ibG9ja1tzdHlsZV0pIHx8IGNvbXBvbmVudHMudW5rbm93bkJsb2NrU3R5bGU7XG4gICAgcmV0dXJuIEJsb2NrID09PSBjb21wb25lbnRzLnVua25vd25CbG9ja1N0eWxlICYmIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bkJsb2NrU3R5bGVXYXJuaW5nKHN0eWxlKSwge1xuICAgICAgbm9kZVR5cGU6IFwiYmxvY2tTdHlsZVwiLFxuICAgICAgdHlwZTogc3R5bGVcbiAgICB9KSwgLyogQF9fUFVSRV9fICovanN4KEJsb2NrLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwge30sIHtcbiAgICAgIHZhbHVlOiBwcm9wcy5ub2RlLFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH0pLCBrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlclRleHQobm9kZSwga2V5KSB7XG4gICAgaWYgKG5vZGUudGV4dCA9PT0gYFxuYCkge1xuICAgICAgY29uc3QgSGFyZEJyZWFrID0gY29tcG9uZW50cy5oYXJkQnJlYWs7XG4gICAgICByZXR1cm4gSGFyZEJyZWFrID8gLyogQF9fUFVSRV9fICovanN4KEhhcmRCcmVhaywge30sIGtleSkgOiBgXG5gO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS50ZXh0O1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlclVua25vd25UeXBlKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKSB7XG4gICAgY29uc3Qgbm9kZU9wdGlvbnMgPSB7XG4gICAgICB2YWx1ZTogbm9kZSxcbiAgICAgIGlzSW5saW5lLFxuICAgICAgaW5kZXgsXG4gICAgICByZW5kZXJOb2RlXG4gICAgfTtcbiAgICBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25UeXBlV2FybmluZyhub2RlLl90eXBlKSwge1xuICAgICAgbm9kZVR5cGU6IFwiYmxvY2tcIixcbiAgICAgIHR5cGU6IG5vZGUuX3R5cGVcbiAgICB9KTtcbiAgICBjb25zdCBVbmtub3duVHlwZSA9IGNvbXBvbmVudHMudW5rbm93blR5cGU7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChVbmtub3duVHlwZSwgX29iamVjdFNwcmVhZCh7fSwgbm9kZU9wdGlvbnMpLCBrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckN1c3RvbUJsb2NrKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKSB7XG4gICAgY29uc3Qgbm9kZU9wdGlvbnMgPSB7XG4gICAgICAgIHZhbHVlOiBub2RlLFxuICAgICAgICBpc0lubGluZSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHJlbmRlck5vZGVcbiAgICAgIH0sXG4gICAgICBOb2RlID0gY29tcG9uZW50cy50eXBlc1tub2RlLl90eXBlXTtcbiAgICByZXR1cm4gTm9kZSA/IC8qIEBfX1BVUkVfXyAqL2pzeChOb2RlLCBfb2JqZWN0U3ByZWFkKHt9LCBub2RlT3B0aW9ucyksIGtleSkgOiBudWxsO1xuICB9XG4gIHJldHVybiByZW5kZXJOb2RlO1xufTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZUJsb2NrKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgICAgbm9kZSxcbiAgICAgIGluZGV4LFxuICAgICAgaXNJbmxpbmUsXG4gICAgICByZW5kZXJOb2RlXG4gICAgfSA9IG9wdGlvbnMsXG4gICAgY2hpbGRyZW4gPSBidWlsZE1hcmtzVHJlZShub2RlKS5tYXAoKGNoaWxkLCBpKSA9PiByZW5kZXJOb2RlKHtcbiAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgaXNJbmxpbmU6ICEwLFxuICAgICAgaW5kZXg6IGksXG4gICAgICByZW5kZXJOb2RlXG4gICAgfSkpO1xuICByZXR1cm4ge1xuICAgIF9rZXk6IG5vZGUuX2tleSB8fCBgYmxvY2stJHtpbmRleH1gLFxuICAgIGNoaWxkcmVuLFxuICAgIGluZGV4LFxuICAgIGlzSW5saW5lLFxuICAgIG5vZGVcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuZXhwb3J0IHsgUG9ydGFibGVUZXh0LCBkZWZhdWx0Q29tcG9uZW50cywgbWVyZ2VDb21wb25lbnRzLCB0b1BsYWluVGV4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/react/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/to-html/dist/pt-to-html.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@portabletext/to-html/dist/pt-to-html.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultComponents: () => (/* binding */ defaultComponents),\n/* harmony export */   escapeHTML: () => (/* binding */ escapeHTML),\n/* harmony export */   mergeComponents: () => (/* binding */ mergeComponents),\n/* harmony export */   toHTML: () => (/* binding */ toHTML),\n/* harmony export */   uriLooksSafe: () => (/* binding */ uriLooksSafe)\n/* harmony export */ });\n/* harmony import */ var _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @portabletext/toolkit */ \"(ssr)/./node_modules/@portabletext/toolkit/dist/index.js\");\nconst _excluded = [\"block\", \"list\", \"listItem\", \"marks\", \"types\"],\n  _excluded2 = [\"listItem\"],\n  _excluded3 = [\"_key\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\n\nconst defaultLists = {\n    number: ({\n      children\n    }) => `<ol>${children}</ol>`,\n    bullet: ({\n      children\n    }) => `<ul>${children}</ul>`\n  },\n  DefaultListItem = ({\n    children\n  }) => `<li>${children}</li>`,\n  allowedProtocols = [\"http\", \"https\", \"mailto\", \"tel\"],\n  charMap = {\n    \"&\": \"amp\",\n    \"<\": \"lt\",\n    \">\": \"gt\",\n    '\"': \"quot\",\n    \"'\": \"#x27\"\n  };\nfunction escapeHTML(str) {\n  return str.replace(/[&<>\"']/g, s => `&${charMap[s]};`);\n}\nfunction uriLooksSafe(uri) {\n  const url = (uri || \"\").trim(),\n    first = url.charAt(0);\n  if (first === \"#\" || first === \"/\") return !0;\n  const colonIndex = url.indexOf(\":\");\n  if (colonIndex === -1) return !0;\n  const proto = url.slice(0, colonIndex).toLowerCase();\n  if (allowedProtocols.indexOf(proto) !== -1) return !0;\n  const queryIndex = url.indexOf(\"?\");\n  if (queryIndex !== -1 && colonIndex > queryIndex) return !0;\n  const hashIndex = url.indexOf(\"#\");\n  return hashIndex !== -1 && colonIndex > hashIndex;\n}\nconst link = ({\n    children,\n    value\n  }) => {\n    const href = (value == null ? void 0 : value.href) || \"\";\n    return uriLooksSafe(href) ? `<a href=\"${escapeHTML(href)}\">${children}</a>` : children;\n  },\n  defaultMarks = {\n    em: ({\n      children\n    }) => `<em>${children}</em>`,\n    strong: ({\n      children\n    }) => `<strong>${children}</strong>`,\n    code: ({\n      children\n    }) => `<code>${children}</code>`,\n    underline: ({\n      children\n    }) => `<span style=\"text-decoration:underline\">${children}</span>`,\n    \"strike-through\": ({\n      children\n    }) => `<del>${children}</del>`,\n    link\n  },\n  getTemplate = (type, prop) => `Unknown ${type}, specify a component for it in the \\`components.${prop}\\` option`,\n  unknownTypeWarning = typeName => getTemplate(`block type \"${typeName}\"`, \"types\"),\n  unknownMarkWarning = markType => getTemplate(`mark type \"${markType}\"`, \"marks\"),\n  unknownBlockStyleWarning = blockStyle => getTemplate(`block style \"${blockStyle}\"`, \"block\"),\n  unknownListStyleWarning = listStyle => getTemplate(`list style \"${listStyle}\"`, \"list\"),\n  unknownListItemStyleWarning = listStyle => getTemplate(`list item style \"${listStyle}\"`, \"listItem\");\nfunction printWarning(message) {\n  console.warn(message);\n}\nconst DefaultUnknownType = ({\n    value,\n    isInline\n  }) => {\n    const warning = unknownTypeWarning(value._type);\n    return isInline ? `<span style=\"display:none\">${warning}</span>` : `<div style=\"display:none\">${warning}</div>`;\n  },\n  DefaultUnknownMark = ({\n    markType,\n    children\n  }) => `<span class=\"unknown__pt__mark__${markType}\">${children}</span>`,\n  DefaultUnknownBlockStyle = ({\n    children\n  }) => `<p>${children}</p>`,\n  DefaultUnknownList = ({\n    children\n  }) => `<ul>${children}</ul>`,\n  DefaultUnknownListItem = ({\n    children\n  }) => `<li>${children}</li>`,\n  DefaultHardBreak = () => \"<br/>\",\n  defaultPortableTextBlockStyles = {\n    normal: ({\n      children\n    }) => `<p>${children}</p>`,\n    blockquote: ({\n      children\n    }) => `<blockquote>${children}</blockquote>`,\n    h1: ({\n      children\n    }) => `<h1>${children}</h1>`,\n    h2: ({\n      children\n    }) => `<h2>${children}</h2>`,\n    h3: ({\n      children\n    }) => `<h3>${children}</h3>`,\n    h4: ({\n      children\n    }) => `<h4>${children}</h4>`,\n    h5: ({\n      children\n    }) => `<h5>${children}</h5>`,\n    h6: ({\n      children\n    }) => `<h6>${children}</h6>`\n  },\n  defaultComponents = {\n    types: {},\n    block: defaultPortableTextBlockStyles,\n    marks: defaultMarks,\n    list: defaultLists,\n    listItem: DefaultListItem,\n    hardBreak: DefaultHardBreak,\n    unknownType: DefaultUnknownType,\n    unknownMark: DefaultUnknownMark,\n    unknownList: DefaultUnknownList,\n    unknownListItem: DefaultUnknownListItem,\n    unknownBlockStyle: DefaultUnknownBlockStyle\n  };\nfunction mergeComponents(parent, overrides) {\n  const {\n      block,\n      list,\n      listItem,\n      marks,\n      types\n    } = overrides,\n    rest = _objectWithoutProperties(overrides, _excluded);\n  return _objectSpread(_objectSpread({}, parent), {}, {\n    block: mergeDeeply(parent, overrides, \"block\"),\n    list: mergeDeeply(parent, overrides, \"list\"),\n    listItem: mergeDeeply(parent, overrides, \"listItem\"),\n    marks: mergeDeeply(parent, overrides, \"marks\"),\n    types: mergeDeeply(parent, overrides, \"types\")\n  }, rest);\n}\nfunction mergeDeeply(parent, overrides, key) {\n  const override = overrides[key],\n    parentVal = parent[key];\n  return typeof override == \"function\" || override && typeof parentVal == \"function\" ? override : override ? _objectSpread(_objectSpread({}, parentVal), override) : parentVal;\n}\nfunction toHTML(value, options = {}) {\n  const {\n      components: componentOverrides,\n      onMissingComponent: missingComponentHandler = printWarning\n    } = options,\n    handleMissingComponent = missingComponentHandler || noop,\n    blocks = Array.isArray(value) ? value : [value],\n    nested = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.nestLists)(blocks, \"html\"),\n    components = componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents,\n    renderNode = getNodeRenderer(components, handleMissingComponent);\n  return nested.map((node, index) => renderNode({\n    node,\n    index,\n    isInline: !1,\n    renderNode\n  })).join(\"\");\n}\nconst getNodeRenderer = (components, handleMissingComponent) => {\n  function renderNode(options) {\n    const {\n      node,\n      index,\n      isInline\n    } = options;\n    return (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextToolkitList)(node) ? renderList(node, index) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextListItemBlock)(node) ? renderListItem(node, index) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextToolkitSpan)(node) ? renderSpan(node) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextBlock)(node) ? renderBlock(node, index, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextToolkitTextNode)(node) ? renderText(node) : renderCustomBlock(node, index, isInline);\n  }\n  function renderListItem(node, index) {\n    const tree = serializeBlock({\n        node,\n        index,\n        isInline: !1,\n        renderNode\n      }),\n      renderer = components.listItem,\n      itemHandler = (typeof renderer == \"function\" ? renderer : renderer[node.listItem]) || components.unknownListItem;\n    if (itemHandler === components.unknownListItem) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: \"listItemStyle\"\n      });\n    }\n    let children = tree.children;\n    if (node.style && node.style !== \"normal\") {\n      const {\n          listItem\n        } = node,\n        blockNode = _objectWithoutProperties(node, _excluded2);\n      children = renderNode({\n        node: blockNode,\n        index,\n        isInline: !1,\n        renderNode\n      });\n    }\n    return itemHandler({\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children\n    });\n  }\n  function renderList(node, index) {\n    const children = node.children.map((child, childIndex) => renderNode({\n        node: child._key ? child : _objectSpread(_objectSpread({}, child), {}, {\n          _key: `li-${index}-${childIndex}`\n        }),\n        index,\n        isInline: !1,\n        renderNode\n      })),\n      component = components.list,\n      list = (typeof component == \"function\" ? component : component[node.listItem]) || components.unknownList;\n    if (list === components.unknownList) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListStyleWarning(style), {\n        nodeType: \"listStyle\",\n        type: style\n      });\n    }\n    return list({\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children: children.join(\"\")\n    });\n  }\n  function renderSpan(node) {\n    const {\n        markDef,\n        markType,\n        markKey\n      } = node,\n      span = components.marks[markType] || components.unknownMark,\n      children = node.children.map((child, childIndex) => renderNode({\n        node: child,\n        index: childIndex,\n        isInline: !0,\n        renderNode\n      }));\n    return span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), {\n      nodeType: \"mark\",\n      type: markType\n    }), span({\n      text: (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.spanToPlainText)(node),\n      value: markDef,\n      markType,\n      markKey,\n      renderNode,\n      children: children.join(\"\")\n    });\n  }\n  function renderBlock(node, index, isInline) {\n    const _serializeBlock = serializeBlock({\n        node,\n        index,\n        isInline,\n        renderNode\n      }),\n      {\n        _key\n      } = _serializeBlock,\n      props = _objectWithoutProperties(_serializeBlock, _excluded3),\n      style = props.node.style || \"normal\",\n      block = (typeof components.block == \"function\" ? components.block : components.block[style]) || components.unknownBlockStyle;\n    return block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {\n      nodeType: \"blockStyle\",\n      type: style\n    }), block(_objectSpread(_objectSpread({}, props), {}, {\n      value: props.node,\n      renderNode\n    }));\n  }\n  function renderText(node) {\n    if (node.text === `\n`) {\n      const hardBreak = components.hardBreak;\n      return hardBreak ? hardBreak() : `\n`;\n    }\n    return escapeHTML(node.text);\n  }\n  function renderCustomBlock(value, index, isInline) {\n    const node = components.types[value._type];\n    return node || handleMissingComponent(unknownTypeWarning(value._type), {\n      nodeType: \"block\",\n      type: value._type\n    }), (node || components.unknownType)({\n      value,\n      isInline,\n      index,\n      renderNode\n    });\n  }\n  return renderNode;\n};\nfunction serializeBlock(options) {\n  const {\n      node,\n      index,\n      isInline,\n      renderNode\n    } = options,\n    children = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.buildMarksTree)(node).map((child, i) => renderNode({\n      node: child,\n      isInline: !0,\n      index: i,\n      renderNode\n    }));\n  return {\n    _key: node._key || `block-${index}`,\n    children: children.join(\"\"),\n    index,\n    isInline,\n    node\n  };\n}\nfunction noop() {}\n\n//# sourceMappingURL=pt-to-html.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90by1odG1sL2Rpc3QvcHQtdG8taHRtbC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3BQLDRCQUE0QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQzVhLG9DQUFvQyxvRUFBb0UsMERBQTBEO0FBQ2xLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDBDQUEwQywrQkFBK0Isb0JBQW9CLG1DQUFtQyxvQ0FBb0MsdUVBQXVFO0FBQ3pRLDBDQUEwQywwQkFBMEIsbURBQW1ELG9DQUFvQyx5Q0FBeUMsWUFBWSxjQUFjLHNDQUFzQyxxREFBcUQ7QUFDelQsK0NBQStDLDBCQUEwQixZQUFZLHVCQUF1Qiw4QkFBOEIsaUNBQWlDLGVBQWU7QUFDZ0M7QUFDMU47QUFDQTtBQUNBO0FBQ0EsS0FBSyxZQUFZLFNBQVM7QUFDMUI7QUFDQTtBQUNBLEtBQUssWUFBWSxTQUFTO0FBQzFCLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRyxZQUFZLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDRDQUE0QyxpQkFBaUIsSUFBSSxTQUFTO0FBQzFFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLLFlBQVksU0FBUztBQUMxQjtBQUNBO0FBQ0EsS0FBSyxnQkFBZ0IsU0FBUztBQUM5QjtBQUNBO0FBQ0EsS0FBSyxjQUFjLFNBQVM7QUFDNUI7QUFDQTtBQUNBLEtB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QUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGVBQWUscUVBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRjtBQUNoRiIsInNvdXJjZXMiOlsiL1VzZXJzL21hY2Jvb2twcm8vRG93bmxvYWRzL2NvbmljYXBwcy9pZ2VuZS9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90by1odG1sL2Rpc3QvcHQtdG8taHRtbC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgX2V4Y2x1ZGVkID0gW1wiYmxvY2tcIiwgXCJsaXN0XCIsIFwibGlzdEl0ZW1cIiwgXCJtYXJrc1wiLCBcInR5cGVzXCJdLFxuICBfZXhjbHVkZWQyID0gW1wibGlzdEl0ZW1cIl0sXG4gIF9leGNsdWRlZDMgPSBbXCJfa2V5XCJdO1xuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZSwgdCkgeyBpZiAobnVsbCA9PSBlKSByZXR1cm4ge307IHZhciBvLCByLCBpID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoZSwgdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBuID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgZm9yIChyID0gMDsgciA8IG4ubGVuZ3RoOyByKyspIG8gPSBuW3JdLCB0LmluZGV4T2YobykgPj0gMCB8fCB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIG8pICYmIChpW29dID0gZVtvXSk7IH0gcmV0dXJuIGk7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHIsIGUpIHsgaWYgKG51bGwgPT0gcikgcmV0dXJuIHt9OyB2YXIgdCA9IHt9OyBmb3IgKHZhciBuIGluIHIpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsIG4pKSB7IGlmIChlLmluZGV4T2YobikgPj0gMCkgY29udGludWU7IHRbbl0gPSByW25dOyB9IHJldHVybiB0OyB9XG5pbXBvcnQgeyBuZXN0TGlzdHMsIGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3QsIGlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jaywgaXNQb3J0YWJsZVRleHRUb29sa2l0U3BhbiwgaXNQb3J0YWJsZVRleHRCbG9jaywgaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUsIHNwYW5Ub1BsYWluVGV4dCwgYnVpbGRNYXJrc1RyZWUgfSBmcm9tIFwiQHBvcnRhYmxldGV4dC90b29sa2l0XCI7XG5jb25zdCBkZWZhdWx0TGlzdHMgPSB7XG4gICAgbnVtYmVyOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiBgPG9sPiR7Y2hpbGRyZW59PC9vbD5gLFxuICAgIGJ1bGxldDogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gYDx1bD4ke2NoaWxkcmVufTwvdWw+YFxuICB9LFxuICBEZWZhdWx0TGlzdEl0ZW0gPSAoe1xuICAgIGNoaWxkcmVuXG4gIH0pID0+IGA8bGk+JHtjaGlsZHJlbn08L2xpPmAsXG4gIGFsbG93ZWRQcm90b2NvbHMgPSBbXCJodHRwXCIsIFwiaHR0cHNcIiwgXCJtYWlsdG9cIiwgXCJ0ZWxcIl0sXG4gIGNoYXJNYXAgPSB7XG4gICAgXCImXCI6IFwiYW1wXCIsXG4gICAgXCI8XCI6IFwibHRcIixcbiAgICBcIj5cIjogXCJndFwiLFxuICAgICdcIic6IFwicXVvdFwiLFxuICAgIFwiJ1wiOiBcIiN4MjdcIlxuICB9O1xuZnVuY3Rpb24gZXNjYXBlSFRNTChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bJjw+XCInXS9nLCBzID0+IGAmJHtjaGFyTWFwW3NdfTtgKTtcbn1cbmZ1bmN0aW9uIHVyaUxvb2tzU2FmZSh1cmkpIHtcbiAgY29uc3QgdXJsID0gKHVyaSB8fCBcIlwiKS50cmltKCksXG4gICAgZmlyc3QgPSB1cmwuY2hhckF0KDApO1xuICBpZiAoZmlyc3QgPT09IFwiI1wiIHx8IGZpcnN0ID09PSBcIi9cIikgcmV0dXJuICEwO1xuICBjb25zdCBjb2xvbkluZGV4ID0gdXJsLmluZGV4T2YoXCI6XCIpO1xuICBpZiAoY29sb25JbmRleCA9PT0gLTEpIHJldHVybiAhMDtcbiAgY29uc3QgcHJvdG8gPSB1cmwuc2xpY2UoMCwgY29sb25JbmRleCkudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGFsbG93ZWRQcm90b2NvbHMuaW5kZXhPZihwcm90bykgIT09IC0xKSByZXR1cm4gITA7XG4gIGNvbnN0IHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZihcIj9cIik7XG4gIGlmIChxdWVyeUluZGV4ICE9PSAtMSAmJiBjb2xvbkluZGV4ID4gcXVlcnlJbmRleCkgcmV0dXJuICEwO1xuICBjb25zdCBoYXNoSW5kZXggPSB1cmwuaW5kZXhPZihcIiNcIik7XG4gIHJldHVybiBoYXNoSW5kZXggIT09IC0xICYmIGNvbG9uSW5kZXggPiBoYXNoSW5kZXg7XG59XG5jb25zdCBsaW5rID0gKHtcbiAgICBjaGlsZHJlbixcbiAgICB2YWx1ZVxuICB9KSA9PiB7XG4gICAgY29uc3QgaHJlZiA9ICh2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWUuaHJlZikgfHwgXCJcIjtcbiAgICByZXR1cm4gdXJpTG9va3NTYWZlKGhyZWYpID8gYDxhIGhyZWY9XCIke2VzY2FwZUhUTUwoaHJlZil9XCI+JHtjaGlsZHJlbn08L2E+YCA6IGNoaWxkcmVuO1xuICB9LFxuICBkZWZhdWx0TWFya3MgPSB7XG4gICAgZW06ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IGA8ZW0+JHtjaGlsZHJlbn08L2VtPmAsXG4gICAgc3Ryb25nOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiBgPHN0cm9uZz4ke2NoaWxkcmVufTwvc3Ryb25nPmAsXG4gICAgY29kZTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gYDxjb2RlPiR7Y2hpbGRyZW59PC9jb2RlPmAsXG4gICAgdW5kZXJsaW5lOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiBgPHNwYW4gc3R5bGU9XCJ0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lXCI+JHtjaGlsZHJlbn08L3NwYW4+YCxcbiAgICBcInN0cmlrZS10aHJvdWdoXCI6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IGA8ZGVsPiR7Y2hpbGRyZW59PC9kZWw+YCxcbiAgICBsaW5rXG4gIH0sXG4gIGdldFRlbXBsYXRlID0gKHR5cGUsIHByb3ApID0+IGBVbmtub3duICR7dHlwZX0sIHNwZWNpZnkgYSBjb21wb25lbnQgZm9yIGl0IGluIHRoZSBcXGBjb21wb25lbnRzLiR7cHJvcH1cXGAgb3B0aW9uYCxcbiAgdW5rbm93blR5cGVXYXJuaW5nID0gdHlwZU5hbWUgPT4gZ2V0VGVtcGxhdGUoYGJsb2NrIHR5cGUgXCIke3R5cGVOYW1lfVwiYCwgXCJ0eXBlc1wiKSxcbiAgdW5rbm93bk1hcmtXYXJuaW5nID0gbWFya1R5cGUgPT4gZ2V0VGVtcGxhdGUoYG1hcmsgdHlwZSBcIiR7bWFya1R5cGV9XCJgLCBcIm1hcmtzXCIpLFxuICB1bmtub3duQmxvY2tTdHlsZVdhcm5pbmcgPSBibG9ja1N0eWxlID0+IGdldFRlbXBsYXRlKGBibG9jayBzdHlsZSBcIiR7YmxvY2tTdHlsZX1cImAsIFwiYmxvY2tcIiksXG4gIHVua25vd25MaXN0U3R5bGVXYXJuaW5nID0gbGlzdFN0eWxlID0+IGdldFRlbXBsYXRlKGBsaXN0IHN0eWxlIFwiJHtsaXN0U3R5bGV9XCJgLCBcImxpc3RcIiksXG4gIHVua25vd25MaXN0SXRlbVN0eWxlV2FybmluZyA9IGxpc3RTdHlsZSA9PiBnZXRUZW1wbGF0ZShgbGlzdCBpdGVtIHN0eWxlIFwiJHtsaXN0U3R5bGV9XCJgLCBcImxpc3RJdGVtXCIpO1xuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKG1lc3NhZ2UpIHtcbiAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xufVxuY29uc3QgRGVmYXVsdFVua25vd25UeXBlID0gKHtcbiAgICB2YWx1ZSxcbiAgICBpc0lubGluZVxuICB9KSA9PiB7XG4gICAgY29uc3Qgd2FybmluZyA9IHVua25vd25UeXBlV2FybmluZyh2YWx1ZS5fdHlwZSk7XG4gICAgcmV0dXJuIGlzSW5saW5lID8gYDxzcGFuIHN0eWxlPVwiZGlzcGxheTpub25lXCI+JHt3YXJuaW5nfTwvc3Bhbj5gIDogYDxkaXYgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIj4ke3dhcm5pbmd9PC9kaXY+YDtcbiAgfSxcbiAgRGVmYXVsdFVua25vd25NYXJrID0gKHtcbiAgICBtYXJrVHlwZSxcbiAgICBjaGlsZHJlblxuICB9KSA9PiBgPHNwYW4gY2xhc3M9XCJ1bmtub3duX19wdF9fbWFya19fJHttYXJrVHlwZX1cIj4ke2NoaWxkcmVufTwvc3Bhbj5gLFxuICBEZWZhdWx0VW5rbm93bkJsb2NrU3R5bGUgPSAoe1xuICAgIGNoaWxkcmVuXG4gIH0pID0+IGA8cD4ke2NoaWxkcmVufTwvcD5gLFxuICBEZWZhdWx0VW5rbm93bkxpc3QgPSAoe1xuICAgIGNoaWxkcmVuXG4gIH0pID0+IGA8dWw+JHtjaGlsZHJlbn08L3VsPmAsXG4gIERlZmF1bHRVbmtub3duTGlzdEl0ZW0gPSAoe1xuICAgIGNoaWxkcmVuXG4gIH0pID0+IGA8bGk+JHtjaGlsZHJlbn08L2xpPmAsXG4gIERlZmF1bHRIYXJkQnJlYWsgPSAoKSA9PiBcIjxici8+XCIsXG4gIGRlZmF1bHRQb3J0YWJsZVRleHRCbG9ja1N0eWxlcyA9IHtcbiAgICBub3JtYWw6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IGA8cD4ke2NoaWxkcmVufTwvcD5gLFxuICAgIGJsb2NrcXVvdGU6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IGA8YmxvY2txdW90ZT4ke2NoaWxkcmVufTwvYmxvY2txdW90ZT5gLFxuICAgIGgxOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiBgPGgxPiR7Y2hpbGRyZW59PC9oMT5gLFxuICAgIGgyOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiBgPGgyPiR7Y2hpbGRyZW59PC9oMj5gLFxuICAgIGgzOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiBgPGgzPiR7Y2hpbGRyZW59PC9oMz5gLFxuICAgIGg0OiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiBgPGg0PiR7Y2hpbGRyZW59PC9oND5gLFxuICAgIGg1OiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiBgPGg1PiR7Y2hpbGRyZW59PC9oNT5gLFxuICAgIGg2OiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiBgPGg2PiR7Y2hpbGRyZW59PC9oNj5gXG4gIH0sXG4gIGRlZmF1bHRDb21wb25lbnRzID0ge1xuICAgIHR5cGVzOiB7fSxcbiAgICBibG9jazogZGVmYXVsdFBvcnRhYmxlVGV4dEJsb2NrU3R5bGVzLFxuICAgIG1hcmtzOiBkZWZhdWx0TWFya3MsXG4gICAgbGlzdDogZGVmYXVsdExpc3RzLFxuICAgIGxpc3RJdGVtOiBEZWZhdWx0TGlzdEl0ZW0sXG4gICAgaGFyZEJyZWFrOiBEZWZhdWx0SGFyZEJyZWFrLFxuICAgIHVua25vd25UeXBlOiBEZWZhdWx0VW5rbm93blR5cGUsXG4gICAgdW5rbm93bk1hcms6IERlZmF1bHRVbmtub3duTWFyayxcbiAgICB1bmtub3duTGlzdDogRGVmYXVsdFVua25vd25MaXN0LFxuICAgIHVua25vd25MaXN0SXRlbTogRGVmYXVsdFVua25vd25MaXN0SXRlbSxcbiAgICB1bmtub3duQmxvY2tTdHlsZTogRGVmYXVsdFVua25vd25CbG9ja1N0eWxlXG4gIH07XG5mdW5jdGlvbiBtZXJnZUNvbXBvbmVudHMocGFyZW50LCBvdmVycmlkZXMpIHtcbiAgY29uc3Qge1xuICAgICAgYmxvY2ssXG4gICAgICBsaXN0LFxuICAgICAgbGlzdEl0ZW0sXG4gICAgICBtYXJrcyxcbiAgICAgIHR5cGVzXG4gICAgfSA9IG92ZXJyaWRlcyxcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG92ZXJyaWRlcywgX2V4Y2x1ZGVkKTtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGFyZW50KSwge30sIHtcbiAgICBibG9jazogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwiYmxvY2tcIiksXG4gICAgbGlzdDogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwibGlzdFwiKSxcbiAgICBsaXN0SXRlbTogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwibGlzdEl0ZW1cIiksXG4gICAgbWFya3M6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcIm1hcmtzXCIpLFxuICAgIHR5cGVzOiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJ0eXBlc1wiKVxuICB9LCByZXN0KTtcbn1cbmZ1bmN0aW9uIG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBrZXkpIHtcbiAgY29uc3Qgb3ZlcnJpZGUgPSBvdmVycmlkZXNba2V5XSxcbiAgICBwYXJlbnRWYWwgPSBwYXJlbnRba2V5XTtcbiAgcmV0dXJuIHR5cGVvZiBvdmVycmlkZSA9PSBcImZ1bmN0aW9uXCIgfHwgb3ZlcnJpZGUgJiYgdHlwZW9mIHBhcmVudFZhbCA9PSBcImZ1bmN0aW9uXCIgPyBvdmVycmlkZSA6IG92ZXJyaWRlID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwYXJlbnRWYWwpLCBvdmVycmlkZSkgOiBwYXJlbnRWYWw7XG59XG5mdW5jdGlvbiB0b0hUTUwodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgICBjb21wb25lbnRzOiBjb21wb25lbnRPdmVycmlkZXMsXG4gICAgICBvbk1pc3NpbmdDb21wb25lbnQ6IG1pc3NpbmdDb21wb25lbnRIYW5kbGVyID0gcHJpbnRXYXJuaW5nXG4gICAgfSA9IG9wdGlvbnMsXG4gICAgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCA9IG1pc3NpbmdDb21wb25lbnRIYW5kbGVyIHx8IG5vb3AsXG4gICAgYmxvY2tzID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0sXG4gICAgbmVzdGVkID0gbmVzdExpc3RzKGJsb2NrcywgXCJodG1sXCIpLFxuICAgIGNvbXBvbmVudHMgPSBjb21wb25lbnRPdmVycmlkZXMgPyBtZXJnZUNvbXBvbmVudHMoZGVmYXVsdENvbXBvbmVudHMsIGNvbXBvbmVudE92ZXJyaWRlcykgOiBkZWZhdWx0Q29tcG9uZW50cyxcbiAgICByZW5kZXJOb2RlID0gZ2V0Tm9kZVJlbmRlcmVyKGNvbXBvbmVudHMsIGhhbmRsZU1pc3NpbmdDb21wb25lbnQpO1xuICByZXR1cm4gbmVzdGVkLm1hcCgobm9kZSwgaW5kZXgpID0+IHJlbmRlck5vZGUoe1xuICAgIG5vZGUsXG4gICAgaW5kZXgsXG4gICAgaXNJbmxpbmU6ICExLFxuICAgIHJlbmRlck5vZGVcbiAgfSkpLmpvaW4oXCJcIik7XG59XG5jb25zdCBnZXROb2RlUmVuZGVyZXIgPSAoY29tcG9uZW50cywgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCkgPT4ge1xuICBmdW5jdGlvbiByZW5kZXJOb2RlKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBub2RlLFxuICAgICAgaW5kZXgsXG4gICAgICBpc0lubGluZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0KG5vZGUpID8gcmVuZGVyTGlzdChub2RlLCBpbmRleCkgOiBpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2sobm9kZSkgPyByZW5kZXJMaXN0SXRlbShub2RlLCBpbmRleCkgOiBpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuKG5vZGUpID8gcmVuZGVyU3Bhbihub2RlKSA6IGlzUG9ydGFibGVUZXh0QmxvY2sobm9kZSkgPyByZW5kZXJCbG9jayhub2RlLCBpbmRleCwgaXNJbmxpbmUpIDogaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUobm9kZSkgPyByZW5kZXJUZXh0KG5vZGUpIDogcmVuZGVyQ3VzdG9tQmxvY2sobm9kZSwgaW5kZXgsIGlzSW5saW5lKTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJMaXN0SXRlbShub2RlLCBpbmRleCkge1xuICAgIGNvbnN0IHRyZWUgPSBzZXJpYWxpemVCbG9jayh7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBpc0lubGluZTogITEsXG4gICAgICAgIHJlbmRlck5vZGVcbiAgICAgIH0pLFxuICAgICAgcmVuZGVyZXIgPSBjb21wb25lbnRzLmxpc3RJdGVtLFxuICAgICAgaXRlbUhhbmRsZXIgPSAodHlwZW9mIHJlbmRlcmVyID09IFwiZnVuY3Rpb25cIiA/IHJlbmRlcmVyIDogcmVuZGVyZXJbbm9kZS5saXN0SXRlbV0pIHx8IGNvbXBvbmVudHMudW5rbm93bkxpc3RJdGVtO1xuICAgIGlmIChpdGVtSGFuZGxlciA9PT0gY29tcG9uZW50cy51bmtub3duTGlzdEl0ZW0pIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gbm9kZS5saXN0SXRlbSB8fCBcImJ1bGxldFwiO1xuICAgICAgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duTGlzdEl0ZW1TdHlsZVdhcm5pbmcoc3R5bGUpLCB7XG4gICAgICAgIHR5cGU6IHN0eWxlLFxuICAgICAgICBub2RlVHlwZTogXCJsaXN0SXRlbVN0eWxlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgY2hpbGRyZW4gPSB0cmVlLmNoaWxkcmVuO1xuICAgIGlmIChub2RlLnN0eWxlICYmIG5vZGUuc3R5bGUgIT09IFwibm9ybWFsXCIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgICBsaXN0SXRlbVxuICAgICAgICB9ID0gbm9kZSxcbiAgICAgICAgYmxvY2tOb2RlID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZDIpO1xuICAgICAgY2hpbGRyZW4gPSByZW5kZXJOb2RlKHtcbiAgICAgICAgbm9kZTogYmxvY2tOb2RlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1IYW5kbGVyKHtcbiAgICAgIHZhbHVlOiBub2RlLFxuICAgICAgaW5kZXgsXG4gICAgICBpc0lubGluZTogITEsXG4gICAgICByZW5kZXJOb2RlLFxuICAgICAgY2hpbGRyZW5cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJMaXN0KG5vZGUsIGluZGV4KSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcCgoY2hpbGQsIGNoaWxkSW5kZXgpID0+IHJlbmRlck5vZGUoe1xuICAgICAgICBub2RlOiBjaGlsZC5fa2V5ID8gY2hpbGQgOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNoaWxkKSwge30sIHtcbiAgICAgICAgICBfa2V5OiBgbGktJHtpbmRleH0tJHtjaGlsZEluZGV4fWBcbiAgICAgICAgfSksXG4gICAgICAgIGluZGV4LFxuICAgICAgICBpc0lubGluZTogITEsXG4gICAgICAgIHJlbmRlck5vZGVcbiAgICAgIH0pKSxcbiAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHMubGlzdCxcbiAgICAgIGxpc3QgPSAodHlwZW9mIGNvbXBvbmVudCA9PSBcImZ1bmN0aW9uXCIgPyBjb21wb25lbnQgOiBjb21wb25lbnRbbm9kZS5saXN0SXRlbV0pIHx8IGNvbXBvbmVudHMudW5rbm93bkxpc3Q7XG4gICAgaWYgKGxpc3QgPT09IGNvbXBvbmVudHMudW5rbm93bkxpc3QpIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gbm9kZS5saXN0SXRlbSB8fCBcImJ1bGxldFwiO1xuICAgICAgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duTGlzdFN0eWxlV2FybmluZyhzdHlsZSksIHtcbiAgICAgICAgbm9kZVR5cGU6IFwibGlzdFN0eWxlXCIsXG4gICAgICAgIHR5cGU6IHN0eWxlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Qoe1xuICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICBpbmRleCxcbiAgICAgIGlzSW5saW5lOiAhMSxcbiAgICAgIHJlbmRlck5vZGUsXG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4uam9pbihcIlwiKVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlclNwYW4obm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgICAgbWFya0RlZixcbiAgICAgICAgbWFya1R5cGUsXG4gICAgICAgIG1hcmtLZXlcbiAgICAgIH0gPSBub2RlLFxuICAgICAgc3BhbiA9IGNvbXBvbmVudHMubWFya3NbbWFya1R5cGVdIHx8IGNvbXBvbmVudHMudW5rbm93bk1hcmssXG4gICAgICBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4ubWFwKChjaGlsZCwgY2hpbGRJbmRleCkgPT4gcmVuZGVyTm9kZSh7XG4gICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICBpbmRleDogY2hpbGRJbmRleCxcbiAgICAgICAgaXNJbmxpbmU6ICEwLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KSk7XG4gICAgcmV0dXJuIHNwYW4gPT09IGNvbXBvbmVudHMudW5rbm93bk1hcmsgJiYgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duTWFya1dhcm5pbmcobWFya1R5cGUpLCB7XG4gICAgICBub2RlVHlwZTogXCJtYXJrXCIsXG4gICAgICB0eXBlOiBtYXJrVHlwZVxuICAgIH0pLCBzcGFuKHtcbiAgICAgIHRleHQ6IHNwYW5Ub1BsYWluVGV4dChub2RlKSxcbiAgICAgIHZhbHVlOiBtYXJrRGVmLFxuICAgICAgbWFya1R5cGUsXG4gICAgICBtYXJrS2V5LFxuICAgICAgcmVuZGVyTm9kZSxcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbi5qb2luKFwiXCIpXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyQmxvY2sobm9kZSwgaW5kZXgsIGlzSW5saW5lKSB7XG4gICAgY29uc3QgX3NlcmlhbGl6ZUJsb2NrID0gc2VyaWFsaXplQmxvY2soe1xuICAgICAgICBub2RlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaXNJbmxpbmUsXG4gICAgICAgIHJlbmRlck5vZGVcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICBfa2V5XG4gICAgICB9ID0gX3NlcmlhbGl6ZUJsb2NrLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3NlcmlhbGl6ZUJsb2NrLCBfZXhjbHVkZWQzKSxcbiAgICAgIHN0eWxlID0gcHJvcHMubm9kZS5zdHlsZSB8fCBcIm5vcm1hbFwiLFxuICAgICAgYmxvY2sgPSAodHlwZW9mIGNvbXBvbmVudHMuYmxvY2sgPT0gXCJmdW5jdGlvblwiID8gY29tcG9uZW50cy5ibG9jayA6IGNvbXBvbmVudHMuYmxvY2tbc3R5bGVdKSB8fCBjb21wb25lbnRzLnVua25vd25CbG9ja1N0eWxlO1xuICAgIHJldHVybiBibG9jayA9PT0gY29tcG9uZW50cy51bmtub3duQmxvY2tTdHlsZSAmJiBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25CbG9ja1N0eWxlV2FybmluZyhzdHlsZSksIHtcbiAgICAgIG5vZGVUeXBlOiBcImJsb2NrU3R5bGVcIixcbiAgICAgIHR5cGU6IHN0eWxlXG4gICAgfSksIGJsb2NrKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgICAgdmFsdWU6IHByb3BzLm5vZGUsXG4gICAgICByZW5kZXJOb2RlXG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlclRleHQobm9kZSkge1xuICAgIGlmIChub2RlLnRleHQgPT09IGBcbmApIHtcbiAgICAgIGNvbnN0IGhhcmRCcmVhayA9IGNvbXBvbmVudHMuaGFyZEJyZWFrO1xuICAgICAgcmV0dXJuIGhhcmRCcmVhayA/IGhhcmRCcmVhaygpIDogYFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIGVzY2FwZUhUTUwobm9kZS50ZXh0KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJDdXN0b21CbG9jayh2YWx1ZSwgaW5kZXgsIGlzSW5saW5lKSB7XG4gICAgY29uc3Qgbm9kZSA9IGNvbXBvbmVudHMudHlwZXNbdmFsdWUuX3R5cGVdO1xuICAgIHJldHVybiBub2RlIHx8IGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93blR5cGVXYXJuaW5nKHZhbHVlLl90eXBlKSwge1xuICAgICAgbm9kZVR5cGU6IFwiYmxvY2tcIixcbiAgICAgIHR5cGU6IHZhbHVlLl90eXBlXG4gICAgfSksIChub2RlIHx8IGNvbXBvbmVudHMudW5rbm93blR5cGUpKHtcbiAgICAgIHZhbHVlLFxuICAgICAgaXNJbmxpbmUsXG4gICAgICBpbmRleCxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVuZGVyTm9kZTtcbn07XG5mdW5jdGlvbiBzZXJpYWxpemVCbG9jayhvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICAgIG5vZGUsXG4gICAgICBpbmRleCxcbiAgICAgIGlzSW5saW5lLFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH0gPSBvcHRpb25zLFxuICAgIGNoaWxkcmVuID0gYnVpbGRNYXJrc1RyZWUobm9kZSkubWFwKChjaGlsZCwgaSkgPT4gcmVuZGVyTm9kZSh7XG4gICAgICBub2RlOiBjaGlsZCxcbiAgICAgIGlzSW5saW5lOiAhMCxcbiAgICAgIGluZGV4OiBpLFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH0pKTtcbiAgcmV0dXJuIHtcbiAgICBfa2V5OiBub2RlLl9rZXkgfHwgYGJsb2NrLSR7aW5kZXh9YCxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4uam9pbihcIlwiKSxcbiAgICBpbmRleCxcbiAgICBpc0lubGluZSxcbiAgICBub2RlXG4gIH07XG59XG5mdW5jdGlvbiBub29wKCkge31cbmV4cG9ydCB7IGRlZmF1bHRDb21wb25lbnRzLCBlc2NhcGVIVE1MLCBtZXJnZUNvbXBvbmVudHMsIHRvSFRNTCwgdXJpTG9va3NTYWZlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdC10by1odG1sLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/to-html/dist/pt-to-html.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/toolkit/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@portabletext/toolkit/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LIST_NEST_MODE_DIRECT: () => (/* binding */ LIST_NEST_MODE_DIRECT),\n/* harmony export */   LIST_NEST_MODE_HTML: () => (/* binding */ LIST_NEST_MODE_HTML),\n/* harmony export */   buildMarksTree: () => (/* binding */ buildMarksTree),\n/* harmony export */   isPortableTextBlock: () => (/* binding */ isPortableTextBlock),\n/* harmony export */   isPortableTextListItemBlock: () => (/* binding */ isPortableTextListItemBlock),\n/* harmony export */   isPortableTextSpan: () => (/* binding */ isPortableTextSpan),\n/* harmony export */   isPortableTextToolkitList: () => (/* binding */ isPortableTextToolkitList),\n/* harmony export */   isPortableTextToolkitSpan: () => (/* binding */ isPortableTextToolkitSpan),\n/* harmony export */   isPortableTextToolkitTextNode: () => (/* binding */ isPortableTextToolkitTextNode),\n/* harmony export */   nestLists: () => (/* binding */ nestLists),\n/* harmony export */   sortMarksByOccurences: () => (/* binding */ sortMarksByOccurences),\n/* harmony export */   spanToPlainText: () => (/* binding */ spanToPlainText),\n/* harmony export */   toPlainText: () => (/* binding */ toPlainText)\n/* harmony export */ });\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction isPortableTextSpan(node) {\n  return node._type === \"span\" && \"text\" in node && typeof node.text == \"string\" && (typeof node.marks > \"u\" || Array.isArray(node.marks) && node.marks.every(mark => typeof mark == \"string\"));\n}\nfunction isPortableTextBlock(node) {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type == \"string\" &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== \"@\" && (\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    !(\"markDefs\" in node) || !node.markDefs || Array.isArray(node.markDefs) &&\n    // Every mark definition needs to have an `_key` to be mappable in child spans\n    node.markDefs.every(def => typeof def._key == \"string\")) &&\n    // `children` is required and needs to be an array\n    \"children\" in node && Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every(child => typeof child == \"object\" && \"_type\" in child)\n  );\n}\nfunction isPortableTextListItemBlock(block) {\n  return isPortableTextBlock(block) && \"listItem\" in block && typeof block.listItem == \"string\" && (typeof block.level > \"u\" || typeof block.level == \"number\");\n}\nfunction isPortableTextToolkitList(block) {\n  return block._type === \"@list\";\n}\nfunction isPortableTextToolkitSpan(span) {\n  return span._type === \"@span\";\n}\nfunction isPortableTextToolkitTextNode(node) {\n  return node._type === \"@text\";\n}\nconst knownDecorators = [\"strong\", \"em\", \"code\", \"underline\", \"strike-through\"];\nfunction sortMarksByOccurences(span, index, blockChildren) {\n  if (!isPortableTextSpan(span) || !span.marks) return [];\n  if (!span.marks.length) return [];\n  const marks = span.marks.slice(),\n    occurences = {};\n  return marks.forEach(mark => {\n    occurences[mark] = 1;\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex];\n      if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) occurences[mark]++;else break;\n    }\n  }), marks.sort((markA, markB) => sortMarks(occurences, markA, markB));\n}\nfunction sortMarks(occurences, markA, markB) {\n  const aOccurences = occurences[markA],\n    bOccurences = occurences[markB];\n  if (aOccurences !== bOccurences) return bOccurences - aOccurences;\n  const aKnownPos = knownDecorators.indexOf(markA),\n    bKnownPos = knownDecorators.indexOf(markB);\n  return aKnownPos !== bKnownPos ? aKnownPos - bKnownPos : markA.localeCompare(markB);\n}\nfunction buildMarksTree(block) {\n  var _a, _b;\n  const {\n      children\n    } = block,\n    markDefs = (_a = block.markDefs) != null ? _a : [];\n  if (!children || !children.length) return [];\n  const sortedMarks = children.map(sortMarksByOccurences),\n    rootNode = {\n      _type: \"@span\",\n      children: [],\n      markType: \"<unknown>\"\n    };\n  let nodeStack = [rootNode];\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i];\n    if (!span) continue;\n    const marksNeeded = sortedMarks[i] || [];\n    let pos = 1;\n    if (nodeStack.length > 1) for (pos; pos < nodeStack.length; pos++) {\n      const mark = ((_b = nodeStack[pos]) == null ? void 0 : _b.markKey) || \"\",\n        index = marksNeeded.indexOf(mark);\n      if (index === -1) break;\n      marksNeeded.splice(index, 1);\n    }\n    nodeStack = nodeStack.slice(0, pos);\n    let currentNode = nodeStack[nodeStack.length - 1];\n    if (currentNode) {\n      for (const markKey of marksNeeded) {\n        const markDef = markDefs == null ? void 0 : markDefs.find(def => def._key === markKey),\n          markType = markDef ? markDef._type : markKey,\n          node = {\n            _type: \"@span\",\n            _key: span._key,\n            children: [],\n            markDef,\n            markType,\n            markKey\n          };\n        currentNode.children.push(node), nodeStack.push(node), currentNode = node;\n      }\n      if (isPortableTextSpan(span)) {\n        const lines = span.text.split(`\n`);\n        for (let line = lines.length; line-- > 1;) lines.splice(line, 0, `\n`);\n        currentNode.children = currentNode.children.concat(lines.map(text => ({\n          _type: \"@text\",\n          text\n        })));\n      } else currentNode.children = currentNode.children.concat(span);\n    }\n  }\n  return rootNode.children;\n}\nfunction nestLists(blocks, mode) {\n  const tree = [];\n  let currentList;\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    if (block) {\n      if (!isPortableTextListItemBlock(block)) {\n        tree.push(block), currentList = void 0;\n        continue;\n      }\n      if (!currentList) {\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (blockMatchesList(block, currentList)) {\n        currentList.children.push(block);\n        continue;\n      }\n      if ((block.level || 1) > currentList.level) {\n        const newList = listFromBlock(block, i, mode);\n        if (mode === \"html\") {\n          const lastListItem = currentList.children[currentList.children.length - 1],\n            newLastChild = _objectSpread(_objectSpread({}, lastListItem), {}, {\n              children: [...lastListItem.children, newList]\n            });\n          currentList.children[currentList.children.length - 1] = newLastChild;\n        } else currentList.children.push(newList);\n        currentList = newList;\n        continue;\n      }\n      if ((block.level || 1) < currentList.level) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, block);\n        if (match) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        }\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (block.listItem !== currentList.listItem) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, {\n            level: block.level || 1\n          });\n        if (match && match.listItem === block.listItem) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        } else {\n          currentList = listFromBlock(block, i, mode), tree.push(currentList);\n          continue;\n        }\n      }\n      console.warn(\"Unknown state encountered for block\", block), tree.push(block);\n    }\n  }\n  return tree;\n}\nfunction blockMatchesList(block, list) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem;\n}\nfunction listFromBlock(block, index, mode) {\n  return {\n    _type: \"@list\",\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block]\n  };\n}\nfunction findListMatching(rootNode, matching) {\n  const level = matching.level || 1,\n    style = matching.listItem || \"normal\",\n    filterOnType = typeof matching.listItem == \"string\";\n  if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || \"normal\") === style) return rootNode;\n  if (!(\"children\" in rootNode)) return;\n  const node = rootNode.children[rootNode.children.length - 1];\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;\n}\nfunction spanToPlainText(span) {\n  let text = \"\";\n  return span.children.forEach(current => {\n    isPortableTextToolkitTextNode(current) ? text += current.text : isPortableTextToolkitSpan(current) && (text += spanToPlainText(current));\n  }), text;\n}\nconst leadingSpace = /^\\s/,\n  trailingSpace = /\\s$/;\nfunction toPlainText(block) {\n  const blocks = Array.isArray(block) ? block : [block];\n  let text = \"\";\n  return blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) return;\n    let pad = !1;\n    current.children.forEach(span => {\n      isPortableTextSpan(span) ? (text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? \" \" : \"\", text += span.text, pad = !1) : pad = !0;\n    }), index !== blocks.length - 1 && (text += `\n\n`);\n  }), text;\n}\nconst LIST_NEST_MODE_HTML = \"html\",\n  LIST_NEST_MODE_DIRECT = \"direct\";\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90b29sa2l0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSxvQ0FBb0Msb0VBQW9FLDBEQUEwRDtBQUNsSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4QiwwQ0FBMEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsb0NBQW9DLHVFQUF1RTtBQUN6UTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxQ0FBcUM7QUFDNUU7QUFDQSwySUFBMkk7QUFDM0k7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3QkFBd0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsbUJBQW1CO0FBQzVFO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCLE1BQU0sRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDaVM7QUFDalMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNib29rcHJvL0Rvd25sb2Fkcy9jb25pY2FwcHMvaWdlbmUvbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvdG9vbGtpdC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRTcGFuKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3R5cGUgPT09IFwic3BhblwiICYmIFwidGV4dFwiIGluIG5vZGUgJiYgdHlwZW9mIG5vZGUudGV4dCA9PSBcInN0cmluZ1wiICYmICh0eXBlb2Ygbm9kZS5tYXJrcyA+IFwidVwiIHx8IEFycmF5LmlzQXJyYXkobm9kZS5tYXJrcykgJiYgbm9kZS5tYXJrcy5ldmVyeShtYXJrID0+IHR5cGVvZiBtYXJrID09IFwic3RyaW5nXCIpKTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0QmxvY2sobm9kZSkge1xuICByZXR1cm4gKFxuICAgIC8vIEEgYmxvY2sgZG9lc24ndCBfaGF2ZV8gdG8gYmUgbmFtZWQgJ2Jsb2NrJyAtIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlblxuICAgIC8vIGFsbG93ZWQgY2hpbGQgdHlwZXMgYW5kIG1hcmtzLCBvbmUgbWlnaHQgbmFtZSB0aGVtIGRpZmZlcmVudGx5XG4gICAgdHlwZW9mIG5vZGUuX3R5cGUgPT0gXCJzdHJpbmdcIiAmJlxuICAgIC8vIFRvb2xraXQtdHlwZXMgbGlrZSBuZXN0ZWQgc3BhbnMgYXJlIEAtcHJlZml4ZWRcbiAgICBub2RlLl90eXBlWzBdICE9PSBcIkBcIiAmJiAoXG4gICAgLy8gYG1hcmtEZWZzYCBpc24ndCBfcmVxdWlyZWRfIHBlciBzYXksIGJ1dCBpZiBpdCdzIHRoZXJlLCBpdCBuZWVkcyB0byBiZSBhbiBhcnJheVxuICAgICEoXCJtYXJrRGVmc1wiIGluIG5vZGUpIHx8ICFub2RlLm1hcmtEZWZzIHx8IEFycmF5LmlzQXJyYXkobm9kZS5tYXJrRGVmcykgJiZcbiAgICAvLyBFdmVyeSBtYXJrIGRlZmluaXRpb24gbmVlZHMgdG8gaGF2ZSBhbiBgX2tleWAgdG8gYmUgbWFwcGFibGUgaW4gY2hpbGQgc3BhbnNcbiAgICBub2RlLm1hcmtEZWZzLmV2ZXJ5KGRlZiA9PiB0eXBlb2YgZGVmLl9rZXkgPT0gXCJzdHJpbmdcIikpICYmXG4gICAgLy8gYGNoaWxkcmVuYCBpcyByZXF1aXJlZCBhbmQgbmVlZHMgdG8gYmUgYW4gYXJyYXlcbiAgICBcImNoaWxkcmVuXCIgaW4gbm9kZSAmJiBBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pICYmXG4gICAgLy8gQWxsIGNoaWxkcmVuIGFyZSBvYmplY3RzIHdpdGggYF90eXBlYCAodXN1YWxseSBzcGFucywgYnV0IGNhbiBjb250YWluIG90aGVyIHN0dWZmKVxuICAgIG5vZGUuY2hpbGRyZW4uZXZlcnkoY2hpbGQgPT4gdHlwZW9mIGNoaWxkID09IFwib2JqZWN0XCIgJiYgXCJfdHlwZVwiIGluIGNoaWxkKVxuICApO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrKGJsb2NrKSB7XG4gIHJldHVybiBpc1BvcnRhYmxlVGV4dEJsb2NrKGJsb2NrKSAmJiBcImxpc3RJdGVtXCIgaW4gYmxvY2sgJiYgdHlwZW9mIGJsb2NrLmxpc3RJdGVtID09IFwic3RyaW5nXCIgJiYgKHR5cGVvZiBibG9jay5sZXZlbCA+IFwidVwiIHx8IHR5cGVvZiBibG9jay5sZXZlbCA9PSBcIm51bWJlclwiKTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3QoYmxvY2spIHtcbiAgcmV0dXJuIGJsb2NrLl90eXBlID09PSBcIkBsaXN0XCI7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuKHNwYW4pIHtcbiAgcmV0dXJuIHNwYW4uX3R5cGUgPT09IFwiQHNwYW5cIjtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3R5cGUgPT09IFwiQHRleHRcIjtcbn1cbmNvbnN0IGtub3duRGVjb3JhdG9ycyA9IFtcInN0cm9uZ1wiLCBcImVtXCIsIFwiY29kZVwiLCBcInVuZGVybGluZVwiLCBcInN0cmlrZS10aHJvdWdoXCJdO1xuZnVuY3Rpb24gc29ydE1hcmtzQnlPY2N1cmVuY2VzKHNwYW4sIGluZGV4LCBibG9ja0NoaWxkcmVuKSB7XG4gIGlmICghaXNQb3J0YWJsZVRleHRTcGFuKHNwYW4pIHx8ICFzcGFuLm1hcmtzKSByZXR1cm4gW107XG4gIGlmICghc3Bhbi5tYXJrcy5sZW5ndGgpIHJldHVybiBbXTtcbiAgY29uc3QgbWFya3MgPSBzcGFuLm1hcmtzLnNsaWNlKCksXG4gICAgb2NjdXJlbmNlcyA9IHt9O1xuICByZXR1cm4gbWFya3MuZm9yRWFjaChtYXJrID0+IHtcbiAgICBvY2N1cmVuY2VzW21hcmtdID0gMTtcbiAgICBmb3IgKGxldCBzaWJsaW5nSW5kZXggPSBpbmRleCArIDE7IHNpYmxpbmdJbmRleCA8IGJsb2NrQ2hpbGRyZW4ubGVuZ3RoOyBzaWJsaW5nSW5kZXgrKykge1xuICAgICAgY29uc3Qgc2libGluZyA9IGJsb2NrQ2hpbGRyZW5bc2libGluZ0luZGV4XTtcbiAgICAgIGlmIChzaWJsaW5nICYmIGlzUG9ydGFibGVUZXh0U3BhbihzaWJsaW5nKSAmJiBBcnJheS5pc0FycmF5KHNpYmxpbmcubWFya3MpICYmIHNpYmxpbmcubWFya3MuaW5kZXhPZihtYXJrKSAhPT0gLTEpIG9jY3VyZW5jZXNbbWFya10rKztlbHNlIGJyZWFrO1xuICAgIH1cbiAgfSksIG1hcmtzLnNvcnQoKG1hcmtBLCBtYXJrQikgPT4gc29ydE1hcmtzKG9jY3VyZW5jZXMsIG1hcmtBLCBtYXJrQikpO1xufVxuZnVuY3Rpb24gc29ydE1hcmtzKG9jY3VyZW5jZXMsIG1hcmtBLCBtYXJrQikge1xuICBjb25zdCBhT2NjdXJlbmNlcyA9IG9jY3VyZW5jZXNbbWFya0FdLFxuICAgIGJPY2N1cmVuY2VzID0gb2NjdXJlbmNlc1ttYXJrQl07XG4gIGlmIChhT2NjdXJlbmNlcyAhPT0gYk9jY3VyZW5jZXMpIHJldHVybiBiT2NjdXJlbmNlcyAtIGFPY2N1cmVuY2VzO1xuICBjb25zdCBhS25vd25Qb3MgPSBrbm93bkRlY29yYXRvcnMuaW5kZXhPZihtYXJrQSksXG4gICAgYktub3duUG9zID0ga25vd25EZWNvcmF0b3JzLmluZGV4T2YobWFya0IpO1xuICByZXR1cm4gYUtub3duUG9zICE9PSBiS25vd25Qb3MgPyBhS25vd25Qb3MgLSBiS25vd25Qb3MgOiBtYXJrQS5sb2NhbGVDb21wYXJlKG1hcmtCKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTWFya3NUcmVlKGJsb2NrKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IGJsb2NrLFxuICAgIG1hcmtEZWZzID0gKF9hID0gYmxvY2subWFya0RlZnMpICE9IG51bGwgPyBfYSA6IFtdO1xuICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHJldHVybiBbXTtcbiAgY29uc3Qgc29ydGVkTWFya3MgPSBjaGlsZHJlbi5tYXAoc29ydE1hcmtzQnlPY2N1cmVuY2VzKSxcbiAgICByb290Tm9kZSA9IHtcbiAgICAgIF90eXBlOiBcIkBzcGFuXCIsXG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBtYXJrVHlwZTogXCI8dW5rbm93bj5cIlxuICAgIH07XG4gIGxldCBub2RlU3RhY2sgPSBbcm9vdE5vZGVdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc3BhbiA9IGNoaWxkcmVuW2ldO1xuICAgIGlmICghc3BhbikgY29udGludWU7XG4gICAgY29uc3QgbWFya3NOZWVkZWQgPSBzb3J0ZWRNYXJrc1tpXSB8fCBbXTtcbiAgICBsZXQgcG9zID0gMTtcbiAgICBpZiAobm9kZVN0YWNrLmxlbmd0aCA+IDEpIGZvciAocG9zOyBwb3MgPCBub2RlU3RhY2subGVuZ3RoOyBwb3MrKykge1xuICAgICAgY29uc3QgbWFyayA9ICgoX2IgPSBub2RlU3RhY2tbcG9zXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm1hcmtLZXkpIHx8IFwiXCIsXG4gICAgICAgIGluZGV4ID0gbWFya3NOZWVkZWQuaW5kZXhPZihtYXJrKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIGJyZWFrO1xuICAgICAgbWFya3NOZWVkZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgbm9kZVN0YWNrID0gbm9kZVN0YWNrLnNsaWNlKDAsIHBvcyk7XG4gICAgbGV0IGN1cnJlbnROb2RlID0gbm9kZVN0YWNrW25vZGVTdGFjay5sZW5ndGggLSAxXTtcbiAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgIGZvciAoY29uc3QgbWFya0tleSBvZiBtYXJrc05lZWRlZCkge1xuICAgICAgICBjb25zdCBtYXJrRGVmID0gbWFya0RlZnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1hcmtEZWZzLmZpbmQoZGVmID0+IGRlZi5fa2V5ID09PSBtYXJrS2V5KSxcbiAgICAgICAgICBtYXJrVHlwZSA9IG1hcmtEZWYgPyBtYXJrRGVmLl90eXBlIDogbWFya0tleSxcbiAgICAgICAgICBub2RlID0ge1xuICAgICAgICAgICAgX3R5cGU6IFwiQHNwYW5cIixcbiAgICAgICAgICAgIF9rZXk6IHNwYW4uX2tleSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIG1hcmtEZWYsXG4gICAgICAgICAgICBtYXJrVHlwZSxcbiAgICAgICAgICAgIG1hcmtLZXlcbiAgICAgICAgICB9O1xuICAgICAgICBjdXJyZW50Tm9kZS5jaGlsZHJlbi5wdXNoKG5vZGUpLCBub2RlU3RhY2sucHVzaChub2RlKSwgY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgfVxuICAgICAgaWYgKGlzUG9ydGFibGVUZXh0U3BhbihzcGFuKSkge1xuICAgICAgICBjb25zdCBsaW5lcyA9IHNwYW4udGV4dC5zcGxpdChgXG5gKTtcbiAgICAgICAgZm9yIChsZXQgbGluZSA9IGxpbmVzLmxlbmd0aDsgbGluZS0tID4gMTspIGxpbmVzLnNwbGljZShsaW5lLCAwLCBgXG5gKTtcbiAgICAgICAgY3VycmVudE5vZGUuY2hpbGRyZW4gPSBjdXJyZW50Tm9kZS5jaGlsZHJlbi5jb25jYXQobGluZXMubWFwKHRleHQgPT4gKHtcbiAgICAgICAgICBfdHlwZTogXCJAdGV4dFwiLFxuICAgICAgICAgIHRleHRcbiAgICAgICAgfSkpKTtcbiAgICAgIH0gZWxzZSBjdXJyZW50Tm9kZS5jaGlsZHJlbiA9IGN1cnJlbnROb2RlLmNoaWxkcmVuLmNvbmNhdChzcGFuKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJvb3ROb2RlLmNoaWxkcmVuO1xufVxuZnVuY3Rpb24gbmVzdExpc3RzKGJsb2NrcywgbW9kZSkge1xuICBjb25zdCB0cmVlID0gW107XG4gIGxldCBjdXJyZW50TGlzdDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBibG9jayA9IGJsb2Nrc1tpXTtcbiAgICBpZiAoYmxvY2spIHtcbiAgICAgIGlmICghaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrKGJsb2NrKSkge1xuICAgICAgICB0cmVlLnB1c2goYmxvY2spLCBjdXJyZW50TGlzdCA9IHZvaWQgMDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWN1cnJlbnRMaXN0KSB7XG4gICAgICAgIGN1cnJlbnRMaXN0ID0gbGlzdEZyb21CbG9jayhibG9jaywgaSwgbW9kZSksIHRyZWUucHVzaChjdXJyZW50TGlzdCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGJsb2NrTWF0Y2hlc0xpc3QoYmxvY2ssIGN1cnJlbnRMaXN0KSkge1xuICAgICAgICBjdXJyZW50TGlzdC5jaGlsZHJlbi5wdXNoKGJsb2NrKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoKGJsb2NrLmxldmVsIHx8IDEpID4gY3VycmVudExpc3QubGV2ZWwpIHtcbiAgICAgICAgY29uc3QgbmV3TGlzdCA9IGxpc3RGcm9tQmxvY2soYmxvY2ssIGksIG1vZGUpO1xuICAgICAgICBpZiAobW9kZSA9PT0gXCJodG1sXCIpIHtcbiAgICAgICAgICBjb25zdCBsYXN0TGlzdEl0ZW0gPSBjdXJyZW50TGlzdC5jaGlsZHJlbltjdXJyZW50TGlzdC5jaGlsZHJlbi5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIG5ld0xhc3RDaGlsZCA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbGFzdExpc3RJdGVtKSwge30sIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFsuLi5sYXN0TGlzdEl0ZW0uY2hpbGRyZW4sIG5ld0xpc3RdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjdXJyZW50TGlzdC5jaGlsZHJlbltjdXJyZW50TGlzdC5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IG5ld0xhc3RDaGlsZDtcbiAgICAgICAgfSBlbHNlIGN1cnJlbnRMaXN0LmNoaWxkcmVuLnB1c2gobmV3TGlzdCk7XG4gICAgICAgIGN1cnJlbnRMaXN0ID0gbmV3TGlzdDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoKGJsb2NrLmxldmVsIHx8IDEpIDwgY3VycmVudExpc3QubGV2ZWwpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdCcmFuY2ggPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgbWF0Y2ggPSBtYXRjaGluZ0JyYW5jaCAmJiBmaW5kTGlzdE1hdGNoaW5nKG1hdGNoaW5nQnJhbmNoLCBibG9jayk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGN1cnJlbnRMaXN0ID0gbWF0Y2gsIGN1cnJlbnRMaXN0LmNoaWxkcmVuLnB1c2goYmxvY2spO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRMaXN0ID0gbGlzdEZyb21CbG9jayhibG9jaywgaSwgbW9kZSksIHRyZWUucHVzaChjdXJyZW50TGlzdCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGJsb2NrLmxpc3RJdGVtICE9PSBjdXJyZW50TGlzdC5saXN0SXRlbSkge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0JyYW5jaCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXSxcbiAgICAgICAgICBtYXRjaCA9IG1hdGNoaW5nQnJhbmNoICYmIGZpbmRMaXN0TWF0Y2hpbmcobWF0Y2hpbmdCcmFuY2gsIHtcbiAgICAgICAgICAgIGxldmVsOiBibG9jay5sZXZlbCB8fCAxXG4gICAgICAgICAgfSk7XG4gICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5saXN0SXRlbSA9PT0gYmxvY2subGlzdEl0ZW0pIHtcbiAgICAgICAgICBjdXJyZW50TGlzdCA9IG1hdGNoLCBjdXJyZW50TGlzdC5jaGlsZHJlbi5wdXNoKGJsb2NrKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50TGlzdCA9IGxpc3RGcm9tQmxvY2soYmxvY2ssIGksIG1vZGUpLCB0cmVlLnB1c2goY3VycmVudExpc3QpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zb2xlLndhcm4oXCJVbmtub3duIHN0YXRlIGVuY291bnRlcmVkIGZvciBibG9ja1wiLCBibG9jayksIHRyZWUucHVzaChibG9jayk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmVlO1xufVxuZnVuY3Rpb24gYmxvY2tNYXRjaGVzTGlzdChibG9jaywgbGlzdCkge1xuICByZXR1cm4gKGJsb2NrLmxldmVsIHx8IDEpID09PSBsaXN0LmxldmVsICYmIGJsb2NrLmxpc3RJdGVtID09PSBsaXN0Lmxpc3RJdGVtO1xufVxuZnVuY3Rpb24gbGlzdEZyb21CbG9jayhibG9jaywgaW5kZXgsIG1vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBfdHlwZTogXCJAbGlzdFwiLFxuICAgIF9rZXk6IGAke2Jsb2NrLl9rZXkgfHwgYCR7aW5kZXh9YH0tcGFyZW50YCxcbiAgICBtb2RlLFxuICAgIGxldmVsOiBibG9jay5sZXZlbCB8fCAxLFxuICAgIGxpc3RJdGVtOiBibG9jay5saXN0SXRlbSxcbiAgICBjaGlsZHJlbjogW2Jsb2NrXVxuICB9O1xufVxuZnVuY3Rpb24gZmluZExpc3RNYXRjaGluZyhyb290Tm9kZSwgbWF0Y2hpbmcpIHtcbiAgY29uc3QgbGV2ZWwgPSBtYXRjaGluZy5sZXZlbCB8fCAxLFxuICAgIHN0eWxlID0gbWF0Y2hpbmcubGlzdEl0ZW0gfHwgXCJub3JtYWxcIixcbiAgICBmaWx0ZXJPblR5cGUgPSB0eXBlb2YgbWF0Y2hpbmcubGlzdEl0ZW0gPT0gXCJzdHJpbmdcIjtcbiAgaWYgKGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3Qocm9vdE5vZGUpICYmIChyb290Tm9kZS5sZXZlbCB8fCAxKSA9PT0gbGV2ZWwgJiYgZmlsdGVyT25UeXBlICYmIChyb290Tm9kZS5saXN0SXRlbSB8fCBcIm5vcm1hbFwiKSA9PT0gc3R5bGUpIHJldHVybiByb290Tm9kZTtcbiAgaWYgKCEoXCJjaGlsZHJlblwiIGluIHJvb3ROb2RlKSkgcmV0dXJuO1xuICBjb25zdCBub2RlID0gcm9vdE5vZGUuY2hpbGRyZW5bcm9vdE5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gIHJldHVybiBub2RlICYmICFpc1BvcnRhYmxlVGV4dFNwYW4obm9kZSkgPyBmaW5kTGlzdE1hdGNoaW5nKG5vZGUsIG1hdGNoaW5nKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHNwYW5Ub1BsYWluVGV4dChzcGFuKSB7XG4gIGxldCB0ZXh0ID0gXCJcIjtcbiAgcmV0dXJuIHNwYW4uY2hpbGRyZW4uZm9yRWFjaChjdXJyZW50ID0+IHtcbiAgICBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZShjdXJyZW50KSA/IHRleHQgKz0gY3VycmVudC50ZXh0IDogaXNQb3J0YWJsZVRleHRUb29sa2l0U3BhbihjdXJyZW50KSAmJiAodGV4dCArPSBzcGFuVG9QbGFpblRleHQoY3VycmVudCkpO1xuICB9KSwgdGV4dDtcbn1cbmNvbnN0IGxlYWRpbmdTcGFjZSA9IC9eXFxzLyxcbiAgdHJhaWxpbmdTcGFjZSA9IC9cXHMkLztcbmZ1bmN0aW9uIHRvUGxhaW5UZXh0KGJsb2NrKSB7XG4gIGNvbnN0IGJsb2NrcyA9IEFycmF5LmlzQXJyYXkoYmxvY2spID8gYmxvY2sgOiBbYmxvY2tdO1xuICBsZXQgdGV4dCA9IFwiXCI7XG4gIHJldHVybiBibG9ja3MuZm9yRWFjaCgoY3VycmVudCwgaW5kZXgpID0+IHtcbiAgICBpZiAoIWlzUG9ydGFibGVUZXh0QmxvY2soY3VycmVudCkpIHJldHVybjtcbiAgICBsZXQgcGFkID0gITE7XG4gICAgY3VycmVudC5jaGlsZHJlbi5mb3JFYWNoKHNwYW4gPT4ge1xuICAgICAgaXNQb3J0YWJsZVRleHRTcGFuKHNwYW4pID8gKHRleHQgKz0gcGFkICYmIHRleHQgJiYgIXRyYWlsaW5nU3BhY2UudGVzdCh0ZXh0KSAmJiAhbGVhZGluZ1NwYWNlLnRlc3Qoc3Bhbi50ZXh0KSA/IFwiIFwiIDogXCJcIiwgdGV4dCArPSBzcGFuLnRleHQsIHBhZCA9ICExKSA6IHBhZCA9ICEwO1xuICAgIH0pLCBpbmRleCAhPT0gYmxvY2tzLmxlbmd0aCAtIDEgJiYgKHRleHQgKz0gYFxuXG5gKTtcbiAgfSksIHRleHQ7XG59XG5jb25zdCBMSVNUX05FU1RfTU9ERV9IVE1MID0gXCJodG1sXCIsXG4gIExJU1RfTkVTVF9NT0RFX0RJUkVDVCA9IFwiZGlyZWN0XCI7XG5leHBvcnQgeyBMSVNUX05FU1RfTU9ERV9ESVJFQ1QsIExJU1RfTkVTVF9NT0RFX0hUTUwsIGJ1aWxkTWFya3NUcmVlLCBpc1BvcnRhYmxlVGV4dEJsb2NrLCBpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2ssIGlzUG9ydGFibGVUZXh0U3BhbiwgaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdCwgaXNQb3J0YWJsZVRleHRUb29sa2l0U3BhbiwgaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUsIG5lc3RMaXN0cywgc29ydE1hcmtzQnlPY2N1cmVuY2VzLCBzcGFuVG9QbGFpblRleHQsIHRvUGxhaW5UZXh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/toolkit/dist/index.js\n");

/***/ })

};
;